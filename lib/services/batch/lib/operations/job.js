/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var msRestAzure = require('ms-rest-azure');
var WebResource = msRest.WebResource;

/**
 * @class
 * Job
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the BatchServiceClient.
 * Initializes a new instance of the Job class.
 * @constructor
 *
 * @param {BatchServiceClient} client Reference to the service client.
 */
function Job(client) {
  this.client = client;
}

/**
 * @summary Gets lifetime summary statistics for all of the jobs in the
 * specified account.
 *
 * Statistics are aggregated across all jobs that have ever existed in the
 * account, from account creation to the last update time of the statistics.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobGetAllJobsLifetimeStatisticsOptions] Additional
 * parameters for the operation
 * 
 * @param {number} [options.jobGetAllJobsLifetimeStatisticsOptions.timeout] The
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 * 
 * @param {string}
 * [options.jobGetAllJobsLifetimeStatisticsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobGetAllJobsLifetimeStatisticsOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobGetAllJobsLifetimeStatisticsOptions.ocpDate] The
 * time the request was issued. If not specified, this header will be
 * automatically populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link JobStatistics} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.getAllJobsLifetimeStatistics = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobGetAllJobsLifetimeStatisticsOptions = (options && options.jobGetAllJobsLifetimeStatisticsOptions !== undefined) ? options.jobGetAllJobsLifetimeStatisticsOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobGetAllJobsLifetimeStatisticsOptions !== null && jobGetAllJobsLifetimeStatisticsOptions !== undefined)
    {
      timeout = jobGetAllJobsLifetimeStatisticsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobGetAllJobsLifetimeStatisticsOptions !== null && jobGetAllJobsLifetimeStatisticsOptions !== undefined)
    {
      clientRequestId = jobGetAllJobsLifetimeStatisticsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobGetAllJobsLifetimeStatisticsOptions !== null && jobGetAllJobsLifetimeStatisticsOptions !== undefined)
    {
      returnClientRequestId = jobGetAllJobsLifetimeStatisticsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobGetAllJobsLifetimeStatisticsOptions !== null && jobGetAllJobsLifetimeStatisticsOptions !== undefined)
    {
      ocpDate = jobGetAllJobsLifetimeStatisticsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimejobstats';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['JobStatistics']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Deletes a job.
 *
 * Deleting a job also deletes all tasks that are part of that job, and all job
 * statistics. This also overrides the retention period for task data; that is,
 * if the job contains tasks which are still retained on compute nodes, the
 * Batch services deletes those tasks' working directories and all their
 * contents.
 *
 * @param {string} jobId The ID of the job to delete.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobDeleteMethodOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.jobDeleteMethodOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 * 
 * @param {string} [options.jobDeleteMethodOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobDeleteMethodOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobDeleteMethodOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.jobDeleteMethodOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobDeleteMethodOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobDeleteMethodOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.jobDeleteMethodOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.deleteMethod = function (jobId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      timeout = jobDeleteMethodOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      clientRequestId = jobDeleteMethodOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      ocpDate = jobDeleteMethodOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      ifMatch = jobDeleteMethodOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined)
    {
      ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Gets information about the specified job.
 *
 * @param {string} jobId The ID of the job.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobGetOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.jobGetOptions.select] An OData $select clause.
 * 
 * @param {string} [options.jobGetOptions.expand] An OData $expand clause.
 * 
 * @param {number} [options.jobGetOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobGetOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobGetOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobGetOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobGetOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobGetOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.jobGetOptions.ifModifiedSince] Specify this header to
 * perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.jobGetOptions.ifUnmodifiedSince] Specify this header
 * to perform the operation only if the resource has not been modified since
 * the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJob} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.get = function (jobId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var select;
  var expand;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      select = jobGetOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      expand = jobGetOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      timeout = jobGetOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      clientRequestId = jobGetOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      returnClientRequestId = jobGetOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      ocpDate = jobGetOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      ifMatch = jobGetOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      ifNoneMatch = jobGetOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      ifModifiedSince = jobGetOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined)
    {
      ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJob']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Updates the properties of the specified job.
 *
 * This replaces only the job properties specified in the request. For example,
 * if the job has constraints, and a request does not specify the constraints
 * element, then the job keeps the existing constraints.
 *
 * @param {string} jobId The ID of the job whose properties you want to update.
 * 
 * @param {object} jobPatchParameter The parameters for the request.
 * 
 * @param {number} [jobPatchParameter.priority] The priority of the job.
 * Priority values can range from -1000 to 1000, with -1000 being the lowest
 * priority and 1000 being the highest priority. If omitted, the priority of
 * the job is left unchanged.
 * 
 * @param {string} [jobPatchParameter.onAllTasksComplete] Specifies an action
 * the Batch service should take when all tasks in the job are in the completed
 * state. If omitted, the completion behavior is left unchanged. You may not
 * change the value from terminatejob to noaction – that is, once you have
 * engaged automatic job termination, you cannot turn it off again. If you try
 * to do this, the request fails with an 'invalid property value' error
 * response; if you are calling the REST API directly, the HTTP status code is
 * 400 (Bad Request). Possible values include: 'noAction', 'terminateJob'
 * 
 * @param {object} [jobPatchParameter.constraints] The execution constraints
 * for the job. If omitted, the existing execution constraints are left
 * unchanged.
 * 
 * @param {moment.duration} [jobPatchParameter.constraints.maxWallClockTime]
 * The maximum elapsed time that the job may run, measured from the time the
 * job is created. If the job does not complete within the time limit, the
 * Batch service terminates it and any tasks that are still running. In this
 * case, the termination reason will be MaxWallClockTimeExpiry. If this
 * property is not specified, there is no time limit on how long the job may
 * run.
 * 
 * @param {number} [jobPatchParameter.constraints.maxTaskRetryCount] The
 * maximum number of times each task may be retried. The Batch service retries
 * a task if its exit code is nonzero. Note that this value specifically
 * controls the number of retries. The Batch service will try each task once,
 * and may then retry up to this limit. For example, if the maximum retry count
 * is 3, Batch tries a task up to 4 times (one initial try and 3 retries). If
 * the maximum retry count is 0, the Batch service does not retry tasks. If the
 * maximum retry count is -1, the Batch service retries tasks without limit.
 * The default value is 0 (no retries).
 * 
 * @param {object} [jobPatchParameter.poolInfo] The pool on which the Batch
 * service runs the job's tasks. You may change the pool for a job only when
 * the job is disabled. The Patch Job call will fail if you include the
 * poolInfo element and the job is not disabled. If you specify an
 * autoPoolSpecification specification in the poolInfo, only the keepAlive
 * property can be updated, and then only if the auto pool has a
 * poolLifetimeOption of job. If omitted, the job continues to run on its
 * current pool.
 * 
 * @param {string} [jobPatchParameter.poolInfo.poolId] The ID of an existing
 * pool. All the tasks of the job will run on the specified pool. You must
 * ensure that the pool referenced by this property exists. If the pool does
 * not exist at the time the Batch service tries to schedule a job, no tasks
 * for the job will run until you create a pool with that id. Note that the
 * Batch service will not reject the job request; it will simply not run tasks
 * until the pool exists. You must specify either the pool ID or the auto pool
 * specification, but not both.
 * 
 * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification]
 * Characteristics for a temporary 'auto pool'. The Batch service will create
 * this auto pool when the job is submitted. If auto pool creation fails, the
 * Batch service moves the job to a completed state, and the pool creation
 * error is set in the job's scheduling error property. The Batch service
 * manages the lifetime (both creation and, unless keepAlive is specified,
 * deletion) of the auto pool. Any user actions that affect the lifetime of the
 * auto pool while the job is active will result in unexpected behavior. You
 * must specify either the pool ID or the auto pool specification, but not
 * both.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A prefix
 * to be added to the unique identifier when a pool is automatically created.
 * The Batch service assigns each auto pool a unique identifier on creation. To
 * distinguish between pools created for different purposes, you can specify
 * this element to add a prefix to the id that is assigned. The prefix can be
 * up to 20 characters long.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto pools, and how multiple jobs on a schedule
 * are assigned to pools. When the pool lifetime scope is jobschedule level,
 * the Batch service keeps track of the last autopool created for the
 * jobschedule, and deletes that pool when the jobschedule completes. Batch
 * will also delete this pool if the user updates the auto pool specification
 * in a way that changes this lifetime. Possible values include: 'jobschedule',
 * 'job', 'unmapped'
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to keep
 * an auto pool alive after its lifetime expires. If false, the Batch service
 * deletes the pool once its lifetime (as determined by the poolLifetimeOption
 * setting) expires; that is, when the job or job schedule completes. If true,
 * the Batch service does not delete the pool automatically. It is up to the
 * user to delete auto pools created with this option.
 * 
 * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification.pool] The
 * pool specification for the auto pool.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 * 
 * @param {string} jobPatchParameter.poolInfo.autoPoolSpecification.pool.vmSize
 * The size of the virtual machines in the pool. All virtual machines in a pool
 * are the same size. For information about available sizes of virtual machines
 * for Cloud Services pools (pools created with cloudServiceConfiguration), see
 * Sizes for Cloud Services
 * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
 * Batch supports all Cloud Services VM sizes except ExtraSmall. For
 * information about available VM sizes for pools using images from the Virtual
 * Machines Marketplace (pools created with virtualMachineConfiguration) see
 * Sizes for Virtual Machines (Linux)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
 * or Sizes for Virtual Machines (Windows)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
 * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
 * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
 * The cloud service configuration for the pool. This property must be
 * specified if the pool needs to be created with Azure PaaS VMs. This property
 * and virtualMachineConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * pool. Possible values are: 2 – OS Family 2, equivalent to Windows Server
 * 2008 R2 SP1. 3 – OS Family 3, equivalent to Windows Server 2012. 4 – OS
 * Family 4, equivalent to Windows Server 2012 R2. For more information, see
 * Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
 * The Azure Guest OS Version currently installed on the virtual machines in
 * the pool. This may differ from targetOSVersion if the pool state is
 * Upgrading. In this case some virtual machines may be on the targetOSVersion
 * and some may be on the currentOSVersion during the upgrade process. Once all
 * virtual machines have upgraded, currentOSVersion is updated to be the same
 * as targetOSVersion.
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
 * The virtual machine configuration for the pool. This property must be
 * specified if the pool needs to be created with Azure IaaS VMs. This property
 * and cloudServiceConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 * 
 * @param {object}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace image to use.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
 * The publisher of the Azure Virtual Machines Marketplace image. For example,
 * Canonical or MicrosoftWindowsServer.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
 * The offer type of the Azure Virtual Machines Marketplace image. For example,
 * UbuntuServer or WindowsServer.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
 * The SKU of the Azure Virtual Machines Marketplace image. For example,
 * 14.04.0-LTS or 2012-R2-Datacenter.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace image. A value of
 * 'latest' can be specified to select the latest version of an image. If
 * omitted, the default is 'latest'.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch node agent to be provisioned on compute nodes in the
 * pool. The Batch node agent is a program that runs on each node in the pool,
 * and provides the command-and-control interface between the node and the
 * Batch service. There are different implementations of the node agent, known
 * as SKUs, for different operating systems. You must specify a node agent SKU
 * which matches the selected image reference. To get the list of supported
 * node agent SKUs along with their list of verified image references, see the
 * 'List supported node agent SKUs' operation.
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS image.
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 * 
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.maxTasksPerNode] The
 * maximum number of tasks that can run concurrently on a single compute node
 * in the pool. The default value is 1. The maximum value of this setting
 * depends on the size of the compute nodes in the pool (the vmSize setting).
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * How tasks are distributed among compute nodes in the pool.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How tasks should be distributed across compute nodes Possible values
 * include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
 * timeout for allocation of compute nodes to the pool. This timeout applies
 * only to manual scaling; it has no effect when enableAutoScale is set to
 * true. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service rejects the
 * request with an error; if you are calling the REST API directly, the HTTP
 * status code is 400 (Bad Request).
 * 
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetDedicated] The
 * desired number of compute nodes in the pool. This property must not be
 * specified if enableAutoScale is set to true. It is required if
 * enableAutoScale is set to false.
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the pool size should automatically adjust over time. If false, the
 * targetDedicated element is required. If true, the autoScaleFormula element
 * is required. The pool automatically resizes according to the formula. The
 * default value is false.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula] The
 * formula for the desired number of compute nodes in the pool. This property
 * must not be specified if enableAutoScale is set to false. It is required if
 * enableAutoScale is set to true. The formula is checked for validity before
 * the pool is created. If the formula is not valid, the Batch service rejects
 * the request with detailed error information.
 * 
 * @param {moment.duration}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * The time interval at which to automatically adjust the pool size according
 * to the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the pool permits direct communication between nodes. Enabling
 * inter-node communication limits the maximum size of the pool due to
 * deployment restrictions on the nodes of the pool. This may result in the
 * pool not reaching its desired size. The default value is false.
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
 * The network configuration for the pool.
 * 
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
 * The ARM resource identifier of the virtual network subnet which the compute
 * nodes of the pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch account. The specified subnet should have enough free IP addresses to
 * accommodate the number of nodes in the pool. If the subnet doesn't have
 * enough free IP addresses, the pool will partially allocate compute nodes,
 * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
 * must have the 'Classic Virtual Machine Contributor' Role-Based Access
 * Control (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule tasks on
 * the compute nodes. This can be verified by checking if the specified VNet
 * has any associated Network Security Groups (NSG). If communication to the
 * compute nodes in the specified subnet is denied by an NSG, then the Batch
 * service will set the state of the compute nodes to unusable. This property
 * can only be specified for pools created with a cloudServiceConfiguration.
 * 
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask] A task to
 * run on each compute node as it joins the pool. The task runs when the node
 * is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
 * The command line of the start task. The command line does not run under a
 * shell, and therefore cannot take advantage of shell features such as
 * environment variable expansion. If you want to take advantage of such
 * features, you should invoke the shell in the command line, for example using
 * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * A list of files that the Batch service will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * A list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.runElevated]
 * Whether to run the start task in elevated mode. The default value is false.
 * 
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * The maximum number of times the task may be retried. The Batch service
 * retries a task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the task. If the maximum retry count is -1, the Batch service retries the
 * task without limit.
 * 
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Whether the Batch service should wait for the start task to complete
 * successfully (that is, to exit with exit code 0) before scheduling any tasks
 * on the compute node. If true and the start task fails on a compute node, the
 * Batch service retries the start task up to its maximum retry count
 * (maxTaskRetryCount). If the task has still not completed successfully after
 * all retries, then the Batch service marks the compute node unusable, and
 * will not schedule tasks to it. This condition can be detected via the node
 * state and scheduling error detail. If false, the Batch service will not wait
 * for the start task to complete. In this case, other tasks can start
 * executing on the compute node while the start task is still running; and
 * even if the start task fails, new tasks will continue to be scheduled on the
 * node. The default is false.
 * 
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * A list of certificates to be installed on each compute node in the pool. For
 * Windows compute nodes, the Batch service installs the certificates to the
 * specified certificate store and location. For Linux compute nodes, the
 * certificates are stored in a directory inside the task working directory and
 * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
 * query for this location. For certificates with visibility of remoteuser, a
 * certs directory is created in the user's home directory (e.g.,
 * /home/<user-name>/certs) where certificates are placed.
 * 
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * The list of application packages to be installed on each compute node in the
 * pool. This property is currently not supported on auto pools created with
 * the virtualMachineConfiguration (IaaS) property.
 * 
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 * 
 * @param {array} [jobPatchParameter.metadata] A list of name-value pairs
 * associated with the job as metadata. If omitted, the existing job metadata
 * is left unchanged.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobPatchOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobPatchOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobPatchOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobPatchOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobPatchOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobPatchOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobPatchOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.jobPatchOptions.ifModifiedSince] Specify this header
 * to perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.jobPatchOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.patch = function (jobId, jobPatchParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (jobPatchParameter === null || jobPatchParameter === undefined) {
      throw new Error('jobPatchParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      timeout = jobPatchOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      clientRequestId = jobPatchOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      returnClientRequestId = jobPatchOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      ocpDate = jobPatchOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      ifMatch = jobPatchOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      ifNoneMatch = jobPatchOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      ifModifiedSince = jobPatchOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined)
    {
      ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobPatchParameter !== null && jobPatchParameter !== undefined) {
      var requestModelMapper = new client.models['JobPatchParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobPatchParameter, 'jobPatchParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobPatchParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Updates the properties of the specified job.
 *
 * This fully replaces all the updateable properties of the job. For example,
 * if the job has constraints associated with it and if constraints is not
 * specified with this request, then the Batch service will remove the existing
 * constraints.
 *
 * @param {string} jobId The ID of the job whose properties you want to update.
 * 
 * @param {object} jobUpdateParameter The parameters for the request.
 * 
 * @param {number} [jobUpdateParameter.priority] The priority of the job.
 * Priority values can range from -1000 to 1000, with -1000 being the lowest
 * priority and 1000 being the highest priority. If omitted, it is set to the
 * default value 0.
 * 
 * @param {object} [jobUpdateParameter.constraints] The execution constraints
 * for the job. If omitted, the constraints are cleared.
 * 
 * @param {moment.duration} [jobUpdateParameter.constraints.maxWallClockTime]
 * The maximum elapsed time that the job may run, measured from the time the
 * job is created. If the job does not complete within the time limit, the
 * Batch service terminates it and any tasks that are still running. In this
 * case, the termination reason will be MaxWallClockTimeExpiry. If this
 * property is not specified, there is no time limit on how long the job may
 * run.
 * 
 * @param {number} [jobUpdateParameter.constraints.maxTaskRetryCount] The
 * maximum number of times each task may be retried. The Batch service retries
 * a task if its exit code is nonzero. Note that this value specifically
 * controls the number of retries. The Batch service will try each task once,
 * and may then retry up to this limit. For example, if the maximum retry count
 * is 3, Batch tries a task up to 4 times (one initial try and 3 retries). If
 * the maximum retry count is 0, the Batch service does not retry tasks. If the
 * maximum retry count is -1, the Batch service retries tasks without limit.
 * The default value is 0 (no retries).
 * 
 * @param {object} jobUpdateParameter.poolInfo The pool on which the Batch
 * service runs the job's tasks. You may change the pool for a job only when
 * the job is disabled. The Update Job call will fail if you include the
 * poolInfo element and the job is not disabled. If you specify an
 * autoPoolSpecification specification in the poolInfo, only the keepAlive
 * property can be updated, and then only if the auto pool has a
 * poolLifetimeOption of job.
 * 
 * @param {string} [jobUpdateParameter.poolInfo.poolId] The ID of an existing
 * pool. All the tasks of the job will run on the specified pool. You must
 * ensure that the pool referenced by this property exists. If the pool does
 * not exist at the time the Batch service tries to schedule a job, no tasks
 * for the job will run until you create a pool with that id. Note that the
 * Batch service will not reject the job request; it will simply not run tasks
 * until the pool exists. You must specify either the pool ID or the auto pool
 * specification, but not both.
 * 
 * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification]
 * Characteristics for a temporary 'auto pool'. The Batch service will create
 * this auto pool when the job is submitted. If auto pool creation fails, the
 * Batch service moves the job to a completed state, and the pool creation
 * error is set in the job's scheduling error property. The Batch service
 * manages the lifetime (both creation and, unless keepAlive is specified,
 * deletion) of the auto pool. Any user actions that affect the lifetime of the
 * auto pool while the job is active will result in unexpected behavior. You
 * must specify either the pool ID or the auto pool specification, but not
 * both.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
 * prefix to be added to the unique identifier when a pool is automatically
 * created. The Batch service assigns each auto pool a unique identifier on
 * creation. To distinguish between pools created for different purposes, you
 * can specify this element to add a prefix to the id that is assigned. The
 * prefix can be up to 20 characters long.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto pools, and how multiple jobs on a schedule
 * are assigned to pools. When the pool lifetime scope is jobschedule level,
 * the Batch service keeps track of the last autopool created for the
 * jobschedule, and deletes that pool when the jobschedule completes. Batch
 * will also delete this pool if the user updates the auto pool specification
 * in a way that changes this lifetime. Possible values include: 'jobschedule',
 * 'job', 'unmapped'
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to
 * keep an auto pool alive after its lifetime expires. If false, the Batch
 * service deletes the pool once its lifetime (as determined by the
 * poolLifetimeOption setting) expires; that is, when the job or job schedule
 * completes. If true, the Batch service does not delete the pool
 * automatically. It is up to the user to delete auto pools created with this
 * option.
 * 
 * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification.pool] The
 * pool specification for the auto pool.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.vmSize The size of
 * the virtual machines in the pool. All virtual machines in a pool are the
 * same size. For information about available sizes of virtual machines for
 * Cloud Services pools (pools created with cloudServiceConfiguration), see
 * Sizes for Cloud Services
 * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
 * Batch supports all Cloud Services VM sizes except ExtraSmall. For
 * information about available VM sizes for pools using images from the Virtual
 * Machines Marketplace (pools created with virtualMachineConfiguration) see
 * Sizes for Virtual Machines (Linux)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
 * or Sizes for Virtual Machines (Windows)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
 * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
 * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
 * The cloud service configuration for the pool. This property must be
 * specified if the pool needs to be created with Azure PaaS VMs. This property
 * and virtualMachineConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * pool. Possible values are: 2 – OS Family 2, equivalent to Windows Server
 * 2008 R2 SP1. 3 – OS Family 3, equivalent to Windows Server 2012. 4 – OS
 * Family 4, equivalent to Windows Server 2012 R2. For more information, see
 * Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
 * The Azure Guest OS Version currently installed on the virtual machines in
 * the pool. This may differ from targetOSVersion if the pool state is
 * Upgrading. In this case some virtual machines may be on the targetOSVersion
 * and some may be on the currentOSVersion during the upgrade process. Once all
 * virtual machines have upgraded, currentOSVersion is updated to be the same
 * as targetOSVersion.
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
 * The virtual machine configuration for the pool. This property must be
 * specified if the pool needs to be created with Azure IaaS VMs. This property
 * and cloudServiceConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 * 
 * @param {object}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace image to use.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
 * The publisher of the Azure Virtual Machines Marketplace image. For example,
 * Canonical or MicrosoftWindowsServer.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
 * The offer type of the Azure Virtual Machines Marketplace image. For example,
 * UbuntuServer or WindowsServer.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
 * The SKU of the Azure Virtual Machines Marketplace image. For example,
 * 14.04.0-LTS or 2012-R2-Datacenter.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace image. A value of
 * 'latest' can be specified to select the latest version of an image. If
 * omitted, the default is 'latest'.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch node agent to be provisioned on compute nodes in the
 * pool. The Batch node agent is a program that runs on each node in the pool,
 * and provides the command-and-control interface between the node and the
 * Batch service. There are different implementations of the node agent, known
 * as SKUs, for different operating systems. You must specify a node agent SKU
 * which matches the selected image reference. To get the list of supported
 * node agent SKUs along with their list of verified image references, see the
 * 'List supported node agent SKUs' operation.
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS image.
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 * 
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.maxTasksPerNode] The
 * maximum number of tasks that can run concurrently on a single compute node
 * in the pool. The default value is 1. The maximum value of this setting
 * depends on the size of the compute nodes in the pool (the vmSize setting).
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * How tasks are distributed among compute nodes in the pool.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How tasks should be distributed across compute nodes Possible values
 * include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
 * timeout for allocation of compute nodes to the pool. This timeout applies
 * only to manual scaling; it has no effect when enableAutoScale is set to
 * true. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service rejects the
 * request with an error; if you are calling the REST API directly, the HTTP
 * status code is 400 (Bad Request).
 * 
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetDedicated] The
 * desired number of compute nodes in the pool. This property must not be
 * specified if enableAutoScale is set to true. It is required if
 * enableAutoScale is set to false.
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the pool size should automatically adjust over time. If false, the
 * targetDedicated element is required. If true, the autoScaleFormula element
 * is required. The pool automatically resizes according to the formula. The
 * default value is false.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * The formula for the desired number of compute nodes in the pool. This
 * property must not be specified if enableAutoScale is set to false. It is
 * required if enableAutoScale is set to true. The formula is checked for
 * validity before the pool is created. If the formula is not valid, the Batch
 * service rejects the request with detailed error information.
 * 
 * @param {moment.duration}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * The time interval at which to automatically adjust the pool size according
 * to the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the pool permits direct communication between nodes. Enabling
 * inter-node communication limits the maximum size of the pool due to
 * deployment restrictions on the nodes of the pool. This may result in the
 * pool not reaching its desired size. The default value is false.
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
 * The network configuration for the pool.
 * 
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
 * The ARM resource identifier of the virtual network subnet which the compute
 * nodes of the pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch account. The specified subnet should have enough free IP addresses to
 * accommodate the number of nodes in the pool. If the subnet doesn't have
 * enough free IP addresses, the pool will partially allocate compute nodes,
 * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
 * must have the 'Classic Virtual Machine Contributor' Role-Based Access
 * Control (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule tasks on
 * the compute nodes. This can be verified by checking if the specified VNet
 * has any associated Network Security Groups (NSG). If communication to the
 * compute nodes in the specified subnet is denied by an NSG, then the Batch
 * service will set the state of the compute nodes to unusable. This property
 * can only be specified for pools created with a cloudServiceConfiguration.
 * 
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask] A task to
 * run on each compute node as it joins the pool. The task runs when the node
 * is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
 * The command line of the start task. The command line does not run under a
 * shell, and therefore cannot take advantage of shell features such as
 * environment variable expansion. If you want to take advantage of such
 * features, you should invoke the shell in the command line, for example using
 * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * A list of files that the Batch service will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * A list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.runElevated]
 * Whether to run the start task in elevated mode. The default value is false.
 * 
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * The maximum number of times the task may be retried. The Batch service
 * retries a task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the task. If the maximum retry count is -1, the Batch service retries the
 * task without limit.
 * 
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Whether the Batch service should wait for the start task to complete
 * successfully (that is, to exit with exit code 0) before scheduling any tasks
 * on the compute node. If true and the start task fails on a compute node, the
 * Batch service retries the start task up to its maximum retry count
 * (maxTaskRetryCount). If the task has still not completed successfully after
 * all retries, then the Batch service marks the compute node unusable, and
 * will not schedule tasks to it. This condition can be detected via the node
 * state and scheduling error detail. If false, the Batch service will not wait
 * for the start task to complete. In this case, other tasks can start
 * executing on the compute node while the start task is still running; and
 * even if the start task fails, new tasks will continue to be scheduled on the
 * node. The default is false.
 * 
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * A list of certificates to be installed on each compute node in the pool. For
 * Windows compute nodes, the Batch service installs the certificates to the
 * specified certificate store and location. For Linux compute nodes, the
 * certificates are stored in a directory inside the task working directory and
 * an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
 * query for this location. For certificates with visibility of remoteuser, a
 * certs directory is created in the user's home directory (e.g.,
 * /home/<user-name>/certs) where certificates are placed.
 * 
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * The list of application packages to be installed on each compute node in the
 * pool. This property is currently not supported on auto pools created with
 * the virtualMachineConfiguration (IaaS) property.
 * 
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 * 
 * @param {array} [jobUpdateParameter.metadata] A list of name-value pairs
 * associated with the job as metadata. If omitted, it takes the default value
 * of an empty list; in effect, any existing metadata is deleted.
 * 
 * @param {string} [jobUpdateParameter.onAllTasksComplete] Specifies an action
 * the Batch service should take when all tasks in the job are in the completed
 * state. If omitted, the completion behavior is set to noaction. If the
 * current value is terminatejob, this is an error because a job's completion
 * behavior may not be changed from terminatejob to noaction. Possible values
 * include: 'noAction', 'terminateJob'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobUpdateOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobUpdateOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobUpdateOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobUpdateOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobUpdateOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobUpdateOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobUpdateOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.jobUpdateOptions.ifModifiedSince] Specify this header
 * to perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.jobUpdateOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.update = function (jobId, jobUpdateParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
      throw new Error('jobUpdateParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      timeout = jobUpdateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      clientRequestId = jobUpdateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      returnClientRequestId = jobUpdateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      ocpDate = jobUpdateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      ifMatch = jobUpdateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      ifNoneMatch = jobUpdateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      ifModifiedSince = jobUpdateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined)
    {
      ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobUpdateParameter !== null && jobUpdateParameter !== undefined) {
      var requestModelMapper = new client.models['JobUpdateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobUpdateParameter, 'jobUpdateParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobUpdateParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Disables the specified job, preventing new tasks from running.
 *
 * The Batch Service immediately moves the job to the disabling state. Batch
 * then uses the disableTasks parameter to determine what to do with the
 * currently running tasks of the job. The job remains in the disabling state
 * until the disable operation is completed and all tasks have been dealt with
 * according to the disableTasks option; the job then moves to the disabled
 * state. No new tasks are started under the job until it moves back to active
 * state. If you try to disable a job that is in any state other than active,
 * disabling, or disabled, the request fails with status code 409.
 *
 * @param {string} jobId The ID of the job to disable.
 * 
 * @param {string} disableTasks What to do with active tasks associated with
 * the job. Possible values are: requeue – Terminate running tasks and requeue
 * them. The tasks will run again when the job is enabled. terminate –
 * Terminate running tasks. The tasks will not run again. wait – Allow
 * currently running tasks to complete. Possible values include: 'requeue',
 * 'terminate', 'wait'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobDisableOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobDisableOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobDisableOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobDisableOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobDisableOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobDisableOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobDisableOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobDisableOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.jobDisableOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.disable = function (jobId, disableTasks, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (disableTasks) {
      var allowedValues = [ 'requeue', 'terminate', 'wait' ];
      if (!allowedValues.some( function(item) { return item === disableTasks; })) {
        throw new Error(disableTasks + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    } else {
      throw new Error('disableTasks cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  var jobDisableParameter = new client.models['JobDisableParameter']();
  try {
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      timeout = jobDisableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      clientRequestId = jobDisableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      returnClientRequestId = jobDisableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      ocpDate = jobDisableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      ifMatch = jobDisableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      ifNoneMatch = jobDisableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      ifModifiedSince = jobDisableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined)
    {
      ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (disableTasks !== null && disableTasks !== undefined)
    {
      jobDisableParameter.disableTasks = disableTasks;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/disable';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobDisableParameter !== null && jobDisableParameter !== undefined) {
      var requestModelMapper = new client.models['JobDisableParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobDisableParameter, 'jobDisableParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobDisableParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Enables the specified job, allowing new tasks to run.
 *
 * When you call this API, the Batch service sets a disabled job to the
 * enabling state. After the this operation is completed, the job moves to the
 * active state, and scheduling of new tasks under the job resumes. The Batch
 * service does not allow a task to remain in the active state for more than 7
 * days. Therefore, if you enable a job containing active tasks which were
 * added more than 7 days ago, those tasks will not run.
 *
 * @param {string} jobId The ID of the job to enable.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobEnableOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobEnableOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobEnableOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobEnableOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobEnableOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobEnableOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobEnableOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.jobEnableOptions.ifModifiedSince] Specify this header
 * to perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.jobEnableOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.enable = function (jobId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      timeout = jobEnableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      clientRequestId = jobEnableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      returnClientRequestId = jobEnableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      ocpDate = jobEnableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      ifMatch = jobEnableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      ifNoneMatch = jobEnableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      ifModifiedSince = jobEnableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined)
    {
      ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/enable';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Terminates the specified job, marking it as completed.
 *
 * When a Terminate Job request is received, the Batch service sets the job to
 * the terminating state. The Batch service then terminates any active or
 * running tasks associated with the job, and runs any required Job Release
 * tasks. The job then moves into the completed state.
 *
 * @param {string} jobId The ID of the job to terminate.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.terminateReason] The text you want to appear as the
 * job's TerminateReason. The default is 'UserTerminate'.
 * 
 * @param {object} [options.jobTerminateOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobTerminateOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobTerminateOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobTerminateOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobTerminateOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.jobTerminateOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.jobTerminateOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobTerminateOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.jobTerminateOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.terminate = function (jobId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var terminateReason = (options && options.terminateReason !== undefined) ? options.terminateReason : undefined;
  var jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (terminateReason !== null && terminateReason !== undefined && typeof terminateReason.valueOf() !== 'string') {
      throw new Error('terminateReason must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  var jobTerminateParameter;
  try {
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      timeout = jobTerminateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      clientRequestId = jobTerminateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      returnClientRequestId = jobTerminateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      ocpDate = jobTerminateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      ifMatch = jobTerminateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      ifNoneMatch = jobTerminateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      ifModifiedSince = jobTerminateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined)
    {
      ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (terminateReason !== null && terminateReason !== undefined)
    {
      jobTerminateParameter = new client.models['JobTerminateParameter']();
      jobTerminateParameter.terminateReason = terminateReason;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/terminate';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobTerminateParameter !== null && jobTerminateParameter !== undefined) {
      var requestModelMapper = new client.models['JobTerminateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobTerminateParameter, 'jobTerminateParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobTerminateParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Adds a job to the specified account.
 *
 * The Batch service supports two ways to control the work done as part of a
 * job. In the first approach, the user specifies a Job Manager task. The Batch
 * service launches this task when it is ready to start the job. The Job
 * Manager task controls all other tasks that run under this job, by using the
 * Task APIs. In the second approach, the user directly controls the execution
 * of tasks under an active job, by using the Task APIs. Also note: when naming
 * jobs, avoid including sensitive information such as user names or secret
 * project names. This information may appear in telemetry logs accessible to
 * Microsoft Support engineers.
 *
 * @param {object} job The job to be added.
 * 
 * @param {string} job.id A string that uniquely identifies the job within the
 * account. The ID can contain any combination of alphanumeric characters
 * including hyphens and underscores, and cannot contain more than 64
 * characters. It is common to use a GUID for the id.
 * 
 * @param {string} [job.displayName] The display name for the job. The display
 * name need not be unique and can contain any Unicode characters up to a
 * maximum length of 1024.
 * 
 * @param {number} [job.priority] The priority of the job.  Priority values can
 * range from -1000 to 1000, with -1000 being the lowest priority and 1000
 * being the highest priority. The default value is 0.
 * 
 * @param {object} [job.constraints] The execution constraints for the job.
 * 
 * @param {moment.duration} [job.constraints.maxWallClockTime] The maximum
 * elapsed time that the job may run, measured from the time the job is
 * created. If the job does not complete within the time limit, the Batch
 * service terminates it and any tasks that are still running. In this case,
 * the termination reason will be MaxWallClockTimeExpiry. If this property is
 * not specified, there is no time limit on how long the job may run.
 * 
 * @param {number} [job.constraints.maxTaskRetryCount] The maximum number of
 * times each task may be retried. The Batch service retries a task if its exit
 * code is nonzero. Note that this value specifically controls the number of
 * retries. The Batch service will try each task once, and may then retry up to
 * this limit. For example, if the maximum retry count is 3, Batch tries a task
 * up to 4 times (one initial try and 3 retries). If the maximum retry count is
 * 0, the Batch service does not retry tasks. If the maximum retry count is -1,
 * the Batch service retries tasks without limit. The default value is 0 (no
 * retries).
 * 
 * @param {object} [job.jobManagerTask] Details of a Job Manager task to be
 * launched when the job is started. If the job does not specify a Job Manager
 * task, the user must explicitly add tasks to the job. If the job does specify
 * a Job Manager task, the Batch service creates the Job Manager task when the
 * job is created, and will try to schedule the Job Manager task before
 * scheduling other tasks in the job. The Job Manager task's typical purpose is
 * to control and/or monitor job execution, for example by deciding what
 * additional tasks to run, determining when the work is complete, etc.
 * (However, a Job Manager task is not restricted to these activities – it is a
 * fully-fledged task in the system and perform whatever actions are required
 * for the job.) For example, a Job Manager task might download a file
 * specified as a parameter, analyze the contents of that file and submit
 * additional tasks based on those contents.
 * 
 * @param {string} job.jobManagerTask.id A string that uniquely identifies the
 * Job Manager taskwithin the job. The id can contain any combination of
 * alphanumeric characters including hyphens and underscores and cannot contain
 * more than 64 characters.
 * 
 * @param {string} [job.jobManagerTask.displayName] The display name of the Job
 * Manager task. It need not be unique and can contain any Unicode characters
 * up to a maximum length of 1024.
 * 
 * @param {string} job.jobManagerTask.commandLine The command line of the Job
 * Manager task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array} [job.jobManagerTask.resourceFiles] A list of files that the
 * Batch service will download to the compute node before running the command
 * line. Files listed under this element are located in the task's working
 * directory.
 * 
 * @param {array} [job.jobManagerTask.environmentSettings] A list of
 * environment variable settings for the Job Manager task.
 * 
 * @param {object} [job.jobManagerTask.constraints] Constraints that apply to
 * the Job Manager task.
 * 
 * @param {boolean} [job.jobManagerTask.killJobOnCompletion] Whether completion
 * of the Job Manager task signifies completion of the entire job. If true,
 * when the Job Manager task completes, the Batch service marks the job as
 * complete. If any tasks are still running at this time (other than Job
 * Release), those tasks are terminated. If false, the completion of the Job
 * Manager task does not affect the job status. In this case, you should either
 * use the onAllTasksComplete attribute to terminate the job, or have a client
 * or user terminate the job explicitly. An example of this is if the Job
 * Manager creates a set of tasks but then takes no further role in their
 * execution. The default value is true. If you are using the
 * onAllTasksComplete and onTaskFailure attributes to control job lifetime, and
 * using the job manager task only to create the tasks for the job (not to
 * monitor progress), then it is important to set killJobOnCompletion to false.
 * 
 * @param {boolean} [job.jobManagerTask.runElevated] Whether to run the Job
 * Manager task in elevated mode. The default value is false.
 * 
 * @param {boolean} [job.jobManagerTask.runExclusive] Whether the Job Manager
 * task requires exclusive use of the compute node where it runs. If true, no
 * other tasks will run on the same compute node for as long as the Job Manager
 * is running. If false, other tasks can run simultaneously with the Job
 * Manager on a compute node. The Job Manager task counts normally against the
 * node's concurrent task limit, so this is only relevant if the node allows
 * multiple concurrent tasks. The default value is true.
 * 
 * @param {array} [job.jobManagerTask.applicationPackageReferences] A list of
 * application packages that the Batch service will deploy to the compute node
 * before running the command line. Application packages are downloaded and
 * deployed to a shared directory, not the task directory. Therefore, if a
 * referenced package is already on the compute node, and is up to date, then
 * it is not re-downloaded; the existing copy on the compute node is used. If a
 * referenced application package cannot be installed, for example because the
 * package has been deleted or because download failed, the task fails with a
 * scheduling error. This property is currently not supported on jobs running
 * on pools created using the virtualMachineConfiguration (IaaS) property. If a
 * task specifying applicationPackageReferences runs on such a pool, it fails
 * with a scheduling error with code TaskSchedulingConstraintFailed.
 * 
 * @param {object} [job.jobPreparationTask] The Job Preparation task. If a job
 * has a Job Preparation task, the Batch service will run the Job Preparation
 * task on a compute node before starting any tasks of that job on that compute
 * node.
 * 
 * @param {string} [job.jobPreparationTask.id] A string that uniquely
 * identifies the job preparation task within the job. The ID can contain any
 * combination of alphanumeric characters including hyphens and underscores and
 * cannot contain more than 64 characters. If you do not specify this property,
 * the Batch service assigns a default value of 'jobpreparation'. No other task
 * in the job can have the same id as the Job Preparation task. If you try to
 * submit a task with the same id, the Batch service rejects the request with
 * error code TaskIdSameAsJobPreparationTask; if you are calling the REST API
 * directly, the HTTP status code is 409 (Conflict).
 * 
 * @param {string} job.jobPreparationTask.commandLine The command line of the
 * Job Preparation task. The command line does not run under a shell, and
 * therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array} [job.jobPreparationTask.resourceFiles] A list of files that
 * the Batch service will download to the compute node before running the
 * command line. Files listed under this element are located in the task's
 * working directory.
 * 
 * @param {array} [job.jobPreparationTask.environmentSettings] A list of
 * environment variable settings for the Job Preparation task.
 * 
 * @param {object} [job.jobPreparationTask.constraints] Constraints that apply
 * to the Job Preparation task.
 * 
 * @param {moment.duration}
 * [job.jobPreparationTask.constraints.maxWallClockTime] The maximum elapsed
 * time that the task may run, measured from the time the task starts. If the
 * task does not complete within the time limit, the Batch service terminates
 * it. If this is not specified, there is no time limit on how long the task
 * may run.
 * 
 * @param {moment.duration} [job.jobPreparationTask.constraints.retentionTime]
 * The minimum time to retain the task directory on the compute node where it
 * ran, from the time it completes execution. After this time, the Batch
 * service may delete the task directory and all its contents. The default is
 * infinite, i.e. the task directory will be retained until the compute node is
 * removed or reimaged.
 * 
 * @param {number} [job.jobPreparationTask.constraints.maxTaskRetryCount] The
 * maximum number of times the task may be retried. The Batch service retries a
 * task if its exit code is nonzero. Note that this value specifically controls
 * the number of retries. The Batch service will try the task once, and may
 * then retry up to this limit. For example, if the maximum retry count is 3,
 * Batch tries the task up to 4 times (one initial try and 3 retries). If the
 * maximum retry count is 0, the Batch service does not retry the task. If the
 * maximum retry count is -1, the Batch service retries the task without limit.
 * 
 * @param {boolean} [job.jobPreparationTask.waitForSuccess] Whether the Batch
 * service should wait for the Job Preparation task to complete successfully
 * before scheduling any other tasks of the job on the compute node. If true
 * and the Job Preparation task fails on a compute node, the Batch service
 * retries the Job Preparation task up to its maximum retry count (as specified
 * in the constraints element). If the task has still not completed
 * successfully after all retries, then the Batch service will not schedule
 * tasks of the job to the compute node. The compute node remains active and
 * eligible to run tasks of other jobs. If false, the Batch service will not
 * wait for the Job Preparation task to complete. In this case, other tasks of
 * the job can start executing on the compute node while the Job Preparation
 * task is still running; and even if the Job Preparation task fails, new tasks
 * will continue to be scheduled on the node. The default value is true.
 * 
 * @param {boolean} [job.jobPreparationTask.runElevated] Whether to run the Job
 * Preparation task in elevated mode. The default value is false.
 * 
 * @param {boolean} [job.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
 * Whether the Batch service should rerun the Job Preparation task after a
 * compute node reboots. The Job Preparation task is always rerun if a compute
 * node is reimaged, or if the Job Preparation task did not complete (e.g.
 * because the reboot occurred while the task was running). Therefore, you
 * should always write a Job Preparation task to be idempotent and to behave
 * correctly if run multiple times. The default value is true.
 * 
 * @param {object} [job.jobReleaseTask] The Job Release task. A Job Release
 * task cannot be specified without also specifying a Job Preparation task for
 * the job. The Batch service runs the Job Release task on the compute nodes
 * that have run the Job Preparation task. The primary purpose of the Job
 * Release task is to undo changes to compute nodes made by the Job Preparation
 * task. Example activities include deleting local files, or shutting down
 * services that were started as part of job preparation.
 * 
 * @param {string} [job.jobReleaseTask.id] A string that uniquely identifies
 * the Job Release task within the job. The ID can contain any combination of
 * alphanumeric characters including hyphens and underscores and cannot contain
 * more than 64 characters. If you do not specify this property, the Batch
 * service assigns a default value of 'jobrelease'. No other task in the job
 * can have the same id as the Job Release task. If you try to submit a task
 * with the same id, the Batch service rejects the request with error code
 * TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the
 * HTTP status code is 409 (Conflict).
 * 
 * @param {string} job.jobReleaseTask.commandLine The command line of the Job
 * Release task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array} [job.jobReleaseTask.resourceFiles] A list of files that the
 * Batch service will download to the compute node before running the command
 * line. Files listed under this element are located in the task's working
 * directory.
 * 
 * @param {array} [job.jobReleaseTask.environmentSettings] A list of
 * environment variable settings for the Job Release task.
 * 
 * @param {moment.duration} [job.jobReleaseTask.maxWallClockTime] The maximum
 * elapsed time that the Job Release task may run on a given compute node,
 * measured from the time the task starts. If the task does not complete within
 * the time limit, the Batch service terminates it. The default value is 15
 * minutes. You may not specify a timeout longer than 15 minutes. If you do,
 * the Batch service rejects it with an error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request).
 * 
 * @param {moment.duration} [job.jobReleaseTask.retentionTime] The minimum time
 * to retain the task directory for the Job Release task on the compute node.
 * After this time, the Batch service may delete the task directory and all its
 * contents. The default is infinite, i.e. the task directory will be retained
 * until the compute node is removed or reimaged.
 * 
 * @param {boolean} [job.jobReleaseTask.runElevated] Whether to run the Job
 * Release task in elevated mode. The default value is false.
 * 
 * @param {array} [job.commonEnvironmentSettings] The list of common
 * environment variable settings. These environment variables are set for all
 * tasks in the job (including the Job Manager, Job Preparation and Job Release
 * tasks).
 * 
 * @param {object} job.poolInfo The pool on which the Batch service runs the
 * job's tasks.
 * 
 * @param {string} [job.poolInfo.poolId] The ID of an existing pool. All the
 * tasks of the job will run on the specified pool. You must ensure that the
 * pool referenced by this property exists. If the pool does not exist at the
 * time the Batch service tries to schedule a job, no tasks for the job will
 * run until you create a pool with that id. Note that the Batch service will
 * not reject the job request; it will simply not run tasks until the pool
 * exists. You must specify either the pool ID or the auto pool specification,
 * but not both.
 * 
 * @param {object} [job.poolInfo.autoPoolSpecification] Characteristics for a
 * temporary 'auto pool'. The Batch service will create this auto pool when the
 * job is submitted. If auto pool creation fails, the Batch service moves the
 * job to a completed state, and the pool creation error is set in the job's
 * scheduling error property. The Batch service manages the lifetime (both
 * creation and, unless keepAlive is specified, deletion) of the auto pool. Any
 * user actions that affect the lifetime of the auto pool while the job is
 * active will result in unexpected behavior. You must specify either the pool
 * ID or the auto pool specification, but not both.
 * 
 * @param {string} [job.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
 * prefix to be added to the unique identifier when a pool is automatically
 * created. The Batch service assigns each auto pool a unique identifier on
 * creation. To distinguish between pools created for different purposes, you
 * can specify this element to add a prefix to the id that is assigned. The
 * prefix can be up to 20 characters long.
 * 
 * @param {string} job.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto pools, and how multiple jobs on a schedule
 * are assigned to pools. When the pool lifetime scope is jobschedule level,
 * the Batch service keeps track of the last autopool created for the
 * jobschedule, and deletes that pool when the jobschedule completes. Batch
 * will also delete this pool if the user updates the auto pool specification
 * in a way that changes this lifetime. Possible values include: 'jobschedule',
 * 'job', 'unmapped'
 * 
 * @param {boolean} [job.poolInfo.autoPoolSpecification.keepAlive] Whether to
 * keep an auto pool alive after its lifetime expires. If false, the Batch
 * service deletes the pool once its lifetime (as determined by the
 * poolLifetimeOption setting) expires; that is, when the job or job schedule
 * completes. If true, the Batch service does not delete the pool
 * automatically. It is up to the user to delete auto pools created with this
 * option.
 * 
 * @param {object} [job.poolInfo.autoPoolSpecification.pool] The pool
 * specification for the auto pool.
 * 
 * @param {string} [job.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 * 
 * @param {string} job.poolInfo.autoPoolSpecification.pool.vmSize The size of
 * the virtual machines in the pool. All virtual machines in a pool are the
 * same size. For information about available sizes of virtual machines for
 * Cloud Services pools (pools created with cloudServiceConfiguration), see
 * Sizes for Cloud Services
 * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
 * Batch supports all Cloud Services VM sizes except ExtraSmall. For
 * information about available VM sizes for pools using images from the Virtual
 * Machines Marketplace (pools created with virtualMachineConfiguration) see
 * Sizes for Virtual Machines (Linux)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
 * or Sizes for Virtual Machines (Windows)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
 * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
 * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
 * 
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration] The
 * cloud service configuration for the pool. This property must be specified if
 * the pool needs to be created with Azure PaaS VMs. This property and
 * virtualMachineConfiguration are mutually exclusive and one of the properties
 * must be specified. If neither is specified then the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request).
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * pool. Possible values are: 2 – OS Family 2, equivalent to Windows Server
 * 2008 R2 SP1. 3 – OS Family 3, equivalent to Windows Server 2012. 4 – OS
 * Family 4, equivalent to Windows Server 2012 R2. For more information, see
 * Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 * 
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.targetOSVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 * 
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.currentOSVersion]
 * The Azure Guest OS Version currently installed on the virtual machines in
 * the pool. This may differ from targetOSVersion if the pool state is
 * Upgrading. In this case some virtual machines may be on the targetOSVersion
 * and some may be on the currentOSVersion during the upgrade process. Once all
 * virtual machines have upgraded, currentOSVersion is updated to be the same
 * as targetOSVersion.
 * 
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration] The
 * virtual machine configuration for the pool. This property must be specified
 * if the pool needs to be created with Azure IaaS VMs. This property and
 * cloudServiceConfiguration are mutually exclusive and one of the properties
 * must be specified. If neither is specified then the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request).
 * 
 * @param {object}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace image to use.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher
 * The publisher of the Azure Virtual Machines Marketplace image. For example,
 * Canonical or MicrosoftWindowsServer.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer
 * The offer type of the Azure Virtual Machines Marketplace image. For example,
 * UbuntuServer or WindowsServer.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku
 * The SKU of the Azure Virtual Machines Marketplace image. For example,
 * 14.04.0-LTS or 2012-R2-Datacenter.
 * 
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace image. A value of
 * 'latest' can be specified to select the latest version of an image. If
 * omitted, the default is 'latest'.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch node agent to be provisioned on compute nodes in the
 * pool. The Batch node agent is a program that runs on each node in the pool,
 * and provides the command-and-control interface between the node and the
 * Batch service. There are different implementations of the node agent, known
 * as SKUs, for different operating systems. You must specify a node agent SKU
 * which matches the selected image reference. To get the list of supported
 * node agent SKUs along with their list of verified image references, see the
 * 'List supported node agent SKUs' operation.
 * 
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS image.
 * 
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 * 
 * @param {number} [job.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
 * The maximum number of tasks that can run concurrently on a single compute
 * node in the pool. The default value is 1. The maximum value of this setting
 * depends on the size of the compute nodes in the pool (the vmSize setting).
 * 
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy] How tasks are
 * distributed among compute nodes in the pool.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How tasks should be distributed across compute nodes Possible values
 * include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [job.poolInfo.autoPoolSpecification.pool.resizeTimeout] The timeout for
 * allocation of compute nodes to the pool. This timeout applies only to manual
 * scaling; it has no effect when enableAutoScale is set to true. The default
 * value is 15 minutes. The minimum value is 5 minutes. If you specify a value
 * less than 5 minutes, the Batch service rejects the request with an error; if
 * you are calling the REST API directly, the HTTP status code is 400 (Bad
 * Request).
 * 
 * @param {number} [job.poolInfo.autoPoolSpecification.pool.targetDedicated]
 * The desired number of compute nodes in the pool. This property must not be
 * specified if enableAutoScale is set to true. It is required if
 * enableAutoScale is set to false.
 * 
 * @param {boolean} [job.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the pool size should automatically adjust over time. If false, the
 * targetDedicated element is required. If true, the autoScaleFormula element
 * is required. The pool automatically resizes according to the formula. The
 * default value is false.
 * 
 * @param {string} [job.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * The formula for the desired number of compute nodes in the pool. This
 * property must not be specified if enableAutoScale is set to false. It is
 * required if enableAutoScale is set to true. The formula is checked for
 * validity before the pool is created. If the formula is not valid, the Batch
 * service rejects the request with detailed error information.
 * 
 * @param {moment.duration}
 * [job.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval] The
 * time interval at which to automatically adjust the pool size according to
 * the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 * 
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the pool permits direct communication between nodes. Enabling
 * inter-node communication limits the maximum size of the pool due to
 * deployment restrictions on the nodes of the pool. This may result in the
 * pool not reaching its desired size. The default value is false.
 * 
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration] The network
 * configuration for the pool.
 * 
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId] The
 * ARM resource identifier of the virtual network subnet which the compute
 * nodes of the pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch account. The specified subnet should have enough free IP addresses to
 * accommodate the number of nodes in the pool. If the subnet doesn't have
 * enough free IP addresses, the pool will partially allocate compute nodes,
 * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
 * must have the 'Classic Virtual Machine Contributor' Role-Based Access
 * Control (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule tasks on
 * the compute nodes. This can be verified by checking if the specified VNet
 * has any associated Network Security Groups (NSG). If communication to the
 * compute nodes in the specified subnet is denied by an NSG, then the Batch
 * service will set the state of the compute nodes to unusable. This property
 * can only be specified for pools created with a cloudServiceConfiguration.
 * 
 * @param {object} [job.poolInfo.autoPoolSpecification.pool.startTask] A task
 * to run on each compute node as it joins the pool. The task runs when the
 * node is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.startTask.commandLine The command
 * line of the start task. The command line does not run under a shell, and
 * therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles] A list of
 * files that the Batch service will download to the compute node before
 * running the command line.
 * 
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings] A
 * list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.runElevated] Whether to
 * run the start task in elevated mode. The default value is false.
 * 
 * @param {number}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount] The
 * maximum number of times the task may be retried. The Batch service retries a
 * task if its exit code is nonzero. Note that this value specifically controls
 * the number of retries. The Batch service will try the task once, and may
 * then retry up to this limit. For example, if the maximum retry count is 3,
 * Batch tries the task up to 4 times (one initial try and 3 retries). If the
 * maximum retry count is 0, the Batch service does not retry the task. If the
 * maximum retry count is -1, the Batch service retries the task without limit.
 * 
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess] Whether
 * the Batch service should wait for the start task to complete successfully
 * (that is, to exit with exit code 0) before scheduling any tasks on the
 * compute node. If true and the start task fails on a compute node, the Batch
 * service retries the start task up to its maximum retry count
 * (maxTaskRetryCount). If the task has still not completed successfully after
 * all retries, then the Batch service marks the compute node unusable, and
 * will not schedule tasks to it. This condition can be detected via the node
 * state and scheduling error detail. If false, the Batch service will not wait
 * for the start task to complete. In this case, other tasks can start
 * executing on the compute node while the start task is still running; and
 * even if the start task fails, new tasks will continue to be scheduled on the
 * node. The default is false.
 * 
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.certificateReferences] A list of
 * certificates to be installed on each compute node in the pool. For Windows
 * compute nodes, the Batch service installs the certificates to the specified
 * certificate store and location. For Linux compute nodes, the certificates
 * are stored in a directory inside the task working directory and an
 * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
 * query for this location. For certificates with visibility of remoteuser, a
 * certs directory is created in the user's home directory (e.g.,
 * /home/<user-name>/certs) where certificates are placed.
 * 
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.applicationPackageReferences] The
 * list of application packages to be installed on each compute node in the
 * pool. This property is currently not supported on auto pools created with
 * the virtualMachineConfiguration (IaaS) property.
 * 
 * @param {array} [job.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 * 
 * @param {string} [job.onAllTasksComplete] The action the Batch service should
 * take when all tasks in the job are in the completed state. Note that if a
 * job contains no tasks, then all tasks are considered complete. This option
 * is therefore most commonly used with a job manager task; if you want to use
 * automatic job termination without a job manager, you should initially set
 * onAllTasksComplete to noaction and update the job properties to set
 * onAllTasksComplete to terminatejob once you have finished adding tasks.
 * Permitted values are: noaction – do nothing. The job remains active unless
 * terminated or disabled by some other means. terminatejob – terminate the
 * job. The job’s terminateReason is set to 'AllTasksComplete'. The default is
 * noaction. Possible values include: 'noAction', 'terminateJob'
 * 
 * @param {string} [job.onTaskFailure] The action the Batch service should take
 * when any task in the job fails. A task is considered to have failed if it
 * completes with a non-zero exit code and has exhausted its retry count, or if
 * it had a scheduling error. Permitted values are: noaction – do nothing.
 * performexitoptionsjobaction – take the action associated with the task exit
 * condition in the task's exitConditions collection. (This may still result in
 * no action being taken, if that is what the task specifies.) The default is
 * noaction. Possible values include: 'noAction', 'performExitOptionsJobAction'
 * 
 * @param {array} [job.metadata] A list of name-value pairs associated with the
 * job as metadata. The Batch service does not assign any meaning to metadata;
 * it is solely for the use of user code.
 * 
 * @param {boolean} [job.usesTaskDependencies] The flag that determines if this
 * job will use tasks with dependencies.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobAddOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.jobAddOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobAddOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobAddOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobAddOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.add = function (job, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
  // Validate
  try {
    if (job === null || job === undefined) {
      throw new Error('job cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobAddOptions !== null && jobAddOptions !== undefined)
    {
      timeout = jobAddOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined)
    {
      clientRequestId = jobAddOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined)
    {
      returnClientRequestId = jobAddOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined)
    {
      ocpDate = jobAddOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (job !== null && job !== undefined) {
      var requestModelMapper = new client.models['JobAddParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, job, 'job');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(job, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 201) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists all of the jobs in the specified account.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.jobListOptions.filter] An OData $filter clause.
 * 
 * @param {string} [options.jobListOptions.select] An OData $select clause.
 * 
 * @param {string} [options.jobListOptions.expand] An OData $expand clause.
 * 
 * @param {number} [options.jobListOptions.maxResults] The maximum number of
 * items to return in the response. A maximum of 1000 jobs can be returned.
 * 
 * @param {number} [options.jobListOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.jobListOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobListOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobListOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.list = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var filter;
  var select;
  var expand;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      filter = jobListOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      select = jobListOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      expand = jobListOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      maxResults = jobListOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      timeout = jobListOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      clientRequestId = jobListOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      returnClientRequestId = jobListOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined)
    {
      ocpDate = jobListOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists the jobs that have been created under the specified job
 * schedule.
 *
 * @param {string} jobScheduleId The ID of the job schedule from which you want
 * to get a list of jobs.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListFromJobScheduleOptions] Additional
 * parameters for the operation
 * 
 * @param {string} [options.jobListFromJobScheduleOptions.filter] An OData
 * $filter clause.
 * 
 * @param {string} [options.jobListFromJobScheduleOptions.select] An OData
 * $select clause.
 * 
 * @param {string} [options.jobListFromJobScheduleOptions.expand] An OData
 * $expand clause.
 * 
 * @param {number} [options.jobListFromJobScheduleOptions.maxResults] The
 * maximum number of items to return in the response. A maximum of 1000 jobs
 * can be returned.
 * 
 * @param {number} [options.jobListFromJobScheduleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobListFromJobScheduleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobListFromJobScheduleOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobListFromJobScheduleOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.listFromJobSchedule = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var filter;
  var select;
  var expand;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      filter = jobListFromJobScheduleOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      select = jobListFromJobScheduleOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      expand = jobListFromJobScheduleOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      maxResults = jobListFromJobScheduleOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      timeout = jobListFromJobScheduleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined)
    {
      ocpDate = jobListFromJobScheduleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/jobs';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists the execution status of the Job Preparation and Job Release
 * task for the specified job across the compute nodes where the job has run.
 *
 * This API returns the Job Preparation and Job Release task status on all
 * compute nodes that have run the Job Preparation or Job Release task. This
 * includes nodes which have since been removed from the pool.
 *
 * @param {string} jobId The ID of the job.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListPreparationAndReleaseTaskStatusOptions]
 * Additional parameters for the operation
 * 
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.filter] An OData
 * $filter clause.
 * 
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.select] An OData
 * $select clause.
 * 
 * @param {number}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.maxResults] The
 * maximum number of items to return in the response. A maximum of 1000 tasks
 * can be returned.
 * 
 * @param {number}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link
 *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.listPreparationAndReleaseTaskStatus = function (jobId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
  // Validate
  try {
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var filter;
  var select;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      select = jobListPreparationAndReleaseTaskStatusOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined)
    {
      ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/jobpreparationandreleasetaskstatus';
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListPreparationAndReleaseTaskStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists all of the jobs in the specified account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListNextOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.jobListNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobListNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobListNextOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.listNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListNextOptions !== null && jobListNextOptions !== undefined)
    {
      clientRequestId = jobListNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListNextOptions !== null && jobListNextOptions !== undefined)
    {
      returnClientRequestId = jobListNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListNextOptions !== null && jobListNextOptions !== undefined)
    {
      ocpDate = jobListNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists the jobs that have been created under the specified job
 * schedule.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListFromJobScheduleNextOptions] Additional
 * parameters for the operation
 * 
 * @param {string} [options.jobListFromJobScheduleNextOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobListFromJobScheduleNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.jobListFromJobScheduleNextOptions.ocpDate] The time
 * the request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.listFromJobScheduleNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined)
    {
      clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined)
    {
      returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined)
    {
      ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists the execution status of the Job Preparation and Job Release
 * task for the specified job across the compute nodes where the job has run.
 *
 * This API returns the Job Preparation and Job Release task status on all
 * compute nodes that have run the Job Preparation or Job Release task. This
 * includes nodes which have since been removed from the pool.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobListPreparationAndReleaseTaskStatusNextOptions]
 * Additional parameters for the operation
 * 
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate] The time
 * the request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link
 *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Job.prototype.listPreparationAndReleaseTaskStatusNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined)
    {
      clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined)
    {
      returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined)
    {
      ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobListPreparationAndReleaseTaskStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};


module.exports = Job;
