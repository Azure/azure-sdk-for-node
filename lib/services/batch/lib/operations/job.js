/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * @summary Gets lifetime summary statistics for all of the Jobs in the
 * specified Account.
 *
 * Statistics are aggregated across all Jobs that have ever existed in the
 * Account, from Account creation to the last update time of the statistics.
 * The statistics may not be immediately available. The Batch service performs
 * periodic roll-up of statistics. The typical delay is about 30 minutes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobGetAllLifetimeStatisticsOptions] Additional
 * parameters for the operation
 *
 * @param {number} [options.jobGetAllLifetimeStatisticsOptions.timeout] The
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 *
 * @param {uuid} [options.jobGetAllLifetimeStatisticsOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.jobGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobGetAllLifetimeStatisticsOptions.ocpDate] The time
 * the request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link JobStatistics} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllLifetimeStatistics(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobGetAllLifetimeStatisticsOptions = (options && options.jobGetAllLifetimeStatisticsOptions !== undefined) ? options.jobGetAllLifetimeStatisticsOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
      timeout = jobGetAllLifetimeStatisticsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
      clientRequestId = jobGetAllLifetimeStatisticsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
      returnClientRequestId = jobGetAllLifetimeStatisticsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobGetAllLifetimeStatisticsOptions !== null && jobGetAllLifetimeStatisticsOptions !== undefined) {
      ocpDate = jobGetAllLifetimeStatisticsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimejobstats';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['JobStatistics']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a Job.
 *
 * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
 * statistics. This also overrides the retention period for Task data; that is,
 * if the Job contains Tasks which are still retained on Compute Nodes, the
 * Batch services deletes those Tasks' working directories and all their
 * contents.  When a Delete Job request is received, the Batch service sets the
 * Job to the deleting state. All update operations on a Job that is in
 * deleting state will fail with status code 409 (Conflict), with additional
 * information indicating that the Job is being deleted.
 *
 * @param {string} jobId The ID of the Job to delete.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobDeleteMethodOptions] Additional parameters for
 * the operation
 *
 * @param {number} [options.jobDeleteMethodOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 *
 * @param {uuid} [options.jobDeleteMethodOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobDeleteMethodOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobDeleteMethodOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobDeleteMethodOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.jobDeleteMethodOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobDeleteMethodOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobDeleteMethodOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobDeleteMethodOptions = (options && options.jobDeleteMethodOptions !== undefined) ? options.jobDeleteMethodOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      timeout = jobDeleteMethodOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      clientRequestId = jobDeleteMethodOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      returnClientRequestId = jobDeleteMethodOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      ocpDate = jobDeleteMethodOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      ifMatch = jobDeleteMethodOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      ifNoneMatch = jobDeleteMethodOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      ifModifiedSince = jobDeleteMethodOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobDeleteMethodOptions !== null && jobDeleteMethodOptions !== undefined) {
      ifUnmodifiedSince = jobDeleteMethodOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information about the specified Job.
 *
 * @param {string} jobId The ID of the Job.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobGetOptions] Additional parameters for the
 * operation
 *
 * @param {string} [options.jobGetOptions.select] An OData $select clause.
 *
 * @param {string} [options.jobGetOptions.expand] An OData $expand clause.
 *
 * @param {number} [options.jobGetOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobGetOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobGetOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.jobGetOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobGetOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.jobGetOptions.ifNoneMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service does not match
 * the value specified by the client.
 *
 * @param {date} [options.jobGetOptions.ifModifiedSince] A timestamp indicating
 * the last modified time of the resource known to the client. The operation
 * will be performed only if the resource on the service has been modified
 * since the specified time.
 *
 * @param {date} [options.jobGetOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudJob} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobGetOptions = (options && options.jobGetOptions !== undefined) ? options.jobGetOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let select;
  let expand;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      select = jobGetOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      expand = jobGetOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      timeout = jobGetOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      clientRequestId = jobGetOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      returnClientRequestId = jobGetOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      ocpDate = jobGetOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      ifMatch = jobGetOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      ifNoneMatch = jobGetOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      ifModifiedSince = jobGetOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobGetOptions !== null && jobGetOptions !== undefined) {
      ifUnmodifiedSince = jobGetOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJob']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the properties of the specified Job.
 *
 * This replaces only the Job properties specified in the request. For example,
 * if the Job has constraints, and a request does not specify the constraints
 * element, then the Job keeps the existing constraints.
 *
 * @param {string} jobId The ID of the Job whose properties you want to update.
 *
 * @param {object} jobPatchParameter The parameters for the request.
 *
 * @param {number} [jobPatchParameter.priority] The priority of the Job.
 * Priority values can range from -1000 to 1000, with -1000 being the lowest
 * priority and 1000 being the highest priority. If omitted, the priority of
 * the Job is left unchanged.
 *
 * @param {string} [jobPatchParameter.onAllTasksComplete] The action the Batch
 * service should take when all Tasks in the Job are in the completed state. If
 * omitted, the completion behavior is left unchanged. You may not change the
 * value from terminatejob to noaction - that is, once you have engaged
 * automatic Job termination, you cannot turn it off again. If you try to do
 * this, the request fails with an 'invalid property value' error response; if
 * you are calling the REST API directly, the HTTP status code is 400 (Bad
 * Request). Possible values include: 'noAction', 'terminateJob'
 *
 * @param {object} [jobPatchParameter.constraints] The execution constraints
 * for the Job. If omitted, the existing execution constraints are left
 * unchanged.
 *
 * @param {moment.duration} [jobPatchParameter.constraints.maxWallClockTime]
 * The maximum elapsed time that the Job may run, measured from the time the
 * Job is created. If the Job does not complete within the time limit, the
 * Batch service terminates it and any Tasks that are still running. In this
 * case, the termination reason will be MaxWallClockTimeExpiry. If this
 * property is not specified, there is no time limit on how long the Job may
 * run.
 *
 * @param {number} [jobPatchParameter.constraints.maxTaskRetryCount] The
 * maximum number of times each Task may be retried. The Batch service retries
 * a Task if its exit code is nonzero. Note that this value specifically
 * controls the number of retries. The Batch service will try each Task once,
 * and may then retry up to this limit. For example, if the maximum retry count
 * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
 * the maximum retry count is 0, the Batch service does not retry Tasks. If the
 * maximum retry count is -1, the Batch service retries Tasks without limit.
 * The default value is 0 (no retries).
 *
 * @param {object} [jobPatchParameter.poolInfo] The Pool on which the Batch
 * service runs the Job's Tasks. You may change the Pool for a Job only when
 * the Job is disabled. The Patch Job call will fail if you include the
 * poolInfo element and the Job is not disabled. If you specify an
 * autoPoolSpecification in the poolInfo, only the keepAlive property of the
 * autoPoolSpecification can be updated, and then only if the
 * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
 * can be updated as normal). If omitted, the Job continues to run on its
 * current Pool.
 *
 * @param {string} [jobPatchParameter.poolInfo.poolId] The ID of an existing
 * Pool. All the Tasks of the Job will run on the specified Pool. You must
 * ensure that the Pool referenced by this property exists. If the Pool does
 * not exist at the time the Batch service tries to schedule a Job, no Tasks
 * for the Job will run until you create a Pool with that id. Note that the
 * Batch service will not reject the Job request; it will simply not run Tasks
 * until the Pool exists. You must specify either the Pool ID or the auto Pool
 * specification, but not both.
 *
 * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification]
 * Characteristics for a temporary 'auto pool'. The Batch service will create
 * this auto Pool when the Job is submitted. If auto Pool creation fails, the
 * Batch service moves the Job to a completed state, and the Pool creation
 * error is set in the Job's scheduling error property. The Batch service
 * manages the lifetime (both creation and, unless keepAlive is specified,
 * deletion) of the auto Pool. Any user actions that affect the lifetime of the
 * auto Pool while the Job is active will result in unexpected behavior. You
 * must specify either the Pool ID or the auto Pool specification, but not
 * both.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A prefix
 * to be added to the unique identifier when a Pool is automatically created.
 * The Batch service assigns each auto Pool a unique identifier on creation. To
 * distinguish between Pools created for different purposes, you can specify
 * this element to add a prefix to the ID that is assigned. The prefix can be
 * up to 20 characters long.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
 * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
 *
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to keep
 * an auto Pool alive after its lifetime expires. If false, the Batch service
 * deletes the Pool once its lifetime (as determined by the poolLifetimeOption
 * setting) expires; that is, when the Job or Job Schedule completes. If true,
 * the Batch service does not delete the Pool automatically. It is up to the
 * user to delete auto Pools created with this option.
 *
 * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification.pool] The
 * Pool specification for the auto Pool.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the Pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 *
 * @param {string} jobPatchParameter.poolInfo.autoPoolSpecification.pool.vmSize
 * The size of the virtual machines in the Pool. All virtual machines in a Pool
 * are the same size. For information about available sizes of virtual machines
 * in Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
 * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
 * The cloud service configuration for the Pool. This property must be
 * specified if the Pool needs to be created with Azure PaaS VMs. This property
 * and virtualMachineConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request). This property cannot be specified if the Batch
 * Account was created with its poolAllocationMode property set to
 * 'UserSubscription'.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * Pool. Possible values are:
 * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
 * 3 - OS Family 3, equivalent to Windows Server 2012.
 * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
 * 5 - OS Family 5, equivalent to Windows Server 2016.
 * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
 * see Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * Pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
 * The virtual machine configuration for the Pool. This property must be
 * specified if the Pool needs to be created with Azure IaaS VMs. This property
 * and cloudServiceConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 *
 * @param {object}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace Image or the custom
 * Virtual Machine Image to use.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
 * The publisher of the Azure Virtual Machines Marketplace Image. For example,
 * Canonical or MicrosoftWindowsServer.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
 * The offer type of the Azure Virtual Machines Marketplace Image. For example,
 * UbuntuServer or WindowsServer.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
 * The SKU of the Azure Virtual Machines Marketplace Image. For example,
 * 18.04-LTS or 2019-Datacenter.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace Image. A value of
 * 'latest' can be specified to select the latest version of an Image. If
 * omitted, the default is 'latest'.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
 * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
 * in the Pool will be created using this Image Id. This is of the form
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
 * or
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
 * for always defaulting to the latest image version. This property is mutually
 * exclusive with other ImageReference properties. The Shared Image Gallery
 * Image must have replicas in the same region and must be in the same
 * subscription as the Azure Batch account. If the image version is not
 * specified in the imageId, the latest version will be used. For information
 * about the firewall settings for the Batch Compute Node agent to communicate
 * with the Batch service see
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
 * in the Pool. The Batch Compute Node agent is a program that runs on each
 * Compute Node in the Pool, and provides the command-and-control interface
 * between the Compute Node and the Batch service. There are different
 * implementations of the Compute Node agent, known as SKUs, for different
 * operating systems. You must specify a Compute Node agent SKU which matches
 * the selected Image reference. To get the list of supported Compute Node
 * agent SKUs along with their list of verified Image references, see the 'List
 * supported Compute Node agent SKUs' operation.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS Image.
 *
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
 * The configuration for data disks attached to the Compute Nodes in the Pool.
 * This property must be specified if the Compute Nodes in the Pool need to
 * have empty data disks attached to them. This cannot be updated. Each Compute
 * Node gets its own disk (the disk is not a file share). Existing disks cannot
 * be attached, each attached disk is empty. When the Compute Node is removed
 * from the Pool, the disk and all data associated with it is also deleted. The
 * disk is not formatted after being attached, it must be formatted before use
 * - for more information see
 * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
 * and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
 * The type of on-premises license to be used when deploying the operating
 * system. This only applies to Images that contain the Windows operating
 * system, and should only be used when you hold valid on-premises licenses for
 * the Compute Nodes which will be deployed. If omitted, no on-premises
 * licensing discount is applied. Values are:
 *
 * Windows_Server - The on-premises license is for Windows Server.
 * Windows_Client - The on-premises license is for Windows Client.
 *
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
 * The container configuration for the Pool. If specified, setup is performed
 * on each Compute Node in the Pool to allow Tasks to run in containers. All
 * regular Tasks and Job manager Tasks run on this Pool must specify the
 * containerSettings property, and all other Tasks may specify it.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
 * The collection of container Image names. This is the full Image reference,
 * as would be specified to "docker pull". An Image will be sourced from the
 * default Docker registry unless the Image is fully qualified with an
 * alternative registry.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
 * Additional private registries from which containers can be pulled. If any
 * Images must be downloaded from a private registry which requires
 * credentials, then those credentials must be provided here.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
 * The disk encryption configuration for the pool. If specified, encryption is
 * performed on each node in the pool during node provisioning.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
 * The list of disk targets Batch Service will encrypt on the compute node. If
 * omitted, no disks on the compute nodes in the pool will be encrypted. On
 * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
 * "TemporaryDisk" must be specified.
 *
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode] The
 * number of task slots that can be used to run concurrent tasks on a single
 * compute node in the pool. The default value is 1. The maximum value is the
 * smaller of 4 times the number of cores of the vmSize of the pool or 256.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
 * the default is spread.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
 * the default is spread. Possible values include: 'spread', 'pack'
 *
 * @param {moment.duration}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
 * timeout for allocation of Compute Nodes to the Pool. This timeout applies
 * only to manual scaling; it has no effect when enableAutoScale is set to
 * true. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service rejects the
 * request with an error; if you are calling the REST API directly, the HTTP
 * status code is 400 (Bad Request).
 *
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
 * The desired number of dedicated Compute Nodes in the Pool. This property
 * must not be specified if enableAutoScale is set to true. If enableAutoScale
 * is set to false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
 * The desired number of low-priority Compute Nodes in the Pool. This property
 * must not be specified if enableAutoScale is set to true. If enableAutoScale
 * is set to false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the Pool size should automatically adjust over time. If false, at
 * least one of targetDedicateNodes and targetLowPriorityNodes must be
 * specified. If true, the autoScaleFormula element is required. The Pool
 * automatically resizes according to the formula. The default value is false.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula] The
 * formula for the desired number of Compute Nodes in the Pool. This property
 * must not be specified if enableAutoScale is set to false. It is required if
 * enableAutoScale is set to true. The formula is checked for validity before
 * the Pool is created. If the formula is not valid, the Batch service rejects
 * the request with detailed error information.
 *
 * @param {moment.duration}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * The time interval at which to automatically adjust the Pool size according
 * to the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 *
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the Pool permits direct communication between Compute Nodes.
 * Enabling inter-node communication limits the maximum size of the Pool due to
 * deployment restrictions on the Compute Nodes of the Pool. This may result in
 * the Pool not reaching its desired size. The default value is false.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
 * The network configuration for the Pool.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
 * The ARM resource identifier of the virtual network subnet which the Compute
 * Nodes of the Pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch Account. The specified subnet should have enough free IP addresses to
 * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
 * have enough free IP addresses, the Pool will partially allocate Nodes and a
 * resize error will occur. The 'MicrosoftAzureBatch' service principal must
 * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
 * (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule Tasks on
 * the Nodes. This can be verified by checking if the specified VNet has any
 * associated Network Security Groups (NSG). If communication to the Nodes in
 * the specified subnet is denied by an NSG, then the Batch service will set
 * the state of the Compute Nodes to unusable. For Pools created with
 * virtualMachineConfiguration only ARM virtual networks
 * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
 * with cloudServiceConfiguration both ARM and classic virtual networks are
 * supported. If the specified VNet has any associated Network Security Groups
 * (NSG), then a few reserved system ports must be enabled for inbound
 * communication. For Pools created with a virtual machine configuration,
 * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
 * Windows. For Pools created with a cloud service configuration, enable ports
 * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
 * on port 443. For more details see:
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
 * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
 * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
 * endpoint configuration is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {array}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
 * A list of inbound NAT Pools that can be used to address specific ports on an
 * individual Compute Node externally. The maximum number of inbound NAT Pools
 * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
 * the request fails with HTTP status code 400. This cannot be specified if the
 * IPAddressProvisioningType is NoPublicIPAddresses.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
 * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
 * Public IP configuration property is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
 * The provisioning type for Public IP Addresses for the Pool. The default
 * value is BatchManaged. Possible values include: 'batchManaged',
 * 'userManaged', 'noPublicIPAddresses'
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
 * The list of public IPs which the Batch service will use when provisioning
 * Compute Nodes. The number of IPs specified here limits the maximum size of
 * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
 * for each public IP. For example, a pool needing 250 dedicated VMs would need
 * at least 3 public IPs specified. Each element of this collection is of the
 * form:
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
 * run on each Compute Node as it joins the Pool. The Task runs when the
 * Compute Node is added to the Pool or when the Compute Node is restarted.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
 * The command line of the StartTask. The command line does not run under a
 * shell, and therefore cannot take advantage of shell features such as
 * environment variable expansion. If you want to take advantage of such
 * features, you should invoke the shell in the command line, for example using
 * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
 * command line refers to file paths, it should use a relative path (relative
 * to the Task working directory), or use the Batch provided environment
 * variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
 * The settings for the container under which the StartTask runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all Task environment variables are mapped into the container, and the Task
 * command line is executed in the container. Files produced in the container
 * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
 * meaning that Batch file APIs will not be able to access those files.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
 * The Image to use to create the container in which the Task will run. This is
 * the full Image reference, as would be specified to "docker pull". If no tag
 * is provided as part of the Image name, the tag ":latest" is used as a
 * default.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
 * The private registry which contains the container Image. This setting can be
 * omitted if was already provided at Pool creation.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
 * The registry URL. If omitted, the default is "docker.io".
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
 * The user name to log into the registry server.
 *
 * @param {string}
 * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
 * The password to log into the registry server.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
 * The location of the container Task working directory. The default is
 * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
 * 'containerImageDefault'
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * A list of files that the Batch service will download to the Compute Node
 * before running the command line.  There is a maximum size for the list of
 * resource files. When the max size is exceeded, the request will fail and the
 * response error code will be RequestEntityTooLarge. If this occurs, the
 * collection of ResourceFiles must be reduced in size. This can be achieved
 * using .zip files, Application Packages, or Docker Containers. Files listed
 * under this element are located in the Task's working directory.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * A list of environment variable settings for the StartTask.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
 * The user identity under which the StartTask runs. If omitted, the Task runs
 * as a non-administrative user unique to the Task.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
 * The name of the user identity under which the Task is run. The userName and
 * autoUser properties are mutually exclusive; you must specify one but not
 * both.
 *
 * @param {object}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
 * The auto user under which the Task is run. The userName and autoUser
 * properties are mutually exclusive; you must specify one but not both.
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
 * The scope for the auto user The default value is pool. If the pool is
 * running Windows a value of Task should be specified if stricter isolation
 * between tasks is required. For example, if the task mutates the registry in
 * a way which could impact other tasks, or if certificates have been specified
 * on the pool which should not be accessible by normal tasks but should be
 * accessible by StartTasks. Possible values include: 'task', 'pool'
 *
 * @param {string}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
 * The elevation level of the auto user. The default value is nonAdmin.
 * Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * The maximum number of times the Task may be retried. The Batch service
 * retries a Task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * Task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the Task. If the maximum retry count is -1, the Batch service retries the
 * Task without limit.
 *
 * @param {boolean}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Whether the Batch service should wait for the StartTask to complete
 * successfully (that is, to exit with exit code 0) before scheduling any Tasks
 * on the Compute Node. If true and the StartTask fails on a Node, the Batch
 * service retries the StartTask up to its maximum retry count
 * (maxTaskRetryCount). If the Task has still not completed successfully after
 * all retries, then the Batch service marks the Node unusable, and will not
 * schedule Tasks to it. This condition can be detected via the Compute Node
 * state and failure info details. If false, the Batch service will not wait
 * for the StartTask to complete. In this case, other Tasks can start executing
 * on the Compute Node while the StartTask is still running; and even if the
 * StartTask fails, new Tasks will continue to be scheduled on the Compute
 * Node. The default is true.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * A list of Certificates to be installed on each Compute Node in the Pool. For
 * Windows Nodes, the Batch service installs the Certificates to the specified
 * Certificate store and location. For Linux Compute Nodes, the Certificates
 * are stored in a directory inside the Task working directory and an
 * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
 * query for this location. For Certificates with visibility of 'remoteUser', a
 * 'certs' directory is created in the user's home directory (e.g.,
 * /home/{user-name}/certs) and Certificates are placed in that directory.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * The list of Packages to be installed on each Compute Node in the Pool.
 * Changes to Package references affect all new Nodes joining the Pool, but do
 * not affect Compute Nodes that are already in the Pool until they are
 * rebooted or reimaged. There is a maximum of 10 Package references on any
 * given Pool.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
 * The list of application licenses the Batch service will make available on
 * each Compute Node in the Pool. The list of application licenses must be a
 * subset of available Batch service application licenses. If a license is
 * requested which is not supported, Pool creation will fail. The permitted
 * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
 * additional charge applies for each application license added to the Pool.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
 * list of user Accounts to be created on each Compute Node in the Pool.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the Pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 *
 * @param {array}
 * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration] A
 * list of file systems to mount on each node in the pool. This supports Azure
 * Files, NFS, CIFS/SMB, and Blobfuse.
 *
 * @param {array} [jobPatchParameter.metadata] A list of name-value pairs
 * associated with the Job as metadata. If omitted, the existing Job metadata
 * is left unchanged.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobPatchOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobPatchOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobPatchOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobPatchOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.jobPatchOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobPatchOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.jobPatchOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobPatchOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobPatchOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _patch(jobId, jobPatchParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobPatchOptions = (options && options.jobPatchOptions !== undefined) ? options.jobPatchOptions : undefined;
  if (jobPatchParameter === null || jobPatchParameter === undefined)
  {
    jobPatchParameter = {};
  }
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (jobPatchParameter === null || jobPatchParameter === undefined) {
      throw new Error('jobPatchParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      timeout = jobPatchOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      clientRequestId = jobPatchOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      returnClientRequestId = jobPatchOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      ocpDate = jobPatchOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      ifMatch = jobPatchOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      ifNoneMatch = jobPatchOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      ifModifiedSince = jobPatchOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobPatchOptions !== null && jobPatchOptions !== undefined) {
      ifUnmodifiedSince = jobPatchOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (jobPatchParameter !== null && jobPatchParameter !== undefined) {
      let requestModelMapper = new client.models['JobPatchParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobPatchParameter, 'jobPatchParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(jobPatchParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the properties of the specified Job.
 *
 * This fully replaces all the updatable properties of the Job. For example, if
 * the Job has constraints associated with it and if constraints is not
 * specified with this request, then the Batch service will remove the existing
 * constraints.
 *
 * @param {string} jobId The ID of the Job whose properties you want to update.
 *
 * @param {object} jobUpdateParameter The parameters for the request.
 *
 * @param {number} [jobUpdateParameter.priority] The priority of the Job.
 * Priority values can range from -1000 to 1000, with -1000 being the lowest
 * priority and 1000 being the highest priority. If omitted, it is set to the
 * default value 0.
 *
 * @param {object} [jobUpdateParameter.constraints] The execution constraints
 * for the Job. If omitted, the constraints are cleared.
 *
 * @param {moment.duration} [jobUpdateParameter.constraints.maxWallClockTime]
 * The maximum elapsed time that the Job may run, measured from the time the
 * Job is created. If the Job does not complete within the time limit, the
 * Batch service terminates it and any Tasks that are still running. In this
 * case, the termination reason will be MaxWallClockTimeExpiry. If this
 * property is not specified, there is no time limit on how long the Job may
 * run.
 *
 * @param {number} [jobUpdateParameter.constraints.maxTaskRetryCount] The
 * maximum number of times each Task may be retried. The Batch service retries
 * a Task if its exit code is nonzero. Note that this value specifically
 * controls the number of retries. The Batch service will try each Task once,
 * and may then retry up to this limit. For example, if the maximum retry count
 * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
 * the maximum retry count is 0, the Batch service does not retry Tasks. If the
 * maximum retry count is -1, the Batch service retries Tasks without limit.
 * The default value is 0 (no retries).
 *
 * @param {object} jobUpdateParameter.poolInfo The Pool on which the Batch
 * service runs the Job's Tasks. You may change the Pool for a Job only when
 * the Job is disabled. The Update Job call will fail if you include the
 * poolInfo element and the Job is not disabled. If you specify an
 * autoPoolSpecification in the poolInfo, only the keepAlive property of the
 * autoPoolSpecification can be updated, and then only if the
 * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
 * can be updated as normal).
 *
 * @param {string} [jobUpdateParameter.poolInfo.poolId] The ID of an existing
 * Pool. All the Tasks of the Job will run on the specified Pool. You must
 * ensure that the Pool referenced by this property exists. If the Pool does
 * not exist at the time the Batch service tries to schedule a Job, no Tasks
 * for the Job will run until you create a Pool with that id. Note that the
 * Batch service will not reject the Job request; it will simply not run Tasks
 * until the Pool exists. You must specify either the Pool ID or the auto Pool
 * specification, but not both.
 *
 * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification]
 * Characteristics for a temporary 'auto pool'. The Batch service will create
 * this auto Pool when the Job is submitted. If auto Pool creation fails, the
 * Batch service moves the Job to a completed state, and the Pool creation
 * error is set in the Job's scheduling error property. The Batch service
 * manages the lifetime (both creation and, unless keepAlive is specified,
 * deletion) of the auto Pool. Any user actions that affect the lifetime of the
 * auto Pool while the Job is active will result in unexpected behavior. You
 * must specify either the Pool ID or the auto Pool specification, but not
 * both.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
 * prefix to be added to the unique identifier when a Pool is automatically
 * created. The Batch service assigns each auto Pool a unique identifier on
 * creation. To distinguish between Pools created for different purposes, you
 * can specify this element to add a prefix to the ID that is assigned. The
 * prefix can be up to 20 characters long.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
 * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
 *
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to
 * keep an auto Pool alive after its lifetime expires. If false, the Batch
 * service deletes the Pool once its lifetime (as determined by the
 * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
 * completes. If true, the Batch service does not delete the Pool
 * automatically. It is up to the user to delete auto Pools created with this
 * option.
 *
 * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification.pool] The
 * Pool specification for the auto Pool.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the Pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.vmSize The size of
 * the virtual machines in the Pool. All virtual machines in a Pool are the
 * same size. For information about available sizes of virtual machines in
 * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
 * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
 * The cloud service configuration for the Pool. This property must be
 * specified if the Pool needs to be created with Azure PaaS VMs. This property
 * and virtualMachineConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request). This property cannot be specified if the Batch
 * Account was created with its poolAllocationMode property set to
 * 'UserSubscription'.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * Pool. Possible values are:
 * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
 * 3 - OS Family 3, equivalent to Windows Server 2012.
 * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
 * 5 - OS Family 5, equivalent to Windows Server 2016.
 * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
 * see Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * Pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
 * The virtual machine configuration for the Pool. This property must be
 * specified if the Pool needs to be created with Azure IaaS VMs. This property
 * and cloudServiceConfiguration are mutually exclusive and one of the
 * properties must be specified. If neither is specified then the Batch service
 * returns an error; if you are calling the REST API directly, the HTTP status
 * code is 400 (Bad Request).
 *
 * @param {object}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace Image or the custom
 * Virtual Machine Image to use.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
 * The publisher of the Azure Virtual Machines Marketplace Image. For example,
 * Canonical or MicrosoftWindowsServer.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
 * The offer type of the Azure Virtual Machines Marketplace Image. For example,
 * UbuntuServer or WindowsServer.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
 * The SKU of the Azure Virtual Machines Marketplace Image. For example,
 * 18.04-LTS or 2019-Datacenter.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace Image. A value of
 * 'latest' can be specified to select the latest version of an Image. If
 * omitted, the default is 'latest'.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
 * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
 * in the Pool will be created using this Image Id. This is of the form
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
 * or
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
 * for always defaulting to the latest image version. This property is mutually
 * exclusive with other ImageReference properties. The Shared Image Gallery
 * Image must have replicas in the same region and must be in the same
 * subscription as the Azure Batch account. If the image version is not
 * specified in the imageId, the latest version will be used. For information
 * about the firewall settings for the Batch Compute Node agent to communicate
 * with the Batch service see
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
 * in the Pool. The Batch Compute Node agent is a program that runs on each
 * Compute Node in the Pool, and provides the command-and-control interface
 * between the Compute Node and the Batch service. There are different
 * implementations of the Compute Node agent, known as SKUs, for different
 * operating systems. You must specify a Compute Node agent SKU which matches
 * the selected Image reference. To get the list of supported Compute Node
 * agent SKUs along with their list of verified Image references, see the 'List
 * supported Compute Node agent SKUs' operation.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS Image.
 *
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
 * The configuration for data disks attached to the Compute Nodes in the Pool.
 * This property must be specified if the Compute Nodes in the Pool need to
 * have empty data disks attached to them. This cannot be updated. Each Compute
 * Node gets its own disk (the disk is not a file share). Existing disks cannot
 * be attached, each attached disk is empty. When the Compute Node is removed
 * from the Pool, the disk and all data associated with it is also deleted. The
 * disk is not formatted after being attached, it must be formatted before use
 * - for more information see
 * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
 * and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
 * The type of on-premises license to be used when deploying the operating
 * system. This only applies to Images that contain the Windows operating
 * system, and should only be used when you hold valid on-premises licenses for
 * the Compute Nodes which will be deployed. If omitted, no on-premises
 * licensing discount is applied. Values are:
 *
 * Windows_Server - The on-premises license is for Windows Server.
 * Windows_Client - The on-premises license is for Windows Client.
 *
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
 * The container configuration for the Pool. If specified, setup is performed
 * on each Compute Node in the Pool to allow Tasks to run in containers. All
 * regular Tasks and Job manager Tasks run on this Pool must specify the
 * containerSettings property, and all other Tasks may specify it.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
 * The collection of container Image names. This is the full Image reference,
 * as would be specified to "docker pull". An Image will be sourced from the
 * default Docker registry unless the Image is fully qualified with an
 * alternative registry.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
 * Additional private registries from which containers can be pulled. If any
 * Images must be downloaded from a private registry which requires
 * credentials, then those credentials must be provided here.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
 * The disk encryption configuration for the pool. If specified, encryption is
 * performed on each node in the pool during node provisioning.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
 * The list of disk targets Batch Service will encrypt on the compute node. If
 * omitted, no disks on the compute nodes in the pool will be encrypted. On
 * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
 * "TemporaryDisk" must be specified.
 *
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
 * The number of task slots that can be used to run concurrent tasks on a
 * single compute node in the pool. The default value is 1. The maximum value
 * is the smaller of 4 times the number of cores of the vmSize of the pool or
 * 256.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
 * the default is spread.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
 * the default is spread. Possible values include: 'spread', 'pack'
 *
 * @param {moment.duration}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
 * timeout for allocation of Compute Nodes to the Pool. This timeout applies
 * only to manual scaling; it has no effect when enableAutoScale is set to
 * true. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service rejects the
 * request with an error; if you are calling the REST API directly, the HTTP
 * status code is 400 (Bad Request).
 *
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
 * The desired number of dedicated Compute Nodes in the Pool. This property
 * must not be specified if enableAutoScale is set to true. If enableAutoScale
 * is set to false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
 * The desired number of low-priority Compute Nodes in the Pool. This property
 * must not be specified if enableAutoScale is set to true. If enableAutoScale
 * is set to false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the Pool size should automatically adjust over time. If false, at
 * least one of targetDedicateNodes and targetLowPriorityNodes must be
 * specified. If true, the autoScaleFormula element is required. The Pool
 * automatically resizes according to the formula. The default value is false.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * The formula for the desired number of Compute Nodes in the Pool. This
 * property must not be specified if enableAutoScale is set to false. It is
 * required if enableAutoScale is set to true. The formula is checked for
 * validity before the Pool is created. If the formula is not valid, the Batch
 * service rejects the request with detailed error information.
 *
 * @param {moment.duration}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * The time interval at which to automatically adjust the Pool size according
 * to the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 *
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the Pool permits direct communication between Compute Nodes.
 * Enabling inter-node communication limits the maximum size of the Pool due to
 * deployment restrictions on the Compute Nodes of the Pool. This may result in
 * the Pool not reaching its desired size. The default value is false.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
 * The network configuration for the Pool.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
 * The ARM resource identifier of the virtual network subnet which the Compute
 * Nodes of the Pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch Account. The specified subnet should have enough free IP addresses to
 * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
 * have enough free IP addresses, the Pool will partially allocate Nodes and a
 * resize error will occur. The 'MicrosoftAzureBatch' service principal must
 * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
 * (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule Tasks on
 * the Nodes. This can be verified by checking if the specified VNet has any
 * associated Network Security Groups (NSG). If communication to the Nodes in
 * the specified subnet is denied by an NSG, then the Batch service will set
 * the state of the Compute Nodes to unusable. For Pools created with
 * virtualMachineConfiguration only ARM virtual networks
 * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
 * with cloudServiceConfiguration both ARM and classic virtual networks are
 * supported. If the specified VNet has any associated Network Security Groups
 * (NSG), then a few reserved system ports must be enabled for inbound
 * communication. For Pools created with a virtual machine configuration,
 * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
 * Windows. For Pools created with a cloud service configuration, enable ports
 * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
 * on port 443. For more details see:
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
 * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
 * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
 * endpoint configuration is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {array}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
 * A list of inbound NAT Pools that can be used to address specific ports on an
 * individual Compute Node externally. The maximum number of inbound NAT Pools
 * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
 * the request fails with HTTP status code 400. This cannot be specified if the
 * IPAddressProvisioningType is NoPublicIPAddresses.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
 * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
 * Public IP configuration property is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
 * The provisioning type for Public IP Addresses for the Pool. The default
 * value is BatchManaged. Possible values include: 'batchManaged',
 * 'userManaged', 'noPublicIPAddresses'
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
 * The list of public IPs which the Batch service will use when provisioning
 * Compute Nodes. The number of IPs specified here limits the maximum size of
 * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
 * for each public IP. For example, a pool needing 250 dedicated VMs would need
 * at least 3 public IPs specified. Each element of this collection is of the
 * form:
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
 * run on each Compute Node as it joins the Pool. The Task runs when the
 * Compute Node is added to the Pool or when the Compute Node is restarted.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
 * The command line of the StartTask. The command line does not run under a
 * shell, and therefore cannot take advantage of shell features such as
 * environment variable expansion. If you want to take advantage of such
 * features, you should invoke the shell in the command line, for example using
 * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
 * command line refers to file paths, it should use a relative path (relative
 * to the Task working directory), or use the Batch provided environment
 * variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
 * The settings for the container under which the StartTask runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all Task environment variables are mapped into the container, and the Task
 * command line is executed in the container. Files produced in the container
 * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
 * meaning that Batch file APIs will not be able to access those files.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
 * The Image to use to create the container in which the Task will run. This is
 * the full Image reference, as would be specified to "docker pull". If no tag
 * is provided as part of the Image name, the tag ":latest" is used as a
 * default.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
 * The private registry which contains the container Image. This setting can be
 * omitted if was already provided at Pool creation.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
 * The registry URL. If omitted, the default is "docker.io".
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
 * The user name to log into the registry server.
 *
 * @param {string}
 * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
 * The password to log into the registry server.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
 * The location of the container Task working directory. The default is
 * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
 * 'containerImageDefault'
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * A list of files that the Batch service will download to the Compute Node
 * before running the command line.  There is a maximum size for the list of
 * resource files. When the max size is exceeded, the request will fail and the
 * response error code will be RequestEntityTooLarge. If this occurs, the
 * collection of ResourceFiles must be reduced in size. This can be achieved
 * using .zip files, Application Packages, or Docker Containers. Files listed
 * under this element are located in the Task's working directory.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * A list of environment variable settings for the StartTask.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
 * The user identity under which the StartTask runs. If omitted, the Task runs
 * as a non-administrative user unique to the Task.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
 * The name of the user identity under which the Task is run. The userName and
 * autoUser properties are mutually exclusive; you must specify one but not
 * both.
 *
 * @param {object}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
 * The auto user under which the Task is run. The userName and autoUser
 * properties are mutually exclusive; you must specify one but not both.
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
 * The scope for the auto user The default value is pool. If the pool is
 * running Windows a value of Task should be specified if stricter isolation
 * between tasks is required. For example, if the task mutates the registry in
 * a way which could impact other tasks, or if certificates have been specified
 * on the pool which should not be accessible by normal tasks but should be
 * accessible by StartTasks. Possible values include: 'task', 'pool'
 *
 * @param {string}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
 * The elevation level of the auto user. The default value is nonAdmin.
 * Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * The maximum number of times the Task may be retried. The Batch service
 * retries a Task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * Task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the Task. If the maximum retry count is -1, the Batch service retries the
 * Task without limit.
 *
 * @param {boolean}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Whether the Batch service should wait for the StartTask to complete
 * successfully (that is, to exit with exit code 0) before scheduling any Tasks
 * on the Compute Node. If true and the StartTask fails on a Node, the Batch
 * service retries the StartTask up to its maximum retry count
 * (maxTaskRetryCount). If the Task has still not completed successfully after
 * all retries, then the Batch service marks the Node unusable, and will not
 * schedule Tasks to it. This condition can be detected via the Compute Node
 * state and failure info details. If false, the Batch service will not wait
 * for the StartTask to complete. In this case, other Tasks can start executing
 * on the Compute Node while the StartTask is still running; and even if the
 * StartTask fails, new Tasks will continue to be scheduled on the Compute
 * Node. The default is true.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * A list of Certificates to be installed on each Compute Node in the Pool. For
 * Windows Nodes, the Batch service installs the Certificates to the specified
 * Certificate store and location. For Linux Compute Nodes, the Certificates
 * are stored in a directory inside the Task working directory and an
 * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
 * query for this location. For Certificates with visibility of 'remoteUser', a
 * 'certs' directory is created in the user's home directory (e.g.,
 * /home/{user-name}/certs) and Certificates are placed in that directory.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * The list of Packages to be installed on each Compute Node in the Pool.
 * Changes to Package references affect all new Nodes joining the Pool, but do
 * not affect Compute Nodes that are already in the Pool until they are
 * rebooted or reimaged. There is a maximum of 10 Package references on any
 * given Pool.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
 * The list of application licenses the Batch service will make available on
 * each Compute Node in the Pool. The list of application licenses must be a
 * subset of available Batch service application licenses. If a license is
 * requested which is not supported, Pool creation will fail. The permitted
 * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
 * additional charge applies for each application license added to the Pool.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
 * list of user Accounts to be created on each Compute Node in the Pool.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the Pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 *
 * @param {array}
 * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration]
 * A list of file systems to mount on each node in the pool. This supports
 * Azure Files, NFS, CIFS/SMB, and Blobfuse.
 *
 * @param {array} [jobUpdateParameter.metadata] A list of name-value pairs
 * associated with the Job as metadata. If omitted, it takes the default value
 * of an empty list; in effect, any existing metadata is deleted.
 *
 * @param {string} [jobUpdateParameter.onAllTasksComplete] The action the Batch
 * service should take when all Tasks in the Job are in the completed state. If
 * omitted, the completion behavior is set to noaction. If the current value is
 * terminatejob, this is an error because a Job's completion behavior may not
 * be changed from terminatejob to noaction. You may not change the value from
 * terminatejob to noaction - that is, once you have engaged automatic Job
 * termination, you cannot turn it off again. If you try to do this, the
 * request fails and Batch returns status code 400 (Bad Request) and an
 * 'invalid property value' error response. If you do not specify this element
 * in a PUT request, it is equivalent to passing noaction. This is an error if
 * the current value is terminatejob. Possible values include: 'noAction',
 * 'terminateJob'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobUpdateOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobUpdateOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobUpdateOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobUpdateOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobUpdateOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobUpdateOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.jobUpdateOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobUpdateOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobUpdateOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _update(jobId, jobUpdateParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobUpdateOptions = (options && options.jobUpdateOptions !== undefined) ? options.jobUpdateOptions : undefined;
  if (jobUpdateParameter === null || jobUpdateParameter === undefined)
  {
    jobUpdateParameter = {};
  }
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (jobUpdateParameter === null || jobUpdateParameter === undefined) {
      throw new Error('jobUpdateParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      timeout = jobUpdateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      clientRequestId = jobUpdateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      returnClientRequestId = jobUpdateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      ocpDate = jobUpdateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      ifMatch = jobUpdateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      ifNoneMatch = jobUpdateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      ifModifiedSince = jobUpdateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobUpdateOptions !== null && jobUpdateOptions !== undefined) {
      ifUnmodifiedSince = jobUpdateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (jobUpdateParameter !== null && jobUpdateParameter !== undefined) {
      let requestModelMapper = new client.models['JobUpdateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobUpdateParameter, 'jobUpdateParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(jobUpdateParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Disables the specified Job, preventing new Tasks from running.
 *
 * The Batch Service immediately moves the Job to the disabling state. Batch
 * then uses the disableTasks parameter to determine what to do with the
 * currently running Tasks of the Job. The Job remains in the disabling state
 * until the disable operation is completed and all Tasks have been dealt with
 * according to the disableTasks option; the Job then moves to the disabled
 * state. No new Tasks are started under the Job until it moves back to active
 * state. If you try to disable a Job that is in any state other than active,
 * disabling, or disabled, the request fails with status code 409.
 *
 * @param {string} jobId The ID of the Job to disable.
 *
 * @param {string} disableTasks What to do with active Tasks associated with
 * the Job. Possible values include: 'requeue', 'terminate', 'wait'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobDisableOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobDisableOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobDisableOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobDisableOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobDisableOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobDisableOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.jobDisableOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobDisableOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobDisableOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disable(jobId, disableTasks, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobDisableOptions = (options && options.jobDisableOptions !== undefined) ? options.jobDisableOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (disableTasks) {
      let allowedValues = [ 'requeue', 'terminate', 'wait' ];
      if (!allowedValues.some( function(item) { return item === disableTasks; })) {
        throw new Error(disableTasks + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    } else {
      throw new Error('disableTasks cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  let jobDisableParameter = new client.models['JobDisableParameter']();
  try {
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      timeout = jobDisableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      clientRequestId = jobDisableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      returnClientRequestId = jobDisableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      ocpDate = jobDisableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      ifMatch = jobDisableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      ifNoneMatch = jobDisableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      ifModifiedSince = jobDisableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobDisableOptions !== null && jobDisableOptions !== undefined) {
      ifUnmodifiedSince = jobDisableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (disableTasks !== null && disableTasks !== undefined) {
      jobDisableParameter.disableTasks = disableTasks;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/disable';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (jobDisableParameter !== null && jobDisableParameter !== undefined) {
      let requestModelMapper = new client.models['JobDisableParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobDisableParameter, 'jobDisableParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(jobDisableParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enables the specified Job, allowing new Tasks to run.
 *
 * When you call this API, the Batch service sets a disabled Job to the
 * enabling state. After the this operation is completed, the Job moves to the
 * active state, and scheduling of new Tasks under the Job resumes. The Batch
 * service does not allow a Task to remain in the active state for more than
 * 180 days. Therefore, if you enable a Job containing active Tasks which were
 * added more than 180 days ago, those Tasks will not run.
 *
 * @param {string} jobId The ID of the Job to enable.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobEnableOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobEnableOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobEnableOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobEnableOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobEnableOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobEnableOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.jobEnableOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobEnableOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobEnableOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enable(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobEnableOptions = (options && options.jobEnableOptions !== undefined) ? options.jobEnableOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      timeout = jobEnableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      clientRequestId = jobEnableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      returnClientRequestId = jobEnableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      ocpDate = jobEnableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      ifMatch = jobEnableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      ifNoneMatch = jobEnableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      ifModifiedSince = jobEnableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobEnableOptions !== null && jobEnableOptions !== undefined) {
      ifUnmodifiedSince = jobEnableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/enable';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Terminates the specified Job, marking it as completed.
 *
 * When a Terminate Job request is received, the Batch service sets the Job to
 * the terminating state. The Batch service then terminates any running Tasks
 * associated with the Job and runs any required Job release Tasks. Then the
 * Job moves into the completed state. If there are any Tasks in the Job in the
 * active state, they will remain in the active state. Once a Job is
 * terminated, new Tasks cannot be added and any remaining active Tasks will
 * not be scheduled.
 *
 * @param {string} jobId The ID of the Job to terminate.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.terminateReason] The text you want to appear as the
 * Job's TerminateReason. The default is 'UserTerminate'.
 *
 * @param {object} [options.jobTerminateOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobTerminateOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobTerminateOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobTerminateOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobTerminateOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.jobTerminateOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.jobTerminateOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.jobTerminateOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.jobTerminateOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _terminate(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let terminateReason = (options && options.terminateReason !== undefined) ? options.terminateReason : undefined;
  let jobTerminateOptions = (options && options.jobTerminateOptions !== undefined) ? options.jobTerminateOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (terminateReason !== null && terminateReason !== undefined && typeof terminateReason.valueOf() !== 'string') {
      throw new Error('terminateReason must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  let jobTerminateParameter;
  try {
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      timeout = jobTerminateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      clientRequestId = jobTerminateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      returnClientRequestId = jobTerminateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      ocpDate = jobTerminateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      ifMatch = jobTerminateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      ifNoneMatch = jobTerminateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      ifModifiedSince = jobTerminateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobTerminateOptions !== null && jobTerminateOptions !== undefined) {
      ifUnmodifiedSince = jobTerminateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (terminateReason !== null && terminateReason !== undefined) {
      jobTerminateParameter = new client.models['JobTerminateParameter']();
      jobTerminateParameter.terminateReason = terminateReason;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/terminate';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (jobTerminateParameter !== null && jobTerminateParameter !== undefined) {
      let requestModelMapper = new client.models['JobTerminateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobTerminateParameter, 'jobTerminateParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(jobTerminateParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Job to the specified Account.
 *
 * The Batch service supports two ways to control the work done as part of a
 * Job. In the first approach, the user specifies a Job Manager Task. The Batch
 * service launches this Task when it is ready to start the Job. The Job
 * Manager Task controls all other Tasks that run under this Job, by using the
 * Task APIs. In the second approach, the user directly controls the execution
 * of Tasks under an active Job, by using the Task APIs. Also note: when naming
 * Jobs, avoid including sensitive information such as user names or secret
 * project names. This information may appear in telemetry logs accessible to
 * Microsoft Support engineers.
 *
 * @param {object} job The Job to be added.
 *
 * @param {string} job.id A string that uniquely identifies the Job within the
 * Account. The ID can contain any combination of alphanumeric characters
 * including hyphens and underscores, and cannot contain more than 64
 * characters. The ID is case-preserving and case-insensitive (that is, you may
 * not have two IDs within an Account that differ only by case).
 *
 * @param {string} [job.displayName] The display name for the Job. The display
 * name need not be unique and can contain any Unicode characters up to a
 * maximum length of 1024.
 *
 * @param {number} [job.priority] The priority of the Job. Priority values can
 * range from -1000 to 1000, with -1000 being the lowest priority and 1000
 * being the highest priority. The default value is 0.
 *
 * @param {object} [job.constraints] The execution constraints for the Job.
 *
 * @param {moment.duration} [job.constraints.maxWallClockTime] The maximum
 * elapsed time that the Job may run, measured from the time the Job is
 * created. If the Job does not complete within the time limit, the Batch
 * service terminates it and any Tasks that are still running. In this case,
 * the termination reason will be MaxWallClockTimeExpiry. If this property is
 * not specified, there is no time limit on how long the Job may run.
 *
 * @param {number} [job.constraints.maxTaskRetryCount] The maximum number of
 * times each Task may be retried. The Batch service retries a Task if its exit
 * code is nonzero. Note that this value specifically controls the number of
 * retries. The Batch service will try each Task once, and may then retry up to
 * this limit. For example, if the maximum retry count is 3, Batch tries a Task
 * up to 4 times (one initial try and 3 retries). If the maximum retry count is
 * 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
 * the Batch service retries Tasks without limit. The default value is 0 (no
 * retries).
 *
 * @param {object} [job.jobManagerTask] Details of a Job Manager Task to be
 * launched when the Job is started. If the Job does not specify a Job Manager
 * Task, the user must explicitly add Tasks to the Job. If the Job does specify
 * a Job Manager Task, the Batch service creates the Job Manager Task when the
 * Job is created, and will try to schedule the Job Manager Task before
 * scheduling other Tasks in the Job. The Job Manager Task's typical purpose is
 * to control and/or monitor Job execution, for example by deciding what
 * additional Tasks to run, determining when the work is complete, etc.
 * (However, a Job Manager Task is not restricted to these activities - it is a
 * fully-fledged Task in the system and perform whatever actions are required
 * for the Job.) For example, a Job Manager Task might download a file
 * specified as a parameter, analyze the contents of that file and submit
 * additional Tasks based on those contents.
 *
 * @param {string} job.jobManagerTask.id A string that uniquely identifies the
 * Job Manager Task within the Job. The ID can contain any combination of
 * alphanumeric characters including hyphens and underscores and cannot contain
 * more than 64 characters.
 *
 * @param {string} [job.jobManagerTask.displayName] The display name of the Job
 * Manager Task. It need not be unique and can contain any Unicode characters
 * up to a maximum length of 1024.
 *
 * @param {string} job.jobManagerTask.commandLine The command line of the Job
 * Manager Task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
 * file paths, it should use a relative path (relative to the Task working
 * directory), or use the Batch provided environment variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object} [job.jobManagerTask.containerSettings] The settings for the
 * container under which the Job Manager Task runs. If the Pool that will run
 * this Task has containerConfiguration set, this must be set as well. If the
 * Pool that will run this Task doesn't have containerConfiguration set, this
 * must not be set. When this is specified, all directories recursively below
 * the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories on the node)
 * are mapped into the container, all Task environment variables are mapped
 * into the container, and the Task command line is executed in the container.
 * Files produced in the container outside of AZ_BATCH_NODE_ROOT_DIR might not
 * be reflected to the host disk, meaning that Batch file APIs will not be able
 * to access those files.
 *
 * @param {array} [job.jobManagerTask.resourceFiles] A list of files that the
 * Batch service will download to the Compute Node before running the command
 * line. Files listed under this element are located in the Task's working
 * directory. There is a maximum size for the list of resource files.  When the
 * max size is exceeded, the request will fail and the response error code will
 * be RequestEntityTooLarge. If this occurs, the collection of ResourceFiles
 * must be reduced in size. This can be achieved using .zip files, Application
 * Packages, or Docker Containers.
 *
 * @param {array} [job.jobManagerTask.outputFiles] A list of files that the
 * Batch service will upload from the Compute Node after running the command
 * line. For multi-instance Tasks, the files will only be uploaded from the
 * Compute Node on which the primary Task is executed.
 *
 * @param {array} [job.jobManagerTask.environmentSettings] A list of
 * environment variable settings for the Job Manager Task.
 *
 * @param {object} [job.jobManagerTask.constraints] Constraints that apply to
 * the Job Manager Task.
 *
 * @param {number} [job.jobManagerTask.requiredSlots] The number of scheduling
 * slots that the Task requires to run. The default is 1. A Task can only be
 * scheduled to run on a compute node if the node has enough free scheduling
 * slots available. For multi-instance Tasks, this must be 1.
 *
 * @param {boolean} [job.jobManagerTask.killJobOnCompletion] Whether completion
 * of the Job Manager Task signifies completion of the entire Job. If true,
 * when the Job Manager Task completes, the Batch service marks the Job as
 * complete. If any Tasks are still running at this time (other than Job
 * Release), those Tasks are terminated. If false, the completion of the Job
 * Manager Task does not affect the Job status. In this case, you should either
 * use the onAllTasksComplete attribute to terminate the Job, or have a client
 * or user terminate the Job explicitly. An example of this is if the Job
 * Manager creates a set of Tasks but then takes no further role in their
 * execution. The default value is true. If you are using the
 * onAllTasksComplete and onTaskFailure attributes to control Job lifetime, and
 * using the Job Manager Task only to create the Tasks for the Job (not to
 * monitor progress), then it is important to set killJobOnCompletion to false.
 *
 * @param {object} [job.jobManagerTask.userIdentity] The user identity under
 * which the Job Manager Task runs. If omitted, the Task runs as a
 * non-administrative user unique to the Task.
 *
 * @param {boolean} [job.jobManagerTask.runExclusive] Whether the Job Manager
 * Task requires exclusive use of the Compute Node where it runs. If true, no
 * other Tasks will run on the same Node for as long as the Job Manager is
 * running. If false, other Tasks can run simultaneously with the Job Manager
 * on a Compute Node. The Job Manager Task counts normally against the Compute
 * Node's concurrent Task limit, so this is only relevant if the Compute Node
 * allows multiple concurrent Tasks. The default value is true.
 *
 * @param {array} [job.jobManagerTask.applicationPackageReferences] A list of
 * Application Packages that the Batch service will deploy to the Compute Node
 * before running the command line. Application Packages are downloaded and
 * deployed to a shared directory, not the Task working directory. Therefore,
 * if a referenced Application Package is already on the Compute Node, and is
 * up to date, then it is not re-downloaded; the existing copy on the Compute
 * Node is used. If a referenced Application Package cannot be installed, for
 * example because the package has been deleted or because download failed, the
 * Task fails.
 *
 * @param {object} [job.jobManagerTask.authenticationTokenSettings] The
 * settings for an authentication token that the Task can use to perform Batch
 * service operations. If this property is set, the Batch service provides the
 * Task with an authentication token which can be used to authenticate Batch
 * service operations without requiring an Account access key. The token is
 * provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment variable. The
 * operations that the Task can carry out using the token depend on the
 * settings. For example, a Task can request Job permissions in order to add
 * other Tasks to the Job, or check the status of the Job or of other Tasks
 * under the Job.
 *
 * @param {array} [job.jobManagerTask.authenticationTokenSettings.access] The
 * Batch resources to which the token grants access. The authentication token
 * grants access to a limited set of Batch service operations. Currently the
 * only supported value for the access property is 'job', which grants access
 * to all operations related to the Job which contains the Task.
 *
 * @param {boolean} [job.jobManagerTask.allowLowPriorityNode] Whether the Job
 * Manager Task may run on a low-priority Compute Node. The default value is
 * true.
 *
 * @param {object} [job.jobPreparationTask] The Job Preparation Task. If a Job
 * has a Job Preparation Task, the Batch service will run the Job Preparation
 * Task on a Node before starting any Tasks of that Job on that Compute Node.
 *
 * @param {string} [job.jobPreparationTask.id] A string that uniquely
 * identifies the Job Preparation Task within the Job. The ID can contain any
 * combination of alphanumeric characters including hyphens and underscores and
 * cannot contain more than 64 characters. If you do not specify this property,
 * the Batch service assigns a default value of 'jobpreparation'. No other Task
 * in the Job can have the same ID as the Job Preparation Task. If you try to
 * submit a Task with the same id, the Batch service rejects the request with
 * error code TaskIdSameAsJobPreparationTask; if you are calling the REST API
 * directly, the HTTP status code is 409 (Conflict).
 *
 * @param {string} job.jobPreparationTask.commandLine The command line of the
 * Job Preparation Task. The command line does not run under a shell, and
 * therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
 * line refers to file paths, it should use a relative path (relative to the
 * Task working directory), or use the Batch provided environment variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object} [job.jobPreparationTask.containerSettings] The settings for
 * the container under which the Job Preparation Task runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all Task environment variables are mapped into the container, and the Task
 * command line is executed in the container. Files produced in the container
 * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
 * meaning that Batch file APIs will not be able to access those files.
 *
 * @param {array} [job.jobPreparationTask.resourceFiles] A list of files that
 * the Batch service will download to the Compute Node before running the
 * command line. Files listed under this element are located in the Task's
 * working directory.  There is a maximum size for the list of resource files.
 * When the max size is exceeded, the request will fail and the response error
 * code will be RequestEntityTooLarge. If this occurs, the collection of
 * ResourceFiles must be reduced in size. This can be achieved using .zip
 * files, Application Packages, or Docker Containers.
 *
 * @param {array} [job.jobPreparationTask.environmentSettings] A list of
 * environment variable settings for the Job Preparation Task.
 *
 * @param {object} [job.jobPreparationTask.constraints] Constraints that apply
 * to the Job Preparation Task.
 *
 * @param {moment.duration}
 * [job.jobPreparationTask.constraints.maxWallClockTime] The maximum elapsed
 * time that the Task may run, measured from the time the Task starts. If the
 * Task does not complete within the time limit, the Batch service terminates
 * it. If this is not specified, there is no time limit on how long the Task
 * may run.
 *
 * @param {moment.duration} [job.jobPreparationTask.constraints.retentionTime]
 * The minimum time to retain the Task directory on the Compute Node where it
 * ran, from the time it completes execution. After this time, the Batch
 * service may delete the Task directory and all its contents. The default is 7
 * days, i.e. the Task directory will be retained for 7 days unless the Compute
 * Node is removed or the Job is deleted.
 *
 * @param {number} [job.jobPreparationTask.constraints.maxTaskRetryCount] The
 * maximum number of times the Task may be retried. The Batch service retries a
 * Task if its exit code is nonzero. Note that this value specifically controls
 * the number of retries for the Task executable due to a nonzero exit code.
 * The Batch service will try the Task once, and may then retry up to this
 * limit. For example, if the maximum retry count is 3, Batch tries the Task up
 * to 4 times (one initial try and 3 retries). If the maximum retry count is 0,
 * the Batch service does not retry the Task after the first attempt. If the
 * maximum retry count is -1, the Batch service retries the Task without limit.
 *
 * @param {boolean} [job.jobPreparationTask.waitForSuccess] Whether the Batch
 * service should wait for the Job Preparation Task to complete successfully
 * before scheduling any other Tasks of the Job on the Compute Node. A Job
 * Preparation Task has completed successfully if it exits with exit code 0. If
 * true and the Job Preparation Task fails on a Node, the Batch service retries
 * the Job Preparation Task up to its maximum retry count (as specified in the
 * constraints element). If the Task has still not completed successfully after
 * all retries, then the Batch service will not schedule Tasks of the Job to
 * the Node. The Node remains active and eligible to run Tasks of other Jobs.
 * If false, the Batch service will not wait for the Job Preparation Task to
 * complete. In this case, other Tasks of the Job can start executing on the
 * Compute Node while the Job Preparation Task is still running; and even if
 * the Job Preparation Task fails, new Tasks will continue to be scheduled on
 * the Compute Node. The default value is true.
 *
 * @param {object} [job.jobPreparationTask.userIdentity] The user identity
 * under which the Job Preparation Task runs. If omitted, the Task runs as a
 * non-administrative user unique to the Task on Windows Compute Nodes, or a
 * non-administrative user unique to the Pool on Linux Compute Nodes.
 *
 * @param {boolean} [job.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
 * Whether the Batch service should rerun the Job Preparation Task after a
 * Compute Node reboots. The Job Preparation Task is always rerun if a Compute
 * Node is reimaged, or if the Job Preparation Task did not complete (e.g.
 * because the reboot occurred while the Task was running). Therefore, you
 * should always write a Job Preparation Task to be idempotent and to behave
 * correctly if run multiple times. The default value is true.
 *
 * @param {object} [job.jobReleaseTask] The Job Release Task. A Job Release
 * Task cannot be specified without also specifying a Job Preparation Task for
 * the Job. The Batch service runs the Job Release Task on the Nodes that have
 * run the Job Preparation Task. The primary purpose of the Job Release Task is
 * to undo changes to Compute Nodes made by the Job Preparation Task. Example
 * activities include deleting local files, or shutting down services that were
 * started as part of Job preparation.
 *
 * @param {string} [job.jobReleaseTask.id] A string that uniquely identifies
 * the Job Release Task within the Job. The ID can contain any combination of
 * alphanumeric characters including hyphens and underscores and cannot contain
 * more than 64 characters. If you do not specify this property, the Batch
 * service assigns a default value of 'jobrelease'. No other Task in the Job
 * can have the same ID as the Job Release Task. If you try to submit a Task
 * with the same id, the Batch service rejects the request with error code
 * TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the
 * HTTP status code is 409 (Conflict).
 *
 * @param {string} job.jobReleaseTask.commandLine The command line of the Job
 * Release Task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
 * file paths, it should use a relative path (relative to the Task working
 * directory), or use the Batch provided environment variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object} [job.jobReleaseTask.containerSettings] The settings for the
 * container under which the Job Release Task runs. When this is specified, all
 * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
 * Batch directories on the node) are mapped into the container, all Task
 * environment variables are mapped into the container, and the Task command
 * line is executed in the container. Files produced in the container outside
 * of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk, meaning
 * that Batch file APIs will not be able to access those files.
 *
 * @param {array} [job.jobReleaseTask.resourceFiles] A list of files that the
 * Batch service will download to the Compute Node before running the command
 * line.  There is a maximum size for the list of resource files.  When the max
 * size is exceeded, the request will fail and the response error code will be
 * RequestEntityTooLarge. If this occurs, the collection of ResourceFiles must
 * be reduced in size. This can be achieved using .zip files, Application
 * Packages, or Docker Containers. Files listed under this element are located
 * in the Task's working directory.
 *
 * @param {array} [job.jobReleaseTask.environmentSettings] A list of
 * environment variable settings for the Job Release Task.
 *
 * @param {moment.duration} [job.jobReleaseTask.maxWallClockTime] The maximum
 * elapsed time that the Job Release Task may run on a given Compute Node,
 * measured from the time the Task starts. If the Task does not complete within
 * the time limit, the Batch service terminates it. The default value is 15
 * minutes. You may not specify a timeout longer than 15 minutes. If you do,
 * the Batch service rejects it with an error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request).
 *
 * @param {moment.duration} [job.jobReleaseTask.retentionTime] The minimum time
 * to retain the Task directory for the Job Release Task on the Compute Node.
 * After this time, the Batch service may delete the Task directory and all its
 * contents. The default is 7 days, i.e. the Task directory will be retained
 * for 7 days unless the Compute Node is removed or the Job is deleted.
 *
 * @param {object} [job.jobReleaseTask.userIdentity] The user identity under
 * which the Job Release Task runs. If omitted, the Task runs as a
 * non-administrative user unique to the Task.
 *
 * @param {array} [job.commonEnvironmentSettings] The list of common
 * environment variable settings. These environment variables are set for all
 * Tasks in the Job (including the Job Manager, Job Preparation and Job Release
 * Tasks). Individual Tasks can override an environment setting specified here
 * by specifying the same setting name with a different value.
 *
 * @param {object} job.poolInfo The Pool on which the Batch service runs the
 * Job's Tasks.
 *
 * @param {string} [job.poolInfo.poolId] The ID of an existing Pool. All the
 * Tasks of the Job will run on the specified Pool. You must ensure that the
 * Pool referenced by this property exists. If the Pool does not exist at the
 * time the Batch service tries to schedule a Job, no Tasks for the Job will
 * run until you create a Pool with that id. Note that the Batch service will
 * not reject the Job request; it will simply not run Tasks until the Pool
 * exists. You must specify either the Pool ID or the auto Pool specification,
 * but not both.
 *
 * @param {object} [job.poolInfo.autoPoolSpecification] Characteristics for a
 * temporary 'auto pool'. The Batch service will create this auto Pool when the
 * Job is submitted. If auto Pool creation fails, the Batch service moves the
 * Job to a completed state, and the Pool creation error is set in the Job's
 * scheduling error property. The Batch service manages the lifetime (both
 * creation and, unless keepAlive is specified, deletion) of the auto Pool. Any
 * user actions that affect the lifetime of the auto Pool while the Job is
 * active will result in unexpected behavior. You must specify either the Pool
 * ID or the auto Pool specification, but not both.
 *
 * @param {string} [job.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
 * prefix to be added to the unique identifier when a Pool is automatically
 * created. The Batch service assigns each auto Pool a unique identifier on
 * creation. To distinguish between Pools created for different purposes, you
 * can specify this element to add a prefix to the ID that is assigned. The
 * prefix can be up to 20 characters long.
 *
 * @param {string} job.poolInfo.autoPoolSpecification.poolLifetimeOption The
 * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
 * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
 *
 * @param {boolean} [job.poolInfo.autoPoolSpecification.keepAlive] Whether to
 * keep an auto Pool alive after its lifetime expires. If false, the Batch
 * service deletes the Pool once its lifetime (as determined by the
 * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
 * completes. If true, the Batch service does not delete the Pool
 * automatically. It is up to the user to delete auto Pools created with this
 * option.
 *
 * @param {object} [job.poolInfo.autoPoolSpecification.pool] The Pool
 * specification for the auto Pool.
 *
 * @param {string} [job.poolInfo.autoPoolSpecification.pool.displayName] The
 * display name for the Pool. The display name need not be unique and can
 * contain any Unicode characters up to a maximum length of 1024.
 *
 * @param {string} job.poolInfo.autoPoolSpecification.pool.vmSize The size of
 * the virtual machines in the Pool. All virtual machines in a Pool are the
 * same size. For information about available sizes of virtual machines in
 * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
 * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration] The
 * cloud service configuration for the Pool. This property must be specified if
 * the Pool needs to be created with Azure PaaS VMs. This property and
 * virtualMachineConfiguration are mutually exclusive and one of the properties
 * must be specified. If neither is specified then the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request). This property cannot be specified if the Batch Account was
 * created with its poolAllocationMode property set to 'UserSubscription'.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
 * The Azure Guest OS family to be installed on the virtual machines in the
 * Pool. Possible values are:
 * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
 * 3 - OS Family 3, equivalent to Windows Server 2012.
 * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
 * 5 - OS Family 5, equivalent to Windows Server 2016.
 * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
 * see Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
 * The Azure Guest OS version to be installed on the virtual machines in the
 * Pool. The default value is * which specifies the latest operating system
 * version for the specified OS family.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration] The
 * virtual machine configuration for the Pool. This property must be specified
 * if the Pool needs to be created with Azure IaaS VMs. This property and
 * cloudServiceConfiguration are mutually exclusive and one of the properties
 * must be specified. If neither is specified then the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request).
 *
 * @param {object}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
 * A reference to the Azure Virtual Machines Marketplace Image or the custom
 * Virtual Machine Image to use.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
 * The publisher of the Azure Virtual Machines Marketplace Image. For example,
 * Canonical or MicrosoftWindowsServer.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
 * The offer type of the Azure Virtual Machines Marketplace Image. For example,
 * UbuntuServer or WindowsServer.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
 * The SKU of the Azure Virtual Machines Marketplace Image. For example,
 * 18.04-LTS or 2019-Datacenter.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace Image. A value of
 * 'latest' can be specified to select the latest version of an Image. If
 * omitted, the default is 'latest'.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
 * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
 * in the Pool will be created using this Image Id. This is of the form
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
 * or
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
 * for always defaulting to the latest image version. This property is mutually
 * exclusive with other ImageReference properties. The Shared Image Gallery
 * Image must have replicas in the same region and must be in the same
 * subscription as the Azure Batch account. If the image version is not
 * specified in the imageId, the latest version will be used. For information
 * about the firewall settings for the Batch Compute Node agent to communicate
 * with the Batch service see
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
 * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
 * in the Pool. The Batch Compute Node agent is a program that runs on each
 * Compute Node in the Pool, and provides the command-and-control interface
 * between the Compute Node and the Batch service. There are different
 * implementations of the Compute Node agent, known as SKUs, for different
 * operating systems. You must specify a Compute Node agent SKU which matches
 * the selected Image reference. To get the list of supported Compute Node
 * agent SKUs along with their list of verified Image references, see the 'List
 * supported Compute Node agent SKUs' operation.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS Image.
 *
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
 * The configuration for data disks attached to the Compute Nodes in the Pool.
 * This property must be specified if the Compute Nodes in the Pool need to
 * have empty data disks attached to them. This cannot be updated. Each Compute
 * Node gets its own disk (the disk is not a file share). Existing disks cannot
 * be attached, each attached disk is empty. When the Compute Node is removed
 * from the Pool, the disk and all data associated with it is also deleted. The
 * disk is not formatted after being attached, it must be formatted before use
 * - for more information see
 * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
 * and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
 * The type of on-premises license to be used when deploying the operating
 * system. This only applies to Images that contain the Windows operating
 * system, and should only be used when you hold valid on-premises licenses for
 * the Compute Nodes which will be deployed. If omitted, no on-premises
 * licensing discount is applied. Values are:
 *
 * Windows_Server - The on-premises license is for Windows Server.
 * Windows_Client - The on-premises license is for Windows Client.
 *
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
 * The container configuration for the Pool. If specified, setup is performed
 * on each Compute Node in the Pool to allow Tasks to run in containers. All
 * regular Tasks and Job manager Tasks run on this Pool must specify the
 * containerSettings property, and all other Tasks may specify it.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
 * The collection of container Image names. This is the full Image reference,
 * as would be specified to "docker pull". An Image will be sourced from the
 * default Docker registry unless the Image is fully qualified with an
 * alternative registry.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
 * Additional private registries from which containers can be pulled. If any
 * Images must be downloaded from a private registry which requires
 * credentials, then those credentials must be provided here.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
 * The disk encryption configuration for the pool. If specified, encryption is
 * performed on each node in the pool during node provisioning.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
 * The list of disk targets Batch Service will encrypt on the compute node. If
 * omitted, no disks on the compute nodes in the pool will be encrypted. On
 * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
 * "TemporaryDisk" must be specified.
 *
 * @param {number} [job.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
 * The number of task slots that can be used to run concurrent tasks on a
 * single compute node in the pool. The default value is 1. The maximum value
 * is the smaller of 4 times the number of cores of the vmSize of the pool or
 * 256.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy] How Tasks are
 * distributed across Compute Nodes in a Pool. If not specified, the default is
 * spread.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
 * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
 * the default is spread. Possible values include: 'spread', 'pack'
 *
 * @param {moment.duration}
 * [job.poolInfo.autoPoolSpecification.pool.resizeTimeout] The timeout for
 * allocation of Compute Nodes to the Pool. This timeout applies only to manual
 * scaling; it has no effect when enableAutoScale is set to true. The default
 * value is 15 minutes. The minimum value is 5 minutes. If you specify a value
 * less than 5 minutes, the Batch service rejects the request with an error; if
 * you are calling the REST API directly, the HTTP status code is 400 (Bad
 * Request).
 *
 * @param {number}
 * [job.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes] The desired
 * number of dedicated Compute Nodes in the Pool. This property must not be
 * specified if enableAutoScale is set to true. If enableAutoScale is set to
 * false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {number}
 * [job.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes] The desired
 * number of low-priority Compute Nodes in the Pool. This property must not be
 * specified if enableAutoScale is set to true. If enableAutoScale is set to
 * false, then you must set either targetDedicatedNodes,
 * targetLowPriorityNodes, or both.
 *
 * @param {boolean} [job.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Whether the Pool size should automatically adjust over time. If false, at
 * least one of targetDedicateNodes and targetLowPriorityNodes must be
 * specified. If true, the autoScaleFormula element is required. The Pool
 * automatically resizes according to the formula. The default value is false.
 *
 * @param {string} [job.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * The formula for the desired number of Compute Nodes in the Pool. This
 * property must not be specified if enableAutoScale is set to false. It is
 * required if enableAutoScale is set to true. The formula is checked for
 * validity before the Pool is created. If the formula is not valid, the Batch
 * service rejects the request with detailed error information.
 *
 * @param {moment.duration}
 * [job.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval] The
 * time interval at which to automatically adjust the Pool size according to
 * the autoscale formula. The default value is 15 minutes. The minimum and
 * maximum value are 5 minutes and 168 hours respectively. If you specify a
 * value less than 5 minutes or greater than 168 hours, the Batch service
 * rejects the request with an invalid property value error; if you are calling
 * the REST API directly, the HTTP status code is 400 (Bad Request).
 *
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Whether the Pool permits direct communication between Compute Nodes.
 * Enabling inter-node communication limits the maximum size of the Pool due to
 * deployment restrictions on the Compute Nodes of the Pool. This may result in
 * the Pool not reaching its desired size. The default value is false.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration] The network
 * configuration for the Pool.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId] The
 * ARM resource identifier of the virtual network subnet which the Compute
 * Nodes of the Pool will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch Account. The specified subnet should have enough free IP addresses to
 * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
 * have enough free IP addresses, the Pool will partially allocate Nodes and a
 * resize error will occur. The 'MicrosoftAzureBatch' service principal must
 * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
 * (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule Tasks on
 * the Nodes. This can be verified by checking if the specified VNet has any
 * associated Network Security Groups (NSG). If communication to the Nodes in
 * the specified subnet is denied by an NSG, then the Batch service will set
 * the state of the Compute Nodes to unusable. For Pools created with
 * virtualMachineConfiguration only ARM virtual networks
 * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
 * with cloudServiceConfiguration both ARM and classic virtual networks are
 * supported. If the specified VNet has any associated Network Security Groups
 * (NSG), then a few reserved system ports must be enabled for inbound
 * communication. For Pools created with a virtual machine configuration,
 * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
 * Windows. For Pools created with a cloud service configuration, enable ports
 * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
 * on port 443. For more details see:
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
 * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
 * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
 * endpoint configuration is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {array}
 * job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
 * A list of inbound NAT Pools that can be used to address specific ports on an
 * individual Compute Node externally. The maximum number of inbound NAT Pools
 * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
 * the request fails with HTTP status code 400. This cannot be specified if the
 * IPAddressProvisioningType is NoPublicIPAddresses.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
 * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
 * Public IP configuration property is only supported on Pools with the
 * virtualMachineConfiguration property.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
 * The provisioning type for Public IP Addresses for the Pool. The default
 * value is BatchManaged. Possible values include: 'batchManaged',
 * 'userManaged', 'noPublicIPAddresses'
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
 * The list of public IPs which the Batch service will use when provisioning
 * Compute Nodes. The number of IPs specified here limits the maximum size of
 * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
 * for each public IP. For example, a pool needing 250 dedicated VMs would need
 * at least 3 public IPs specified. Each element of this collection is of the
 * form:
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
 *
 * @param {object} [job.poolInfo.autoPoolSpecification.pool.startTask] A Task
 * to run on each Compute Node as it joins the Pool. The Task runs when the
 * Compute Node is added to the Pool or when the Compute Node is restarted.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.startTask.commandLine The command
 * line of the StartTask. The command line does not run under a shell, and
 * therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
 * line refers to file paths, it should use a relative path (relative to the
 * Task working directory), or use the Batch provided environment variable
 * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings] The
 * settings for the container under which the StartTask runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all Task environment variables are mapped into the container, and the Task
 * command line is executed in the container. Files produced in the container
 * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
 * meaning that Batch file APIs will not be able to access those files.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
 * The Image to use to create the container in which the Task will run. This is
 * the full Image reference, as would be specified to "docker pull". If no tag
 * is provided as part of the Image name, the tag ":latest" is used as a
 * default.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
 * The private registry which contains the container Image. This setting can be
 * omitted if was already provided at Pool creation.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
 * The registry URL. If omitted, the default is "docker.io".
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
 * The user name to log into the registry server.
 *
 * @param {string}
 * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
 * The password to log into the registry server.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
 * The location of the container Task working directory. The default is
 * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
 * 'containerImageDefault'
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles] A list of
 * files that the Batch service will download to the Compute Node before
 * running the command line.  There is a maximum size for the list of resource
 * files. When the max size is exceeded, the request will fail and the response
 * error code will be RequestEntityTooLarge. If this occurs, the collection of
 * ResourceFiles must be reduced in size. This can be achieved using .zip
 * files, Application Packages, or Docker Containers. Files listed under this
 * element are located in the Task's working directory.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings] A
 * list of environment variable settings for the StartTask.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity] The user
 * identity under which the StartTask runs. If omitted, the Task runs as a
 * non-administrative user unique to the Task.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
 * The name of the user identity under which the Task is run. The userName and
 * autoUser properties are mutually exclusive; you must specify one but not
 * both.
 *
 * @param {object}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
 * The auto user under which the Task is run. The userName and autoUser
 * properties are mutually exclusive; you must specify one but not both.
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
 * The scope for the auto user The default value is pool. If the pool is
 * running Windows a value of Task should be specified if stricter isolation
 * between tasks is required. For example, if the task mutates the registry in
 * a way which could impact other tasks, or if certificates have been specified
 * on the pool which should not be accessible by normal tasks but should be
 * accessible by StartTasks. Possible values include: 'task', 'pool'
 *
 * @param {string}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
 * The elevation level of the auto user. The default value is nonAdmin.
 * Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount] The
 * maximum number of times the Task may be retried. The Batch service retries a
 * Task if its exit code is nonzero. Note that this value specifically controls
 * the number of retries. The Batch service will try the Task once, and may
 * then retry up to this limit. For example, if the maximum retry count is 3,
 * Batch tries the Task up to 4 times (one initial try and 3 retries). If the
 * maximum retry count is 0, the Batch service does not retry the Task. If the
 * maximum retry count is -1, the Batch service retries the Task without limit.
 *
 * @param {boolean}
 * [job.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess] Whether
 * the Batch service should wait for the StartTask to complete successfully
 * (that is, to exit with exit code 0) before scheduling any Tasks on the
 * Compute Node. If true and the StartTask fails on a Node, the Batch service
 * retries the StartTask up to its maximum retry count (maxTaskRetryCount). If
 * the Task has still not completed successfully after all retries, then the
 * Batch service marks the Node unusable, and will not schedule Tasks to it.
 * This condition can be detected via the Compute Node state and failure info
 * details. If false, the Batch service will not wait for the StartTask to
 * complete. In this case, other Tasks can start executing on the Compute Node
 * while the StartTask is still running; and even if the StartTask fails, new
 * Tasks will continue to be scheduled on the Compute Node. The default is
 * true.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.certificateReferences] A list of
 * Certificates to be installed on each Compute Node in the Pool. For Windows
 * Nodes, the Batch service installs the Certificates to the specified
 * Certificate store and location. For Linux Compute Nodes, the Certificates
 * are stored in a directory inside the Task working directory and an
 * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
 * query for this location. For Certificates with visibility of 'remoteUser', a
 * 'certs' directory is created in the user's home directory (e.g.,
 * /home/{user-name}/certs) and Certificates are placed in that directory.
 *
 * @param {array}
 * [job.poolInfo.autoPoolSpecification.pool.applicationPackageReferences] The
 * list of Packages to be installed on each Compute Node in the Pool. Changes
 * to Package references affect all new Nodes joining the Pool, but do not
 * affect Compute Nodes that are already in the Pool until they are rebooted or
 * reimaged. There is a maximum of 10 Package references on any given Pool.
 *
 * @param {array} [job.poolInfo.autoPoolSpecification.pool.applicationLicenses]
 * The list of application licenses the Batch service will make available on
 * each Compute Node in the Pool. The list of application licenses must be a
 * subset of available Batch service application licenses. If a license is
 * requested which is not supported, Pool creation will fail. The permitted
 * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
 * additional charge applies for each application license added to the Pool.
 *
 * @param {array} [job.poolInfo.autoPoolSpecification.pool.userAccounts] The
 * list of user Accounts to be created on each Compute Node in the Pool.
 *
 * @param {array} [job.poolInfo.autoPoolSpecification.pool.metadata] A list of
 * name-value pairs associated with the Pool as metadata. The Batch service
 * does not assign any meaning to metadata; it is solely for the use of user
 * code.
 *
 * @param {array} [job.poolInfo.autoPoolSpecification.pool.mountConfiguration]
 * A list of file systems to mount on each node in the pool. This supports
 * Azure Files, NFS, CIFS/SMB, and Blobfuse.
 *
 * @param {string} [job.onAllTasksComplete] The action the Batch service should
 * take when all Tasks in the Job are in the completed state. Note that if a
 * Job contains no Tasks, then all Tasks are considered complete. This option
 * is therefore most commonly used with a Job Manager task; if you want to use
 * automatic Job termination without a Job Manager, you should initially set
 * onAllTasksComplete to noaction and update the Job properties to set
 * onAllTasksComplete to terminatejob once you have finished adding Tasks. The
 * default is noaction. Possible values include: 'noAction', 'terminateJob'
 *
 * @param {string} [job.onTaskFailure] The action the Batch service should take
 * when any Task in the Job fails. A Task is considered to have failed if has a
 * failureInfo. A failureInfo is set if the Task completes with a non-zero exit
 * code after exhausting its retry count, or if there was an error starting the
 * Task, for example due to a resource file download error. The default is
 * noaction. Possible values include: 'noAction', 'performExitOptionsJobAction'
 *
 * @param {array} [job.metadata] A list of name-value pairs associated with the
 * Job as metadata. The Batch service does not assign any meaning to metadata;
 * it is solely for the use of user code.
 *
 * @param {boolean} [job.usesTaskDependencies] Whether Tasks in the Job can
 * define dependencies on each other. The default is false.
 *
 * @param {object} [job.networkConfiguration] The network configuration for the
 * Job.
 *
 * @param {string} job.networkConfiguration.subnetId The ARM resource
 * identifier of the virtual network subnet which Compute Nodes running Tasks
 * from the Job will join for the duration of the Task. This will only work
 * with a VirtualMachineConfiguration Pool. The virtual network must be in the
 * same region and subscription as the Azure Batch Account. The specified
 * subnet should have enough free IP addresses to accommodate the number of
 * Compute Nodes which will run Tasks from the Job. This can be up to the
 * number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service
 * principal must have the 'Classic Virtual Machine Contributor' Role-Based
 * Access Control (RBAC) role for the specified VNet so that Azure Batch
 * service can schedule Tasks on the Nodes. This can be verified by checking if
 * the specified VNet has any associated Network Security Groups (NSG). If
 * communication to the Nodes in the specified subnet is denied by an NSG, then
 * the Batch service will set the state of the Compute Nodes to unusable. This
 * is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * If the specified VNet has any associated Network Security Groups (NSG), then
 * a few reserved system ports must be enabled for inbound communication from
 * the Azure Batch service. For Pools created with a Virtual Machine
 * configuration, enable ports 29876 and 29877, as well as port 22 for Linux
 * and port 3389 for Windows. Port 443 is also required to be open for outbound
 * connections for communications to Azure Storage. For more details see:
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobAddOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.jobAddOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobAddOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobAddOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.jobAddOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _add(job, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobAddOptions = (options && options.jobAddOptions !== undefined) ? options.jobAddOptions : undefined;
  if (job === null || job === undefined)
  {
    job = {};
  }
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (job === null || job === undefined) {
      throw new Error('job cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobAddOptions !== null && jobAddOptions !== undefined) {
      timeout = jobAddOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined) {
      clientRequestId = jobAddOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined) {
      returnClientRequestId = jobAddOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobAddOptions !== null && jobAddOptions !== undefined) {
      ocpDate = jobAddOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (job !== null && job !== undefined) {
      let requestModelMapper = new client.models['JobAddParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, job, 'job');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(job, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists all of the Jobs in the specified Account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListOptions] Additional parameters for the
 * operation
 *
 * @param {string} [options.jobListOptions.filter] An OData $filter clause. For
 * more information on constructing this filter, see
 * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
 *
 * @param {string} [options.jobListOptions.select] An OData $select clause.
 *
 * @param {string} [options.jobListOptions.expand] An OData $expand clause.
 *
 * @param {number} [options.jobListOptions.maxResults] The maximum number of
 * items to return in the response. A maximum of 1000 Jobs can be returned.
 *
 * @param {number} [options.jobListOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.jobListOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobListOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.jobListOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListOptions = (options && options.jobListOptions !== undefined) ? options.jobListOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let filter;
  let select;
  let expand;
  let maxResults;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListOptions !== null && jobListOptions !== undefined) {
      filter = jobListOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      select = jobListOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      expand = jobListOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      maxResults = jobListOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      timeout = jobListOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      clientRequestId = jobListOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      returnClientRequestId = jobListOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListOptions !== null && jobListOptions !== undefined) {
      ocpDate = jobListOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the Jobs that have been created under the specified Job
 * Schedule.
 *
 * @param {string} jobScheduleId The ID of the Job Schedule from which you want
 * to get a list of Jobs.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListFromJobScheduleOptions] Additional
 * parameters for the operation
 *
 * @param {string} [options.jobListFromJobScheduleOptions.filter] An OData
 * $filter clause. For more information on constructing this filter, see
 * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
 *
 * @param {string} [options.jobListFromJobScheduleOptions.select] An OData
 * $select clause.
 *
 * @param {string} [options.jobListFromJobScheduleOptions.expand] An OData
 * $expand clause.
 *
 * @param {number} [options.jobListFromJobScheduleOptions.maxResults] The
 * maximum number of items to return in the response. A maximum of 1000 Jobs
 * can be returned.
 *
 * @param {number} [options.jobListFromJobScheduleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.jobListFromJobScheduleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.jobListFromJobScheduleOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.jobListFromJobScheduleOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listFromJobSchedule(jobScheduleId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListFromJobScheduleOptions = (options && options.jobListFromJobScheduleOptions !== undefined) ? options.jobListFromJobScheduleOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let filter;
  let select;
  let expand;
  let maxResults;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      filter = jobListFromJobScheduleOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      select = jobListFromJobScheduleOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      expand = jobListFromJobScheduleOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      maxResults = jobListFromJobScheduleOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      timeout = jobListFromJobScheduleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      clientRequestId = jobListFromJobScheduleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      returnClientRequestId = jobListFromJobScheduleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListFromJobScheduleOptions !== null && jobListFromJobScheduleOptions !== undefined) {
      ocpDate = jobListFromJobScheduleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobschedules/{jobScheduleId}/jobs';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the execution status of the Job Preparation and Job Release
 * Task for the specified Job across the Compute Nodes where the Job has run.
 *
 * This API returns the Job Preparation and Job Release Task status on all
 * Compute Nodes that have run the Job Preparation or Job Release Task. This
 * includes Compute Nodes which have since been removed from the Pool. If this
 * API is invoked on a Job which has no Job Preparation or Job Release Task,
 * the Batch service returns HTTP status code 409 (Conflict) with an error code
 * of JobPreparationTaskNotSpecified.
 *
 * @param {string} jobId The ID of the Job.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListPreparationAndReleaseTaskStatusOptions]
 * Additional parameters for the operation
 *
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.filter] An OData
 * $filter clause. For more information on constructing this filter, see
 * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
 *
 * @param {string}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.select] An OData
 * $select clause.
 *
 * @param {number}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.maxResults] The
 * maximum number of items to return in the response. A maximum of 1000 Tasks
 * can be returned.
 *
 * @param {number}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date}
 * [options.jobListPreparationAndReleaseTaskStatusOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPreparationAndReleaseTaskStatus(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListPreparationAndReleaseTaskStatusOptions = (options && options.jobListPreparationAndReleaseTaskStatusOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let filter;
  let select;
  let maxResults;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      filter = jobListPreparationAndReleaseTaskStatusOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      select = jobListPreparationAndReleaseTaskStatusOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      maxResults = jobListPreparationAndReleaseTaskStatusOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      timeout = jobListPreparationAndReleaseTaskStatusOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      clientRequestId = jobListPreparationAndReleaseTaskStatusOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      returnClientRequestId = jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusOptions !== null && jobListPreparationAndReleaseTaskStatusOptions !== undefined) {
      ocpDate = jobListPreparationAndReleaseTaskStatusOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/jobpreparationandreleasetaskstatus';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListPreparationAndReleaseTaskStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Task counts for the specified Job.
 *
 * Task counts provide a count of the Tasks by active, running or completed
 * Task state, and a count of Tasks which succeeded or failed. Tasks in the
 * preparing state are counted as running. Note that the numbers returned may
 * not always be up to date. If you need exact task counts, use a list query.
 *
 * @param {string} jobId The ID of the Job.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobGetTaskCountsOptions] Additional parameters for
 * the operation
 *
 * @param {number} [options.jobGetTaskCountsOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 *
 * @param {uuid} [options.jobGetTaskCountsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobGetTaskCountsOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobGetTaskCountsOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link TaskCountsResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTaskCounts(jobId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobGetTaskCountsOptions = (options && options.jobGetTaskCountsOptions !== undefined) ? options.jobGetTaskCountsOptions : undefined;
  // Validate
  try {
    if (this.client.batchUrl === null || this.client.batchUrl === undefined || typeof this.client.batchUrl.valueOf() !== 'string') {
      throw new Error('this.client.batchUrl cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
      timeout = jobGetTaskCountsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
      clientRequestId = jobGetTaskCountsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
      returnClientRequestId = jobGetTaskCountsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobGetTaskCountsOptions !== null && jobGetTaskCountsOptions !== undefined) {
      ocpDate = jobGetTaskCountsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'jobs/{jobId}/taskcounts';
  requestUrl = requestUrl.replace('{batchUrl}', this.client.batchUrl);
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['TaskCountsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists all of the Jobs in the specified Account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListNextOptions] Additional parameters for the
 * operation
 *
 * @param {uuid} [options.jobListNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.jobListNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobListNextOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListNextOptions = (options && options.jobListNextOptions !== undefined) ? options.jobListNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
      clientRequestId = jobListNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
      returnClientRequestId = jobListNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListNextOptions !== null && jobListNextOptions !== undefined) {
      ocpDate = jobListNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the Jobs that have been created under the specified Job
 * Schedule.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListFromJobScheduleNextOptions] Additional
 * parameters for the operation
 *
 * @param {uuid} [options.jobListFromJobScheduleNextOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.jobListFromJobScheduleNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.jobListFromJobScheduleNextOptions.ocpDate] The time
 * the request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudJobListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listFromJobScheduleNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListFromJobScheduleNextOptions = (options && options.jobListFromJobScheduleNextOptions !== undefined) ? options.jobListFromJobScheduleNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
      clientRequestId = jobListFromJobScheduleNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
      returnClientRequestId = jobListFromJobScheduleNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListFromJobScheduleNextOptions !== null && jobListFromJobScheduleNextOptions !== undefined) {
      ocpDate = jobListFromJobScheduleNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the execution status of the Job Preparation and Job Release
 * Task for the specified Job across the Compute Nodes where the Job has run.
 *
 * This API returns the Job Preparation and Job Release Task status on all
 * Compute Nodes that have run the Job Preparation or Job Release Task. This
 * includes Compute Nodes which have since been removed from the Pool. If this
 * API is invoked on a Job which has no Job Preparation or Job Release Task,
 * the Batch service returns HTTP status code 409 (Conflict) with an error code
 * of JobPreparationTaskNotSpecified.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.jobListPreparationAndReleaseTaskStatusNextOptions]
 * Additional parameters for the operation
 *
 * @param {uuid}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date}
 * [options.jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate] The time
 * the request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link
 *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPreparationAndReleaseTaskStatusNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let jobListPreparationAndReleaseTaskStatusNextOptions = (options && options.jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) ? options.jobListPreparationAndReleaseTaskStatusNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
      clientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
      returnClientRequestId = jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobListPreparationAndReleaseTaskStatusNextOptions !== null && jobListPreparationAndReleaseTaskStatusNextOptions !== undefined) {
      ocpDate = jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudJobListPreparationAndReleaseTaskStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a Job. */
class Job {
  /**
   * Create a Job.
   * @param {BatchServiceClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._getAllLifetimeStatistics = _getAllLifetimeStatistics;
    this._deleteMethod = _deleteMethod;
    this._get = _get;
    this._patch = _patch;
    this._update = _update;
    this._disable = _disable;
    this._enable = _enable;
    this._terminate = _terminate;
    this._add = _add;
    this._list = _list;
    this._listFromJobSchedule = _listFromJobSchedule;
    this._listPreparationAndReleaseTaskStatus = _listPreparationAndReleaseTaskStatus;
    this._getTaskCounts = _getTaskCounts;
    this._listNext = _listNext;
    this._listFromJobScheduleNext = _listFromJobScheduleNext;
    this._listPreparationAndReleaseTaskStatusNext = _listPreparationAndReleaseTaskStatusNext;
  }

  /**
   * @summary Gets lifetime summary statistics for all of the Jobs in the
   * specified Account.
   *
   * Statistics are aggregated across all Jobs that have ever existed in the
   * Account, from Account creation to the last update time of the statistics.
   * The statistics may not be immediately available. The Batch service performs
   * periodic roll-up of statistics. The typical delay is about 30 minutes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetAllLifetimeStatisticsOptions] Additional
   * parameters for the operation
   *
   * @param {number} [options.jobGetAllLifetimeStatisticsOptions.timeout] The
   * maximum time that the server can spend processing the request, in seconds.
   * The default is 30 seconds.
   *
   * @param {uuid} [options.jobGetAllLifetimeStatisticsOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetAllLifetimeStatisticsOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<JobStatistics>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllLifetimeStatisticsWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllLifetimeStatistics(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets lifetime summary statistics for all of the Jobs in the
   * specified Account.
   *
   * Statistics are aggregated across all Jobs that have ever existed in the
   * Account, from Account creation to the last update time of the statistics.
   * The statistics may not be immediately available. The Batch service performs
   * periodic roll-up of statistics. The typical delay is about 30 minutes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetAllLifetimeStatisticsOptions] Additional
   * parameters for the operation
   *
   * @param {number} [options.jobGetAllLifetimeStatisticsOptions.timeout] The
   * maximum time that the server can spend processing the request, in seconds.
   * The default is 30 seconds.
   *
   * @param {uuid} [options.jobGetAllLifetimeStatisticsOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetAllLifetimeStatisticsOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {JobStatistics} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link JobStatistics} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllLifetimeStatistics(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllLifetimeStatistics(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllLifetimeStatistics(options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a Job.
   *
   * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
   * statistics. This also overrides the retention period for Task data; that is,
   * if the Job contains Tasks which are still retained on Compute Nodes, the
   * Batch services deletes those Tasks' working directories and all their
   * contents.  When a Delete Job request is received, the Batch service sets the
   * Job to the deleting state. All update operations on a Job that is in
   * deleting state will fail with status code 409 (Conflict), with additional
   * information indicating that the Job is being deleted.
   *
   * @param {string} jobId The ID of the Job to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobDeleteMethodOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.jobDeleteMethodOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.jobDeleteMethodOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobDeleteMethodOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobDeleteMethodOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobDeleteMethodOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.jobDeleteMethodOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobDeleteMethodOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobDeleteMethodOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a Job.
   *
   * Deleting a Job also deletes all Tasks that are part of that Job, and all Job
   * statistics. This also overrides the retention period for Task data; that is,
   * if the Job contains Tasks which are still retained on Compute Nodes, the
   * Batch services deletes those Tasks' working directories and all their
   * contents.  When a Delete Job request is received, the Batch service sets the
   * Job to the deleting state. All update operations on a Job that is in
   * deleting state will fail with status code 409 (Conflict), with additional
   * information indicating that the Job is being deleted.
   *
   * @param {string} jobId The ID of the Job to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobDeleteMethodOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.jobDeleteMethodOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.jobDeleteMethodOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobDeleteMethodOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobDeleteMethodOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobDeleteMethodOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.jobDeleteMethodOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobDeleteMethodOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobDeleteMethodOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets information about the specified Job.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.jobGetOptions.select] An OData $select clause.
   *
   * @param {string} [options.jobGetOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.jobGetOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobGetOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobGetOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobGetOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobGetOptions.ifNoneMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service does not match
   * the value specified by the client.
   *
   * @param {date} [options.jobGetOptions.ifModifiedSince] A timestamp indicating
   * the last modified time of the resource known to the client. The operation
   * will be performed only if the resource on the service has been modified
   * since the specified time.
   *
   * @param {date} [options.jobGetOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJob>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information about the specified Job.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.jobGetOptions.select] An OData $select clause.
   *
   * @param {string} [options.jobGetOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.jobGetOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobGetOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobGetOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobGetOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobGetOptions.ifNoneMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service does not match
   * the value specified by the client.
   *
   * @param {date} [options.jobGetOptions.ifModifiedSince] A timestamp indicating
   * the last modified time of the resource known to the client. The operation
   * will be performed only if the resource on the service has been modified
   * since the specified time.
   *
   * @param {date} [options.jobGetOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJob} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudJob} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the properties of the specified Job.
   *
   * This replaces only the Job properties specified in the request. For example,
   * if the Job has constraints, and a request does not specify the constraints
   * element, then the Job keeps the existing constraints.
   *
   * @param {string} jobId The ID of the Job whose properties you want to update.
   *
   * @param {object} jobPatchParameter The parameters for the request.
   *
   * @param {number} [jobPatchParameter.priority] The priority of the Job.
   * Priority values can range from -1000 to 1000, with -1000 being the lowest
   * priority and 1000 being the highest priority. If omitted, the priority of
   * the Job is left unchanged.
   *
   * @param {string} [jobPatchParameter.onAllTasksComplete] The action the Batch
   * service should take when all Tasks in the Job are in the completed state. If
   * omitted, the completion behavior is left unchanged. You may not change the
   * value from terminatejob to noaction - that is, once you have engaged
   * automatic Job termination, you cannot turn it off again. If you try to do
   * this, the request fails with an 'invalid property value' error response; if
   * you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request). Possible values include: 'noAction', 'terminateJob'
   *
   * @param {object} [jobPatchParameter.constraints] The execution constraints
   * for the Job. If omitted, the existing execution constraints are left
   * unchanged.
   *
   * @param {moment.duration} [jobPatchParameter.constraints.maxWallClockTime]
   * The maximum elapsed time that the Job may run, measured from the time the
   * Job is created. If the Job does not complete within the time limit, the
   * Batch service terminates it and any Tasks that are still running. In this
   * case, the termination reason will be MaxWallClockTimeExpiry. If this
   * property is not specified, there is no time limit on how long the Job may
   * run.
   *
   * @param {number} [jobPatchParameter.constraints.maxTaskRetryCount] The
   * maximum number of times each Task may be retried. The Batch service retries
   * a Task if its exit code is nonzero. Note that this value specifically
   * controls the number of retries. The Batch service will try each Task once,
   * and may then retry up to this limit. For example, if the maximum retry count
   * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
   * the maximum retry count is 0, the Batch service does not retry Tasks. If the
   * maximum retry count is -1, the Batch service retries Tasks without limit.
   * The default value is 0 (no retries).
   *
   * @param {object} [jobPatchParameter.poolInfo] The Pool on which the Batch
   * service runs the Job's Tasks. You may change the Pool for a Job only when
   * the Job is disabled. The Patch Job call will fail if you include the
   * poolInfo element and the Job is not disabled. If you specify an
   * autoPoolSpecification in the poolInfo, only the keepAlive property of the
   * autoPoolSpecification can be updated, and then only if the
   * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
   * can be updated as normal). If omitted, the Job continues to run on its
   * current Pool.
   *
   * @param {string} [jobPatchParameter.poolInfo.poolId] The ID of an existing
   * Pool. All the Tasks of the Job will run on the specified Pool. You must
   * ensure that the Pool referenced by this property exists. If the Pool does
   * not exist at the time the Batch service tries to schedule a Job, no Tasks
   * for the Job will run until you create a Pool with that id. Note that the
   * Batch service will not reject the Job request; it will simply not run Tasks
   * until the Pool exists. You must specify either the Pool ID or the auto Pool
   * specification, but not both.
   *
   * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification]
   * Characteristics for a temporary 'auto pool'. The Batch service will create
   * this auto Pool when the Job is submitted. If auto Pool creation fails, the
   * Batch service moves the Job to a completed state, and the Pool creation
   * error is set in the Job's scheduling error property. The Batch service
   * manages the lifetime (both creation and, unless keepAlive is specified,
   * deletion) of the auto Pool. Any user actions that affect the lifetime of the
   * auto Pool while the Job is active will result in unexpected behavior. You
   * must specify either the Pool ID or the auto Pool specification, but not
   * both.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A prefix
   * to be added to the unique identifier when a Pool is automatically created.
   * The Batch service assigns each auto Pool a unique identifier on creation. To
   * distinguish between Pools created for different purposes, you can specify
   * this element to add a prefix to the ID that is assigned. The prefix can be
   * up to 20 characters long.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to keep
   * an auto Pool alive after its lifetime expires. If false, the Batch service
   * deletes the Pool once its lifetime (as determined by the poolLifetimeOption
   * setting) expires; that is, when the Job or Job Schedule completes. If true,
   * the Batch service does not delete the Pool automatically. It is up to the
   * user to delete auto Pools created with this option.
   *
   * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification.pool] The
   * Pool specification for the auto Pool.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string} jobPatchParameter.poolInfo.autoPoolSpecification.pool.vmSize
   * The size of the virtual machines in the Pool. All virtual machines in a Pool
   * are the same size. For information about available sizes of virtual machines
   * in Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
   * The cloud service configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure PaaS VMs. This property
   * and virtualMachineConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request). This property cannot be specified if the Batch
   * Account was created with its poolAllocationMode property set to
   * 'UserSubscription'.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
   * The virtual machine configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure IaaS VMs. This property
   * and cloudServiceConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request).
   *
   * @param {object}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode] The
   * number of task slots that can be used to run concurrent tasks on a single
   * compute node in the pool. The default value is 1. The maximum value is the
   * smaller of 4 times the number of cores of the vmSize of the pool or 256.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
   * timeout for allocation of Compute Nodes to the Pool. This timeout applies
   * only to manual scaling; it has no effect when enableAutoScale is set to
   * true. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service rejects the
   * request with an error; if you are calling the REST API directly, the HTTP
   * status code is 400 (Bad Request).
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
   * The desired number of dedicated Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
   * The desired number of low-priority Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula] The
   * formula for the desired number of Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to false. It is required if
   * enableAutoScale is set to true. The formula is checked for validity before
   * the Pool is created. If the formula is not valid, the Batch service rejects
   * the request with detailed error information.
   *
   * @param {moment.duration}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
   * The time interval at which to automatically adjust the Pool size according
   * to the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
   * The network configuration for the Pool.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
   * The ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
   * run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
   * The command line of the StartTask. The command line does not run under a
   * shell, and therefore cannot take advantage of shell features such as
   * environment variable expansion. If you want to take advantage of such
   * features, you should invoke the shell in the command line, for example using
   * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
   * command line refers to file paths, it should use a relative path (relative
   * to the Task working directory), or use the Batch provided environment
   * variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
   * The settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
   * A list of files that the Batch service will download to the Compute Node
   * before running the command line.  There is a maximum size for the list of
   * resource files. When the max size is exceeded, the request will fail and the
   * response error code will be RequestEntityTooLarge. If this occurs, the
   * collection of ResourceFiles must be reduced in size. This can be achieved
   * using .zip files, Application Packages, or Docker Containers. Files listed
   * under this element are located in the Task's working directory.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
   * A list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
   * The user identity under which the StartTask runs. If omitted, the Task runs
   * as a non-administrative user unique to the Task.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
   * The maximum number of times the Task may be retried. The Batch service
   * retries a Task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * Task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the Task. If the maximum retry count is -1, the Batch service retries the
   * Task without limit.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
   * Whether the Batch service should wait for the StartTask to complete
   * successfully (that is, to exit with exit code 0) before scheduling any Tasks
   * on the Compute Node. If true and the StartTask fails on a Node, the Batch
   * service retries the StartTask up to its maximum retry count
   * (maxTaskRetryCount). If the Task has still not completed successfully after
   * all retries, then the Batch service marks the Node unusable, and will not
   * schedule Tasks to it. This condition can be detected via the Compute Node
   * state and failure info details. If false, the Batch service will not wait
   * for the StartTask to complete. In this case, other Tasks can start executing
   * on the Compute Node while the StartTask is still running; and even if the
   * StartTask fails, new Tasks will continue to be scheduled on the Compute
   * Node. The default is true.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
   * A list of Certificates to be installed on each Compute Node in the Pool. For
   * Windows Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
   * The list of Packages to be installed on each Compute Node in the Pool.
   * Changes to Package references affect all new Nodes joining the Pool, but do
   * not affect Compute Nodes that are already in the Pool until they are
   * rebooted or reimaged. There is a maximum of 10 Package references on any
   * given Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration] A
   * list of file systems to mount on each node in the pool. This supports Azure
   * Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {array} [jobPatchParameter.metadata] A list of name-value pairs
   * associated with the Job as metadata. If omitted, the existing Job metadata
   * is left unchanged.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobPatchOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobPatchOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobPatchOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobPatchOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobPatchOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobPatchOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobPatchOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobPatchOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobPatchOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  patchWithHttpOperationResponse(jobId, jobPatchParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._patch(jobId, jobPatchParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the properties of the specified Job.
   *
   * This replaces only the Job properties specified in the request. For example,
   * if the Job has constraints, and a request does not specify the constraints
   * element, then the Job keeps the existing constraints.
   *
   * @param {string} jobId The ID of the Job whose properties you want to update.
   *
   * @param {object} jobPatchParameter The parameters for the request.
   *
   * @param {number} [jobPatchParameter.priority] The priority of the Job.
   * Priority values can range from -1000 to 1000, with -1000 being the lowest
   * priority and 1000 being the highest priority. If omitted, the priority of
   * the Job is left unchanged.
   *
   * @param {string} [jobPatchParameter.onAllTasksComplete] The action the Batch
   * service should take when all Tasks in the Job are in the completed state. If
   * omitted, the completion behavior is left unchanged. You may not change the
   * value from terminatejob to noaction - that is, once you have engaged
   * automatic Job termination, you cannot turn it off again. If you try to do
   * this, the request fails with an 'invalid property value' error response; if
   * you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request). Possible values include: 'noAction', 'terminateJob'
   *
   * @param {object} [jobPatchParameter.constraints] The execution constraints
   * for the Job. If omitted, the existing execution constraints are left
   * unchanged.
   *
   * @param {moment.duration} [jobPatchParameter.constraints.maxWallClockTime]
   * The maximum elapsed time that the Job may run, measured from the time the
   * Job is created. If the Job does not complete within the time limit, the
   * Batch service terminates it and any Tasks that are still running. In this
   * case, the termination reason will be MaxWallClockTimeExpiry. If this
   * property is not specified, there is no time limit on how long the Job may
   * run.
   *
   * @param {number} [jobPatchParameter.constraints.maxTaskRetryCount] The
   * maximum number of times each Task may be retried. The Batch service retries
   * a Task if its exit code is nonzero. Note that this value specifically
   * controls the number of retries. The Batch service will try each Task once,
   * and may then retry up to this limit. For example, if the maximum retry count
   * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
   * the maximum retry count is 0, the Batch service does not retry Tasks. If the
   * maximum retry count is -1, the Batch service retries Tasks without limit.
   * The default value is 0 (no retries).
   *
   * @param {object} [jobPatchParameter.poolInfo] The Pool on which the Batch
   * service runs the Job's Tasks. You may change the Pool for a Job only when
   * the Job is disabled. The Patch Job call will fail if you include the
   * poolInfo element and the Job is not disabled. If you specify an
   * autoPoolSpecification in the poolInfo, only the keepAlive property of the
   * autoPoolSpecification can be updated, and then only if the
   * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
   * can be updated as normal). If omitted, the Job continues to run on its
   * current Pool.
   *
   * @param {string} [jobPatchParameter.poolInfo.poolId] The ID of an existing
   * Pool. All the Tasks of the Job will run on the specified Pool. You must
   * ensure that the Pool referenced by this property exists. If the Pool does
   * not exist at the time the Batch service tries to schedule a Job, no Tasks
   * for the Job will run until you create a Pool with that id. Note that the
   * Batch service will not reject the Job request; it will simply not run Tasks
   * until the Pool exists. You must specify either the Pool ID or the auto Pool
   * specification, but not both.
   *
   * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification]
   * Characteristics for a temporary 'auto pool'. The Batch service will create
   * this auto Pool when the Job is submitted. If auto Pool creation fails, the
   * Batch service moves the Job to a completed state, and the Pool creation
   * error is set in the Job's scheduling error property. The Batch service
   * manages the lifetime (both creation and, unless keepAlive is specified,
   * deletion) of the auto Pool. Any user actions that affect the lifetime of the
   * auto Pool while the Job is active will result in unexpected behavior. You
   * must specify either the Pool ID or the auto Pool specification, but not
   * both.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A prefix
   * to be added to the unique identifier when a Pool is automatically created.
   * The Batch service assigns each auto Pool a unique identifier on creation. To
   * distinguish between Pools created for different purposes, you can specify
   * this element to add a prefix to the ID that is assigned. The prefix can be
   * up to 20 characters long.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to keep
   * an auto Pool alive after its lifetime expires. If false, the Batch service
   * deletes the Pool once its lifetime (as determined by the poolLifetimeOption
   * setting) expires; that is, when the Job or Job Schedule completes. If true,
   * the Batch service does not delete the Pool automatically. It is up to the
   * user to delete auto Pools created with this option.
   *
   * @param {object} [jobPatchParameter.poolInfo.autoPoolSpecification.pool] The
   * Pool specification for the auto Pool.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string} jobPatchParameter.poolInfo.autoPoolSpecification.pool.vmSize
   * The size of the virtual machines in the Pool. All virtual machines in a Pool
   * are the same size. For information about available sizes of virtual machines
   * in Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
   * The cloud service configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure PaaS VMs. This property
   * and virtualMachineConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request). This property cannot be specified if the Batch
   * Account was created with its poolAllocationMode property set to
   * 'UserSubscription'.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
   * The virtual machine configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure IaaS VMs. This property
   * and cloudServiceConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request).
   *
   * @param {object}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode] The
   * number of task slots that can be used to run concurrent tasks on a single
   * compute node in the pool. The default value is 1. The maximum value is the
   * smaller of 4 times the number of cores of the vmSize of the pool or 256.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
   * timeout for allocation of Compute Nodes to the Pool. This timeout applies
   * only to manual scaling; it has no effect when enableAutoScale is set to
   * true. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service rejects the
   * request with an error; if you are calling the REST API directly, the HTTP
   * status code is 400 (Bad Request).
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
   * The desired number of dedicated Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
   * The desired number of low-priority Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula] The
   * formula for the desired number of Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to false. It is required if
   * enableAutoScale is set to true. The formula is checked for validity before
   * the Pool is created. If the formula is not valid, the Batch service rejects
   * the request with detailed error information.
   *
   * @param {moment.duration}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
   * The time interval at which to automatically adjust the Pool size according
   * to the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
   * The network configuration for the Pool.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
   * The ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
   * run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
   * The command line of the StartTask. The command line does not run under a
   * shell, and therefore cannot take advantage of shell features such as
   * environment variable expansion. If you want to take advantage of such
   * features, you should invoke the shell in the command line, for example using
   * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
   * command line refers to file paths, it should use a relative path (relative
   * to the Task working directory), or use the Batch provided environment
   * variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
   * The settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
   * A list of files that the Batch service will download to the Compute Node
   * before running the command line.  There is a maximum size for the list of
   * resource files. When the max size is exceeded, the request will fail and the
   * response error code will be RequestEntityTooLarge. If this occurs, the
   * collection of ResourceFiles must be reduced in size. This can be achieved
   * using .zip files, Application Packages, or Docker Containers. Files listed
   * under this element are located in the Task's working directory.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
   * A list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
   * The user identity under which the StartTask runs. If omitted, the Task runs
   * as a non-administrative user unique to the Task.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
   * The maximum number of times the Task may be retried. The Batch service
   * retries a Task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * Task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the Task. If the maximum retry count is -1, the Batch service retries the
   * Task without limit.
   *
   * @param {boolean}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
   * Whether the Batch service should wait for the StartTask to complete
   * successfully (that is, to exit with exit code 0) before scheduling any Tasks
   * on the Compute Node. If true and the StartTask fails on a Node, the Batch
   * service retries the StartTask up to its maximum retry count
   * (maxTaskRetryCount). If the Task has still not completed successfully after
   * all retries, then the Batch service marks the Node unusable, and will not
   * schedule Tasks to it. This condition can be detected via the Compute Node
   * state and failure info details. If false, the Batch service will not wait
   * for the StartTask to complete. In this case, other Tasks can start executing
   * on the Compute Node while the StartTask is still running; and even if the
   * StartTask fails, new Tasks will continue to be scheduled on the Compute
   * Node. The default is true.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
   * A list of Certificates to be installed on each Compute Node in the Pool. For
   * Windows Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
   * The list of Packages to be installed on each Compute Node in the Pool.
   * Changes to Package references affect all new Nodes joining the Pool, but do
   * not affect Compute Nodes that are already in the Pool until they are
   * rebooted or reimaged. There is a maximum of 10 Package references on any
   * given Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array}
   * [jobPatchParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration] A
   * list of file systems to mount on each node in the pool. This supports Azure
   * Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {array} [jobPatchParameter.metadata] A list of name-value pairs
   * associated with the Job as metadata. If omitted, the existing Job metadata
   * is left unchanged.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobPatchOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobPatchOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobPatchOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobPatchOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobPatchOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobPatchOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobPatchOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobPatchOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobPatchOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  patch(jobId, jobPatchParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._patch(jobId, jobPatchParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._patch(jobId, jobPatchParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the properties of the specified Job.
   *
   * This fully replaces all the updatable properties of the Job. For example, if
   * the Job has constraints associated with it and if constraints is not
   * specified with this request, then the Batch service will remove the existing
   * constraints.
   *
   * @param {string} jobId The ID of the Job whose properties you want to update.
   *
   * @param {object} jobUpdateParameter The parameters for the request.
   *
   * @param {number} [jobUpdateParameter.priority] The priority of the Job.
   * Priority values can range from -1000 to 1000, with -1000 being the lowest
   * priority and 1000 being the highest priority. If omitted, it is set to the
   * default value 0.
   *
   * @param {object} [jobUpdateParameter.constraints] The execution constraints
   * for the Job. If omitted, the constraints are cleared.
   *
   * @param {moment.duration} [jobUpdateParameter.constraints.maxWallClockTime]
   * The maximum elapsed time that the Job may run, measured from the time the
   * Job is created. If the Job does not complete within the time limit, the
   * Batch service terminates it and any Tasks that are still running. In this
   * case, the termination reason will be MaxWallClockTimeExpiry. If this
   * property is not specified, there is no time limit on how long the Job may
   * run.
   *
   * @param {number} [jobUpdateParameter.constraints.maxTaskRetryCount] The
   * maximum number of times each Task may be retried. The Batch service retries
   * a Task if its exit code is nonzero. Note that this value specifically
   * controls the number of retries. The Batch service will try each Task once,
   * and may then retry up to this limit. For example, if the maximum retry count
   * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
   * the maximum retry count is 0, the Batch service does not retry Tasks. If the
   * maximum retry count is -1, the Batch service retries Tasks without limit.
   * The default value is 0 (no retries).
   *
   * @param {object} jobUpdateParameter.poolInfo The Pool on which the Batch
   * service runs the Job's Tasks. You may change the Pool for a Job only when
   * the Job is disabled. The Update Job call will fail if you include the
   * poolInfo element and the Job is not disabled. If you specify an
   * autoPoolSpecification in the poolInfo, only the keepAlive property of the
   * autoPoolSpecification can be updated, and then only if the
   * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
   * can be updated as normal).
   *
   * @param {string} [jobUpdateParameter.poolInfo.poolId] The ID of an existing
   * Pool. All the Tasks of the Job will run on the specified Pool. You must
   * ensure that the Pool referenced by this property exists. If the Pool does
   * not exist at the time the Batch service tries to schedule a Job, no Tasks
   * for the Job will run until you create a Pool with that id. Note that the
   * Batch service will not reject the Job request; it will simply not run Tasks
   * until the Pool exists. You must specify either the Pool ID or the auto Pool
   * specification, but not both.
   *
   * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification]
   * Characteristics for a temporary 'auto pool'. The Batch service will create
   * this auto Pool when the Job is submitted. If auto Pool creation fails, the
   * Batch service moves the Job to a completed state, and the Pool creation
   * error is set in the Job's scheduling error property. The Batch service
   * manages the lifetime (both creation and, unless keepAlive is specified,
   * deletion) of the auto Pool. Any user actions that affect the lifetime of the
   * auto Pool while the Job is active will result in unexpected behavior. You
   * must specify either the Pool ID or the auto Pool specification, but not
   * both.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
   * prefix to be added to the unique identifier when a Pool is automatically
   * created. The Batch service assigns each auto Pool a unique identifier on
   * creation. To distinguish between Pools created for different purposes, you
   * can specify this element to add a prefix to the ID that is assigned. The
   * prefix can be up to 20 characters long.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to
   * keep an auto Pool alive after its lifetime expires. If false, the Batch
   * service deletes the Pool once its lifetime (as determined by the
   * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
   * completes. If true, the Batch service does not delete the Pool
   * automatically. It is up to the user to delete auto Pools created with this
   * option.
   *
   * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification.pool] The
   * Pool specification for the auto Pool.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.vmSize The size of
   * the virtual machines in the Pool. All virtual machines in a Pool are the
   * same size. For information about available sizes of virtual machines in
   * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
   * The cloud service configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure PaaS VMs. This property
   * and virtualMachineConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request). This property cannot be specified if the Batch
   * Account was created with its poolAllocationMode property set to
   * 'UserSubscription'.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
   * The virtual machine configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure IaaS VMs. This property
   * and cloudServiceConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request).
   *
   * @param {object}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
   * The number of task slots that can be used to run concurrent tasks on a
   * single compute node in the pool. The default value is 1. The maximum value
   * is the smaller of 4 times the number of cores of the vmSize of the pool or
   * 256.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
   * timeout for allocation of Compute Nodes to the Pool. This timeout applies
   * only to manual scaling; it has no effect when enableAutoScale is set to
   * true. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service rejects the
   * request with an error; if you are calling the REST API directly, the HTTP
   * status code is 400 (Bad Request).
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
   * The desired number of dedicated Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
   * The desired number of low-priority Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
   * The formula for the desired number of Compute Nodes in the Pool. This
   * property must not be specified if enableAutoScale is set to false. It is
   * required if enableAutoScale is set to true. The formula is checked for
   * validity before the Pool is created. If the formula is not valid, the Batch
   * service rejects the request with detailed error information.
   *
   * @param {moment.duration}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
   * The time interval at which to automatically adjust the Pool size according
   * to the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
   * The network configuration for the Pool.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
   * The ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
   * run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
   * The command line of the StartTask. The command line does not run under a
   * shell, and therefore cannot take advantage of shell features such as
   * environment variable expansion. If you want to take advantage of such
   * features, you should invoke the shell in the command line, for example using
   * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
   * command line refers to file paths, it should use a relative path (relative
   * to the Task working directory), or use the Batch provided environment
   * variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
   * The settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
   * A list of files that the Batch service will download to the Compute Node
   * before running the command line.  There is a maximum size for the list of
   * resource files. When the max size is exceeded, the request will fail and the
   * response error code will be RequestEntityTooLarge. If this occurs, the
   * collection of ResourceFiles must be reduced in size. This can be achieved
   * using .zip files, Application Packages, or Docker Containers. Files listed
   * under this element are located in the Task's working directory.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
   * A list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
   * The user identity under which the StartTask runs. If omitted, the Task runs
   * as a non-administrative user unique to the Task.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
   * The maximum number of times the Task may be retried. The Batch service
   * retries a Task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * Task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the Task. If the maximum retry count is -1, the Batch service retries the
   * Task without limit.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
   * Whether the Batch service should wait for the StartTask to complete
   * successfully (that is, to exit with exit code 0) before scheduling any Tasks
   * on the Compute Node. If true and the StartTask fails on a Node, the Batch
   * service retries the StartTask up to its maximum retry count
   * (maxTaskRetryCount). If the Task has still not completed successfully after
   * all retries, then the Batch service marks the Node unusable, and will not
   * schedule Tasks to it. This condition can be detected via the Compute Node
   * state and failure info details. If false, the Batch service will not wait
   * for the StartTask to complete. In this case, other Tasks can start executing
   * on the Compute Node while the StartTask is still running; and even if the
   * StartTask fails, new Tasks will continue to be scheduled on the Compute
   * Node. The default is true.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
   * A list of Certificates to be installed on each Compute Node in the Pool. For
   * Windows Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
   * The list of Packages to be installed on each Compute Node in the Pool.
   * Changes to Package references affect all new Nodes joining the Pool, but do
   * not affect Compute Nodes that are already in the Pool until they are
   * rebooted or reimaged. There is a maximum of 10 Package references on any
   * given Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration]
   * A list of file systems to mount on each node in the pool. This supports
   * Azure Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {array} [jobUpdateParameter.metadata] A list of name-value pairs
   * associated with the Job as metadata. If omitted, it takes the default value
   * of an empty list; in effect, any existing metadata is deleted.
   *
   * @param {string} [jobUpdateParameter.onAllTasksComplete] The action the Batch
   * service should take when all Tasks in the Job are in the completed state. If
   * omitted, the completion behavior is set to noaction. If the current value is
   * terminatejob, this is an error because a Job's completion behavior may not
   * be changed from terminatejob to noaction. You may not change the value from
   * terminatejob to noaction - that is, once you have engaged automatic Job
   * termination, you cannot turn it off again. If you try to do this, the
   * request fails and Batch returns status code 400 (Bad Request) and an
   * 'invalid property value' error response. If you do not specify this element
   * in a PUT request, it is equivalent to passing noaction. This is an error if
   * the current value is terminatejob. Possible values include: 'noAction',
   * 'terminateJob'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobUpdateOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobUpdateOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobUpdateOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobUpdateOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobUpdateOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobUpdateOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobUpdateOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobUpdateOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobUpdateOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateWithHttpOperationResponse(jobId, jobUpdateParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._update(jobId, jobUpdateParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the properties of the specified Job.
   *
   * This fully replaces all the updatable properties of the Job. For example, if
   * the Job has constraints associated with it and if constraints is not
   * specified with this request, then the Batch service will remove the existing
   * constraints.
   *
   * @param {string} jobId The ID of the Job whose properties you want to update.
   *
   * @param {object} jobUpdateParameter The parameters for the request.
   *
   * @param {number} [jobUpdateParameter.priority] The priority of the Job.
   * Priority values can range from -1000 to 1000, with -1000 being the lowest
   * priority and 1000 being the highest priority. If omitted, it is set to the
   * default value 0.
   *
   * @param {object} [jobUpdateParameter.constraints] The execution constraints
   * for the Job. If omitted, the constraints are cleared.
   *
   * @param {moment.duration} [jobUpdateParameter.constraints.maxWallClockTime]
   * The maximum elapsed time that the Job may run, measured from the time the
   * Job is created. If the Job does not complete within the time limit, the
   * Batch service terminates it and any Tasks that are still running. In this
   * case, the termination reason will be MaxWallClockTimeExpiry. If this
   * property is not specified, there is no time limit on how long the Job may
   * run.
   *
   * @param {number} [jobUpdateParameter.constraints.maxTaskRetryCount] The
   * maximum number of times each Task may be retried. The Batch service retries
   * a Task if its exit code is nonzero. Note that this value specifically
   * controls the number of retries. The Batch service will try each Task once,
   * and may then retry up to this limit. For example, if the maximum retry count
   * is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If
   * the maximum retry count is 0, the Batch service does not retry Tasks. If the
   * maximum retry count is -1, the Batch service retries Tasks without limit.
   * The default value is 0 (no retries).
   *
   * @param {object} jobUpdateParameter.poolInfo The Pool on which the Batch
   * service runs the Job's Tasks. You may change the Pool for a Job only when
   * the Job is disabled. The Update Job call will fail if you include the
   * poolInfo element and the Job is not disabled. If you specify an
   * autoPoolSpecification in the poolInfo, only the keepAlive property of the
   * autoPoolSpecification can be updated, and then only if the
   * autoPoolSpecification has a poolLifetimeOption of Job (other job properties
   * can be updated as normal).
   *
   * @param {string} [jobUpdateParameter.poolInfo.poolId] The ID of an existing
   * Pool. All the Tasks of the Job will run on the specified Pool. You must
   * ensure that the Pool referenced by this property exists. If the Pool does
   * not exist at the time the Batch service tries to schedule a Job, no Tasks
   * for the Job will run until you create a Pool with that id. Note that the
   * Batch service will not reject the Job request; it will simply not run Tasks
   * until the Pool exists. You must specify either the Pool ID or the auto Pool
   * specification, but not both.
   *
   * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification]
   * Characteristics for a temporary 'auto pool'. The Batch service will create
   * this auto Pool when the Job is submitted. If auto Pool creation fails, the
   * Batch service moves the Job to a completed state, and the Pool creation
   * error is set in the Job's scheduling error property. The Batch service
   * manages the lifetime (both creation and, unless keepAlive is specified,
   * deletion) of the auto Pool. Any user actions that affect the lifetime of the
   * auto Pool while the Job is active will result in unexpected behavior. You
   * must specify either the Pool ID or the auto Pool specification, but not
   * both.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
   * prefix to be added to the unique identifier when a Pool is automatically
   * created. The Batch service assigns each auto Pool a unique identifier on
   * creation. To distinguish between Pools created for different purposes, you
   * can specify this element to add a prefix to the ID that is assigned. The
   * prefix can be up to 20 characters long.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.keepAlive] Whether to
   * keep an auto Pool alive after its lifetime expires. If false, the Batch
   * service deletes the Pool once its lifetime (as determined by the
   * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
   * completes. If true, the Batch service does not delete the Pool
   * automatically. It is up to the user to delete auto Pools created with this
   * option.
   *
   * @param {object} [jobUpdateParameter.poolInfo.autoPoolSpecification.pool] The
   * Pool specification for the auto Pool.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.vmSize The size of
   * the virtual machines in the Pool. All virtual machines in a Pool are the
   * same size. For information about available sizes of virtual machines in
   * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration]
   * The cloud service configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure PaaS VMs. This property
   * and virtualMachineConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request). This property cannot be specified if the Batch
   * Account was created with its poolAllocationMode property set to
   * 'UserSubscription'.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration]
   * The virtual machine configuration for the Pool. This property must be
   * specified if the Pool needs to be created with Azure IaaS VMs. This property
   * and cloudServiceConfiguration are mutually exclusive and one of the
   * properties must be specified. If neither is specified then the Batch service
   * returns an error; if you are calling the REST API directly, the HTTP status
   * code is 400 (Bad Request).
   *
   * @param {object}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
   * The number of task slots that can be used to run concurrent tasks on a
   * single compute node in the pool. The default value is 1. The maximum value
   * is the smaller of 4 times the number of cores of the vmSize of the pool or
   * 256.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.resizeTimeout] The
   * timeout for allocation of Compute Nodes to the Pool. This timeout applies
   * only to manual scaling; it has no effect when enableAutoScale is set to
   * true. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service rejects the
   * request with an error; if you are calling the REST API directly, the HTTP
   * status code is 400 (Bad Request).
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes]
   * The desired number of dedicated Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes]
   * The desired number of low-priority Compute Nodes in the Pool. This property
   * must not be specified if enableAutoScale is set to true. If enableAutoScale
   * is set to false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
   * The formula for the desired number of Compute Nodes in the Pool. This
   * property must not be specified if enableAutoScale is set to false. It is
   * required if enableAutoScale is set to true. The formula is checked for
   * validity before the Pool is created. If the formula is not valid, the Batch
   * service rejects the request with detailed error information.
   *
   * @param {moment.duration}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
   * The time interval at which to automatically adjust the Pool size according
   * to the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration]
   * The network configuration for the Pool.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId]
   * The ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask] A Task to
   * run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.commandLine
   * The command line of the StartTask. The command line does not run under a
   * shell, and therefore cannot take advantage of shell features such as
   * environment variable expansion. If you want to take advantage of such
   * features, you should invoke the shell in the command line, for example using
   * "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
   * command line refers to file paths, it should use a relative path (relative
   * to the Task working directory), or use the Batch provided environment
   * variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings]
   * The settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
   * A list of files that the Batch service will download to the Compute Node
   * before running the command line.  There is a maximum size for the list of
   * resource files. When the max size is exceeded, the request will fail and the
   * response error code will be RequestEntityTooLarge. If this occurs, the
   * collection of ResourceFiles must be reduced in size. This can be achieved
   * using .zip files, Application Packages, or Docker Containers. Files listed
   * under this element are located in the Task's working directory.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
   * A list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity]
   * The user identity under which the StartTask runs. If omitted, the Task runs
   * as a non-administrative user unique to the Task.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
   * The maximum number of times the Task may be retried. The Batch service
   * retries a Task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * Task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the Task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the Task. If the maximum retry count is -1, the Batch service retries the
   * Task without limit.
   *
   * @param {boolean}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
   * Whether the Batch service should wait for the StartTask to complete
   * successfully (that is, to exit with exit code 0) before scheduling any Tasks
   * on the Compute Node. If true and the StartTask fails on a Node, the Batch
   * service retries the StartTask up to its maximum retry count
   * (maxTaskRetryCount). If the Task has still not completed successfully after
   * all retries, then the Batch service marks the Node unusable, and will not
   * schedule Tasks to it. This condition can be detected via the Compute Node
   * state and failure info details. If false, the Batch service will not wait
   * for the StartTask to complete. In this case, other Tasks can start executing
   * on the Compute Node while the StartTask is still running; and even if the
   * StartTask fails, new Tasks will continue to be scheduled on the Compute
   * Node. The default is true.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.certificateReferences]
   * A list of Certificates to be installed on each Compute Node in the Pool. For
   * Windows Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
   * The list of Packages to be installed on each Compute Node in the Pool.
   * Changes to Package references affect all new Nodes joining the Pool, but do
   * not affect Compute Nodes that are already in the Pool until they are
   * rebooted or reimaged. There is a maximum of 10 Package references on any
   * given Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array}
   * [jobUpdateParameter.poolInfo.autoPoolSpecification.pool.mountConfiguration]
   * A list of file systems to mount on each node in the pool. This supports
   * Azure Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {array} [jobUpdateParameter.metadata] A list of name-value pairs
   * associated with the Job as metadata. If omitted, it takes the default value
   * of an empty list; in effect, any existing metadata is deleted.
   *
   * @param {string} [jobUpdateParameter.onAllTasksComplete] The action the Batch
   * service should take when all Tasks in the Job are in the completed state. If
   * omitted, the completion behavior is set to noaction. If the current value is
   * terminatejob, this is an error because a Job's completion behavior may not
   * be changed from terminatejob to noaction. You may not change the value from
   * terminatejob to noaction - that is, once you have engaged automatic Job
   * termination, you cannot turn it off again. If you try to do this, the
   * request fails and Batch returns status code 400 (Bad Request) and an
   * 'invalid property value' error response. If you do not specify this element
   * in a PUT request, it is equivalent to passing noaction. This is an error if
   * the current value is terminatejob. Possible values include: 'noAction',
   * 'terminateJob'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobUpdateOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobUpdateOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobUpdateOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobUpdateOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobUpdateOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobUpdateOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobUpdateOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobUpdateOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobUpdateOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  update(jobId, jobUpdateParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._update(jobId, jobUpdateParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._update(jobId, jobUpdateParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Disables the specified Job, preventing new Tasks from running.
   *
   * The Batch Service immediately moves the Job to the disabling state. Batch
   * then uses the disableTasks parameter to determine what to do with the
   * currently running Tasks of the Job. The Job remains in the disabling state
   * until the disable operation is completed and all Tasks have been dealt with
   * according to the disableTasks option; the Job then moves to the disabled
   * state. No new Tasks are started under the Job until it moves back to active
   * state. If you try to disable a Job that is in any state other than active,
   * disabling, or disabled, the request fails with status code 409.
   *
   * @param {string} jobId The ID of the Job to disable.
   *
   * @param {string} disableTasks What to do with active Tasks associated with
   * the Job. Possible values include: 'requeue', 'terminate', 'wait'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobDisableOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobDisableOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobDisableOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobDisableOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobDisableOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobDisableOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobDisableOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobDisableOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobDisableOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableWithHttpOperationResponse(jobId, disableTasks, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disable(jobId, disableTasks, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Disables the specified Job, preventing new Tasks from running.
   *
   * The Batch Service immediately moves the Job to the disabling state. Batch
   * then uses the disableTasks parameter to determine what to do with the
   * currently running Tasks of the Job. The Job remains in the disabling state
   * until the disable operation is completed and all Tasks have been dealt with
   * according to the disableTasks option; the Job then moves to the disabled
   * state. No new Tasks are started under the Job until it moves back to active
   * state. If you try to disable a Job that is in any state other than active,
   * disabling, or disabled, the request fails with status code 409.
   *
   * @param {string} jobId The ID of the Job to disable.
   *
   * @param {string} disableTasks What to do with active Tasks associated with
   * the Job. Possible values include: 'requeue', 'terminate', 'wait'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobDisableOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobDisableOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobDisableOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobDisableOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobDisableOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobDisableOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobDisableOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobDisableOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobDisableOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disable(jobId, disableTasks, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disable(jobId, disableTasks, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disable(jobId, disableTasks, options, optionalCallback);
    }
  }

  /**
   * @summary Enables the specified Job, allowing new Tasks to run.
   *
   * When you call this API, the Batch service sets a disabled Job to the
   * enabling state. After the this operation is completed, the Job moves to the
   * active state, and scheduling of new Tasks under the Job resumes. The Batch
   * service does not allow a Task to remain in the active state for more than
   * 180 days. Therefore, if you enable a Job containing active Tasks which were
   * added more than 180 days ago, those Tasks will not run.
   *
   * @param {string} jobId The ID of the Job to enable.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobEnableOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobEnableOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobEnableOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobEnableOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobEnableOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobEnableOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobEnableOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobEnableOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobEnableOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enable(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enables the specified Job, allowing new Tasks to run.
   *
   * When you call this API, the Batch service sets a disabled Job to the
   * enabling state. After the this operation is completed, the Job moves to the
   * active state, and scheduling of new Tasks under the Job resumes. The Batch
   * service does not allow a Task to remain in the active state for more than
   * 180 days. Therefore, if you enable a Job containing active Tasks which were
   * added more than 180 days ago, those Tasks will not run.
   *
   * @param {string} jobId The ID of the Job to enable.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobEnableOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobEnableOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobEnableOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobEnableOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobEnableOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobEnableOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.jobEnableOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobEnableOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobEnableOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enable(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enable(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enable(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Terminates the specified Job, marking it as completed.
   *
   * When a Terminate Job request is received, the Batch service sets the Job to
   * the terminating state. The Batch service then terminates any running Tasks
   * associated with the Job and runs any required Job release Tasks. Then the
   * Job moves into the completed state. If there are any Tasks in the Job in the
   * active state, they will remain in the active state. Once a Job is
   * terminated, new Tasks cannot be added and any remaining active Tasks will
   * not be scheduled.
   *
   * @param {string} jobId The ID of the Job to terminate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.terminateReason] The text you want to appear as the
   * Job's TerminateReason. The default is 'UserTerminate'.
   *
   * @param {object} [options.jobTerminateOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobTerminateOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobTerminateOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobTerminateOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobTerminateOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobTerminateOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.jobTerminateOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobTerminateOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobTerminateOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  terminateWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._terminate(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Terminates the specified Job, marking it as completed.
   *
   * When a Terminate Job request is received, the Batch service sets the Job to
   * the terminating state. The Batch service then terminates any running Tasks
   * associated with the Job and runs any required Job release Tasks. Then the
   * Job moves into the completed state. If there are any Tasks in the Job in the
   * active state, they will remain in the active state. Once a Job is
   * terminated, new Tasks cannot be added and any remaining active Tasks will
   * not be scheduled.
   *
   * @param {string} jobId The ID of the Job to terminate.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.terminateReason] The text you want to appear as the
   * Job's TerminateReason. The default is 'UserTerminate'.
   *
   * @param {object} [options.jobTerminateOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobTerminateOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobTerminateOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobTerminateOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobTerminateOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.jobTerminateOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.jobTerminateOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.jobTerminateOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.jobTerminateOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  terminate(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._terminate(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._terminate(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Job to the specified Account.
   *
   * The Batch service supports two ways to control the work done as part of a
   * Job. In the first approach, the user specifies a Job Manager Task. The Batch
   * service launches this Task when it is ready to start the Job. The Job
   * Manager Task controls all other Tasks that run under this Job, by using the
   * Task APIs. In the second approach, the user directly controls the execution
   * of Tasks under an active Job, by using the Task APIs. Also note: when naming
   * Jobs, avoid including sensitive information such as user names or secret
   * project names. This information may appear in telemetry logs accessible to
   * Microsoft Support engineers.
   *
   * @param {object} job The Job to be added.
   *
   * @param {string} job.id A string that uniquely identifies the Job within the
   * Account. The ID can contain any combination of alphanumeric characters
   * including hyphens and underscores, and cannot contain more than 64
   * characters. The ID is case-preserving and case-insensitive (that is, you may
   * not have two IDs within an Account that differ only by case).
   *
   * @param {string} [job.displayName] The display name for the Job. The display
   * name need not be unique and can contain any Unicode characters up to a
   * maximum length of 1024.
   *
   * @param {number} [job.priority] The priority of the Job. Priority values can
   * range from -1000 to 1000, with -1000 being the lowest priority and 1000
   * being the highest priority. The default value is 0.
   *
   * @param {object} [job.constraints] The execution constraints for the Job.
   *
   * @param {moment.duration} [job.constraints.maxWallClockTime] The maximum
   * elapsed time that the Job may run, measured from the time the Job is
   * created. If the Job does not complete within the time limit, the Batch
   * service terminates it and any Tasks that are still running. In this case,
   * the termination reason will be MaxWallClockTimeExpiry. If this property is
   * not specified, there is no time limit on how long the Job may run.
   *
   * @param {number} [job.constraints.maxTaskRetryCount] The maximum number of
   * times each Task may be retried. The Batch service retries a Task if its exit
   * code is nonzero. Note that this value specifically controls the number of
   * retries. The Batch service will try each Task once, and may then retry up to
   * this limit. For example, if the maximum retry count is 3, Batch tries a Task
   * up to 4 times (one initial try and 3 retries). If the maximum retry count is
   * 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
   * the Batch service retries Tasks without limit. The default value is 0 (no
   * retries).
   *
   * @param {object} [job.jobManagerTask] Details of a Job Manager Task to be
   * launched when the Job is started. If the Job does not specify a Job Manager
   * Task, the user must explicitly add Tasks to the Job. If the Job does specify
   * a Job Manager Task, the Batch service creates the Job Manager Task when the
   * Job is created, and will try to schedule the Job Manager Task before
   * scheduling other Tasks in the Job. The Job Manager Task's typical purpose is
   * to control and/or monitor Job execution, for example by deciding what
   * additional Tasks to run, determining when the work is complete, etc.
   * (However, a Job Manager Task is not restricted to these activities - it is a
   * fully-fledged Task in the system and perform whatever actions are required
   * for the Job.) For example, a Job Manager Task might download a file
   * specified as a parameter, analyze the contents of that file and submit
   * additional Tasks based on those contents.
   *
   * @param {string} job.jobManagerTask.id A string that uniquely identifies the
   * Job Manager Task within the Job. The ID can contain any combination of
   * alphanumeric characters including hyphens and underscores and cannot contain
   * more than 64 characters.
   *
   * @param {string} [job.jobManagerTask.displayName] The display name of the Job
   * Manager Task. It need not be unique and can contain any Unicode characters
   * up to a maximum length of 1024.
   *
   * @param {string} job.jobManagerTask.commandLine The command line of the Job
   * Manager Task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
   * file paths, it should use a relative path (relative to the Task working
   * directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobManagerTask.containerSettings] The settings for the
   * container under which the Job Manager Task runs. If the Pool that will run
   * this Task has containerConfiguration set, this must be set as well. If the
   * Pool that will run this Task doesn't have containerConfiguration set, this
   * must not be set. When this is specified, all directories recursively below
   * the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories on the node)
   * are mapped into the container, all Task environment variables are mapped
   * into the container, and the Task command line is executed in the container.
   * Files produced in the container outside of AZ_BATCH_NODE_ROOT_DIR might not
   * be reflected to the host disk, meaning that Batch file APIs will not be able
   * to access those files.
   *
   * @param {array} [job.jobManagerTask.resourceFiles] A list of files that the
   * Batch service will download to the Compute Node before running the command
   * line. Files listed under this element are located in the Task's working
   * directory. There is a maximum size for the list of resource files.  When the
   * max size is exceeded, the request will fail and the response error code will
   * be RequestEntityTooLarge. If this occurs, the collection of ResourceFiles
   * must be reduced in size. This can be achieved using .zip files, Application
   * Packages, or Docker Containers.
   *
   * @param {array} [job.jobManagerTask.outputFiles] A list of files that the
   * Batch service will upload from the Compute Node after running the command
   * line. For multi-instance Tasks, the files will only be uploaded from the
   * Compute Node on which the primary Task is executed.
   *
   * @param {array} [job.jobManagerTask.environmentSettings] A list of
   * environment variable settings for the Job Manager Task.
   *
   * @param {object} [job.jobManagerTask.constraints] Constraints that apply to
   * the Job Manager Task.
   *
   * @param {number} [job.jobManagerTask.requiredSlots] The number of scheduling
   * slots that the Task requires to run. The default is 1. A Task can only be
   * scheduled to run on a compute node if the node has enough free scheduling
   * slots available. For multi-instance Tasks, this must be 1.
   *
   * @param {boolean} [job.jobManagerTask.killJobOnCompletion] Whether completion
   * of the Job Manager Task signifies completion of the entire Job. If true,
   * when the Job Manager Task completes, the Batch service marks the Job as
   * complete. If any Tasks are still running at this time (other than Job
   * Release), those Tasks are terminated. If false, the completion of the Job
   * Manager Task does not affect the Job status. In this case, you should either
   * use the onAllTasksComplete attribute to terminate the Job, or have a client
   * or user terminate the Job explicitly. An example of this is if the Job
   * Manager creates a set of Tasks but then takes no further role in their
   * execution. The default value is true. If you are using the
   * onAllTasksComplete and onTaskFailure attributes to control Job lifetime, and
   * using the Job Manager Task only to create the Tasks for the Job (not to
   * monitor progress), then it is important to set killJobOnCompletion to false.
   *
   * @param {object} [job.jobManagerTask.userIdentity] The user identity under
   * which the Job Manager Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {boolean} [job.jobManagerTask.runExclusive] Whether the Job Manager
   * Task requires exclusive use of the Compute Node where it runs. If true, no
   * other Tasks will run on the same Node for as long as the Job Manager is
   * running. If false, other Tasks can run simultaneously with the Job Manager
   * on a Compute Node. The Job Manager Task counts normally against the Compute
   * Node's concurrent Task limit, so this is only relevant if the Compute Node
   * allows multiple concurrent Tasks. The default value is true.
   *
   * @param {array} [job.jobManagerTask.applicationPackageReferences] A list of
   * Application Packages that the Batch service will deploy to the Compute Node
   * before running the command line. Application Packages are downloaded and
   * deployed to a shared directory, not the Task working directory. Therefore,
   * if a referenced Application Package is already on the Compute Node, and is
   * up to date, then it is not re-downloaded; the existing copy on the Compute
   * Node is used. If a referenced Application Package cannot be installed, for
   * example because the package has been deleted or because download failed, the
   * Task fails.
   *
   * @param {object} [job.jobManagerTask.authenticationTokenSettings] The
   * settings for an authentication token that the Task can use to perform Batch
   * service operations. If this property is set, the Batch service provides the
   * Task with an authentication token which can be used to authenticate Batch
   * service operations without requiring an Account access key. The token is
   * provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment variable. The
   * operations that the Task can carry out using the token depend on the
   * settings. For example, a Task can request Job permissions in order to add
   * other Tasks to the Job, or check the status of the Job or of other Tasks
   * under the Job.
   *
   * @param {array} [job.jobManagerTask.authenticationTokenSettings.access] The
   * Batch resources to which the token grants access. The authentication token
   * grants access to a limited set of Batch service operations. Currently the
   * only supported value for the access property is 'job', which grants access
   * to all operations related to the Job which contains the Task.
   *
   * @param {boolean} [job.jobManagerTask.allowLowPriorityNode] Whether the Job
   * Manager Task may run on a low-priority Compute Node. The default value is
   * true.
   *
   * @param {object} [job.jobPreparationTask] The Job Preparation Task. If a Job
   * has a Job Preparation Task, the Batch service will run the Job Preparation
   * Task on a Node before starting any Tasks of that Job on that Compute Node.
   *
   * @param {string} [job.jobPreparationTask.id] A string that uniquely
   * identifies the Job Preparation Task within the Job. The ID can contain any
   * combination of alphanumeric characters including hyphens and underscores and
   * cannot contain more than 64 characters. If you do not specify this property,
   * the Batch service assigns a default value of 'jobpreparation'. No other Task
   * in the Job can have the same ID as the Job Preparation Task. If you try to
   * submit a Task with the same id, the Batch service rejects the request with
   * error code TaskIdSameAsJobPreparationTask; if you are calling the REST API
   * directly, the HTTP status code is 409 (Conflict).
   *
   * @param {string} job.jobPreparationTask.commandLine The command line of the
   * Job Preparation Task. The command line does not run under a shell, and
   * therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
   * line refers to file paths, it should use a relative path (relative to the
   * Task working directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobPreparationTask.containerSettings] The settings for
   * the container under which the Job Preparation Task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {array} [job.jobPreparationTask.resourceFiles] A list of files that
   * the Batch service will download to the Compute Node before running the
   * command line. Files listed under this element are located in the Task's
   * working directory.  There is a maximum size for the list of resource files.
   * When the max size is exceeded, the request will fail and the response error
   * code will be RequestEntityTooLarge. If this occurs, the collection of
   * ResourceFiles must be reduced in size. This can be achieved using .zip
   * files, Application Packages, or Docker Containers.
   *
   * @param {array} [job.jobPreparationTask.environmentSettings] A list of
   * environment variable settings for the Job Preparation Task.
   *
   * @param {object} [job.jobPreparationTask.constraints] Constraints that apply
   * to the Job Preparation Task.
   *
   * @param {moment.duration}
   * [job.jobPreparationTask.constraints.maxWallClockTime] The maximum elapsed
   * time that the Task may run, measured from the time the Task starts. If the
   * Task does not complete within the time limit, the Batch service terminates
   * it. If this is not specified, there is no time limit on how long the Task
   * may run.
   *
   * @param {moment.duration} [job.jobPreparationTask.constraints.retentionTime]
   * The minimum time to retain the Task directory on the Compute Node where it
   * ran, from the time it completes execution. After this time, the Batch
   * service may delete the Task directory and all its contents. The default is 7
   * days, i.e. the Task directory will be retained for 7 days unless the Compute
   * Node is removed or the Job is deleted.
   *
   * @param {number} [job.jobPreparationTask.constraints.maxTaskRetryCount] The
   * maximum number of times the Task may be retried. The Batch service retries a
   * Task if its exit code is nonzero. Note that this value specifically controls
   * the number of retries for the Task executable due to a nonzero exit code.
   * The Batch service will try the Task once, and may then retry up to this
   * limit. For example, if the maximum retry count is 3, Batch tries the Task up
   * to 4 times (one initial try and 3 retries). If the maximum retry count is 0,
   * the Batch service does not retry the Task after the first attempt. If the
   * maximum retry count is -1, the Batch service retries the Task without limit.
   *
   * @param {boolean} [job.jobPreparationTask.waitForSuccess] Whether the Batch
   * service should wait for the Job Preparation Task to complete successfully
   * before scheduling any other Tasks of the Job on the Compute Node. A Job
   * Preparation Task has completed successfully if it exits with exit code 0. If
   * true and the Job Preparation Task fails on a Node, the Batch service retries
   * the Job Preparation Task up to its maximum retry count (as specified in the
   * constraints element). If the Task has still not completed successfully after
   * all retries, then the Batch service will not schedule Tasks of the Job to
   * the Node. The Node remains active and eligible to run Tasks of other Jobs.
   * If false, the Batch service will not wait for the Job Preparation Task to
   * complete. In this case, other Tasks of the Job can start executing on the
   * Compute Node while the Job Preparation Task is still running; and even if
   * the Job Preparation Task fails, new Tasks will continue to be scheduled on
   * the Compute Node. The default value is true.
   *
   * @param {object} [job.jobPreparationTask.userIdentity] The user identity
   * under which the Job Preparation Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task on Windows Compute Nodes, or a
   * non-administrative user unique to the Pool on Linux Compute Nodes.
   *
   * @param {boolean} [job.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
   * Whether the Batch service should rerun the Job Preparation Task after a
   * Compute Node reboots. The Job Preparation Task is always rerun if a Compute
   * Node is reimaged, or if the Job Preparation Task did not complete (e.g.
   * because the reboot occurred while the Task was running). Therefore, you
   * should always write a Job Preparation Task to be idempotent and to behave
   * correctly if run multiple times. The default value is true.
   *
   * @param {object} [job.jobReleaseTask] The Job Release Task. A Job Release
   * Task cannot be specified without also specifying a Job Preparation Task for
   * the Job. The Batch service runs the Job Release Task on the Nodes that have
   * run the Job Preparation Task. The primary purpose of the Job Release Task is
   * to undo changes to Compute Nodes made by the Job Preparation Task. Example
   * activities include deleting local files, or shutting down services that were
   * started as part of Job preparation.
   *
   * @param {string} [job.jobReleaseTask.id] A string that uniquely identifies
   * the Job Release Task within the Job. The ID can contain any combination of
   * alphanumeric characters including hyphens and underscores and cannot contain
   * more than 64 characters. If you do not specify this property, the Batch
   * service assigns a default value of 'jobrelease'. No other Task in the Job
   * can have the same ID as the Job Release Task. If you try to submit a Task
   * with the same id, the Batch service rejects the request with error code
   * TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the
   * HTTP status code is 409 (Conflict).
   *
   * @param {string} job.jobReleaseTask.commandLine The command line of the Job
   * Release Task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
   * file paths, it should use a relative path (relative to the Task working
   * directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobReleaseTask.containerSettings] The settings for the
   * container under which the Job Release Task runs. When this is specified, all
   * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
   * Batch directories on the node) are mapped into the container, all Task
   * environment variables are mapped into the container, and the Task command
   * line is executed in the container. Files produced in the container outside
   * of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk, meaning
   * that Batch file APIs will not be able to access those files.
   *
   * @param {array} [job.jobReleaseTask.resourceFiles] A list of files that the
   * Batch service will download to the Compute Node before running the command
   * line.  There is a maximum size for the list of resource files.  When the max
   * size is exceeded, the request will fail and the response error code will be
   * RequestEntityTooLarge. If this occurs, the collection of ResourceFiles must
   * be reduced in size. This can be achieved using .zip files, Application
   * Packages, or Docker Containers. Files listed under this element are located
   * in the Task's working directory.
   *
   * @param {array} [job.jobReleaseTask.environmentSettings] A list of
   * environment variable settings for the Job Release Task.
   *
   * @param {moment.duration} [job.jobReleaseTask.maxWallClockTime] The maximum
   * elapsed time that the Job Release Task may run on a given Compute Node,
   * measured from the time the Task starts. If the Task does not complete within
   * the time limit, the Batch service terminates it. The default value is 15
   * minutes. You may not specify a timeout longer than 15 minutes. If you do,
   * the Batch service rejects it with an error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {moment.duration} [job.jobReleaseTask.retentionTime] The minimum time
   * to retain the Task directory for the Job Release Task on the Compute Node.
   * After this time, the Batch service may delete the Task directory and all its
   * contents. The default is 7 days, i.e. the Task directory will be retained
   * for 7 days unless the Compute Node is removed or the Job is deleted.
   *
   * @param {object} [job.jobReleaseTask.userIdentity] The user identity under
   * which the Job Release Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {array} [job.commonEnvironmentSettings] The list of common
   * environment variable settings. These environment variables are set for all
   * Tasks in the Job (including the Job Manager, Job Preparation and Job Release
   * Tasks). Individual Tasks can override an environment setting specified here
   * by specifying the same setting name with a different value.
   *
   * @param {object} job.poolInfo The Pool on which the Batch service runs the
   * Job's Tasks.
   *
   * @param {string} [job.poolInfo.poolId] The ID of an existing Pool. All the
   * Tasks of the Job will run on the specified Pool. You must ensure that the
   * Pool referenced by this property exists. If the Pool does not exist at the
   * time the Batch service tries to schedule a Job, no Tasks for the Job will
   * run until you create a Pool with that id. Note that the Batch service will
   * not reject the Job request; it will simply not run Tasks until the Pool
   * exists. You must specify either the Pool ID or the auto Pool specification,
   * but not both.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification] Characteristics for a
   * temporary 'auto pool'. The Batch service will create this auto Pool when the
   * Job is submitted. If auto Pool creation fails, the Batch service moves the
   * Job to a completed state, and the Pool creation error is set in the Job's
   * scheduling error property. The Batch service manages the lifetime (both
   * creation and, unless keepAlive is specified, deletion) of the auto Pool. Any
   * user actions that affect the lifetime of the auto Pool while the Job is
   * active will result in unexpected behavior. You must specify either the Pool
   * ID or the auto Pool specification, but not both.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
   * prefix to be added to the unique identifier when a Pool is automatically
   * created. The Batch service assigns each auto Pool a unique identifier on
   * creation. To distinguish between Pools created for different purposes, you
   * can specify this element to add a prefix to the ID that is assigned. The
   * prefix can be up to 20 characters long.
   *
   * @param {string} job.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean} [job.poolInfo.autoPoolSpecification.keepAlive] Whether to
   * keep an auto Pool alive after its lifetime expires. If false, the Batch
   * service deletes the Pool once its lifetime (as determined by the
   * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
   * completes. If true, the Batch service does not delete the Pool
   * automatically. It is up to the user to delete auto Pools created with this
   * option.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification.pool] The Pool
   * specification for the auto Pool.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string} job.poolInfo.autoPoolSpecification.pool.vmSize The size of
   * the virtual machines in the Pool. All virtual machines in a Pool are the
   * same size. For information about available sizes of virtual machines in
   * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration] The
   * cloud service configuration for the Pool. This property must be specified if
   * the Pool needs to be created with Azure PaaS VMs. This property and
   * virtualMachineConfiguration are mutually exclusive and one of the properties
   * must be specified. If neither is specified then the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request). This property cannot be specified if the Batch Account was
   * created with its poolAllocationMode property set to 'UserSubscription'.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration] The
   * virtual machine configuration for the Pool. This property must be specified
   * if the Pool needs to be created with Azure IaaS VMs. This property and
   * cloudServiceConfiguration are mutually exclusive and one of the properties
   * must be specified. If neither is specified then the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request).
   *
   * @param {object}
   * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number} [job.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
   * The number of task slots that can be used to run concurrent tasks on a
   * single compute node in the pool. The default value is 1. The maximum value
   * is the smaller of 4 times the number of cores of the vmSize of the pool or
   * 256.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy] How Tasks are
   * distributed across Compute Nodes in a Pool. If not specified, the default is
   * spread.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [job.poolInfo.autoPoolSpecification.pool.resizeTimeout] The timeout for
   * allocation of Compute Nodes to the Pool. This timeout applies only to manual
   * scaling; it has no effect when enableAutoScale is set to true. The default
   * value is 15 minutes. The minimum value is 5 minutes. If you specify a value
   * less than 5 minutes, the Batch service rejects the request with an error; if
   * you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request).
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes] The desired
   * number of dedicated Compute Nodes in the Pool. This property must not be
   * specified if enableAutoScale is set to true. If enableAutoScale is set to
   * false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes] The desired
   * number of low-priority Compute Nodes in the Pool. This property must not be
   * specified if enableAutoScale is set to true. If enableAutoScale is set to
   * false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean} [job.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
   * The formula for the desired number of Compute Nodes in the Pool. This
   * property must not be specified if enableAutoScale is set to false. It is
   * required if enableAutoScale is set to true. The formula is checked for
   * validity before the Pool is created. If the formula is not valid, the Batch
   * service rejects the request with detailed error information.
   *
   * @param {moment.duration}
   * [job.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval] The
   * time interval at which to automatically adjust the Pool size according to
   * the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration] The network
   * configuration for the Pool.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId] The
   * ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification.pool.startTask] A Task
   * to run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.commandLine The command
   * line of the StartTask. The command line does not run under a shell, and
   * therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
   * line refers to file paths, it should use a relative path (relative to the
   * Task working directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings] The
   * settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles] A list of
   * files that the Batch service will download to the Compute Node before
   * running the command line.  There is a maximum size for the list of resource
   * files. When the max size is exceeded, the request will fail and the response
   * error code will be RequestEntityTooLarge. If this occurs, the collection of
   * ResourceFiles must be reduced in size. This can be achieved using .zip
   * files, Application Packages, or Docker Containers. Files listed under this
   * element are located in the Task's working directory.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings] A
   * list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity] The user
   * identity under which the StartTask runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount] The
   * maximum number of times the Task may be retried. The Batch service retries a
   * Task if its exit code is nonzero. Note that this value specifically controls
   * the number of retries. The Batch service will try the Task once, and may
   * then retry up to this limit. For example, if the maximum retry count is 3,
   * Batch tries the Task up to 4 times (one initial try and 3 retries). If the
   * maximum retry count is 0, the Batch service does not retry the Task. If the
   * maximum retry count is -1, the Batch service retries the Task without limit.
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess] Whether
   * the Batch service should wait for the StartTask to complete successfully
   * (that is, to exit with exit code 0) before scheduling any Tasks on the
   * Compute Node. If true and the StartTask fails on a Node, the Batch service
   * retries the StartTask up to its maximum retry count (maxTaskRetryCount). If
   * the Task has still not completed successfully after all retries, then the
   * Batch service marks the Node unusable, and will not schedule Tasks to it.
   * This condition can be detected via the Compute Node state and failure info
   * details. If false, the Batch service will not wait for the StartTask to
   * complete. In this case, other Tasks can start executing on the Compute Node
   * while the StartTask is still running; and even if the StartTask fails, new
   * Tasks will continue to be scheduled on the Compute Node. The default is
   * true.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.certificateReferences] A list of
   * Certificates to be installed on each Compute Node in the Pool. For Windows
   * Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.applicationPackageReferences] The
   * list of Packages to be installed on each Compute Node in the Pool. Changes
   * to Package references affect all new Nodes joining the Pool, but do not
   * affect Compute Nodes that are already in the Pool until they are rebooted or
   * reimaged. There is a maximum of 10 Package references on any given Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.mountConfiguration]
   * A list of file systems to mount on each node in the pool. This supports
   * Azure Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {string} [job.onAllTasksComplete] The action the Batch service should
   * take when all Tasks in the Job are in the completed state. Note that if a
   * Job contains no Tasks, then all Tasks are considered complete. This option
   * is therefore most commonly used with a Job Manager task; if you want to use
   * automatic Job termination without a Job Manager, you should initially set
   * onAllTasksComplete to noaction and update the Job properties to set
   * onAllTasksComplete to terminatejob once you have finished adding Tasks. The
   * default is noaction. Possible values include: 'noAction', 'terminateJob'
   *
   * @param {string} [job.onTaskFailure] The action the Batch service should take
   * when any Task in the Job fails. A Task is considered to have failed if has a
   * failureInfo. A failureInfo is set if the Task completes with a non-zero exit
   * code after exhausting its retry count, or if there was an error starting the
   * Task, for example due to a resource file download error. The default is
   * noaction. Possible values include: 'noAction', 'performExitOptionsJobAction'
   *
   * @param {array} [job.metadata] A list of name-value pairs associated with the
   * Job as metadata. The Batch service does not assign any meaning to metadata;
   * it is solely for the use of user code.
   *
   * @param {boolean} [job.usesTaskDependencies] Whether Tasks in the Job can
   * define dependencies on each other. The default is false.
   *
   * @param {object} [job.networkConfiguration] The network configuration for the
   * Job.
   *
   * @param {string} job.networkConfiguration.subnetId The ARM resource
   * identifier of the virtual network subnet which Compute Nodes running Tasks
   * from the Job will join for the duration of the Task. This will only work
   * with a VirtualMachineConfiguration Pool. The virtual network must be in the
   * same region and subscription as the Azure Batch Account. The specified
   * subnet should have enough free IP addresses to accommodate the number of
   * Compute Nodes which will run Tasks from the Job. This can be up to the
   * number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service
   * principal must have the 'Classic Virtual Machine Contributor' Role-Based
   * Access Control (RBAC) role for the specified VNet so that Azure Batch
   * service can schedule Tasks on the Nodes. This can be verified by checking if
   * the specified VNet has any associated Network Security Groups (NSG). If
   * communication to the Nodes in the specified subnet is denied by an NSG, then
   * the Batch service will set the state of the Compute Nodes to unusable. This
   * is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * If the specified VNet has any associated Network Security Groups (NSG), then
   * a few reserved system ports must be enabled for inbound communication from
   * the Azure Batch service. For Pools created with a Virtual Machine
   * configuration, enable ports 29876 and 29877, as well as port 22 for Linux
   * and port 3389 for Windows. Port 443 is also required to be open for outbound
   * connections for communications to Azure Storage. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobAddOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobAddOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobAddOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobAddOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobAddOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addWithHttpOperationResponse(job, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._add(job, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Job to the specified Account.
   *
   * The Batch service supports two ways to control the work done as part of a
   * Job. In the first approach, the user specifies a Job Manager Task. The Batch
   * service launches this Task when it is ready to start the Job. The Job
   * Manager Task controls all other Tasks that run under this Job, by using the
   * Task APIs. In the second approach, the user directly controls the execution
   * of Tasks under an active Job, by using the Task APIs. Also note: when naming
   * Jobs, avoid including sensitive information such as user names or secret
   * project names. This information may appear in telemetry logs accessible to
   * Microsoft Support engineers.
   *
   * @param {object} job The Job to be added.
   *
   * @param {string} job.id A string that uniquely identifies the Job within the
   * Account. The ID can contain any combination of alphanumeric characters
   * including hyphens and underscores, and cannot contain more than 64
   * characters. The ID is case-preserving and case-insensitive (that is, you may
   * not have two IDs within an Account that differ only by case).
   *
   * @param {string} [job.displayName] The display name for the Job. The display
   * name need not be unique and can contain any Unicode characters up to a
   * maximum length of 1024.
   *
   * @param {number} [job.priority] The priority of the Job. Priority values can
   * range from -1000 to 1000, with -1000 being the lowest priority and 1000
   * being the highest priority. The default value is 0.
   *
   * @param {object} [job.constraints] The execution constraints for the Job.
   *
   * @param {moment.duration} [job.constraints.maxWallClockTime] The maximum
   * elapsed time that the Job may run, measured from the time the Job is
   * created. If the Job does not complete within the time limit, the Batch
   * service terminates it and any Tasks that are still running. In this case,
   * the termination reason will be MaxWallClockTimeExpiry. If this property is
   * not specified, there is no time limit on how long the Job may run.
   *
   * @param {number} [job.constraints.maxTaskRetryCount] The maximum number of
   * times each Task may be retried. The Batch service retries a Task if its exit
   * code is nonzero. Note that this value specifically controls the number of
   * retries. The Batch service will try each Task once, and may then retry up to
   * this limit. For example, if the maximum retry count is 3, Batch tries a Task
   * up to 4 times (one initial try and 3 retries). If the maximum retry count is
   * 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
   * the Batch service retries Tasks without limit. The default value is 0 (no
   * retries).
   *
   * @param {object} [job.jobManagerTask] Details of a Job Manager Task to be
   * launched when the Job is started. If the Job does not specify a Job Manager
   * Task, the user must explicitly add Tasks to the Job. If the Job does specify
   * a Job Manager Task, the Batch service creates the Job Manager Task when the
   * Job is created, and will try to schedule the Job Manager Task before
   * scheduling other Tasks in the Job. The Job Manager Task's typical purpose is
   * to control and/or monitor Job execution, for example by deciding what
   * additional Tasks to run, determining when the work is complete, etc.
   * (However, a Job Manager Task is not restricted to these activities - it is a
   * fully-fledged Task in the system and perform whatever actions are required
   * for the Job.) For example, a Job Manager Task might download a file
   * specified as a parameter, analyze the contents of that file and submit
   * additional Tasks based on those contents.
   *
   * @param {string} job.jobManagerTask.id A string that uniquely identifies the
   * Job Manager Task within the Job. The ID can contain any combination of
   * alphanumeric characters including hyphens and underscores and cannot contain
   * more than 64 characters.
   *
   * @param {string} [job.jobManagerTask.displayName] The display name of the Job
   * Manager Task. It need not be unique and can contain any Unicode characters
   * up to a maximum length of 1024.
   *
   * @param {string} job.jobManagerTask.commandLine The command line of the Job
   * Manager Task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
   * file paths, it should use a relative path (relative to the Task working
   * directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobManagerTask.containerSettings] The settings for the
   * container under which the Job Manager Task runs. If the Pool that will run
   * this Task has containerConfiguration set, this must be set as well. If the
   * Pool that will run this Task doesn't have containerConfiguration set, this
   * must not be set. When this is specified, all directories recursively below
   * the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories on the node)
   * are mapped into the container, all Task environment variables are mapped
   * into the container, and the Task command line is executed in the container.
   * Files produced in the container outside of AZ_BATCH_NODE_ROOT_DIR might not
   * be reflected to the host disk, meaning that Batch file APIs will not be able
   * to access those files.
   *
   * @param {array} [job.jobManagerTask.resourceFiles] A list of files that the
   * Batch service will download to the Compute Node before running the command
   * line. Files listed under this element are located in the Task's working
   * directory. There is a maximum size for the list of resource files.  When the
   * max size is exceeded, the request will fail and the response error code will
   * be RequestEntityTooLarge. If this occurs, the collection of ResourceFiles
   * must be reduced in size. This can be achieved using .zip files, Application
   * Packages, or Docker Containers.
   *
   * @param {array} [job.jobManagerTask.outputFiles] A list of files that the
   * Batch service will upload from the Compute Node after running the command
   * line. For multi-instance Tasks, the files will only be uploaded from the
   * Compute Node on which the primary Task is executed.
   *
   * @param {array} [job.jobManagerTask.environmentSettings] A list of
   * environment variable settings for the Job Manager Task.
   *
   * @param {object} [job.jobManagerTask.constraints] Constraints that apply to
   * the Job Manager Task.
   *
   * @param {number} [job.jobManagerTask.requiredSlots] The number of scheduling
   * slots that the Task requires to run. The default is 1. A Task can only be
   * scheduled to run on a compute node if the node has enough free scheduling
   * slots available. For multi-instance Tasks, this must be 1.
   *
   * @param {boolean} [job.jobManagerTask.killJobOnCompletion] Whether completion
   * of the Job Manager Task signifies completion of the entire Job. If true,
   * when the Job Manager Task completes, the Batch service marks the Job as
   * complete. If any Tasks are still running at this time (other than Job
   * Release), those Tasks are terminated. If false, the completion of the Job
   * Manager Task does not affect the Job status. In this case, you should either
   * use the onAllTasksComplete attribute to terminate the Job, or have a client
   * or user terminate the Job explicitly. An example of this is if the Job
   * Manager creates a set of Tasks but then takes no further role in their
   * execution. The default value is true. If you are using the
   * onAllTasksComplete and onTaskFailure attributes to control Job lifetime, and
   * using the Job Manager Task only to create the Tasks for the Job (not to
   * monitor progress), then it is important to set killJobOnCompletion to false.
   *
   * @param {object} [job.jobManagerTask.userIdentity] The user identity under
   * which the Job Manager Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {boolean} [job.jobManagerTask.runExclusive] Whether the Job Manager
   * Task requires exclusive use of the Compute Node where it runs. If true, no
   * other Tasks will run on the same Node for as long as the Job Manager is
   * running. If false, other Tasks can run simultaneously with the Job Manager
   * on a Compute Node. The Job Manager Task counts normally against the Compute
   * Node's concurrent Task limit, so this is only relevant if the Compute Node
   * allows multiple concurrent Tasks. The default value is true.
   *
   * @param {array} [job.jobManagerTask.applicationPackageReferences] A list of
   * Application Packages that the Batch service will deploy to the Compute Node
   * before running the command line. Application Packages are downloaded and
   * deployed to a shared directory, not the Task working directory. Therefore,
   * if a referenced Application Package is already on the Compute Node, and is
   * up to date, then it is not re-downloaded; the existing copy on the Compute
   * Node is used. If a referenced Application Package cannot be installed, for
   * example because the package has been deleted or because download failed, the
   * Task fails.
   *
   * @param {object} [job.jobManagerTask.authenticationTokenSettings] The
   * settings for an authentication token that the Task can use to perform Batch
   * service operations. If this property is set, the Batch service provides the
   * Task with an authentication token which can be used to authenticate Batch
   * service operations without requiring an Account access key. The token is
   * provided via the AZ_BATCH_AUTHENTICATION_TOKEN environment variable. The
   * operations that the Task can carry out using the token depend on the
   * settings. For example, a Task can request Job permissions in order to add
   * other Tasks to the Job, or check the status of the Job or of other Tasks
   * under the Job.
   *
   * @param {array} [job.jobManagerTask.authenticationTokenSettings.access] The
   * Batch resources to which the token grants access. The authentication token
   * grants access to a limited set of Batch service operations. Currently the
   * only supported value for the access property is 'job', which grants access
   * to all operations related to the Job which contains the Task.
   *
   * @param {boolean} [job.jobManagerTask.allowLowPriorityNode] Whether the Job
   * Manager Task may run on a low-priority Compute Node. The default value is
   * true.
   *
   * @param {object} [job.jobPreparationTask] The Job Preparation Task. If a Job
   * has a Job Preparation Task, the Batch service will run the Job Preparation
   * Task on a Node before starting any Tasks of that Job on that Compute Node.
   *
   * @param {string} [job.jobPreparationTask.id] A string that uniquely
   * identifies the Job Preparation Task within the Job. The ID can contain any
   * combination of alphanumeric characters including hyphens and underscores and
   * cannot contain more than 64 characters. If you do not specify this property,
   * the Batch service assigns a default value of 'jobpreparation'. No other Task
   * in the Job can have the same ID as the Job Preparation Task. If you try to
   * submit a Task with the same id, the Batch service rejects the request with
   * error code TaskIdSameAsJobPreparationTask; if you are calling the REST API
   * directly, the HTTP status code is 409 (Conflict).
   *
   * @param {string} job.jobPreparationTask.commandLine The command line of the
   * Job Preparation Task. The command line does not run under a shell, and
   * therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
   * line refers to file paths, it should use a relative path (relative to the
   * Task working directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobPreparationTask.containerSettings] The settings for
   * the container under which the Job Preparation Task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {array} [job.jobPreparationTask.resourceFiles] A list of files that
   * the Batch service will download to the Compute Node before running the
   * command line. Files listed under this element are located in the Task's
   * working directory.  There is a maximum size for the list of resource files.
   * When the max size is exceeded, the request will fail and the response error
   * code will be RequestEntityTooLarge. If this occurs, the collection of
   * ResourceFiles must be reduced in size. This can be achieved using .zip
   * files, Application Packages, or Docker Containers.
   *
   * @param {array} [job.jobPreparationTask.environmentSettings] A list of
   * environment variable settings for the Job Preparation Task.
   *
   * @param {object} [job.jobPreparationTask.constraints] Constraints that apply
   * to the Job Preparation Task.
   *
   * @param {moment.duration}
   * [job.jobPreparationTask.constraints.maxWallClockTime] The maximum elapsed
   * time that the Task may run, measured from the time the Task starts. If the
   * Task does not complete within the time limit, the Batch service terminates
   * it. If this is not specified, there is no time limit on how long the Task
   * may run.
   *
   * @param {moment.duration} [job.jobPreparationTask.constraints.retentionTime]
   * The minimum time to retain the Task directory on the Compute Node where it
   * ran, from the time it completes execution. After this time, the Batch
   * service may delete the Task directory and all its contents. The default is 7
   * days, i.e. the Task directory will be retained for 7 days unless the Compute
   * Node is removed or the Job is deleted.
   *
   * @param {number} [job.jobPreparationTask.constraints.maxTaskRetryCount] The
   * maximum number of times the Task may be retried. The Batch service retries a
   * Task if its exit code is nonzero. Note that this value specifically controls
   * the number of retries for the Task executable due to a nonzero exit code.
   * The Batch service will try the Task once, and may then retry up to this
   * limit. For example, if the maximum retry count is 3, Batch tries the Task up
   * to 4 times (one initial try and 3 retries). If the maximum retry count is 0,
   * the Batch service does not retry the Task after the first attempt. If the
   * maximum retry count is -1, the Batch service retries the Task without limit.
   *
   * @param {boolean} [job.jobPreparationTask.waitForSuccess] Whether the Batch
   * service should wait for the Job Preparation Task to complete successfully
   * before scheduling any other Tasks of the Job on the Compute Node. A Job
   * Preparation Task has completed successfully if it exits with exit code 0. If
   * true and the Job Preparation Task fails on a Node, the Batch service retries
   * the Job Preparation Task up to its maximum retry count (as specified in the
   * constraints element). If the Task has still not completed successfully after
   * all retries, then the Batch service will not schedule Tasks of the Job to
   * the Node. The Node remains active and eligible to run Tasks of other Jobs.
   * If false, the Batch service will not wait for the Job Preparation Task to
   * complete. In this case, other Tasks of the Job can start executing on the
   * Compute Node while the Job Preparation Task is still running; and even if
   * the Job Preparation Task fails, new Tasks will continue to be scheduled on
   * the Compute Node. The default value is true.
   *
   * @param {object} [job.jobPreparationTask.userIdentity] The user identity
   * under which the Job Preparation Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task on Windows Compute Nodes, or a
   * non-administrative user unique to the Pool on Linux Compute Nodes.
   *
   * @param {boolean} [job.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
   * Whether the Batch service should rerun the Job Preparation Task after a
   * Compute Node reboots. The Job Preparation Task is always rerun if a Compute
   * Node is reimaged, or if the Job Preparation Task did not complete (e.g.
   * because the reboot occurred while the Task was running). Therefore, you
   * should always write a Job Preparation Task to be idempotent and to behave
   * correctly if run multiple times. The default value is true.
   *
   * @param {object} [job.jobReleaseTask] The Job Release Task. A Job Release
   * Task cannot be specified without also specifying a Job Preparation Task for
   * the Job. The Batch service runs the Job Release Task on the Nodes that have
   * run the Job Preparation Task. The primary purpose of the Job Release Task is
   * to undo changes to Compute Nodes made by the Job Preparation Task. Example
   * activities include deleting local files, or shutting down services that were
   * started as part of Job preparation.
   *
   * @param {string} [job.jobReleaseTask.id] A string that uniquely identifies
   * the Job Release Task within the Job. The ID can contain any combination of
   * alphanumeric characters including hyphens and underscores and cannot contain
   * more than 64 characters. If you do not specify this property, the Batch
   * service assigns a default value of 'jobrelease'. No other Task in the Job
   * can have the same ID as the Job Release Task. If you try to submit a Task
   * with the same id, the Batch service rejects the request with error code
   * TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the
   * HTTP status code is 409 (Conflict).
   *
   * @param {string} job.jobReleaseTask.commandLine The command line of the Job
   * Release Task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux. If the command line refers to
   * file paths, it should use a relative path (relative to the Task working
   * directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object} [job.jobReleaseTask.containerSettings] The settings for the
   * container under which the Job Release Task runs. When this is specified, all
   * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
   * Batch directories on the node) are mapped into the container, all Task
   * environment variables are mapped into the container, and the Task command
   * line is executed in the container. Files produced in the container outside
   * of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk, meaning
   * that Batch file APIs will not be able to access those files.
   *
   * @param {array} [job.jobReleaseTask.resourceFiles] A list of files that the
   * Batch service will download to the Compute Node before running the command
   * line.  There is a maximum size for the list of resource files.  When the max
   * size is exceeded, the request will fail and the response error code will be
   * RequestEntityTooLarge. If this occurs, the collection of ResourceFiles must
   * be reduced in size. This can be achieved using .zip files, Application
   * Packages, or Docker Containers. Files listed under this element are located
   * in the Task's working directory.
   *
   * @param {array} [job.jobReleaseTask.environmentSettings] A list of
   * environment variable settings for the Job Release Task.
   *
   * @param {moment.duration} [job.jobReleaseTask.maxWallClockTime] The maximum
   * elapsed time that the Job Release Task may run on a given Compute Node,
   * measured from the time the Task starts. If the Task does not complete within
   * the time limit, the Batch service terminates it. The default value is 15
   * minutes. You may not specify a timeout longer than 15 minutes. If you do,
   * the Batch service rejects it with an error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {moment.duration} [job.jobReleaseTask.retentionTime] The minimum time
   * to retain the Task directory for the Job Release Task on the Compute Node.
   * After this time, the Batch service may delete the Task directory and all its
   * contents. The default is 7 days, i.e. the Task directory will be retained
   * for 7 days unless the Compute Node is removed or the Job is deleted.
   *
   * @param {object} [job.jobReleaseTask.userIdentity] The user identity under
   * which the Job Release Task runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {array} [job.commonEnvironmentSettings] The list of common
   * environment variable settings. These environment variables are set for all
   * Tasks in the Job (including the Job Manager, Job Preparation and Job Release
   * Tasks). Individual Tasks can override an environment setting specified here
   * by specifying the same setting name with a different value.
   *
   * @param {object} job.poolInfo The Pool on which the Batch service runs the
   * Job's Tasks.
   *
   * @param {string} [job.poolInfo.poolId] The ID of an existing Pool. All the
   * Tasks of the Job will run on the specified Pool. You must ensure that the
   * Pool referenced by this property exists. If the Pool does not exist at the
   * time the Batch service tries to schedule a Job, no Tasks for the Job will
   * run until you create a Pool with that id. Note that the Batch service will
   * not reject the Job request; it will simply not run Tasks until the Pool
   * exists. You must specify either the Pool ID or the auto Pool specification,
   * but not both.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification] Characteristics for a
   * temporary 'auto pool'. The Batch service will create this auto Pool when the
   * Job is submitted. If auto Pool creation fails, the Batch service moves the
   * Job to a completed state, and the Pool creation error is set in the Job's
   * scheduling error property. The Batch service manages the lifetime (both
   * creation and, unless keepAlive is specified, deletion) of the auto Pool. Any
   * user actions that affect the lifetime of the auto Pool while the Job is
   * active will result in unexpected behavior. You must specify either the Pool
   * ID or the auto Pool specification, but not both.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.autoPoolIdPrefix] A
   * prefix to be added to the unique identifier when a Pool is automatically
   * created. The Batch service assigns each auto Pool a unique identifier on
   * creation. To distinguish between Pools created for different purposes, you
   * can specify this element to add a prefix to the ID that is assigned. The
   * prefix can be up to 20 characters long.
   *
   * @param {string} job.poolInfo.autoPoolSpecification.poolLifetimeOption The
   * minimum lifetime of created auto Pools, and how multiple Jobs on a schedule
   * are assigned to Pools. Possible values include: 'jobSchedule', 'job'
   *
   * @param {boolean} [job.poolInfo.autoPoolSpecification.keepAlive] Whether to
   * keep an auto Pool alive after its lifetime expires. If false, the Batch
   * service deletes the Pool once its lifetime (as determined by the
   * poolLifetimeOption setting) expires; that is, when the Job or Job Schedule
   * completes. If true, the Batch service does not delete the Pool
   * automatically. It is up to the user to delete auto Pools created with this
   * option.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification.pool] The Pool
   * specification for the auto Pool.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.pool.displayName] The
   * display name for the Pool. The display name need not be unique and can
   * contain any Unicode characters up to a maximum length of 1024.
   *
   * @param {string} job.poolInfo.autoPoolSpecification.pool.vmSize The size of
   * the virtual machines in the Pool. All virtual machines in a Pool are the
   * same size. For information about available sizes of virtual machines in
   * Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
   * (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration] The
   * cloud service configuration for the Pool. This property must be specified if
   * the Pool needs to be created with Azure PaaS VMs. This property and
   * virtualMachineConfiguration are mutually exclusive and one of the properties
   * must be specified. If neither is specified then the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request). This property cannot be specified if the Batch Account was
   * created with its poolAllocationMode property set to 'UserSubscription'.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osFamily
   * The Azure Guest OS family to be installed on the virtual machines in the
   * Pool. Possible values are:
   * 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1.
   * 3 - OS Family 3, equivalent to Windows Server 2012.
   * 4 - OS Family 4, equivalent to Windows Server 2012 R2.
   * 5 - OS Family 5, equivalent to Windows Server 2016.
   * 6 - OS Family 6, equivalent to Windows Server 2019. For more information,
   * see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.cloudServiceConfiguration.osVersion]
   * The Azure Guest OS version to be installed on the virtual machines in the
   * Pool. The default value is * which specifies the latest operating system
   * version for the specified OS family.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration] The
   * virtual machine configuration for the Pool. This property must be specified
   * if the Pool needs to be created with Azure IaaS VMs. This property and
   * cloudServiceConfiguration are mutually exclusive and one of the properties
   * must be specified. If neither is specified then the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request).
   *
   * @param {object}
   * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference
   * A reference to the Azure Virtual Machines Marketplace Image or the custom
   * Virtual Machine Image to use.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace Image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.offer]
   * The offer type of the Azure Virtual Machines Marketplace Image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.sku]
   * The SKU of the Azure Virtual Machines Marketplace Image. For example,
   * 18.04-LTS or 2019-Datacenter.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace Image. A value of
   * 'latest' can be specified to select the latest version of an Image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.imageReference.virtualMachineImageId]
   * The ARM resource identifier of the Shared Image Gallery Image. Compute Nodes
   * in the Pool will be created using this Image Id. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
   * or
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
   * for always defaulting to the latest image version. This property is mutually
   * exclusive with other ImageReference properties. The Shared Image Gallery
   * Image must have replicas in the same region and must be in the same
   * subscription as the Azure Batch account. If the image version is not
   * specified in the imageId, the latest version will be used. For information
   * about the firewall settings for the Batch Compute Node agent to communicate
   * with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.nodeAgentSKUId
   * The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes
   * in the Pool. The Batch Compute Node agent is a program that runs on each
   * Compute Node in the Pool, and provides the command-and-control interface
   * between the Compute Node and the Batch service. There are different
   * implementations of the Compute Node agent, known as SKUs, for different
   * operating systems. You must specify a Compute Node agent SKU which matches
   * the selected Image reference. To get the list of supported Compute Node
   * agent SKUs along with their list of verified Image references, see the 'List
   * supported Compute Node agent SKUs' operation.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference property specifies a Linux OS Image.
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.dataDisks]
   * The configuration for data disks attached to the Compute Nodes in the Pool.
   * This property must be specified if the Compute Nodes in the Pool need to
   * have empty data disks attached to them. This cannot be updated. Each Compute
   * Node gets its own disk (the disk is not a file share). Existing disks cannot
   * be attached, each attached disk is empty. When the Compute Node is removed
   * from the Pool, the disk and all data associated with it is also deleted. The
   * disk is not formatted after being attached, it must be formatted before use
   * - for more information see
   * https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
   * and
   * https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.licenseType]
   * The type of on-premises license to be used when deploying the operating
   * system. This only applies to Images that contain the Windows operating
   * system, and should only be used when you hold valid on-premises licenses for
   * the Compute Nodes which will be deployed. If omitted, no on-premises
   * licensing discount is applied. Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the Pool. If specified, setup is performed
   * on each Compute Node in the Pool to allow Tasks to run in containers. All
   * regular Tasks and Job manager Tasks run on this Pool must specify the
   * containerSettings property, and all other Tasks may specify it.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container Image names. This is the full Image reference,
   * as would be specified to "docker pull". An Image will be sourced from the
   * default Docker registry unless the Image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * Images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration]
   * The disk encryption configuration for the pool. If specified, encryption is
   * performed on each node in the pool during node provisioning.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.virtualMachineConfiguration.diskEncryptionConfiguration.targets]
   * The list of disk targets Batch Service will encrypt on the compute node. If
   * omitted, no disks on the compute nodes in the pool will be encrypted. On
   * Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
   * "TemporaryDisk" must be specified.
   *
   * @param {number} [job.poolInfo.autoPoolSpecification.pool.taskSlotsPerNode]
   * The number of task slots that can be used to run concurrent tasks on a
   * single compute node in the pool. The default value is 1. The maximum value
   * is the smaller of 4 times the number of cores of the vmSize of the pool or
   * 256.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy] How Tasks are
   * distributed across Compute Nodes in a Pool. If not specified, the default is
   * spread.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType
   * How Tasks are distributed across Compute Nodes in a Pool. If not specified,
   * the default is spread. Possible values include: 'spread', 'pack'
   *
   * @param {moment.duration}
   * [job.poolInfo.autoPoolSpecification.pool.resizeTimeout] The timeout for
   * allocation of Compute Nodes to the Pool. This timeout applies only to manual
   * scaling; it has no effect when enableAutoScale is set to true. The default
   * value is 15 minutes. The minimum value is 5 minutes. If you specify a value
   * less than 5 minutes, the Batch service rejects the request with an error; if
   * you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request).
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.targetDedicatedNodes] The desired
   * number of dedicated Compute Nodes in the Pool. This property must not be
   * specified if enableAutoScale is set to true. If enableAutoScale is set to
   * false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.targetLowPriorityNodes] The desired
   * number of low-priority Compute Nodes in the Pool. This property must not be
   * specified if enableAutoScale is set to true. If enableAutoScale is set to
   * false, then you must set either targetDedicatedNodes,
   * targetLowPriorityNodes, or both.
   *
   * @param {boolean} [job.poolInfo.autoPoolSpecification.pool.enableAutoScale]
   * Whether the Pool size should automatically adjust over time. If false, at
   * least one of targetDedicateNodes and targetLowPriorityNodes must be
   * specified. If true, the autoScaleFormula element is required. The Pool
   * automatically resizes according to the formula. The default value is false.
   *
   * @param {string} [job.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
   * The formula for the desired number of Compute Nodes in the Pool. This
   * property must not be specified if enableAutoScale is set to false. It is
   * required if enableAutoScale is set to true. The formula is checked for
   * validity before the Pool is created. If the formula is not valid, the Batch
   * service rejects the request with detailed error information.
   *
   * @param {moment.duration}
   * [job.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval] The
   * time interval at which to automatically adjust the Pool size according to
   * the autoscale formula. The default value is 15 minutes. The minimum and
   * maximum value are 5 minutes and 168 hours respectively. If you specify a
   * value less than 5 minutes or greater than 168 hours, the Batch service
   * rejects the request with an invalid property value error; if you are calling
   * the REST API directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
   * Whether the Pool permits direct communication between Compute Nodes.
   * Enabling inter-node communication limits the maximum size of the Pool due to
   * deployment restrictions on the Compute Nodes of the Pool. This may result in
   * the Pool not reaching its desired size. The default value is false.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration] The network
   * configuration for the Pool.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.subnetId] The
   * ARM resource identifier of the virtual network subnet which the Compute
   * Nodes of the Pool will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch Account. The specified subnet should have enough free IP addresses to
   * accommodate the number of Compute Nodes in the Pool. If the subnet doesn't
   * have enough free IP addresses, the Pool will partially allocate Nodes and a
   * resize error will occur. The 'MicrosoftAzureBatch' service principal must
   * have the 'Classic Virtual Machine Contributor' Role-Based Access Control
   * (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule Tasks on
   * the Nodes. This can be verified by checking if the specified VNet has any
   * associated Network Security Groups (NSG). If communication to the Nodes in
   * the specified subnet is denied by an NSG, then the Batch service will set
   * the state of the Compute Nodes to unusable. For Pools created with
   * virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for Pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For Pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For Pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.dynamicVNetAssignmentScope]
   * The scope of dynamic vnet assignment. Possible values include: 'none', 'job'
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration]
   * The configuration for endpoints on Compute Nodes in the Batch Pool. Pool
   * endpoint configuration is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * job.poolInfo.autoPoolSpecification.pool.networkConfiguration.endpointConfiguration.inboundNATPools
   * A list of inbound NAT Pools that can be used to address specific ports on an
   * individual Compute Node externally. The maximum number of inbound NAT Pools
   * per Batch Pool is 5. If the maximum number of inbound NAT Pools is exceeded
   * the request fails with HTTP status code 400. This cannot be specified if the
   * IPAddressProvisioningType is NoPublicIPAddresses.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration]
   * The Public IPAddress configuration for Compute Nodes in the Batch Pool.
   * Public IP configuration property is only supported on Pools with the
   * virtualMachineConfiguration property.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.provision]
   * The provisioning type for Public IP Addresses for the Pool. The default
   * value is BatchManaged. Possible values include: 'batchManaged',
   * 'userManaged', 'noPublicIPAddresses'
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.networkConfiguration.publicIPAddressConfiguration.ipAddressIds]
   * The list of public IPs which the Batch service will use when provisioning
   * Compute Nodes. The number of IPs specified here limits the maximum size of
   * the Pool - 100 dedicated nodes or 100 low-priority nodes can be allocated
   * for each public IP. For example, a pool needing 250 dedicated VMs would need
   * at least 3 public IPs specified. Each element of this collection is of the
   * form:
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
   *
   * @param {object} [job.poolInfo.autoPoolSpecification.pool.startTask] A Task
   * to run on each Compute Node as it joins the Pool. The Task runs when the
   * Compute Node is added to the Pool or when the Compute Node is restarted.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.commandLine The command
   * line of the StartTask. The command line does not run under a shell, and
   * therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the command
   * line refers to file paths, it should use a relative path (relative to the
   * Task working directory), or use the Batch provided environment variable
   * (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings] The
   * settings for the container under which the StartTask runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all Task environment variables are mapped into the container, and the Task
   * command line is executed in the container. Files produced in the container
   * outside of AZ_BATCH_NODE_ROOT_DIR might not be reflected to the host disk,
   * meaning that Batch file APIs will not be able to access those files.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.imageName
   * The Image to use to create the container in which the Task will run. This is
   * the full Image reference, as would be specified to "docker pull". If no tag
   * is provided as part of the Image name, the tag ":latest" is used as a
   * default.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry]
   * The private registry which contains the container Image. This setting can be
   * omitted if was already provided at Pool creation.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.containerSettings.workingDirectory]
   * The location of the container Task working directory. The default is
   * 'taskWorkingDirectory'. Possible values include: 'taskWorkingDirectory',
   * 'containerImageDefault'
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles] A list of
   * files that the Batch service will download to the Compute Node before
   * running the command line.  There is a maximum size for the list of resource
   * files. When the max size is exceeded, the request will fail and the response
   * error code will be RequestEntityTooLarge. If this occurs, the collection of
   * ResourceFiles must be reduced in size. This can be achieved using .zip
   * files, Application Packages, or Docker Containers. Files listed under this
   * element are located in the Task's working directory.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings] A
   * list of environment variable settings for the StartTask.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity] The user
   * identity under which the StartTask runs. If omitted, the Task runs as a
   * non-administrative user unique to the Task.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.userName]
   * The name of the user identity under which the Task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser]
   * The auto user under which the Task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user The default value is pool. If the pool is
   * running Windows a value of Task should be specified if stricter isolation
   * between tasks is required. For example, if the task mutates the registry in
   * a way which could impact other tasks, or if certificates have been specified
   * on the pool which should not be accessible by normal tasks but should be
   * accessible by StartTasks. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. The default value is nonAdmin.
   * Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount] The
   * maximum number of times the Task may be retried. The Batch service retries a
   * Task if its exit code is nonzero. Note that this value specifically controls
   * the number of retries. The Batch service will try the Task once, and may
   * then retry up to this limit. For example, if the maximum retry count is 3,
   * Batch tries the Task up to 4 times (one initial try and 3 retries). If the
   * maximum retry count is 0, the Batch service does not retry the Task. If the
   * maximum retry count is -1, the Batch service retries the Task without limit.
   *
   * @param {boolean}
   * [job.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess] Whether
   * the Batch service should wait for the StartTask to complete successfully
   * (that is, to exit with exit code 0) before scheduling any Tasks on the
   * Compute Node. If true and the StartTask fails on a Node, the Batch service
   * retries the StartTask up to its maximum retry count (maxTaskRetryCount). If
   * the Task has still not completed successfully after all retries, then the
   * Batch service marks the Node unusable, and will not schedule Tasks to it.
   * This condition can be detected via the Compute Node state and failure info
   * details. If false, the Batch service will not wait for the StartTask to
   * complete. In this case, other Tasks can start executing on the Compute Node
   * while the StartTask is still running; and even if the StartTask fails, new
   * Tasks will continue to be scheduled on the Compute Node. The default is
   * true.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.certificateReferences] A list of
   * Certificates to be installed on each Compute Node in the Pool. For Windows
   * Nodes, the Batch service installs the Certificates to the specified
   * Certificate store and location. For Linux Compute Nodes, the Certificates
   * are stored in a directory inside the Task working directory and an
   * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to
   * query for this location. For Certificates with visibility of 'remoteUser', a
   * 'certs' directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and Certificates are placed in that directory.
   *
   * @param {array}
   * [job.poolInfo.autoPoolSpecification.pool.applicationPackageReferences] The
   * list of Packages to be installed on each Compute Node in the Pool. Changes
   * to Package references affect all new Nodes joining the Pool, but do not
   * affect Compute Nodes that are already in the Pool until they are rebooted or
   * reimaged. There is a maximum of 10 Package references on any given Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.applicationLicenses]
   * The list of application licenses the Batch service will make available on
   * each Compute Node in the Pool. The list of application licenses must be a
   * subset of available Batch service application licenses. If a license is
   * requested which is not supported, Pool creation will fail. The permitted
   * licenses available on the Pool are 'maya', 'vray', '3dsmax', 'arnold'. An
   * additional charge applies for each application license added to the Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.userAccounts] The
   * list of user Accounts to be created on each Compute Node in the Pool.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.metadata] A list of
   * name-value pairs associated with the Pool as metadata. The Batch service
   * does not assign any meaning to metadata; it is solely for the use of user
   * code.
   *
   * @param {array} [job.poolInfo.autoPoolSpecification.pool.mountConfiguration]
   * A list of file systems to mount on each node in the pool. This supports
   * Azure Files, NFS, CIFS/SMB, and Blobfuse.
   *
   * @param {string} [job.onAllTasksComplete] The action the Batch service should
   * take when all Tasks in the Job are in the completed state. Note that if a
   * Job contains no Tasks, then all Tasks are considered complete. This option
   * is therefore most commonly used with a Job Manager task; if you want to use
   * automatic Job termination without a Job Manager, you should initially set
   * onAllTasksComplete to noaction and update the Job properties to set
   * onAllTasksComplete to terminatejob once you have finished adding Tasks. The
   * default is noaction. Possible values include: 'noAction', 'terminateJob'
   *
   * @param {string} [job.onTaskFailure] The action the Batch service should take
   * when any Task in the Job fails. A Task is considered to have failed if has a
   * failureInfo. A failureInfo is set if the Task completes with a non-zero exit
   * code after exhausting its retry count, or if there was an error starting the
   * Task, for example due to a resource file download error. The default is
   * noaction. Possible values include: 'noAction', 'performExitOptionsJobAction'
   *
   * @param {array} [job.metadata] A list of name-value pairs associated with the
   * Job as metadata. The Batch service does not assign any meaning to metadata;
   * it is solely for the use of user code.
   *
   * @param {boolean} [job.usesTaskDependencies] Whether Tasks in the Job can
   * define dependencies on each other. The default is false.
   *
   * @param {object} [job.networkConfiguration] The network configuration for the
   * Job.
   *
   * @param {string} job.networkConfiguration.subnetId The ARM resource
   * identifier of the virtual network subnet which Compute Nodes running Tasks
   * from the Job will join for the duration of the Task. This will only work
   * with a VirtualMachineConfiguration Pool. The virtual network must be in the
   * same region and subscription as the Azure Batch Account. The specified
   * subnet should have enough free IP addresses to accommodate the number of
   * Compute Nodes which will run Tasks from the Job. This can be up to the
   * number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service
   * principal must have the 'Classic Virtual Machine Contributor' Role-Based
   * Access Control (RBAC) role for the specified VNet so that Azure Batch
   * service can schedule Tasks on the Nodes. This can be verified by checking if
   * the specified VNet has any associated Network Security Groups (NSG). If
   * communication to the Nodes in the specified subnet is denied by an NSG, then
   * the Batch service will set the state of the Compute Nodes to unusable. This
   * is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * If the specified VNet has any associated Network Security Groups (NSG), then
   * a few reserved system ports must be enabled for inbound communication from
   * the Azure Batch service. For Pools created with a Virtual Machine
   * configuration, enable ports 29876 and 29877, as well as port 22 for Linux
   * and port 3389 for Windows. Port 443 is also required to be open for outbound
   * connections for communications to Azure Storage. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobAddOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.jobAddOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobAddOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobAddOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobAddOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  add(job, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._add(job, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._add(job, options, optionalCallback);
    }
  }

  /**
   * @summary Lists all of the Jobs in the specified Account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.jobListOptions.filter] An OData $filter clause. For
   * more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
   *
   * @param {string} [options.jobListOptions.select] An OData $select clause.
   *
   * @param {string} [options.jobListOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.jobListOptions.maxResults] The maximum number of
   * items to return in the response. A maximum of 1000 Jobs can be returned.
   *
   * @param {number} [options.jobListOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobListOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobListOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists all of the Jobs in the specified Account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.jobListOptions.filter] An OData $filter clause. For
   * more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
   *
   * @param {string} [options.jobListOptions.select] An OData $select clause.
   *
   * @param {string} [options.jobListOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.jobListOptions.maxResults] The maximum number of
   * items to return in the response. A maximum of 1000 Jobs can be returned.
   *
   * @param {number} [options.jobListOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.jobListOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobListOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudJobListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * @summary Lists the Jobs that have been created under the specified Job
   * Schedule.
   *
   * @param {string} jobScheduleId The ID of the Job Schedule from which you want
   * to get a list of Jobs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListFromJobScheduleOptions] Additional
   * parameters for the operation
   *
   * @param {string} [options.jobListFromJobScheduleOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
   *
   * @param {string} [options.jobListFromJobScheduleOptions.select] An OData
   * $select clause.
   *
   * @param {string} [options.jobListFromJobScheduleOptions.expand] An OData
   * $expand clause.
   *
   * @param {number} [options.jobListFromJobScheduleOptions.maxResults] The
   * maximum number of items to return in the response. A maximum of 1000 Jobs
   * can be returned.
   *
   * @param {number} [options.jobListFromJobScheduleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.jobListFromJobScheduleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListFromJobScheduleOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListFromJobScheduleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listFromJobScheduleWithHttpOperationResponse(jobScheduleId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listFromJobSchedule(jobScheduleId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the Jobs that have been created under the specified Job
   * Schedule.
   *
   * @param {string} jobScheduleId The ID of the Job Schedule from which you want
   * to get a list of Jobs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListFromJobScheduleOptions] Additional
   * parameters for the operation
   *
   * @param {string} [options.jobListFromJobScheduleOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
   *
   * @param {string} [options.jobListFromJobScheduleOptions.select] An OData
   * $select clause.
   *
   * @param {string} [options.jobListFromJobScheduleOptions.expand] An OData
   * $expand clause.
   *
   * @param {number} [options.jobListFromJobScheduleOptions.maxResults] The
   * maximum number of items to return in the response. A maximum of 1000 Jobs
   * can be returned.
   *
   * @param {number} [options.jobListFromJobScheduleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.jobListFromJobScheduleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListFromJobScheduleOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListFromJobScheduleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudJobListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listFromJobSchedule(jobScheduleId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listFromJobSchedule(jobScheduleId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listFromJobSchedule(jobScheduleId, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the execution status of the Job Preparation and Job Release
   * Task for the specified Job across the Compute Nodes where the Job has run.
   *
   * This API returns the Job Preparation and Job Release Task status on all
   * Compute Nodes that have run the Job Preparation or Job Release Task. This
   * includes Compute Nodes which have since been removed from the Pool. If this
   * API is invoked on a Job which has no Job Preparation or Job Release Task,
   * the Batch service returns HTTP status code 409 (Conflict) with an error code
   * of JobPreparationTaskNotSpecified.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListPreparationAndReleaseTaskStatusOptions]
   * Additional parameters for the operation
   *
   * @param {string}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
   *
   * @param {string}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.select] An OData
   * $select clause.
   *
   * @param {number}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.maxResults] The
   * maximum number of items to return in the response. A maximum of 1000 Tasks
   * can be returned.
   *
   * @param {number}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListPreparationAndReleaseTaskStatusResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPreparationAndReleaseTaskStatusWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPreparationAndReleaseTaskStatus(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the execution status of the Job Preparation and Job Release
   * Task for the specified Job across the Compute Nodes where the Job has run.
   *
   * This API returns the Job Preparation and Job Release Task status on all
   * Compute Nodes that have run the Job Preparation or Job Release Task. This
   * includes Compute Nodes which have since been removed from the Pool. If this
   * API is invoked on a Job which has no Job Preparation or Job Release Task,
   * the Batch service returns HTTP status code 409 (Conflict) with an error code
   * of JobPreparationTaskNotSpecified.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListPreparationAndReleaseTaskStatusOptions]
   * Additional parameters for the operation
   *
   * @param {string}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
   *
   * @param {string}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.select] An OData
   * $select clause.
   *
   * @param {number}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.maxResults] The
   * maximum number of items to return in the response. A maximum of 1000 Tasks
   * can be returned.
   *
   * @param {number}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date}
   * [options.jobListPreparationAndReleaseTaskStatusOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListPreparationAndReleaseTaskStatusResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPreparationAndReleaseTaskStatus(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPreparationAndReleaseTaskStatus(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPreparationAndReleaseTaskStatus(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Task counts for the specified Job.
   *
   * Task counts provide a count of the Tasks by active, running or completed
   * Task state, and a count of Tasks which succeeded or failed. Tasks in the
   * preparing state are counted as running. Note that the numbers returned may
   * not always be up to date. If you need exact task counts, use a list query.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetTaskCountsOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.jobGetTaskCountsOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.jobGetTaskCountsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobGetTaskCountsOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetTaskCountsOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<TaskCountsResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTaskCountsWithHttpOperationResponse(jobId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTaskCounts(jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Task counts for the specified Job.
   *
   * Task counts provide a count of the Tasks by active, running or completed
   * Task state, and a count of Tasks which succeeded or failed. Tasks in the
   * preparing state are counted as running. Note that the numbers returned may
   * not always be up to date. If you need exact task counts, use a list query.
   *
   * @param {string} jobId The ID of the Job.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobGetTaskCountsOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.jobGetTaskCountsOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.jobGetTaskCountsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobGetTaskCountsOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobGetTaskCountsOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {TaskCountsResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link TaskCountsResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTaskCounts(jobId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTaskCounts(jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTaskCounts(jobId, options, optionalCallback);
    }
  }

  /**
   * @summary Lists all of the Jobs in the specified Account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListNextOptions] Additional parameters for the
   * operation
   *
   * @param {uuid} [options.jobListNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobListNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListNextOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists all of the Jobs in the specified Account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListNextOptions] Additional parameters for the
   * operation
   *
   * @param {uuid} [options.jobListNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.jobListNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListNextOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudJobListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the Jobs that have been created under the specified Job
   * Schedule.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListFromJobScheduleNextOptions] Additional
   * parameters for the operation
   *
   * @param {uuid} [options.jobListFromJobScheduleNextOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListFromJobScheduleNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListFromJobScheduleNextOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listFromJobScheduleNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listFromJobScheduleNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the Jobs that have been created under the specified Job
   * Schedule.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListFromJobScheduleNextOptions] Additional
   * parameters for the operation
   *
   * @param {uuid} [options.jobListFromJobScheduleNextOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListFromJobScheduleNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.jobListFromJobScheduleNextOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudJobListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listFromJobScheduleNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listFromJobScheduleNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listFromJobScheduleNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the execution status of the Job Preparation and Job Release
   * Task for the specified Job across the Compute Nodes where the Job has run.
   *
   * This API returns the Job Preparation and Job Release Task status on all
   * Compute Nodes that have run the Job Preparation or Job Release Task. This
   * includes Compute Nodes which have since been removed from the Pool. If this
   * API is invoked on a Job which has no Job Preparation or Job Release Task,
   * the Batch service returns HTTP status code 409 (Conflict) with an error code
   * of JobPreparationTaskNotSpecified.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListPreparationAndReleaseTaskStatusNextOptions]
   * Additional parameters for the operation
   *
   * @param {uuid}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudJobListPreparationAndReleaseTaskStatusResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPreparationAndReleaseTaskStatusNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPreparationAndReleaseTaskStatusNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the execution status of the Job Preparation and Job Release
   * Task for the specified Job across the Compute Nodes where the Job has run.
   *
   * This API returns the Job Preparation and Job Release Task status on all
   * Compute Nodes that have run the Job Preparation or Job Release Task. This
   * includes Compute Nodes which have since been removed from the Pool. If this
   * API is invoked on a Job which has no Job Preparation or Job Release Task,
   * the Batch service returns HTTP status code 409 (Conflict) with an error code
   * of JobPreparationTaskNotSpecified.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.jobListPreparationAndReleaseTaskStatusNextOptions]
   * Additional parameters for the operation
   *
   * @param {uuid}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date}
   * [options.jobListPreparationAndReleaseTaskStatusNextOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudJobListPreparationAndReleaseTaskStatusResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link
   *                      CloudJobListPreparationAndReleaseTaskStatusResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPreparationAndReleaseTaskStatusNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPreparationAndReleaseTaskStatusNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPreparationAndReleaseTaskStatusNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = Job;
