/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var msRestAzure = require('ms-rest-azure');
var WebResource = msRest.WebResource;
var moment = require('moment');

/**
 * @class
 * Pool
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the BatchServiceClient.
 * Initializes a new instance of the Pool class.
 * @constructor
 *
 * @param {BatchServiceClient} client Reference to the service client.
 */
function Pool(client) {
  this.client = client;
}

/**
 * @summary Lists the usage metrics, aggregated by pool across individual time
 * intervals, for the specified account.
 *
 * If you do not specify a $filter clause including a poolId, the response
 * includes all pools that existed in the account in the time range of the
 * returned aggregation intervals.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolListPoolUsageMetricsOptions] Additional
 * parameters for the operation
 * 
 * @param {date} [options.poolListPoolUsageMetricsOptions.startTime] The
 * earliest time from which to include metrics. This must be at least two and a
 * half hours before the current time. If not specified this defaults to the
 * start time of the last aggregation interval currently available.
 * 
 * @param {date} [options.poolListPoolUsageMetricsOptions.endTime] The latest
 * time from which to include metrics. This must be at least two hours before
 * the current time. If not specified this defaults to the end time of the last
 * aggregation interval currently available.
 * 
 * @param {string} [options.poolListPoolUsageMetricsOptions.filter] An OData
 * $filter clause. If this is not specified the response includes all pools
 * that existed in the account in the time range of the returned aggregation
 * intervals.
 * 
 * @param {number} [options.poolListPoolUsageMetricsOptions.maxResults] The
 * maximum number of items to return in the response. A maximum of 1000 results
 * will be returned.
 * 
 * @param {number} [options.poolListPoolUsageMetricsOptions.timeout] The
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 * 
 * @param {string} [options.poolListPoolUsageMetricsOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.poolListPoolUsageMetricsOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolListPoolUsageMetricsOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link PoolListPoolUsageMetricsResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.listPoolUsageMetrics = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolListPoolUsageMetricsOptions = (options && options.poolListPoolUsageMetricsOptions !== undefined) ? options.poolListPoolUsageMetricsOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var startTime;
  var endTime;
  var filter;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      startTime = poolListPoolUsageMetricsOptions.startTime;
      if (startTime && !(startTime instanceof Date || 
          (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
            throw new Error('startTime must be of type date.');
          }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      endTime = poolListPoolUsageMetricsOptions.endTime;
      if (endTime && !(endTime instanceof Date || 
          (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
            throw new Error('endTime must be of type date.');
          }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      filter = poolListPoolUsageMetricsOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      maxResults = poolListPoolUsageMetricsOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      timeout = poolListPoolUsageMetricsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      clientRequestId = poolListPoolUsageMetricsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      returnClientRequestId = poolListPoolUsageMetricsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListPoolUsageMetricsOptions !== null && poolListPoolUsageMetricsOptions !== undefined)
    {
      ocpDate = poolListPoolUsageMetricsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'poolusagemetrics';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (startTime !== null && startTime !== undefined) {
    queryParameters.push('starttime=' + encodeURIComponent(client.serializeObject(startTime)));
  }
  if (endTime !== null && endTime !== undefined) {
    queryParameters.push('endtime=' + encodeURIComponent(client.serializeObject(endTime)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['PoolListPoolUsageMetricsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Gets lifetime summary statistics for all of the pools in the
 * specified account.
 *
 * Statistics are aggregated across all pools that have ever existed in the
 * account, from account creation to the last update time of the statistics.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolGetAllPoolsLifetimeStatisticsOptions]
 * Additional parameters for the operation
 * 
 * @param {number} [options.poolGetAllPoolsLifetimeStatisticsOptions.timeout]
 * The maximum time that the server can spend processing the request, in
 * seconds. The default is 30 seconds.
 * 
 * @param {string}
 * [options.poolGetAllPoolsLifetimeStatisticsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.poolGetAllPoolsLifetimeStatisticsOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolGetAllPoolsLifetimeStatisticsOptions.ocpDate] The
 * time the request was issued. If not specified, this header will be
 * automatically populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link PoolStatistics} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.getAllPoolsLifetimeStatistics = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolGetAllPoolsLifetimeStatisticsOptions = (options && options.poolGetAllPoolsLifetimeStatisticsOptions !== undefined) ? options.poolGetAllPoolsLifetimeStatisticsOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolGetAllPoolsLifetimeStatisticsOptions !== null && poolGetAllPoolsLifetimeStatisticsOptions !== undefined)
    {
      timeout = poolGetAllPoolsLifetimeStatisticsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolGetAllPoolsLifetimeStatisticsOptions !== null && poolGetAllPoolsLifetimeStatisticsOptions !== undefined)
    {
      clientRequestId = poolGetAllPoolsLifetimeStatisticsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolGetAllPoolsLifetimeStatisticsOptions !== null && poolGetAllPoolsLifetimeStatisticsOptions !== undefined)
    {
      returnClientRequestId = poolGetAllPoolsLifetimeStatisticsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolGetAllPoolsLifetimeStatisticsOptions !== null && poolGetAllPoolsLifetimeStatisticsOptions !== undefined)
    {
      ocpDate = poolGetAllPoolsLifetimeStatisticsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimepoolstats';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['PoolStatistics']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Adds a pool to the specified account.
 *
 * When naming pools, avoid including sensitive information such as user names
 * or secret project names. This information may appear in telemetry logs
 * accessible to Microsoft Support engineers.
 *
 * @param {object} pool The pool to be added.
 * 
 * @param {string} pool.id A string that uniquely identifies the pool within
 * the account. The ID can contain any combination of alphanumeric characters
 * including hyphens and underscores, and cannot contain more than 64
 * characters. The ID is case-preserving and case-insensitive (that is, you may
 * not have two pool IDs within an account that differ only by case).
 * 
 * @param {string} [pool.displayName] The display name for the pool. The
 * display name need not be unique and can contain any Unicode characters up to
 * a maximum length of 1024.
 * 
 * @param {string} pool.vmSize The size of virtual machines in the pool. All
 * virtual machines in a pool are the same size. For information about
 * available sizes of virtual machines for Cloud Services pools (pools created
 * with cloudServiceConfiguration), see Sizes for Cloud Services
 * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
 * Batch supports all Cloud Services VM sizes except ExtraSmall. For
 * information about available VM sizes for pools using images from the Virtual
 * Machines Marketplace (pools created with virtualMachineConfiguration) see
 * Sizes for Virtual Machines (Linux)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
 * or Sizes for Virtual Machines (Windows)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
 * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
 * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
 * 
 * @param {object} [pool.cloudServiceConfiguration] The cloud service
 * configuration for the pool. This property and virtualMachineConfiguration
 * are mutually exclusive and one of the properties must be specified.
 * 
 * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
 * family to be installed on the virtual machines in the pool. Possible values
 * are: 2 – OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 – OS
 * Family 3, equivalent to Windows Server 2012. 4 – OS Family 4, equivalent to
 * Windows Server 2012 R2. For more information, see Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 * 
 * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
 * Guest OS version to be installed on the virtual machines in the pool. The
 * default value is * which specifies the latest operating system version for
 * the specified OS family.
 * 
 * @param {string} [pool.cloudServiceConfiguration.currentOSVersion] The Azure
 * Guest OS Version currently installed on the virtual machines in the pool.
 * This may differ from targetOSVersion if the pool state is Upgrading. In this
 * case some virtual machines may be on the targetOSVersion and some may be on
 * the currentOSVersion during the upgrade process. Once all virtual machines
 * have upgraded, currentOSVersion is updated to be the same as
 * targetOSVersion.
 * 
 * @param {object} [pool.virtualMachineConfiguration] The virtual machine
 * configuration for the pool. This property and cloudServiceConfiguration are
 * mutually exclusive and one of the properties must be specified.
 * 
 * @param {object} pool.virtualMachineConfiguration.imageReference A reference
 * to the Azure Virtual Machines Marketplace image to use.
 * 
 * @param {string} pool.virtualMachineConfiguration.imageReference.publisher
 * The publisher of the Azure Virtual Machines Marketplace image. For example,
 * Canonical or MicrosoftWindowsServer.
 * 
 * @param {string} pool.virtualMachineConfiguration.imageReference.offer The
 * offer type of the Azure Virtual Machines Marketplace image. For example,
 * UbuntuServer or WindowsServer.
 * 
 * @param {string} pool.virtualMachineConfiguration.imageReference.sku The SKU
 * of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
 * 2012-R2-Datacenter.
 * 
 * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace image. A value of
 * 'latest' can be specified to select the latest version of an image. If
 * omitted, the default is 'latest'.
 * 
 * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
 * the Batch node agent to be provisioned on compute nodes in the pool. The
 * Batch node agent is a program that runs on each node in the pool, and
 * provides the command-and-control interface between the node and the Batch
 * service. There are different implementations of the node agent, known as
 * SKUs, for different operating systems. You must specify a node agent SKU
 * which matches the selected image reference. To get the list of supported
 * node agent SKUs along with their list of verified image references, see the
 * 'List supported node agent SKUs' operation.
 * 
 * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference property specifies a Linux OS image.
 * 
 * @param {boolean}
 * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 * 
 * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
 * compute nodes to the pool. This timeout applies only to manual scaling; it
 * has no effect when enableAutoScale is set to true. The default value is 15
 * minutes. The minimum value is 5 minutes. If you specify a value less than 5
 * minutes, the Batch service returns an error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request).
 * 
 * @param {number} [pool.targetDedicated] The desired number of compute nodes
 * in the pool. This property must have the default value if enableAutoScale is
 * true. It is required if enableAutoScale is false.
 * 
 * @param {boolean} [pool.enableAutoScale] Whether the pool size should
 * automatically adjust over time. If true, the autoScaleFormula property must
 * be set. If false, the targetDedicated property must be set. The default
 * value is false.
 * 
 * @param {string} [pool.autoScaleFormula] A formula for the desired number of
 * compute nodes in the pool. This property must not be specified if
 * enableAutoScale is set to false. It is required if enableAutoScale is set to
 * true. The formula is checked for validity before the pool is created. If the
 * formula is not valid, the Batch service rejects the request with detailed
 * error information. For more information about specifying this formula, see
 * 'Automatically scale compute nodes in an Azure Batch pool'
 * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
 * 
 * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
 * interval at which to automatically adjust the pool size according to the
 * autoscale formula. The default value is 15 minutes. The minimum and maximum
 * value are 5 minutes and 168 hours respectively. If you specify a value less
 * than 5 minutes or greater than 168 hours, the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request).
 * 
 * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
 * permits direct communication between nodes. Enabling inter-node
 * communication limits the maximum size of the pool due to deployment
 * restrictions on the nodes of the pool. This may result in the pool not
 * reaching its desired size. The default value is false.
 * 
 * @param {object} [pool.networkConfiguration] The network configuration for
 * the pool.
 * 
 * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
 * identifier of the virtual network subnet which the compute nodes of the pool
 * will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch account. The specified subnet should have enough free IP addresses to
 * accommodate the number of nodes in the pool. If the subnet doesn't have
 * enough free IP addresses, the pool will partially allocate compute nodes,
 * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
 * must have the 'Classic Virtual Machine Contributor' Role-Based Access
 * Control (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule tasks on
 * the compute nodes. This can be verified by checking if the specified VNet
 * has any associated Network Security Groups (NSG). If communication to the
 * compute nodes in the specified subnet is denied by an NSG, then the Batch
 * service will set the state of the compute nodes to unusable. This property
 * can only be specified for pools created with a cloudServiceConfiguration.
 * 
 * @param {object} [pool.startTask] A task specified to run on each compute
 * node as it joins the pool. The task runs when the node is added to the pool
 * or when the node is restarted.
 * 
 * @param {string} pool.startTask.commandLine The command line of the start
 * task. The command line does not run under a shell, and therefore cannot take
 * advantage of shell features such as environment variable expansion. If you
 * want to take advantage of such features, you should invoke the shell in the
 * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
 * MyCommand" in Linux.
 * 
 * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
 * service will download to the compute node before running the command line.
 * 
 * @param {array} [pool.startTask.environmentSettings] A list of environment
 * variable settings for the start task.
 * 
 * @param {boolean} [pool.startTask.runElevated] Whether to run the start task
 * in elevated mode. The default value is false.
 * 
 * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
 * times the task may be retried. The Batch service retries a task if its exit
 * code is nonzero. Note that this value specifically controls the number of
 * retries. The Batch service will try the task once, and may then retry up to
 * this limit. For example, if the maximum retry count is 3, Batch tries the
 * task up to 4 times (one initial try and 3 retries). If the maximum retry
 * count is 0, the Batch service does not retry the task. If the maximum retry
 * count is -1, the Batch service retries the task without limit.
 * 
 * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
 * should wait for the start task to complete successfully (that is, to exit
 * with exit code 0) before scheduling any tasks on the compute node. If true
 * and the start task fails on a compute node, the Batch service retries the
 * start task up to its maximum retry count (maxTaskRetryCount). If the task
 * has still not completed successfully after all retries, then the Batch
 * service marks the compute node unusable, and will not schedule tasks to it.
 * This condition can be detected via the node state and scheduling error
 * detail. If false, the Batch service will not wait for the start task to
 * complete. In this case, other tasks can start executing on the compute node
 * while the start task is still running; and even if the start task fails, new
 * tasks will continue to be scheduled on the node. The default is false.
 * 
 * @param {array} [pool.certificateReferences] The list of certificates to be
 * installed on each compute node in the pool. For Windows compute nodes, the
 * Batch service installs the certificates to the specified certificate store
 * and location. For Linux compute nodes, the certificates are stored in a
 * directory inside the task working directory and an environment variable
 * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
 * location. For certificates with visibility of remoteuser, a certs directory
 * is created in the user's home directory (e.g., /home/<user-name>/certs)
 * where certificates are placed.
 * 
 * @param {array} [pool.applicationPackageReferences] The list of application
 * packages to be installed on each compute node in the pool. This property is
 * currently not supported on pools created using the
 * virtualMachineConfiguration (IaaS) property.
 * 
 * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
 * run concurrently on a single compute node in the pool. The default value is
 * 1. The maximum value of this setting depends on the size of the compute
 * nodes in the pool (the vmSize setting).
 * 
 * @param {object} [pool.taskSchedulingPolicy] How the Batch service
 * distributes tasks between compute nodes in the pool.
 * 
 * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks should be
 * distributed across compute nodes Possible values include: 'spread', 'pack',
 * 'unmapped'
 * 
 * @param {array} [pool.metadata] A list of name-value pairs associated with
 * the pool as metadata. The Batch service does not assign any meaning to
 * metadata; it is solely for the use of user code.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolAddOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.poolAddOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolAddOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolAddOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.add = function (pool, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
  // Validate
  try {
    if (pool === null || pool === undefined) {
      throw new Error('pool cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      timeout = poolAddOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      clientRequestId = poolAddOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      returnClientRequestId = poolAddOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      ocpDate = poolAddOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (pool !== null && pool !== undefined) {
      var requestModelMapper = new client.models['PoolAddParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, pool, 'pool');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(pool, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 201) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists all of the pools in the specified account.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolListOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.poolListOptions.filter] An OData $filter clause.
 * 
 * @param {string} [options.poolListOptions.select] An OData $select clause.
 * 
 * @param {string} [options.poolListOptions.expand] An OData $expand clause.
 * 
 * @param {number} [options.poolListOptions.maxResults] The maximum number of
 * items to return in the response. A maximum of 1000 pools can be returned.
 * 
 * @param {number} [options.poolListOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolListOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolListOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudPoolListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.list = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var filter;
  var select;
  var expand;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      filter = poolListOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      select = poolListOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      expand = poolListOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      maxResults = poolListOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      timeout = poolListOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      clientRequestId = poolListOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      returnClientRequestId = poolListOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      ocpDate = poolListOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudPoolListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Deletes a pool from the specified account.
 *
 * When you request that a pool be deleted, the following actions occur: the
 * pool state is set to deleting; any ongoing resize operation on the pool are
 * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
 * running on existing nodes are terminated and requeued (as if a resize pool
 * operation had been requested with the default requeue option); finally, the
 * pool is removed from the system. Because running tasks are requeued, the
 * user can rerun these tasks by updating their job to target a different pool.
 * The tasks can then run on the new pool. If you want to override the requeue
 * behavior, then you should call resize pool explicitly to shrink the pool to
 * zero size before deleting the pool. If you call an Update, Patch or Delete
 * API on a pool in the deleting state, it will fail with HTTP status code 409
 * with error code PoolBeingDeleted.
 *
 * @param {string} poolId The ID of the pool to delete.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 * 
 * @param {string} [options.poolDeleteMethodOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.deleteMethod = function (poolId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      timeout = poolDeleteMethodOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      clientRequestId = poolDeleteMethodOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ocpDate = poolDeleteMethodOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifMatch = poolDeleteMethodOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets basic properties of a pool.
 *
 * @param {string} poolId The ID of the pool to get.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolExistsOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.poolExistsOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolExistsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.poolExistsOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolExistsOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {boolean} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.exists = function (poolId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      timeout = poolExistsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      clientRequestId = poolExistsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      returnClientRequestId = poolExistsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ocpDate = poolExistsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifMatch = poolExistsOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifNoneMatch = poolExistsOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifModifiedSince = poolExistsOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    result = (statusCode === 200);

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets information about the specified pool.
 *
 * @param {string} poolId The ID of the pool to get.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolGetOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.poolGetOptions.select] An OData $select clause.
 * 
 * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
 * 
 * @param {number} [options.poolGetOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolGetOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolGetOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.poolGetOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.poolGetOptions.ifModifiedSince] Specify this header
 * to perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.poolGetOptions.ifUnmodifiedSince] Specify this header
 * to perform the operation only if the resource has not been modified since
 * the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudPool} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.get = function (poolId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var select;
  var expand;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      select = poolGetOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      expand = poolGetOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      timeout = poolGetOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      clientRequestId = poolGetOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      returnClientRequestId = poolGetOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ocpDate = poolGetOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifMatch = poolGetOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifNoneMatch = poolGetOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifModifiedSince = poolGetOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudPool']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Updates the properties of the specified pool.
 *
 * This only replaces the pool properties specified in the request. For
 * example, if the pool has a start task associated with it, and a request does
 * not specify a start task element, then the pool keeps the existing start
 * task.
 *
 * @param {string} poolId The ID of the pool to update.
 * 
 * @param {object} poolPatchParameter The parameters for the request.
 * 
 * @param {object} [poolPatchParameter.startTask] A task to run on each compute
 * node as it joins the pool. The task runs when the node is added to the pool
 * or when the node is restarted. If omitted, any existing start task is left
 * unchanged.
 * 
 * @param {string} poolPatchParameter.startTask.commandLine The command line of
 * the start task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
 * that the Batch service will download to the compute node before running the
 * command line.
 * 
 * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
 * environment variable settings for the start task.
 * 
 * @param {boolean} [poolPatchParameter.startTask.runElevated] Whether to run
 * the start task in elevated mode. The default value is false.
 * 
 * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
 * number of times the task may be retried. The Batch service retries a task if
 * its exit code is nonzero. Note that this value specifically controls the
 * number of retries. The Batch service will try the task once, and may then
 * retry up to this limit. For example, if the maximum retry count is 3, Batch
 * tries the task up to 4 times (one initial try and 3 retries). If the maximum
 * retry count is 0, the Batch service does not retry the task. If the maximum
 * retry count is -1, the Batch service retries the task without limit.
 * 
 * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
 * Batch service should wait for the start task to complete successfully (that
 * is, to exit with exit code 0) before scheduling any tasks on the compute
 * node. If true and the start task fails on a compute node, the Batch service
 * retries the start task up to its maximum retry count (maxTaskRetryCount). If
 * the task has still not completed successfully after all retries, then the
 * Batch service marks the compute node unusable, and will not schedule tasks
 * to it. This condition can be detected via the node state and scheduling
 * error detail. If false, the Batch service will not wait for the start task
 * to complete. In this case, other tasks can start executing on the compute
 * node while the start task is still running; and even if the start task
 * fails, new tasks will continue to be scheduled on the node. The default is
 * false.
 * 
 * @param {array} [poolPatchParameter.certificateReferences] A list of
 * certificates to be installed on each compute node in the pool. If omitted,
 * any existing certificate references are left unchanged. For Windows compute
 * nodes, the Batch service installs the certificates to the specified
 * certificate store and location. For Linux compute nodes, the certificates
 * are stored in a directory inside the task working directory and an
 * environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to
 * query for this location. For certificates with visibility of remoteuser, a
 * certs directory is created in the user's home directory (e.g.,
 * /home/<user-name>/certs) where certificates are placed.
 * 
 * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
 * application packages to be installed on each compute node in the pool.
 * Changes to application package references affect all new compute nodes
 * joining the pool, but do not affect compute nodes that are already in the
 * pool until they are rebooted or reimaged. If this element is present, it
 * replaces any existing application package references. If you specify an
 * empty collection, then all application package references are removed from
 * the pool. If omitted, any existing application package references are left
 * unchanged.
 * 
 * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
 * associated with the pool as metadata. If this element is present, it
 * replaces any existing metadata configured on the pool. If you specify an
 * empty collection, any metadata is removed from the pool. If omitted, any
 * existing metadata is left unchanged.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolPatchOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolPatchOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.poolPatchOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag
 * does not match the specified ETag.
 * 
 * @param {date} [options.poolPatchOptions.ifModifiedSince] Specify this header
 * to perform the operation only if the resource has been modified since the
 * specified date/time.
 * 
 * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.patch = function (poolId, poolPatchParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolPatchParameter === null || poolPatchParameter === undefined) {
      throw new Error('poolPatchParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      timeout = poolPatchOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      clientRequestId = poolPatchOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      returnClientRequestId = poolPatchOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ocpDate = poolPatchOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifMatch = poolPatchOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifNoneMatch = poolPatchOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifModifiedSince = poolPatchOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolPatchParameter !== null && poolPatchParameter !== undefined) {
      var requestModelMapper = new client.models['PoolPatchParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolPatchParameter, 'poolPatchParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolPatchParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Disables automatic scaling for a pool.
 *
 * @param {string} poolId The ID of the pool on which to disable automatic
 * scaling.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.poolDisableAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.disableAutoScale = function (poolId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      timeout = poolDisableAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      ocpDate = poolDisableAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/disableautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Enables automatic scaling for a pool.
 *
 * You cannot enable automatic scaling on a pool if a resize operation is in
 * progress on the pool. If automatic scaling of the pool is currently
 * disabled, you must specify a valid autoscale formula as part of the request.
 * If automatic scaling of the pool is already enabled, you may specify a new
 * autoscale formula and/or a new evaluation interval. You cannot call this API
 * for the same pool more than once every 30 seconds.
 *
 * @param {string} poolId The ID of the pool on which to enable automatic
 * scaling.
 * 
 * @param {object} poolEnableAutoScaleParameter The parameters for the request.
 * 
 * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
 * for the desired number of compute nodes in the pool. The formula is checked
 * for validity before it is applied to the pool. If the formula is not valid,
 * the Batch service rejects the request with detailed error information. For
 * more information about specifying this formula, see Automatically scale
 * compute nodes in an Azure Batch pool
 * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
 * 
 * @param {moment.duration}
 * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
 * at which to automatically adjust the pool size according to the autoscale
 * formula. The default value is 15 minutes. The minimum and maximum value are
 * 5 minutes and 168 hours respectively. If you specify a value less than 5
 * minutes or greater than 168 hours, the Batch service rejects the request
 * with an invalid property value error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request). If you specify a new
 * interval, then the existing autoscale evaluation schedule will be stopped
 * and a new autoscale evaluation schedule will be started, with its starting
 * time being the time when this request was issued.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.poolEnableAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been modified
 * since the specified date/time.
 * 
 * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.enableAutoScale = function (poolId, poolEnableAutoScaleParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
      throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      timeout = poolEnableAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ocpDate = poolEnableAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifMatch = poolEnableAutoScaleOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/enableautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolEnableAutoScaleParameter !== null && poolEnableAutoScaleParameter !== undefined) {
      var requestModelMapper = new client.models['PoolEnableAutoScaleParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolEnableAutoScaleParameter, 'poolEnableAutoScaleParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolEnableAutoScaleParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Gets the result of evaluating an automatic scaling formula on the
 * pool.
 *
 * This API is primarily for validating an autoscale formula, as it simply
 * returns the result without applying the formula to the pool.
 *
 * @param {string} poolId The ID of the pool on which to evaluate the automatic
 * scaling formula.
 * 
 * @param {string} autoScaleFormula The formula for the desired number of
 * compute nodes in the pool. The formula is validated and its results
 * calculated, but it is not applied to the pool. To apply the formula to the
 * pool, 'Enable automatic scaling on a pool'. For more information about
 * specifying this formula, see Automatically scale compute nodes in an Azure
 * Batch pool
 * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link AutoScaleRun} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.evaluateAutoScale = function (poolId, autoScaleFormula, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (autoScaleFormula === null || autoScaleFormula === undefined || typeof autoScaleFormula.valueOf() !== 'string') {
      throw new Error('autoScaleFormula cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var poolEvaluateAutoScaleParameter = new client.models['PoolEvaluateAutoScaleParameter']();
  try {
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      timeout = poolEvaluateAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (autoScaleFormula !== null && autoScaleFormula !== undefined)
    {
      poolEvaluateAutoScaleParameter.autoScaleFormula = autoScaleFormula;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/evaluateautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolEvaluateAutoScaleParameter !== null && poolEvaluateAutoScaleParameter !== undefined) {
      var requestModelMapper = new client.models['PoolEvaluateAutoScaleParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolEvaluateAutoScaleParameter, 'poolEvaluateAutoScaleParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolEvaluateAutoScaleParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['AutoScaleRun']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Changes the number of compute nodes that are assigned to a pool.
 *
 * You can only resize a pool when its allocation state is steady. If the pool
 * is already resizing, the request fails with status code 409. When you resize
 * a pool, the pool's allocation state changes from steady to resizing. You
 * cannot resize pools which are configured for automatic scaling. If you try
 * to do this, the Batch service returns an error 409. If you resize a pool
 * downwards, the Batch service chooses which nodes to remove. To remove
 * specific nodes, use the pool remove nodes API instead.
 *
 * @param {string} poolId The ID of the pool to resize.
 * 
 * @param {object} poolResizeParameter The parameters for the request.
 * 
 * @param {number} poolResizeParameter.targetDedicated The desired number of
 * compute nodes in the pool.
 * 
 * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
 * allocation of compute nodes to the pool or removal of compute nodes from the
 * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service returns an error;
 * if you are calling the REST API directly, the HTTP status code is 400 (Bad
 * Request).
 * 
 * @param {string} [poolResizeParameter.nodeDeallocationOption] When nodes may
 * be removed from the pool, if the pool size is decreasing. The default value
 * is requeue. Possible values include: 'requeue', 'terminate',
 * 'taskcompletion', 'retaineddata'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolResizeOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.poolResizeOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolResizeOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {string} [options.poolResizeOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolResizeOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.resize = function (poolId, poolResizeParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolResizeParameter === null || poolResizeParameter === undefined) {
      throw new Error('poolResizeParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      timeout = poolResizeOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      clientRequestId = poolResizeOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      returnClientRequestId = poolResizeOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ocpDate = poolResizeOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifMatch = poolResizeOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifNoneMatch = poolResizeOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifModifiedSince = poolResizeOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/resize';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolResizeParameter !== null && poolResizeParameter !== undefined) {
      var requestModelMapper = new client.models['PoolResizeParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolResizeParameter, 'poolResizeParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolResizeParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Stops an ongoing resize operation on the pool.
 *
 * This does not restore the pool to its previous state before the resize
 * operation: it only stops any further changes being made, and the pool
 * maintains its current state. A resize operation need not be an explicit
 * resize pool request; this API can also be used to halt the initial sizing of
 * the pool when it is created.
 *
 * @param {string} poolId The ID of the pool whose resizing you want to stop.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolStopResizeOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 * 
 * @param {string} [options.poolStopResizeOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolStopResizeOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.stopResize = function (poolId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      timeout = poolStopResizeOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      clientRequestId = poolStopResizeOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ocpDate = poolStopResizeOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifMatch = poolStopResizeOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/stopresize';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Updates the properties of the specified pool.
 *
 * This fully replaces all the updateable properties of the pool. For example,
 * if the pool has a start task associated with it and if start task is not
 * specified with this request, then the Batch service will remove the existing
 * start task.
 *
 * @param {string} poolId The ID of the pool to update.
 * 
 * @param {object} poolUpdatePropertiesParameter The parameters for the
 * request.
 * 
 * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
 * each compute node as it joins the pool. The task runs when the node is added
 * to the pool or when the node is restarted. If this element is present, it
 * overwrites any existing start task. If omitted, any existing start task is
 * removed from the pool.
 * 
 * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
 * command line of the start task. The command line does not run under a shell,
 * and therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 * 
 * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
 * list of files that the Batch service will download to the compute node
 * before running the command line.
 * 
 * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
 * A list of environment variable settings for the start task.
 * 
 * @param {boolean} [poolUpdatePropertiesParameter.startTask.runElevated]
 * Whether to run the start task in elevated mode. The default value is false.
 * 
 * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
 * The maximum number of times the task may be retried. The Batch service
 * retries a task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the task. If the maximum retry count is -1, the Batch service retries the
 * task without limit.
 * 
 * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
 * Whether the Batch service should wait for the start task to complete
 * successfully (that is, to exit with exit code 0) before scheduling any tasks
 * on the compute node. If true and the start task fails on a compute node, the
 * Batch service retries the start task up to its maximum retry count
 * (maxTaskRetryCount). If the task has still not completed successfully after
 * all retries, then the Batch service marks the compute node unusable, and
 * will not schedule tasks to it. This condition can be detected via the node
 * state and scheduling error detail. If false, the Batch service will not wait
 * for the start task to complete. In this case, other tasks can start
 * executing on the compute node while the start task is still running; and
 * even if the start task fails, new tasks will continue to be scheduled on the
 * node. The default is false.
 * 
 * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
 * certificates to be installed on each compute node in the pool. If you
 * specify an empty collection, any existing certificate references are removed
 * from the pool. For Windows compute nodes, the Batch service installs the
 * certificates to the specified certificate store and location. For Linux
 * compute nodes, the certificates are stored in a directory inside the task
 * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
 * supplied to the task to query for this location. For certificates with
 * visibility of remoteuser, a certs directory is created in the user's home
 * directory (e.g., /home/<user-name>/certs) where certificates are placed.
 * 
 * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
 * list of application packages to be installed on each compute node in the
 * pool. Changes to application package references affect all new compute nodes
 * joining the pool, but do not affect compute nodes that are already in the
 * pool until they are rebooted or reimaged. The list replaces any existing
 * application package references. If omitted, or if you specify an empty
 * collection, any existing application packages references are removed from
 * the pool.
 * 
 * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
 * pairs associated with the pool as metadata. This list replaces any existing
 * metadata configured on the pool. If omitted, or if you specify an empty
 * collection, any existing metadata is removed from the pool.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.poolUpdatePropertiesOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.updateProperties = function (poolId, poolUpdatePropertiesParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
      throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      timeout = poolUpdatePropertiesOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      ocpDate = poolUpdatePropertiesOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/updateproperties';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolUpdatePropertiesParameter !== null && poolUpdatePropertiesParameter !== undefined) {
      var requestModelMapper = new client.models['PoolUpdatePropertiesParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolUpdatePropertiesParameter, 'poolUpdatePropertiesParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolUpdatePropertiesParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 204) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Upgrades the operating system of the specified pool.
 *
 * During an upgrade, the Batch service upgrades each compute node in the pool.
 * When a compute node is chosen for upgrade, any tasks running on that node
 * are removed from the node and returned to the queue to be rerun later (or on
 * a different compute node). The node will be unavailable until the upgrade is
 * complete. This operation results in temporarily reduced pool capacity as
 * nodes are taken out of service to be upgraded. Although the Batch service
 * tries to avoid upgrading all compute nodes at the same time, it does not
 * guarantee to do this (particularly on small pools); therefore, the pool may
 * be temporarily unavailable to run tasks. When this operation runs, the pool
 * state changes to upgrading. When all compute nodes have finished upgrading,
 * the pool state returns to active.
 *
 * @param {string} poolId The ID of the pool to upgrade.
 * 
 * @param {string} targetOSVersion The Azure Guest OS version to be installed
 * on the virtual machines in the pool.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
 * operation
 * 
 * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 * 
 * @param {string} [options.poolUpgradeOSOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag is specified.
 * Specify this header to perform the operation only if the resource's ETag is
 * an exact match as specified.
 * 
 * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] Specify this
 * header to perform the operation only if the resource has not been modified
 * since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.upgradeOS = function (poolId, targetOSVersion, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (targetOSVersion === null || targetOSVersion === undefined || typeof targetOSVersion.valueOf() !== 'string') {
      throw new Error('targetOSVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  var poolUpgradeOSParameter = new client.models['PoolUpgradeOSParameter']();
  try {
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      timeout = poolUpgradeOSOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      clientRequestId = poolUpgradeOSOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ocpDate = poolUpgradeOSOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifMatch = poolUpgradeOSOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (targetOSVersion !== null && targetOSVersion !== undefined)
    {
      poolUpgradeOSParameter.targetOSVersion = targetOSVersion;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/upgradeos';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (poolUpgradeOSParameter !== null && poolUpgradeOSParameter !== undefined) {
      var requestModelMapper = new client.models['PoolUpgradeOSParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolUpgradeOSParameter, 'poolUpgradeOSParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(poolUpgradeOSParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Removes compute nodes from the specified pool.
 *
 * This operation can only run when the allocation state of the pool is steady.
 * When this operation runs, the allocation state changes from steady to
 * resizing.
 *
 * @param {string} poolId The ID of the pool from which you want to remove
 * nodes.
 * 
 * @param {object} nodeRemoveParameter The parameters for the request.
 * 
 * @param {array} nodeRemoveParameter.nodeList A list containing the ids of the
 * compute nodes to be removed from the specified pool.
 * 
 * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
 * removal of compute nodes to the pool. The default value is 15 minutes. The
 * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
 * Batch service returns an error; if you are calling the REST API directly,
 * the HTTP status code is 400 (Bad Request).
 * 
 * @param {string} [nodeRemoveParameter.nodeDeallocationOption] When to remove
 * compute nodes and what to do with currently running tasks. The default value
 * is requeue. Possible values include: 'requeue', 'terminate',
 * 'taskcompletion', 'retaineddata'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 * 
 * @param {string} [options.poolRemoveNodesOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified since
 * the specified date/time.
 * 
 * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.removeNodes = function (poolId, nodeRemoveParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
      throw new Error('nodeRemoveParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      timeout = poolRemoveNodesOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      clientRequestId = poolRemoveNodesOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ocpDate = poolRemoveNodesOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifMatch = poolRemoveNodesOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var baseUrl = this.client.baseUri;
  var requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/removenodes';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (nodeRemoveParameter !== null && nodeRemoveParameter !== undefined) {
      var requestModelMapper = new client.models['NodeRemoveParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, nodeRemoveParameter, 'nodeRemoveParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(nodeRemoveParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists the usage metrics, aggregated by pool across individual time
 * intervals, for the specified account.
 *
 * If you do not specify a $filter clause including a poolId, the response
 * includes all pools that existed in the account in the time range of the
 * returned aggregation intervals.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolListPoolUsageMetricsNextOptions] Additional
 * parameters for the operation
 * 
 * @param {string}
 * [options.poolListPoolUsageMetricsNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.poolListPoolUsageMetricsNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolListPoolUsageMetricsNextOptions.ocpDate] The time
 * the request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link PoolListPoolUsageMetricsResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.listPoolUsageMetricsNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolListPoolUsageMetricsNextOptions = (options && options.poolListPoolUsageMetricsNextOptions !== undefined) ? options.poolListPoolUsageMetricsNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolListPoolUsageMetricsNextOptions !== null && poolListPoolUsageMetricsNextOptions !== undefined)
    {
      clientRequestId = poolListPoolUsageMetricsNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolListPoolUsageMetricsNextOptions !== null && poolListPoolUsageMetricsNextOptions !== undefined)
    {
      returnClientRequestId = poolListPoolUsageMetricsNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListPoolUsageMetricsNextOptions !== null && poolListPoolUsageMetricsNextOptions !== undefined)
    {
      ocpDate = poolListPoolUsageMetricsNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['PoolListPoolUsageMetricsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * @summary Lists all of the pools in the specified account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.poolListNextOptions] Additional parameters for the
 * operation
 * 
 * @param {string} [options.poolListNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 * 
 * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
 * issued. If not specified, this header will be automatically populated with
 * the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudPoolListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Pool.prototype.listNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      clientRequestId = poolListNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      returnClientRequestId = poolListNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      ocpDate = poolListNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudPoolListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};


module.exports = Pool;
