/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;
const moment = require('moment');

/**
 * @summary Lists the usage metrics, aggregated by pool across individual time
 * intervals, for the specified account.
 *
 * If you do not specify a $filter clause including a poolId, the response
 * includes all pools that existed in the account in the time range of the
 * returned aggregation intervals. If you do not specify a $filter clause
 * including a startTime or endTime these filters default to the start and end
 * times of the last aggregation interval currently available; that is, only
 * the last aggregation interval is returned.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolListUsageMetricsOptions] Additional parameters
 * for the operation
 *
 * @param {date} [options.poolListUsageMetricsOptions.startTime] The earliest
 * time from which to include metrics. This must be at least two and a half
 * hours before the current time. If not specified this defaults to the start
 * time of the last aggregation interval currently available.
 *
 * @param {date} [options.poolListUsageMetricsOptions.endTime] The latest time
 * from which to include metrics. This must be at least two hours before the
 * current time. If not specified this defaults to the end time of the last
 * aggregation interval currently available.
 *
 * @param {string} [options.poolListUsageMetricsOptions.filter] An OData
 * $filter clause. For more information on constructing this filter, see
 * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
 *
 * @param {number} [options.poolListUsageMetricsOptions.maxResults] The maximum
 * number of items to return in the response. A maximum of 1000 results will be
 * returned.
 *
 * @param {number} [options.poolListUsageMetricsOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.poolListUsageMetricsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolListUsageMetricsOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolListUsageMetricsOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PoolListUsageMetricsResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsageMetrics(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolListUsageMetricsOptions = (options && options.poolListUsageMetricsOptions !== undefined) ? options.poolListUsageMetricsOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let startTime;
  let endTime;
  let filter;
  let maxResults;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      startTime = poolListUsageMetricsOptions.startTime;
      if (startTime && !(startTime instanceof Date ||
          (typeof startTime.valueOf() === 'string' && !isNaN(Date.parse(startTime))))) {
            throw new Error('startTime must be of type date.');
          }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      endTime = poolListUsageMetricsOptions.endTime;
      if (endTime && !(endTime instanceof Date ||
          (typeof endTime.valueOf() === 'string' && !isNaN(Date.parse(endTime))))) {
            throw new Error('endTime must be of type date.');
          }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      filter = poolListUsageMetricsOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      maxResults = poolListUsageMetricsOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      timeout = poolListUsageMetricsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      clientRequestId = poolListUsageMetricsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      returnClientRequestId = poolListUsageMetricsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListUsageMetricsOptions !== null && poolListUsageMetricsOptions !== undefined)
    {
      ocpDate = poolListUsageMetricsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'poolusagemetrics';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (startTime !== null && startTime !== undefined) {
    queryParameters.push('starttime=' + encodeURIComponent(client.serializeObject(startTime)));
  }
  if (endTime !== null && endTime !== undefined) {
    queryParameters.push('endtime=' + encodeURIComponent(client.serializeObject(endTime)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PoolListUsageMetricsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets lifetime summary statistics for all of the pools in the
 * specified account.
 *
 * Statistics are aggregated across all pools that have ever existed in the
 * account, from account creation to the last update time of the statistics.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolGetAllLifetimeStatisticsOptions] Additional
 * parameters for the operation
 *
 * @param {number} [options.poolGetAllLifetimeStatisticsOptions.timeout] The
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 *
 * @param {uuid} [options.poolGetAllLifetimeStatisticsOptions.clientRequestId]
 * The caller-generated request identity, in the form of a GUID with no
 * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.poolGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolGetAllLifetimeStatisticsOptions.ocpDate] The time
 * the request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PoolStatistics} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllLifetimeStatistics(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolGetAllLifetimeStatisticsOptions = (options && options.poolGetAllLifetimeStatisticsOptions !== undefined) ? options.poolGetAllLifetimeStatisticsOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined)
    {
      timeout = poolGetAllLifetimeStatisticsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined)
    {
      clientRequestId = poolGetAllLifetimeStatisticsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined)
    {
      returnClientRequestId = poolGetAllLifetimeStatisticsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolGetAllLifetimeStatisticsOptions !== null && poolGetAllLifetimeStatisticsOptions !== undefined)
    {
      ocpDate = poolGetAllLifetimeStatisticsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'lifetimepoolstats';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PoolStatistics']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a pool to the specified account.
 *
 * When naming pools, avoid including sensitive information such as user names
 * or secret project names. This information may appear in telemetry logs
 * accessible to Microsoft Support engineers.
 *
 * @param {object} pool The pool to be added.
 *
 * @param {string} pool.id A string that uniquely identifies the pool within
 * the account. The ID can contain any combination of alphanumeric characters
 * including hyphens and underscores, and cannot contain more than 64
 * characters. The ID is case-preserving and case-insensitive (that is, you may
 * not have two pool IDs within an account that differ only by case).
 *
 * @param {string} [pool.displayName] The display name for the pool. The
 * display name need not be unique and can contain any Unicode characters up to
 * a maximum length of 1024.
 *
 * @param {string} pool.vmSize The size of virtual machines in the pool. All
 * virtual machines in a pool are the same size. For information about
 * available sizes of virtual machines for Cloud Services pools (pools created
 * with cloudServiceConfiguration), see Sizes for Cloud Services
 * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
 * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
 * For information about available VM sizes for pools using images from the
 * Virtual Machines Marketplace (pools created with
 * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
 * or Sizes for Virtual Machines (Windows)
 * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
 * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
 * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
 *
 * @param {object} [pool.cloudServiceConfiguration] The cloud service
 * configuration for the pool. This property and virtualMachineConfiguration
 * are mutually exclusive and one of the properties must be specified. This
 * property cannot be specified if the Batch account was created with its
 * poolAllocationMode property set to 'UserSubscription'.
 *
 * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
 * family to be installed on the virtual machines in the pool. Possible values
 * are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS
 * Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to
 * Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016.
 * For more information, see Azure Guest OS Releases
 * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
 *
 * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
 * Guest OS version to be installed on the virtual machines in the pool. The
 * default value is * which specifies the latest operating system version for
 * the specified OS family.
 *
 * @param {object} [pool.virtualMachineConfiguration] The virtual machine
 * configuration for the pool. This property and cloudServiceConfiguration are
 * mutually exclusive and one of the properties must be specified.
 *
 * @param {object} pool.virtualMachineConfiguration.imageReference A reference
 * to the Azure Virtual Machines Marketplace image or the custom Virtual
 * Machine image to use.
 *
 * @param {string} [pool.virtualMachineConfiguration.imageReference.publisher]
 * The publisher of the Azure Virtual Machines Marketplace image. For example,
 * Canonical or MicrosoftWindowsServer.
 *
 * @param {string} [pool.virtualMachineConfiguration.imageReference.offer] The
 * offer type of the Azure Virtual Machines Marketplace image. For example,
 * UbuntuServer or WindowsServer.
 *
 * @param {string} [pool.virtualMachineConfiguration.imageReference.sku] The
 * SKU of the Azure Virtual Machines Marketplace image. For example,
 * 14.04.0-LTS or 2012-R2-Datacenter.
 *
 * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
 * The version of the Azure Virtual Machines Marketplace image. A value of
 * 'latest' can be specified to select the latest version of an image. If
 * omitted, the default is 'latest'.
 *
 * @param {string}
 * [pool.virtualMachineConfiguration.imageReference.virtualMachineImageId] The
 * ARM resource identifier of the virtual machine image. Computes nodes of the
 * pool will be created using this custom image. This is of the form
 * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/images/{imageName}
 * This property is mutually exclusive with other ImageReference properties.
 * The virtual machine image must be in the same region and subscription as the
 * Azure Batch account. For information about the firewall settings for the
 * Batch node agent to communicate with the Batch service see
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
 *
 * @param {object} [pool.virtualMachineConfiguration.osDisk] Settings for the
 * operating system disk of the Virtual Machine.
 *
 * @param {string} [pool.virtualMachineConfiguration.osDisk.caching] The type
 * of caching to enable for the OS disk. Values are:
 *
 * none - The caching mode for the disk is not enabled.
 * readOnly - The caching mode for the disk is read only.
 * readWrite - The caching mode for the disk is read and write.
 *
 * The default value for caching is none. For information about the caching
 * options see:
 * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
 * Possible values include: 'none', 'readOnly', 'readWrite'
 *
 * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
 * the Batch node agent to be provisioned on compute nodes in the pool. The
 * Batch node agent is a program that runs on each node in the pool, and
 * provides the command-and-control interface between the node and the Batch
 * service. There are different implementations of the node agent, known as
 * SKUs, for different operating systems. You must specify a node agent SKU
 * which matches the selected image reference. To get the list of supported
 * node agent SKUs along with their list of verified image references, see the
 * 'List supported node agent SKUs' operation.
 *
 * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
 * Windows operating system settings on the virtual machine. This property must
 * not be specified if the imageReference or osDisk property specifies a Linux
 * OS image.
 *
 * @param {boolean}
 * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
 * Whether automatic updates are enabled on the virtual machine. If omitted,
 * the default value is true.
 *
 * @param {array} [pool.virtualMachineConfiguration.dataDisks] The
 * configuration for data disks attached to the comptue nodes in the pool. This
 * property must be specified if the compute nodes in the pool need to have
 * empty data disks attached to them. This cannot be updated.
 *
 * @param {string} [pool.virtualMachineConfiguration.licenseType] The type of
 * on-premises license to be used when deploying the operating system. This
 * only applies to images that contain the Windows operating system, and should
 * only be used when you hold valid on-premises licenses for the nodes which
 * will be deployed. If omitted, no on-premises licensing discount is applied.
 * Values are:
 *
 * Windows_Server - The on-premises license is for Windows Server.
 * Windows_Client - The on-premises license is for Windows Client.
 *
 *
 * @param {object} [pool.virtualMachineConfiguration.containerConfiguration]
 * The container configuration for the pool. If specified, setup is performed
 * on each node in the pool to allow tasks to run in containers. All regular
 * tasks and job manager tasks run on this pool must specify the
 * containerSettings property, and all other tasks may specify it.
 *
 * @param {array}
 * [pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
 * The collection of container image names. This is the full image reference,
 * as would be specified to "docker pull". An image will be sourced from the
 * default Docker registry unless the image is fully qualified with an
 * alternative registry.
 *
 * @param {array}
 * [pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
 * Additional private registries from which containers can be pulled. If any
 * images must be downloaded from a private registry which requires
 * credentials, then those credentials must be provided here.
 *
 * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
 * compute nodes to the pool. This timeout applies only to manual scaling; it
 * has no effect when enableAutoScale is set to true. The default value is 15
 * minutes. The minimum value is 5 minutes. If you specify a value less than 5
 * minutes, the Batch service returns an error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request).
 *
 * @param {number} [pool.targetDedicatedNodes] The desired number of dedicated
 * compute nodes in the pool. This property must not be specified if
 * enableAutoScale is set to true. If enableAutoScale is set to false, then you
 * must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
 *
 * @param {number} [pool.targetLowPriorityNodes] The desired number of
 * low-priority compute nodes in the pool. This property must not be specified
 * if enableAutoScale is set to true. If enableAutoScale is set to false, then
 * you must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
 *
 * @param {boolean} [pool.enableAutoScale] Whether the pool size should
 * automatically adjust over time. If false, at least one of
 * targetDedicateNodes and targetLowPriorityNodes must be specified. If true,
 * the autoScaleFormula property is required and the pool automatically resizes
 * according to the formula. The default value is false.
 *
 * @param {string} [pool.autoScaleFormula] A formula for the desired number of
 * compute nodes in the pool. This property must not be specified if
 * enableAutoScale is set to false. It is required if enableAutoScale is set to
 * true. The formula is checked for validity before the pool is created. If the
 * formula is not valid, the Batch service rejects the request with detailed
 * error information. For more information about specifying this formula, see
 * 'Automatically scale compute nodes in an Azure Batch pool'
 * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
 *
 * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
 * interval at which to automatically adjust the pool size according to the
 * autoscale formula. The default value is 15 minutes. The minimum and maximum
 * value are 5 minutes and 168 hours respectively. If you specify a value less
 * than 5 minutes or greater than 168 hours, the Batch service returns an
 * error; if you are calling the REST API directly, the HTTP status code is 400
 * (Bad Request).
 *
 * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
 * permits direct communication between nodes. Enabling inter-node
 * communication limits the maximum size of the pool due to deployment
 * restrictions on the nodes of the pool. This may result in the pool not
 * reaching its desired size. The default value is false.
 *
 * @param {object} [pool.networkConfiguration] The network configuration for
 * the pool.
 *
 * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
 * identifier of the virtual network subnet which the compute nodes of the pool
 * will join. This is of the form
 * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
 * The virtual network must be in the same region and subscription as the Azure
 * Batch account. The specified subnet should have enough free IP addresses to
 * accommodate the number of nodes in the pool. If the subnet doesn't have
 * enough free IP addresses, the pool will partially allocate compute nodes,
 * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
 * must have the 'Classic Virtual Machine Contributor' Role-Based Access
 * Control (RBAC) role for the specified VNet. The specified subnet must allow
 * communication from the Azure Batch service to be able to schedule tasks on
 * the compute nodes. This can be verified by checking if the specified VNet
 * has any associated Network Security Groups (NSG). If communication to the
 * compute nodes in the specified subnet is denied by an NSG, then the Batch
 * service will set the state of the compute nodes to unusable. For pools
 * created with virtualMachineConfiguration only ARM virtual networks
 * ('Microsoft.Network/virtualNetworks') are supported, but for pools created
 * with cloudServiceConfiguration both ARM and classic virtual networks are
 * supported. If the specified VNet has any associated Network Security Groups
 * (NSG), then a few reserved system ports must be enabled for inbound
 * communication. For pools created with a virtual machine configuration,
 * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
 * Windows. For pools created with a cloud service configuration, enable ports
 * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
 * on port 443. For more details see:
 * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
 *
 * @param {object} [pool.networkConfiguration.endpointConfiguration] The
 * configuration for endpoints on compute nodes in the Batch pool. Pool
 * endpoint configuration is only supported on pools with the
 * virtualMachineConfiguration property.
 *
 * @param {array}
 * pool.networkConfiguration.endpointConfiguration.inboundNATPools A list of
 * inbound NAT pools that can be used to address specific ports on an
 * individual compute node externally. The maximum number of inbound NAT pools
 * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
 * the request fails with HTTP status code 400.
 *
 * @param {object} [pool.startTask] A task specified to run on each compute
 * node as it joins the pool. The task runs when the node is added to the pool
 * or when the node is restarted.
 *
 * @param {string} pool.startTask.commandLine The command line of the start
 * task. The command line does not run under a shell, and therefore cannot take
 * advantage of shell features such as environment variable expansion. If you
 * want to take advantage of such features, you should invoke the shell in the
 * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
 * MyCommand" in Linux.
 *
 * @param {object} [pool.startTask.containerSettings] The settings for the
 * container under which the start task runs. When this is specified, all
 * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
 * Batch directories on the node) are mapped into the container, all task
 * environment variables are mapped into the container, and the task command
 * line is executed in the container.
 *
 * @param {string} [pool.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string} pool.startTask.containerSettings.imageName The image to use
 * to create the container in which the task will run. This is the full image
 * reference, as would be specified to "docker pull". If no tag is provided as
 * part of the image name, the tag ":latest" is used as a default.
 *
 * @param {object} [pool.startTask.containerSettings.registry] The private
 * registry which contains the container image. This setting can be omitted if
 * was already provided at pool creation.
 *
 * @param {string} [pool.startTask.containerSettings.registry.registryServer]
 * The registry URL. If omitted, the default is "docker.io".
 *
 * @param {string} pool.startTask.containerSettings.registry.userName The user
 * name to log into the registry server.
 *
 * @param {string} pool.startTask.containerSettings.registry.password The
 * password to log into the registry server.
 *
 * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
 * service will download to the compute node before running the command line.
 * Files listed under this element are located in the task's working directory.
 *
 * @param {array} [pool.startTask.environmentSettings] A list of environment
 * variable settings for the start task.
 *
 * @param {object} [pool.startTask.userIdentity] The user identity under which
 * the start task runs. If omitted, the task runs as a non-administrative user
 * unique to the task.
 *
 * @param {string} [pool.startTask.userIdentity.userName] The name of the user
 * identity under which the task is run. The userName and autoUser properties
 * are mutually exclusive; you must specify one but not both.
 *
 * @param {object} [pool.startTask.userIdentity.autoUser] The auto user under
 * which the task is run. The userName and autoUser properties are mutually
 * exclusive; you must specify one but not both.
 *
 * @param {string} [pool.startTask.userIdentity.autoUser.scope] The scope for
 * the auto user Values are:
 *
 * pool - specifies that the task runs as the common auto user account which is
 * created on every node in a pool.
 * task - specifies that the service should create a new user for the task.
 * The default value is task. Possible values include: 'task', 'pool'
 *
 * @param {string} [pool.startTask.userIdentity.autoUser.elevationLevel] The
 * elevation level of the auto user. nonAdmin - The auto user is a standard
 * user without elevated access. admin - The auto user is a user with elevated
 * access and operates with full Administrator permissions. The default value
 * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
 * times the task may be retried. The Batch service retries a task if its exit
 * code is nonzero. Note that this value specifically controls the number of
 * retries. The Batch service will try the task once, and may then retry up to
 * this limit. For example, if the maximum retry count is 3, Batch tries the
 * task up to 4 times (one initial try and 3 retries). If the maximum retry
 * count is 0, the Batch service does not retry the task. If the maximum retry
 * count is -1, the Batch service retries the task without limit.
 *
 * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
 * should wait for the start task to complete successfully (that is, to exit
 * with exit code 0) before scheduling any tasks on the compute node. If true
 * and the start task fails on a compute node, the Batch service retries the
 * start task up to its maximum retry count (maxTaskRetryCount). If the task
 * has still not completed successfully after all retries, then the Batch
 * service marks the compute node unusable, and will not schedule tasks to it.
 * This condition can be detected via the node state and failure info details.
 * If false, the Batch service will not wait for the start task to complete. In
 * this case, other tasks can start executing on the compute node while the
 * start task is still running; and even if the start task fails, new tasks
 * will continue to be scheduled on the node. The default is false.
 *
 * @param {array} [pool.certificateReferences] The list of certificates to be
 * installed on each compute node in the pool. For Windows compute nodes, the
 * Batch service installs the certificates to the specified certificate store
 * and location. For Linux compute nodes, the certificates are stored in a
 * directory inside the task working directory and an environment variable
 * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
 * location. For certificates with visibility of 'remoteUser', a 'certs'
 * directory is created in the user's home directory (e.g.,
 * /home/{user-name}/certs) and certificates are placed in that directory.
 *
 * @param {array} [pool.applicationPackageReferences] The list of application
 * packages to be installed on each compute node in the pool.
 *
 * @param {array} [pool.applicationLicenses] The list of application licenses
 * the Batch service will make available on each compute node in the pool. The
 * list of application licenses must be a subset of available Batch service
 * application licenses. If a license is requested which is not supported, pool
 * creation will fail.
 *
 * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
 * run concurrently on a single compute node in the pool. The default value is
 * 1. The maximum value of this setting depends on the size of the compute
 * nodes in the pool (the vmSize setting).
 *
 * @param {object} [pool.taskSchedulingPolicy] How tasks are distributed across
 * compute nodes in a pool.
 *
 * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks are
 * distributed across compute nodes in a pool. Values are:
 *
 * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
 * each node in the pool before any tasks are assigned to the next node in the
 * pool.
 * spread - Tasks should be assigned evenly across all nodes in the pool.
 * Possible values include: 'spread', 'pack'
 *
 * @param {array} [pool.userAccounts] The list of user accounts to be created
 * on each node in the pool.
 *
 * @param {array} [pool.metadata] A list of name-value pairs associated with
 * the pool as metadata. The Batch service does not assign any meaning to
 * metadata; it is solely for the use of user code.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolAddOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.poolAddOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolAddOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.poolAddOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _add(pool, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolAddOptions = (options && options.poolAddOptions !== undefined) ? options.poolAddOptions : undefined;
  if (pool === null || pool === undefined)
  {
    pool = {};
  }
  // Validate
  try {
    if (pool === null || pool === undefined) {
      throw new Error('pool cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      timeout = poolAddOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      clientRequestId = poolAddOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      returnClientRequestId = poolAddOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolAddOptions !== null && poolAddOptions !== undefined)
    {
      ocpDate = poolAddOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (pool !== null && pool !== undefined) {
      let requestModelMapper = new client.models['PoolAddParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, pool, 'pool');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(pool, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists all of the pools in the specified account.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolListOptions] Additional parameters for the
 * operation
 *
 * @param {string} [options.poolListOptions.filter] An OData $filter clause.
 * For more information on constructing this filter, see
 * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
 *
 * @param {string} [options.poolListOptions.select] An OData $select clause.
 *
 * @param {string} [options.poolListOptions.expand] An OData $expand clause.
 *
 * @param {number} [options.poolListOptions.maxResults] The maximum number of
 * items to return in the response. A maximum of 1000 pools can be returned.
 *
 * @param {number} [options.poolListOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolListOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.poolListOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudPoolListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolListOptions = (options && options.poolListOptions !== undefined) ? options.poolListOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let filter;
  let select;
  let expand;
  let maxResults;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      filter = poolListOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      select = poolListOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      expand = poolListOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      maxResults = poolListOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      timeout = poolListOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      clientRequestId = poolListOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      returnClientRequestId = poolListOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListOptions !== null && poolListOptions !== undefined)
    {
      ocpDate = poolListOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudPoolListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a pool from the specified account.
 *
 * When you request that a pool be deleted, the following actions occur: the
 * pool state is set to deleting; any ongoing resize operation on the pool are
 * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
 * running on existing nodes are terminated and requeued (as if a resize pool
 * operation had been requested with the default requeue option); finally, the
 * pool is removed from the system. Because running tasks are requeued, the
 * user can rerun these tasks by updating their job to target a different pool.
 * The tasks can then run on the new pool. If you want to override the requeue
 * behavior, then you should call resize pool explicitly to shrink the pool to
 * zero size before deleting the pool. If you call an Update, Patch or Delete
 * API on a pool in the deleting state, it will fail with HTTP status code 409
 * with error code PoolBeingDeleted.
 *
 * @param {string} poolId The ID of the pool to delete.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
 * the operation
 *
 * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 *
 * @param {uuid} [options.poolDeleteMethodOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] A
 * timestamp indicating the last modified time of the resource known to the
 * client. The operation will be performed only if the resource on the service
 * has not been modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(poolId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolDeleteMethodOptions = (options && options.poolDeleteMethodOptions !== undefined) ? options.poolDeleteMethodOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      timeout = poolDeleteMethodOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      clientRequestId = poolDeleteMethodOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      returnClientRequestId = poolDeleteMethodOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ocpDate = poolDeleteMethodOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifMatch = poolDeleteMethodOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifNoneMatch = poolDeleteMethodOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifModifiedSince = poolDeleteMethodOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolDeleteMethodOptions !== null && poolDeleteMethodOptions !== undefined)
    {
      ifUnmodifiedSince = poolDeleteMethodOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets basic properties of a pool.
 *
 * @param {string} poolId The ID of the pool to get.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolExistsOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.poolExistsOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolExistsOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolExistsOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolExistsOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {boolean} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _exists(poolId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolExistsOptions = (options && options.poolExistsOptions !== undefined) ? options.poolExistsOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      timeout = poolExistsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      clientRequestId = poolExistsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      returnClientRequestId = poolExistsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ocpDate = poolExistsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifMatch = poolExistsOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifNoneMatch = poolExistsOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifModifiedSince = poolExistsOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolExistsOptions !== null && poolExistsOptions !== undefined)
    {
      ifUnmodifiedSince = poolExistsOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    result = (statusCode === 200);

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets information about the specified pool.
 *
 * @param {string} poolId The ID of the pool to get.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolGetOptions] Additional parameters for the
 * operation
 *
 * @param {string} [options.poolGetOptions.select] An OData $select clause.
 *
 * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
 *
 * @param {number} [options.poolGetOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolGetOptions.clientRequestId] The caller-generated
 * request identity, in the form of a GUID with no decoration such as curly
 * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.poolGetOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolGetOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolGetOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolGetOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudPool} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(poolId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolGetOptions = (options && options.poolGetOptions !== undefined) ? options.poolGetOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let select;
  let expand;
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      select = poolGetOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      expand = poolGetOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      timeout = poolGetOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      clientRequestId = poolGetOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      returnClientRequestId = poolGetOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ocpDate = poolGetOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifMatch = poolGetOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifNoneMatch = poolGetOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifModifiedSince = poolGetOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolGetOptions !== null && poolGetOptions !== undefined)
    {
      ifUnmodifiedSince = poolGetOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudPool']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the properties of the specified pool.
 *
 * This only replaces the pool properties specified in the request. For
 * example, if the pool has a start task associated with it, and a request does
 * not specify a start task element, then the pool keeps the existing start
 * task.
 *
 * @param {string} poolId The ID of the pool to update.
 *
 * @param {object} poolPatchParameter The parameters for the request.
 *
 * @param {object} [poolPatchParameter.startTask] A task to run on each compute
 * node as it joins the pool. The task runs when the node is added to the pool
 * or when the node is restarted. If this element is present, it overwrites any
 * existing start task. If omitted, any existing start task is left unchanged.
 *
 * @param {string} poolPatchParameter.startTask.commandLine The command line of
 * the start task. The command line does not run under a shell, and therefore
 * cannot take advantage of shell features such as environment variable
 * expansion. If you want to take advantage of such features, you should invoke
 * the shell in the command line, for example using "cmd /c MyCommand" in
 * Windows or "/bin/sh -c MyCommand" in Linux.
 *
 * @param {object} [poolPatchParameter.startTask.containerSettings] The
 * settings for the container under which the start task runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all task environment variables are mapped into the container, and the task
 * command line is executed in the container.
 *
 * @param {string}
 * [poolPatchParameter.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string} poolPatchParameter.startTask.containerSettings.imageName The
 * image to use to create the container in which the task will run. This is the
 * full image reference, as would be specified to "docker pull". If no tag is
 * provided as part of the image name, the tag ":latest" is used as a default.
 *
 * @param {object} [poolPatchParameter.startTask.containerSettings.registry]
 * The private registry which contains the container image. This setting can be
 * omitted if was already provided at pool creation.
 *
 * @param {string}
 * [poolPatchParameter.startTask.containerSettings.registry.registryServer] The
 * registry URL. If omitted, the default is "docker.io".
 *
 * @param {string}
 * poolPatchParameter.startTask.containerSettings.registry.userName The user
 * name to log into the registry server.
 *
 * @param {string}
 * poolPatchParameter.startTask.containerSettings.registry.password The
 * password to log into the registry server.
 *
 * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
 * that the Batch service will download to the compute node before running the
 * command line. Files listed under this element are located in the task's
 * working directory.
 *
 * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
 * environment variable settings for the start task.
 *
 * @param {object} [poolPatchParameter.startTask.userIdentity] The user
 * identity under which the start task runs. If omitted, the task runs as a
 * non-administrative user unique to the task.
 *
 * @param {string} [poolPatchParameter.startTask.userIdentity.userName] The
 * name of the user identity under which the task is run. The userName and
 * autoUser properties are mutually exclusive; you must specify one but not
 * both.
 *
 * @param {object} [poolPatchParameter.startTask.userIdentity.autoUser] The
 * auto user under which the task is run. The userName and autoUser properties
 * are mutually exclusive; you must specify one but not both.
 *
 * @param {string} [poolPatchParameter.startTask.userIdentity.autoUser.scope]
 * The scope for the auto user Values are:
 *
 * pool - specifies that the task runs as the common auto user account which is
 * created on every node in a pool.
 * task - specifies that the service should create a new user for the task.
 * The default value is task. Possible values include: 'task', 'pool'
 *
 * @param {string}
 * [poolPatchParameter.startTask.userIdentity.autoUser.elevationLevel] The
 * elevation level of the auto user. nonAdmin - The auto user is a standard
 * user without elevated access. admin - The auto user is a user with elevated
 * access and operates with full Administrator permissions. The default value
 * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
 * number of times the task may be retried. The Batch service retries a task if
 * its exit code is nonzero. Note that this value specifically controls the
 * number of retries. The Batch service will try the task once, and may then
 * retry up to this limit. For example, if the maximum retry count is 3, Batch
 * tries the task up to 4 times (one initial try and 3 retries). If the maximum
 * retry count is 0, the Batch service does not retry the task. If the maximum
 * retry count is -1, the Batch service retries the task without limit.
 *
 * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
 * Batch service should wait for the start task to complete successfully (that
 * is, to exit with exit code 0) before scheduling any tasks on the compute
 * node. If true and the start task fails on a compute node, the Batch service
 * retries the start task up to its maximum retry count (maxTaskRetryCount). If
 * the task has still not completed successfully after all retries, then the
 * Batch service marks the compute node unusable, and will not schedule tasks
 * to it. This condition can be detected via the node state and failure info
 * details. If false, the Batch service will not wait for the start task to
 * complete. In this case, other tasks can start executing on the compute node
 * while the start task is still running; and even if the start task fails, new
 * tasks will continue to be scheduled on the node. The default is false.
 *
 * @param {array} [poolPatchParameter.certificateReferences] A list of
 * certificates to be installed on each compute node in the pool. If this
 * element is present, it replaces any existing certificate references
 * configured on the pool. If omitted, any existing certificate references are
 * left unchanged. For Windows compute nodes, the Batch service installs the
 * certificates to the specified certificate store and location. For Linux
 * compute nodes, the certificates are stored in a directory inside the task
 * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
 * supplied to the task to query for this location. For certificates with
 * visibility of 'remoteUser', a 'certs' directory is created in the user's
 * home directory (e.g., /home/{user-name}/certs) and certificates are placed
 * in that directory.
 *
 * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
 * application packages to be installed on each compute node in the pool.
 * Changes to application package references affect all new compute nodes
 * joining the pool, but do not affect compute nodes that are already in the
 * pool until they are rebooted or reimaged. If this element is present, it
 * replaces any existing application package references. If you specify an
 * empty collection, then all application package references are removed from
 * the pool. If omitted, any existing application package references are left
 * unchanged.
 *
 * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
 * associated with the pool as metadata. If this element is present, it
 * replaces any existing metadata configured on the pool. If you specify an
 * empty collection, any metadata is removed from the pool. If omitted, any
 * existing metadata is left unchanged.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolPatchOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
 * server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolPatchOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolPatchOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolPatchOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _patch(poolId, poolPatchParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolPatchOptions = (options && options.poolPatchOptions !== undefined) ? options.poolPatchOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolPatchParameter === null || poolPatchParameter === undefined) {
      throw new Error('poolPatchParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      timeout = poolPatchOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      clientRequestId = poolPatchOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      returnClientRequestId = poolPatchOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ocpDate = poolPatchOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifMatch = poolPatchOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifNoneMatch = poolPatchOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifModifiedSince = poolPatchOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolPatchOptions !== null && poolPatchOptions !== undefined)
    {
      ifUnmodifiedSince = poolPatchOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolPatchParameter !== null && poolPatchParameter !== undefined) {
      let requestModelMapper = new client.models['PoolPatchParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolPatchParameter, 'poolPatchParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolPatchParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Disables automatic scaling for a pool.
 *
 * @param {string} poolId The ID of the pool on which to disable automatic
 * scaling.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
 * for the operation
 *
 * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.poolDisableAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disableAutoScale(poolId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolDisableAutoScaleOptions = (options && options.poolDisableAutoScaleOptions !== undefined) ? options.poolDisableAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      timeout = poolDisableAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      clientRequestId = poolDisableAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolDisableAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolDisableAutoScaleOptions !== null && poolDisableAutoScaleOptions !== undefined)
    {
      ocpDate = poolDisableAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/disableautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enables automatic scaling for a pool.
 *
 * You cannot enable automatic scaling on a pool if a resize operation is in
 * progress on the pool. If automatic scaling of the pool is currently
 * disabled, you must specify a valid autoscale formula as part of the request.
 * If automatic scaling of the pool is already enabled, you may specify a new
 * autoscale formula and/or a new evaluation interval. You cannot call this API
 * for the same pool more than once every 30 seconds.
 *
 * @param {string} poolId The ID of the pool on which to enable automatic
 * scaling.
 *
 * @param {object} poolEnableAutoScaleParameter The parameters for the request.
 *
 * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
 * for the desired number of compute nodes in the pool. The formula is checked
 * for validity before it is applied to the pool. If the formula is not valid,
 * the Batch service rejects the request with detailed error information. For
 * more information about specifying this formula, see Automatically scale
 * compute nodes in an Azure Batch pool
 * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
 *
 * @param {moment.duration}
 * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
 * at which to automatically adjust the pool size according to the autoscale
 * formula. The default value is 15 minutes. The minimum and maximum value are
 * 5 minutes and 168 hours respectively. If you specify a value less than 5
 * minutes or greater than 168 hours, the Batch service rejects the request
 * with an invalid property value error; if you are calling the REST API
 * directly, the HTTP status code is 400 (Bad Request). If you specify a new
 * interval, then the existing autoscale evaluation schedule will be stopped
 * and a new autoscale evaluation schedule will be started, with its starting
 * time being the time when this request was issued.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
 * for the operation
 *
 * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.poolEnableAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag
 * value associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] A
 * timestamp indicating the last modified time of the resource known to the
 * client. The operation will be performed only if the resource on the service
 * has been modified since the specified time.
 *
 * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] A
 * timestamp indicating the last modified time of the resource known to the
 * client. The operation will be performed only if the resource on the service
 * has not been modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enableAutoScale(poolId, poolEnableAutoScaleParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolEnableAutoScaleOptions = (options && options.poolEnableAutoScaleOptions !== undefined) ? options.poolEnableAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolEnableAutoScaleParameter === null || poolEnableAutoScaleParameter === undefined) {
      throw new Error('poolEnableAutoScaleParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      timeout = poolEnableAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      clientRequestId = poolEnableAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolEnableAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ocpDate = poolEnableAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifMatch = poolEnableAutoScaleOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifNoneMatch = poolEnableAutoScaleOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifModifiedSince = poolEnableAutoScaleOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolEnableAutoScaleOptions !== null && poolEnableAutoScaleOptions !== undefined)
    {
      ifUnmodifiedSince = poolEnableAutoScaleOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/enableautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolEnableAutoScaleParameter !== null && poolEnableAutoScaleParameter !== undefined) {
      let requestModelMapper = new client.models['PoolEnableAutoScaleParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolEnableAutoScaleParameter, 'poolEnableAutoScaleParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolEnableAutoScaleParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the result of evaluating an automatic scaling formula on the
 * pool.
 *
 * This API is primarily for validating an autoscale formula, as it simply
 * returns the result without applying the formula to the pool. The pool must
 * have auto scaling enabled in order to evaluate a formula.
 *
 * @param {string} poolId The ID of the pool on which to evaluate the automatic
 * scaling formula.
 *
 * @param {string} autoScaleFormula The formula for the desired number of
 * compute nodes in the pool. The formula is validated and its results
 * calculated, but it is not applied to the pool. To apply the formula to the
 * pool, 'Enable automatic scaling on a pool'. For more information about
 * specifying this formula, see Automatically scale compute nodes in an Azure
 * Batch pool
 * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
 * for the operation
 *
 * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AutoScaleRun} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _evaluateAutoScale(poolId, autoScaleFormula, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolEvaluateAutoScaleOptions = (options && options.poolEvaluateAutoScaleOptions !== undefined) ? options.poolEvaluateAutoScaleOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (autoScaleFormula === null || autoScaleFormula === undefined || typeof autoScaleFormula.valueOf() !== 'string') {
      throw new Error('autoScaleFormula cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let poolEvaluateAutoScaleParameter = new client.models['PoolEvaluateAutoScaleParameter']();
  try {
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      timeout = poolEvaluateAutoScaleOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      clientRequestId = poolEvaluateAutoScaleOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      returnClientRequestId = poolEvaluateAutoScaleOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolEvaluateAutoScaleOptions !== null && poolEvaluateAutoScaleOptions !== undefined)
    {
      ocpDate = poolEvaluateAutoScaleOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (autoScaleFormula !== null && autoScaleFormula !== undefined)
    {
      poolEvaluateAutoScaleParameter.autoScaleFormula = autoScaleFormula;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/evaluateautoscale';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolEvaluateAutoScaleParameter !== null && poolEvaluateAutoScaleParameter !== undefined) {
      let requestModelMapper = new client.models['PoolEvaluateAutoScaleParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolEvaluateAutoScaleParameter, 'poolEvaluateAutoScaleParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolEvaluateAutoScaleParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AutoScaleRun']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Changes the number of compute nodes that are assigned to a pool.
 *
 * You can only resize a pool when its allocation state is steady. If the pool
 * is already resizing, the request fails with status code 409. When you resize
 * a pool, the pool's allocation state changes from steady to resizing. You
 * cannot resize pools which are configured for automatic scaling. If you try
 * to do this, the Batch service returns an error 409. If you resize a pool
 * downwards, the Batch service chooses which nodes to remove. To remove
 * specific nodes, use the pool remove nodes API instead.
 *
 * @param {string} poolId The ID of the pool to resize.
 *
 * @param {object} poolResizeParameter The parameters for the request.
 *
 * @param {number} [poolResizeParameter.targetDedicatedNodes] The desired
 * number of dedicated compute nodes in the pool.
 *
 * @param {number} [poolResizeParameter.targetLowPriorityNodes] The desired
 * number of low-priority compute nodes in the pool.
 *
 * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
 * allocation of compute nodes to the pool or removal of compute nodes from the
 * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
 * you specify a value less than 5 minutes, the Batch service returns an error;
 * if you are calling the REST API directly, the HTTP status code is 400 (Bad
 * Request).
 *
 * @param {string} [poolResizeParameter.nodeDeallocationOption] Determines what
 * to do with a node and its running task(s) if the pool size is decreasing.
 * The default value is requeue. Possible values include: 'requeue',
 * 'terminate', 'taskCompletion', 'retainedData'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolResizeOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.poolResizeOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolResizeOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolResizeOptions.ifMatch] An ETag value associated
 * with the version of the resource known to the client. The operation will be
 * performed only if the resource's current ETag on the service exactly matches
 * the value specified by the client.
 *
 * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolResizeOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resize(poolId, poolResizeParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolResizeOptions = (options && options.poolResizeOptions !== undefined) ? options.poolResizeOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolResizeParameter === null || poolResizeParameter === undefined) {
      throw new Error('poolResizeParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      timeout = poolResizeOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      clientRequestId = poolResizeOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      returnClientRequestId = poolResizeOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ocpDate = poolResizeOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifMatch = poolResizeOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifNoneMatch = poolResizeOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifModifiedSince = poolResizeOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolResizeOptions !== null && poolResizeOptions !== undefined)
    {
      ifUnmodifiedSince = poolResizeOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/resize';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolResizeParameter !== null && poolResizeParameter !== undefined) {
      let requestModelMapper = new client.models['PoolResizeParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolResizeParameter, 'poolResizeParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolResizeParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops an ongoing resize operation on the pool.
 *
 * This does not restore the pool to its previous state before the resize
 * operation: it only stops any further changes being made, and the pool
 * maintains its current state. After stopping, the pool stabilizes at the
 * number of nodes it was at when the stop operation was done. During the stop
 * operation, the pool allocation state changes first to stopping and then to
 * steady. A resize operation need not be an explicit resize pool request; this
 * API can also be used to halt the initial sizing of the pool when it is
 * created.
 *
 * @param {string} poolId The ID of the pool whose resizing you want to stop.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolStopResizeOptions] Additional parameters for
 * the operation
 *
 * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 *
 * @param {uuid} [options.poolStopResizeOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolStopResizeOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopResize(poolId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolStopResizeOptions = (options && options.poolStopResizeOptions !== undefined) ? options.poolStopResizeOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      timeout = poolStopResizeOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      clientRequestId = poolStopResizeOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      returnClientRequestId = poolStopResizeOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ocpDate = poolStopResizeOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifMatch = poolStopResizeOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifNoneMatch = poolStopResizeOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifModifiedSince = poolStopResizeOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolStopResizeOptions !== null && poolStopResizeOptions !== undefined)
    {
      ifUnmodifiedSince = poolStopResizeOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/stopresize';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the properties of the specified pool.
 *
 * This fully replaces all the updateable properties of the pool. For example,
 * if the pool has a start task associated with it and if start task is not
 * specified with this request, then the Batch service will remove the existing
 * start task.
 *
 * @param {string} poolId The ID of the pool to update.
 *
 * @param {object} poolUpdatePropertiesParameter The parameters for the
 * request.
 *
 * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
 * each compute node as it joins the pool. The task runs when the node is added
 * to the pool or when the node is restarted. If this element is present, it
 * overwrites any existing start task. If omitted, any existing start task is
 * removed from the pool.
 *
 * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
 * command line of the start task. The command line does not run under a shell,
 * and therefore cannot take advantage of shell features such as environment
 * variable expansion. If you want to take advantage of such features, you
 * should invoke the shell in the command line, for example using "cmd /c
 * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
 *
 * @param {object} [poolUpdatePropertiesParameter.startTask.containerSettings]
 * The settings for the container under which the start task runs. When this is
 * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
 * root of Azure Batch directories on the node) are mapped into the container,
 * all task environment variables are mapped into the container, and the task
 * command line is executed in the container.
 *
 * @param {string}
 * [poolUpdatePropertiesParameter.startTask.containerSettings.containerRunOptions]
 * Additional options to the container create command. These additional options
 * are supplied as arguments to the "docker create" command, in addition to
 * those controlled by the Batch Service.
 *
 * @param {string}
 * poolUpdatePropertiesParameter.startTask.containerSettings.imageName The
 * image to use to create the container in which the task will run. This is the
 * full image reference, as would be specified to "docker pull". If no tag is
 * provided as part of the image name, the tag ":latest" is used as a default.
 *
 * @param {object}
 * [poolUpdatePropertiesParameter.startTask.containerSettings.registry] The
 * private registry which contains the container image. This setting can be
 * omitted if was already provided at pool creation.
 *
 * @param {string}
 * [poolUpdatePropertiesParameter.startTask.containerSettings.registry.registryServer]
 * The registry URL. If omitted, the default is "docker.io".
 *
 * @param {string}
 * poolUpdatePropertiesParameter.startTask.containerSettings.registry.userName
 * The user name to log into the registry server.
 *
 * @param {string}
 * poolUpdatePropertiesParameter.startTask.containerSettings.registry.password
 * The password to log into the registry server.
 *
 * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
 * list of files that the Batch service will download to the compute node
 * before running the command line. Files listed under this element are located
 * in the task's working directory.
 *
 * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
 * A list of environment variable settings for the start task.
 *
 * @param {object} [poolUpdatePropertiesParameter.startTask.userIdentity] The
 * user identity under which the start task runs. If omitted, the task runs as
 * a non-administrative user unique to the task.
 *
 * @param {string}
 * [poolUpdatePropertiesParameter.startTask.userIdentity.userName] The name of
 * the user identity under which the task is run. The userName and autoUser
 * properties are mutually exclusive; you must specify one but not both.
 *
 * @param {object}
 * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser] The auto
 * user under which the task is run. The userName and autoUser properties are
 * mutually exclusive; you must specify one but not both.
 *
 * @param {string}
 * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.scope] The
 * scope for the auto user Values are:
 *
 * pool - specifies that the task runs as the common auto user account which is
 * created on every node in a pool.
 * task - specifies that the service should create a new user for the task.
 * The default value is task. Possible values include: 'task', 'pool'
 *
 * @param {string}
 * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.elevationLevel]
 * The elevation level of the auto user. nonAdmin - The auto user is a standard
 * user without elevated access. admin - The auto user is a user with elevated
 * access and operates with full Administrator permissions. The default value
 * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
 *
 * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
 * The maximum number of times the task may be retried. The Batch service
 * retries a task if its exit code is nonzero. Note that this value
 * specifically controls the number of retries. The Batch service will try the
 * task once, and may then retry up to this limit. For example, if the maximum
 * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
 * retries). If the maximum retry count is 0, the Batch service does not retry
 * the task. If the maximum retry count is -1, the Batch service retries the
 * task without limit.
 *
 * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
 * Whether the Batch service should wait for the start task to complete
 * successfully (that is, to exit with exit code 0) before scheduling any tasks
 * on the compute node. If true and the start task fails on a compute node, the
 * Batch service retries the start task up to its maximum retry count
 * (maxTaskRetryCount). If the task has still not completed successfully after
 * all retries, then the Batch service marks the compute node unusable, and
 * will not schedule tasks to it. This condition can be detected via the node
 * state and failure info details. If false, the Batch service will not wait
 * for the start task to complete. In this case, other tasks can start
 * executing on the compute node while the start task is still running; and
 * even if the start task fails, new tasks will continue to be scheduled on the
 * node. The default is false.
 *
 * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
 * certificates to be installed on each compute node in the pool. This list
 * replaces any existing certificate references configured on the pool. If you
 * specify an empty collection, any existing certificate references are removed
 * from the pool. For Windows compute nodes, the Batch service installs the
 * certificates to the specified certificate store and location. For Linux
 * compute nodes, the certificates are stored in a directory inside the task
 * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
 * supplied to the task to query for this location. For certificates with
 * visibility of 'remoteUser', a 'certs' directory is created in the user's
 * home directory (e.g., /home/{user-name}/certs) and certificates are placed
 * in that directory.
 *
 * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
 * list of application packages to be installed on each compute node in the
 * pool. The list replaces any existing application package references on the
 * pool. Changes to application package references affect all new compute nodes
 * joining the pool, but do not affect compute nodes that are already in the
 * pool until they are rebooted or reimaged. If omitted, or if you specify an
 * empty collection, any existing application packages references are removed
 * from the pool.
 *
 * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
 * pairs associated with the pool as metadata. This list replaces any existing
 * metadata configured on the pool. If omitted, or if you specify an empty
 * collection, any existing metadata is removed from the pool.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
 * for the operation
 *
 * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 *
 * @param {uuid} [options.poolUpdatePropertiesOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateProperties(poolId, poolUpdatePropertiesParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolUpdatePropertiesOptions = (options && options.poolUpdatePropertiesOptions !== undefined) ? options.poolUpdatePropertiesOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (poolUpdatePropertiesParameter === null || poolUpdatePropertiesParameter === undefined) {
      throw new Error('poolUpdatePropertiesParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      timeout = poolUpdatePropertiesOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      clientRequestId = poolUpdatePropertiesOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      returnClientRequestId = poolUpdatePropertiesOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolUpdatePropertiesOptions !== null && poolUpdatePropertiesOptions !== undefined)
    {
      ocpDate = poolUpdatePropertiesOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/updateproperties';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolUpdatePropertiesParameter !== null && poolUpdatePropertiesParameter !== undefined) {
      let requestModelMapper = new client.models['PoolUpdatePropertiesParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolUpdatePropertiesParameter, 'poolUpdatePropertiesParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolUpdatePropertiesParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Upgrades the operating system of the specified pool.
 *
 * During an upgrade, the Batch service upgrades each compute node in the pool.
 * When a compute node is chosen for upgrade, any tasks running on that node
 * are removed from the node and returned to the queue to be rerun later (or on
 * a different compute node). The node will be unavailable until the upgrade is
 * complete. This operation results in temporarily reduced pool capacity as
 * nodes are taken out of service to be upgraded. Although the Batch service
 * tries to avoid upgrading all compute nodes at the same time, it does not
 * guarantee to do this (particularly on small pools); therefore, the pool may
 * be temporarily unavailable to run tasks. When this operation runs, the pool
 * state changes to upgrading. When all compute nodes have finished upgrading,
 * the pool state returns to active. While the upgrade is in progress, the
 * pool's currentOSVersion reflects the OS version that nodes are upgrading
 * from, and targetOSVersion reflects the OS version that nodes are upgrading
 * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
 * OS version now running on all nodes. This operation can only be invoked on
 * pools created with the cloudServiceConfiguration property.
 *
 * @param {string} poolId The ID of the pool to upgrade.
 *
 * @param {string} targetOSVersion The Azure Guest OS version to be installed
 * on the virtual machines in the pool.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
 * the server can spend processing the request, in seconds. The default is 30
 * seconds.
 *
 * @param {uuid} [options.poolUpgradeOSOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _upgradeOS(poolId, targetOSVersion, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolUpgradeOSOptions = (options && options.poolUpgradeOSOptions !== undefined) ? options.poolUpgradeOSOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (targetOSVersion === null || targetOSVersion === undefined || typeof targetOSVersion.valueOf() !== 'string') {
      throw new Error('targetOSVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  let poolUpgradeOSParameter = new client.models['PoolUpgradeOSParameter']();
  try {
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      timeout = poolUpgradeOSOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      clientRequestId = poolUpgradeOSOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      returnClientRequestId = poolUpgradeOSOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ocpDate = poolUpgradeOSOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifMatch = poolUpgradeOSOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifNoneMatch = poolUpgradeOSOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifModifiedSince = poolUpgradeOSOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolUpgradeOSOptions !== null && poolUpgradeOSOptions !== undefined)
    {
      ifUnmodifiedSince = poolUpgradeOSOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
    if (targetOSVersion !== null && targetOSVersion !== undefined)
    {
      poolUpgradeOSParameter.targetOSVersion = targetOSVersion;
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/upgradeos';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (poolUpgradeOSParameter !== null && poolUpgradeOSParameter !== undefined) {
      let requestModelMapper = new client.models['PoolUpgradeOSParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, poolUpgradeOSParameter, 'poolUpgradeOSParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(poolUpgradeOSParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes compute nodes from the specified pool.
 *
 * This operation can only run when the allocation state of the pool is steady.
 * When this operation runs, the allocation state changes from steady to
 * resizing.
 *
 * @param {string} poolId The ID of the pool from which you want to remove
 * nodes.
 *
 * @param {object} nodeRemoveParameter The parameters for the request.
 *
 * @param {array} nodeRemoveParameter.nodeList A list containing the IDs of the
 * compute nodes to be removed from the specified pool.
 *
 * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
 * removal of compute nodes to the pool. The default value is 15 minutes. The
 * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
 * Batch service returns an error; if you are calling the REST API directly,
 * the HTTP status code is 400 (Bad Request).
 *
 * @param {string} [nodeRemoveParameter.nodeDeallocationOption] Determines what
 * to do with a node and its running task(s) after it has been selected for
 * deallocation. The default value is requeue. Possible values include:
 * 'requeue', 'terminate', 'taskCompletion', 'retainedData'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
 * the operation
 *
 * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
 * that the server can spend processing the request, in seconds. The default is
 * 30 seconds.
 *
 * @param {uuid} [options.poolRemoveNodesOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
 * Whether the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
 * was issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service exactly matches the value specified by the client.
 *
 * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag value
 * associated with the version of the resource known to the client. The
 * operation will be performed only if the resource's current ETag on the
 * service does not match the value specified by the client.
 *
 * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has been
 * modified since the specified time.
 *
 * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] A timestamp
 * indicating the last modified time of the resource known to the client. The
 * operation will be performed only if the resource on the service has not been
 * modified since the specified time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeNodes(poolId, nodeRemoveParameter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolRemoveNodesOptions = (options && options.poolRemoveNodesOptions !== undefined) ? options.poolRemoveNodesOptions : undefined;
  // Validate
  try {
    if (poolId === null || poolId === undefined || typeof poolId.valueOf() !== 'string') {
      throw new Error('poolId cannot be null or undefined and it must be of type string.');
    }
    if (nodeRemoveParameter === null || nodeRemoveParameter === undefined) {
      throw new Error('nodeRemoveParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let timeout;
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  let ifMatch;
  let ifNoneMatch;
  let ifModifiedSince;
  let ifUnmodifiedSince;
  try {
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      timeout = poolRemoveNodesOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      clientRequestId = poolRemoveNodesOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      returnClientRequestId = poolRemoveNodesOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ocpDate = poolRemoveNodesOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifMatch = poolRemoveNodesOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifNoneMatch = poolRemoveNodesOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifModifiedSince = poolRemoveNodesOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date ||
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (poolRemoveNodesOptions !== null && poolRemoveNodesOptions !== undefined)
    {
      ifUnmodifiedSince = poolRemoveNodesOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date ||
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'pools/{poolId}/removenodes';
  requestUrl = requestUrl.replace('{poolId}', encodeURIComponent(poolId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (nodeRemoveParameter !== null && nodeRemoveParameter !== undefined) {
      let requestModelMapper = new client.models['NodeRemoveParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, nodeRemoveParameter, 'nodeRemoveParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(nodeRemoveParameter, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists the usage metrics, aggregated by pool across individual time
 * intervals, for the specified account.
 *
 * If you do not specify a $filter clause including a poolId, the response
 * includes all pools that existed in the account in the time range of the
 * returned aggregation intervals. If you do not specify a $filter clause
 * including a startTime or endTime these filters default to the start and end
 * times of the last aggregation interval currently available; that is, only
 * the last aggregation interval is returned.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolListUsageMetricsNextOptions] Additional
 * parameters for the operation
 *
 * @param {uuid} [options.poolListUsageMetricsNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean}
 * [options.poolListUsageMetricsNextOptions.returnClientRequestId] Whether the
 * server should return the client-request-id in the response.
 *
 * @param {date} [options.poolListUsageMetricsNextOptions.ocpDate] The time the
 * request was issued. Client libraries typically set this to the current
 * system clock time; set it explicitly if you are calling the REST API
 * directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PoolListUsageMetricsResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsageMetricsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolListUsageMetricsNextOptions = (options && options.poolListUsageMetricsNextOptions !== undefined) ? options.poolListUsageMetricsNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined)
    {
      clientRequestId = poolListUsageMetricsNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined)
    {
      returnClientRequestId = poolListUsageMetricsNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListUsageMetricsNextOptions !== null && poolListUsageMetricsNextOptions !== undefined)
    {
      ocpDate = poolListUsageMetricsNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PoolListUsageMetricsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists all of the pools in the specified account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.poolListNextOptions] Additional parameters for the
 * operation
 *
 * @param {uuid} [options.poolListNextOptions.clientRequestId] The
 * caller-generated request identity, in the form of a GUID with no decoration
 * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 *
 * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
 * the server should return the client-request-id in the response.
 *
 * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
 * issued. Client libraries typically set this to the current system clock
 * time; set it explicitly if you are calling the REST API directly.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CloudPoolListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let poolListNextOptions = (options && options.poolListNextOptions !== undefined) ? options.poolListNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let clientRequestId;
  let returnClientRequestId;
  let ocpDate;
  try {
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      clientRequestId = poolListNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && !(typeof clientRequestId.valueOf() === 'string' && msRest.isValidUuid(clientRequestId))) {
        throw new Error('clientRequestId must be of type string and must be a valid uuid.');
      }
    }
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      returnClientRequestId = poolListNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (poolListNextOptions !== null && poolListNextOptions !== undefined)
    {
      ocpDate = poolListNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date ||
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId.toString();
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CloudPoolListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a Pool. */
class Pool {
  /**
   * Create a Pool.
   * @param {BatchServiceClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._listUsageMetrics = _listUsageMetrics;
    this._getAllLifetimeStatistics = _getAllLifetimeStatistics;
    this._add = _add;
    this._list = _list;
    this._deleteMethod = _deleteMethod;
    this._exists = _exists;
    this._get = _get;
    this._patch = _patch;
    this._disableAutoScale = _disableAutoScale;
    this._enableAutoScale = _enableAutoScale;
    this._evaluateAutoScale = _evaluateAutoScale;
    this._resize = _resize;
    this._stopResize = _stopResize;
    this._updateProperties = _updateProperties;
    this._upgradeOS = _upgradeOS;
    this._removeNodes = _removeNodes;
    this._listUsageMetricsNext = _listUsageMetricsNext;
    this._listNext = _listNext;
  }

  /**
   * @summary Lists the usage metrics, aggregated by pool across individual time
   * intervals, for the specified account.
   *
   * If you do not specify a $filter clause including a poolId, the response
   * includes all pools that existed in the account in the time range of the
   * returned aggregation intervals. If you do not specify a $filter clause
   * including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only
   * the last aggregation interval is returned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListUsageMetricsOptions] Additional parameters
   * for the operation
   *
   * @param {date} [options.poolListUsageMetricsOptions.startTime] The earliest
   * time from which to include metrics. This must be at least two and a half
   * hours before the current time. If not specified this defaults to the start
   * time of the last aggregation interval currently available.
   *
   * @param {date} [options.poolListUsageMetricsOptions.endTime] The latest time
   * from which to include metrics. This must be at least two hours before the
   * current time. If not specified this defaults to the end time of the last
   * aggregation interval currently available.
   *
   * @param {string} [options.poolListUsageMetricsOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
   *
   * @param {number} [options.poolListUsageMetricsOptions.maxResults] The maximum
   * number of items to return in the response. A maximum of 1000 results will be
   * returned.
   *
   * @param {number} [options.poolListUsageMetricsOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolListUsageMetricsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListUsageMetricsOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListUsageMetricsOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsageMetricsWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsageMetrics(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the usage metrics, aggregated by pool across individual time
   * intervals, for the specified account.
   *
   * If you do not specify a $filter clause including a poolId, the response
   * includes all pools that existed in the account in the time range of the
   * returned aggregation intervals. If you do not specify a $filter clause
   * including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only
   * the last aggregation interval is returned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListUsageMetricsOptions] Additional parameters
   * for the operation
   *
   * @param {date} [options.poolListUsageMetricsOptions.startTime] The earliest
   * time from which to include metrics. This must be at least two and a half
   * hours before the current time. If not specified this defaults to the start
   * time of the last aggregation interval currently available.
   *
   * @param {date} [options.poolListUsageMetricsOptions.endTime] The latest time
   * from which to include metrics. This must be at least two hours before the
   * current time. If not specified this defaults to the end time of the last
   * aggregation interval currently available.
   *
   * @param {string} [options.poolListUsageMetricsOptions.filter] An OData
   * $filter clause. For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
   *
   * @param {number} [options.poolListUsageMetricsOptions.maxResults] The maximum
   * number of items to return in the response. A maximum of 1000 results will be
   * returned.
   *
   * @param {number} [options.poolListUsageMetricsOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolListUsageMetricsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListUsageMetricsOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListUsageMetricsOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PoolListUsageMetricsResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PoolListUsageMetricsResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsageMetrics(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsageMetrics(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsageMetrics(options, optionalCallback);
    }
  }

  /**
   * @summary Gets lifetime summary statistics for all of the pools in the
   * specified account.
   *
   * Statistics are aggregated across all pools that have ever existed in the
   * account, from account creation to the last update time of the statistics.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolGetAllLifetimeStatisticsOptions] Additional
   * parameters for the operation
   *
   * @param {number} [options.poolGetAllLifetimeStatisticsOptions.timeout] The
   * maximum time that the server can spend processing the request, in seconds.
   * The default is 30 seconds.
   *
   * @param {uuid} [options.poolGetAllLifetimeStatisticsOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolGetAllLifetimeStatisticsOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PoolStatistics>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllLifetimeStatisticsWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllLifetimeStatistics(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets lifetime summary statistics for all of the pools in the
   * specified account.
   *
   * Statistics are aggregated across all pools that have ever existed in the
   * account, from account creation to the last update time of the statistics.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolGetAllLifetimeStatisticsOptions] Additional
   * parameters for the operation
   *
   * @param {number} [options.poolGetAllLifetimeStatisticsOptions.timeout] The
   * maximum time that the server can spend processing the request, in seconds.
   * The default is 30 seconds.
   *
   * @param {uuid} [options.poolGetAllLifetimeStatisticsOptions.clientRequestId]
   * The caller-generated request identity, in the form of a GUID with no
   * decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolGetAllLifetimeStatisticsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolGetAllLifetimeStatisticsOptions.ocpDate] The time
   * the request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PoolStatistics} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PoolStatistics} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllLifetimeStatistics(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllLifetimeStatistics(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllLifetimeStatistics(options, optionalCallback);
    }
  }

  /**
   * @summary Adds a pool to the specified account.
   *
   * When naming pools, avoid including sensitive information such as user names
   * or secret project names. This information may appear in telemetry logs
   * accessible to Microsoft Support engineers.
   *
   * @param {object} pool The pool to be added.
   *
   * @param {string} pool.id A string that uniquely identifies the pool within
   * the account. The ID can contain any combination of alphanumeric characters
   * including hyphens and underscores, and cannot contain more than 64
   * characters. The ID is case-preserving and case-insensitive (that is, you may
   * not have two pool IDs within an account that differ only by case).
   *
   * @param {string} [pool.displayName] The display name for the pool. The
   * display name need not be unique and can contain any Unicode characters up to
   * a maximum length of 1024.
   *
   * @param {string} pool.vmSize The size of virtual machines in the pool. All
   * virtual machines in a pool are the same size. For information about
   * available sizes of virtual machines for Cloud Services pools (pools created
   * with cloudServiceConfiguration), see Sizes for Cloud Services
   * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
   * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
   * For information about available VM sizes for pools using images from the
   * Virtual Machines Marketplace (pools created with
   * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
   * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
   * or Sizes for Virtual Machines (Windows)
   * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
   * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
   * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
   *
   * @param {object} [pool.cloudServiceConfiguration] The cloud service
   * configuration for the pool. This property and virtualMachineConfiguration
   * are mutually exclusive and one of the properties must be specified. This
   * property cannot be specified if the Batch account was created with its
   * poolAllocationMode property set to 'UserSubscription'.
   *
   * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
   * family to be installed on the virtual machines in the pool. Possible values
   * are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS
   * Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to
   * Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016.
   * For more information, see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
   * Guest OS version to be installed on the virtual machines in the pool. The
   * default value is * which specifies the latest operating system version for
   * the specified OS family.
   *
   * @param {object} [pool.virtualMachineConfiguration] The virtual machine
   * configuration for the pool. This property and cloudServiceConfiguration are
   * mutually exclusive and one of the properties must be specified.
   *
   * @param {object} pool.virtualMachineConfiguration.imageReference A reference
   * to the Azure Virtual Machines Marketplace image or the custom Virtual
   * Machine image to use.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.offer] The
   * offer type of the Azure Virtual Machines Marketplace image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.sku] The
   * SKU of the Azure Virtual Machines Marketplace image. For example,
   * 14.04.0-LTS or 2012-R2-Datacenter.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace image. A value of
   * 'latest' can be specified to select the latest version of an image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [pool.virtualMachineConfiguration.imageReference.virtualMachineImageId] The
   * ARM resource identifier of the virtual machine image. Computes nodes of the
   * pool will be created using this custom image. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/images/{imageName}
   * This property is mutually exclusive with other ImageReference properties.
   * The virtual machine image must be in the same region and subscription as the
   * Azure Batch account. For information about the firewall settings for the
   * Batch node agent to communicate with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {object} [pool.virtualMachineConfiguration.osDisk] Settings for the
   * operating system disk of the Virtual Machine.
   *
   * @param {string} [pool.virtualMachineConfiguration.osDisk.caching] The type
   * of caching to enable for the OS disk. Values are:
   *
   * none - The caching mode for the disk is not enabled.
   * readOnly - The caching mode for the disk is read only.
   * readWrite - The caching mode for the disk is read and write.
   *
   * The default value for caching is none. For information about the caching
   * options see:
   * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
   * Possible values include: 'none', 'readOnly', 'readWrite'
   *
   * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
   * the Batch node agent to be provisioned on compute nodes in the pool. The
   * Batch node agent is a program that runs on each node in the pool, and
   * provides the command-and-control interface between the node and the Batch
   * service. There are different implementations of the node agent, known as
   * SKUs, for different operating systems. You must specify a node agent SKU
   * which matches the selected image reference. To get the list of supported
   * node agent SKUs along with their list of verified image references, see the
   * 'List supported node agent SKUs' operation.
   *
   * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference or osDisk property specifies a Linux
   * OS image.
   *
   * @param {boolean}
   * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array} [pool.virtualMachineConfiguration.dataDisks] The
   * configuration for data disks attached to the comptue nodes in the pool. This
   * property must be specified if the compute nodes in the pool need to have
   * empty data disks attached to them. This cannot be updated.
   *
   * @param {string} [pool.virtualMachineConfiguration.licenseType] The type of
   * on-premises license to be used when deploying the operating system. This
   * only applies to images that contain the Windows operating system, and should
   * only be used when you hold valid on-premises licenses for the nodes which
   * will be deployed. If omitted, no on-premises licensing discount is applied.
   * Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object} [pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the pool. If specified, setup is performed
   * on each node in the pool to allow tasks to run in containers. All regular
   * tasks and job manager tasks run on this pool must specify the
   * containerSettings property, and all other tasks may specify it.
   *
   * @param {array}
   * [pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container image names. This is the full image reference,
   * as would be specified to "docker pull". An image will be sourced from the
   * default Docker registry unless the image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
   * compute nodes to the pool. This timeout applies only to manual scaling; it
   * has no effect when enableAutoScale is set to true. The default value is 15
   * minutes. The minimum value is 5 minutes. If you specify a value less than 5
   * minutes, the Batch service returns an error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {number} [pool.targetDedicatedNodes] The desired number of dedicated
   * compute nodes in the pool. This property must not be specified if
   * enableAutoScale is set to true. If enableAutoScale is set to false, then you
   * must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
   *
   * @param {number} [pool.targetLowPriorityNodes] The desired number of
   * low-priority compute nodes in the pool. This property must not be specified
   * if enableAutoScale is set to true. If enableAutoScale is set to false, then
   * you must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
   *
   * @param {boolean} [pool.enableAutoScale] Whether the pool size should
   * automatically adjust over time. If false, at least one of
   * targetDedicateNodes and targetLowPriorityNodes must be specified. If true,
   * the autoScaleFormula property is required and the pool automatically resizes
   * according to the formula. The default value is false.
   *
   * @param {string} [pool.autoScaleFormula] A formula for the desired number of
   * compute nodes in the pool. This property must not be specified if
   * enableAutoScale is set to false. It is required if enableAutoScale is set to
   * true. The formula is checked for validity before the pool is created. If the
   * formula is not valid, the Batch service rejects the request with detailed
   * error information. For more information about specifying this formula, see
   * 'Automatically scale compute nodes in an Azure Batch pool'
   * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
   *
   * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
   * interval at which to automatically adjust the pool size according to the
   * autoscale formula. The default value is 15 minutes. The minimum and maximum
   * value are 5 minutes and 168 hours respectively. If you specify a value less
   * than 5 minutes or greater than 168 hours, the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request).
   *
   * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
   * permits direct communication between nodes. Enabling inter-node
   * communication limits the maximum size of the pool due to deployment
   * restrictions on the nodes of the pool. This may result in the pool not
   * reaching its desired size. The default value is false.
   *
   * @param {object} [pool.networkConfiguration] The network configuration for
   * the pool.
   *
   * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
   * identifier of the virtual network subnet which the compute nodes of the pool
   * will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch account. The specified subnet should have enough free IP addresses to
   * accommodate the number of nodes in the pool. If the subnet doesn't have
   * enough free IP addresses, the pool will partially allocate compute nodes,
   * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
   * must have the 'Classic Virtual Machine Contributor' Role-Based Access
   * Control (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule tasks on
   * the compute nodes. This can be verified by checking if the specified VNet
   * has any associated Network Security Groups (NSG). If communication to the
   * compute nodes in the specified subnet is denied by an NSG, then the Batch
   * service will set the state of the compute nodes to unusable. For pools
   * created with virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {object} [pool.networkConfiguration.endpointConfiguration] The
   * configuration for endpoints on compute nodes in the Batch pool. Pool
   * endpoint configuration is only supported on pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * pool.networkConfiguration.endpointConfiguration.inboundNATPools A list of
   * inbound NAT pools that can be used to address specific ports on an
   * individual compute node externally. The maximum number of inbound NAT pools
   * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
   * the request fails with HTTP status code 400.
   *
   * @param {object} [pool.startTask] A task specified to run on each compute
   * node as it joins the pool. The task runs when the node is added to the pool
   * or when the node is restarted.
   *
   * @param {string} pool.startTask.commandLine The command line of the start
   * task. The command line does not run under a shell, and therefore cannot take
   * advantage of shell features such as environment variable expansion. If you
   * want to take advantage of such features, you should invoke the shell in the
   * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
   * MyCommand" in Linux.
   *
   * @param {object} [pool.startTask.containerSettings] The settings for the
   * container under which the start task runs. When this is specified, all
   * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
   * Batch directories on the node) are mapped into the container, all task
   * environment variables are mapped into the container, and the task command
   * line is executed in the container.
   *
   * @param {string} [pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string} pool.startTask.containerSettings.imageName The image to use
   * to create the container in which the task will run. This is the full image
   * reference, as would be specified to "docker pull". If no tag is provided as
   * part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object} [pool.startTask.containerSettings.registry] The private
   * registry which contains the container image. This setting can be omitted if
   * was already provided at pool creation.
   *
   * @param {string} [pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string} pool.startTask.containerSettings.registry.userName The user
   * name to log into the registry server.
   *
   * @param {string} pool.startTask.containerSettings.registry.password The
   * password to log into the registry server.
   *
   * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
   * service will download to the compute node before running the command line.
   * Files listed under this element are located in the task's working directory.
   *
   * @param {array} [pool.startTask.environmentSettings] A list of environment
   * variable settings for the start task.
   *
   * @param {object} [pool.startTask.userIdentity] The user identity under which
   * the start task runs. If omitted, the task runs as a non-administrative user
   * unique to the task.
   *
   * @param {string} [pool.startTask.userIdentity.userName] The name of the user
   * identity under which the task is run. The userName and autoUser properties
   * are mutually exclusive; you must specify one but not both.
   *
   * @param {object} [pool.startTask.userIdentity.autoUser] The auto user under
   * which the task is run. The userName and autoUser properties are mutually
   * exclusive; you must specify one but not both.
   *
   * @param {string} [pool.startTask.userIdentity.autoUser.scope] The scope for
   * the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string} [pool.startTask.userIdentity.autoUser.elevationLevel] The
   * elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
   * times the task may be retried. The Batch service retries a task if its exit
   * code is nonzero. Note that this value specifically controls the number of
   * retries. The Batch service will try the task once, and may then retry up to
   * this limit. For example, if the maximum retry count is 3, Batch tries the
   * task up to 4 times (one initial try and 3 retries). If the maximum retry
   * count is 0, the Batch service does not retry the task. If the maximum retry
   * count is -1, the Batch service retries the task without limit.
   *
   * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
   * should wait for the start task to complete successfully (that is, to exit
   * with exit code 0) before scheduling any tasks on the compute node. If true
   * and the start task fails on a compute node, the Batch service retries the
   * start task up to its maximum retry count (maxTaskRetryCount). If the task
   * has still not completed successfully after all retries, then the Batch
   * service marks the compute node unusable, and will not schedule tasks to it.
   * This condition can be detected via the node state and failure info details.
   * If false, the Batch service will not wait for the start task to complete. In
   * this case, other tasks can start executing on the compute node while the
   * start task is still running; and even if the start task fails, new tasks
   * will continue to be scheduled on the node. The default is false.
   *
   * @param {array} [pool.certificateReferences] The list of certificates to be
   * installed on each compute node in the pool. For Windows compute nodes, the
   * Batch service installs the certificates to the specified certificate store
   * and location. For Linux compute nodes, the certificates are stored in a
   * directory inside the task working directory and an environment variable
   * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
   * location. For certificates with visibility of 'remoteUser', a 'certs'
   * directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and certificates are placed in that directory.
   *
   * @param {array} [pool.applicationPackageReferences] The list of application
   * packages to be installed on each compute node in the pool.
   *
   * @param {array} [pool.applicationLicenses] The list of application licenses
   * the Batch service will make available on each compute node in the pool. The
   * list of application licenses must be a subset of available Batch service
   * application licenses. If a license is requested which is not supported, pool
   * creation will fail.
   *
   * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
   * run concurrently on a single compute node in the pool. The default value is
   * 1. The maximum value of this setting depends on the size of the compute
   * nodes in the pool (the vmSize setting).
   *
   * @param {object} [pool.taskSchedulingPolicy] How tasks are distributed across
   * compute nodes in a pool.
   *
   * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks are
   * distributed across compute nodes in a pool. Values are:
   *
   * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
   * each node in the pool before any tasks are assigned to the next node in the
   * pool.
   * spread - Tasks should be assigned evenly across all nodes in the pool.
   * Possible values include: 'spread', 'pack'
   *
   * @param {array} [pool.userAccounts] The list of user accounts to be created
   * on each node in the pool.
   *
   * @param {array} [pool.metadata] A list of name-value pairs associated with
   * the pool as metadata. The Batch service does not assign any meaning to
   * metadata; it is solely for the use of user code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolAddOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolAddOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolAddOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolAddOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addWithHttpOperationResponse(pool, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._add(pool, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a pool to the specified account.
   *
   * When naming pools, avoid including sensitive information such as user names
   * or secret project names. This information may appear in telemetry logs
   * accessible to Microsoft Support engineers.
   *
   * @param {object} pool The pool to be added.
   *
   * @param {string} pool.id A string that uniquely identifies the pool within
   * the account. The ID can contain any combination of alphanumeric characters
   * including hyphens and underscores, and cannot contain more than 64
   * characters. The ID is case-preserving and case-insensitive (that is, you may
   * not have two pool IDs within an account that differ only by case).
   *
   * @param {string} [pool.displayName] The display name for the pool. The
   * display name need not be unique and can contain any Unicode characters up to
   * a maximum length of 1024.
   *
   * @param {string} pool.vmSize The size of virtual machines in the pool. All
   * virtual machines in a pool are the same size. For information about
   * available sizes of virtual machines for Cloud Services pools (pools created
   * with cloudServiceConfiguration), see Sizes for Cloud Services
   * (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
   * Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2.
   * For information about available VM sizes for pools using images from the
   * Virtual Machines Marketplace (pools created with
   * virtualMachineConfiguration) see Sizes for Virtual Machines (Linux)
   * (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
   * or Sizes for Virtual Machines (Windows)
   * (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
   * Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
   * storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
   *
   * @param {object} [pool.cloudServiceConfiguration] The cloud service
   * configuration for the pool. This property and virtualMachineConfiguration
   * are mutually exclusive and one of the properties must be specified. This
   * property cannot be specified if the Batch account was created with its
   * poolAllocationMode property set to 'UserSubscription'.
   *
   * @param {string} pool.cloudServiceConfiguration.osFamily The Azure Guest OS
   * family to be installed on the virtual machines in the pool. Possible values
   * are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS
   * Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to
   * Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016.
   * For more information, see Azure Guest OS Releases
   * (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
   *
   * @param {string} [pool.cloudServiceConfiguration.targetOSVersion] The Azure
   * Guest OS version to be installed on the virtual machines in the pool. The
   * default value is * which specifies the latest operating system version for
   * the specified OS family.
   *
   * @param {object} [pool.virtualMachineConfiguration] The virtual machine
   * configuration for the pool. This property and cloudServiceConfiguration are
   * mutually exclusive and one of the properties must be specified.
   *
   * @param {object} pool.virtualMachineConfiguration.imageReference A reference
   * to the Azure Virtual Machines Marketplace image or the custom Virtual
   * Machine image to use.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.publisher]
   * The publisher of the Azure Virtual Machines Marketplace image. For example,
   * Canonical or MicrosoftWindowsServer.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.offer] The
   * offer type of the Azure Virtual Machines Marketplace image. For example,
   * UbuntuServer or WindowsServer.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.sku] The
   * SKU of the Azure Virtual Machines Marketplace image. For example,
   * 14.04.0-LTS or 2012-R2-Datacenter.
   *
   * @param {string} [pool.virtualMachineConfiguration.imageReference.version]
   * The version of the Azure Virtual Machines Marketplace image. A value of
   * 'latest' can be specified to select the latest version of an image. If
   * omitted, the default is 'latest'.
   *
   * @param {string}
   * [pool.virtualMachineConfiguration.imageReference.virtualMachineImageId] The
   * ARM resource identifier of the virtual machine image. Computes nodes of the
   * pool will be created using this custom image. This is of the form
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/images/{imageName}
   * This property is mutually exclusive with other ImageReference properties.
   * The virtual machine image must be in the same region and subscription as the
   * Azure Batch account. For information about the firewall settings for the
   * Batch node agent to communicate with the Batch service see
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
   *
   * @param {object} [pool.virtualMachineConfiguration.osDisk] Settings for the
   * operating system disk of the Virtual Machine.
   *
   * @param {string} [pool.virtualMachineConfiguration.osDisk.caching] The type
   * of caching to enable for the OS disk. Values are:
   *
   * none - The caching mode for the disk is not enabled.
   * readOnly - The caching mode for the disk is read only.
   * readWrite - The caching mode for the disk is read and write.
   *
   * The default value for caching is none. For information about the caching
   * options see:
   * https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
   * Possible values include: 'none', 'readOnly', 'readWrite'
   *
   * @param {string} pool.virtualMachineConfiguration.nodeAgentSKUId The SKU of
   * the Batch node agent to be provisioned on compute nodes in the pool. The
   * Batch node agent is a program that runs on each node in the pool, and
   * provides the command-and-control interface between the node and the Batch
   * service. There are different implementations of the node agent, known as
   * SKUs, for different operating systems. You must specify a node agent SKU
   * which matches the selected image reference. To get the list of supported
   * node agent SKUs along with their list of verified image references, see the
   * 'List supported node agent SKUs' operation.
   *
   * @param {object} [pool.virtualMachineConfiguration.windowsConfiguration]
   * Windows operating system settings on the virtual machine. This property must
   * not be specified if the imageReference or osDisk property specifies a Linux
   * OS image.
   *
   * @param {boolean}
   * [pool.virtualMachineConfiguration.windowsConfiguration.enableAutomaticUpdates]
   * Whether automatic updates are enabled on the virtual machine. If omitted,
   * the default value is true.
   *
   * @param {array} [pool.virtualMachineConfiguration.dataDisks] The
   * configuration for data disks attached to the comptue nodes in the pool. This
   * property must be specified if the compute nodes in the pool need to have
   * empty data disks attached to them. This cannot be updated.
   *
   * @param {string} [pool.virtualMachineConfiguration.licenseType] The type of
   * on-premises license to be used when deploying the operating system. This
   * only applies to images that contain the Windows operating system, and should
   * only be used when you hold valid on-premises licenses for the nodes which
   * will be deployed. If omitted, no on-premises licensing discount is applied.
   * Values are:
   *
   * Windows_Server - The on-premises license is for Windows Server.
   * Windows_Client - The on-premises license is for Windows Client.
   *
   *
   * @param {object} [pool.virtualMachineConfiguration.containerConfiguration]
   * The container configuration for the pool. If specified, setup is performed
   * on each node in the pool to allow tasks to run in containers. All regular
   * tasks and job manager tasks run on this pool must specify the
   * containerSettings property, and all other tasks may specify it.
   *
   * @param {array}
   * [pool.virtualMachineConfiguration.containerConfiguration.containerImageNames]
   * The collection of container image names. This is the full image reference,
   * as would be specified to "docker pull". An image will be sourced from the
   * default Docker registry unless the image is fully qualified with an
   * alternative registry.
   *
   * @param {array}
   * [pool.virtualMachineConfiguration.containerConfiguration.containerRegistries]
   * Additional private registries from which containers can be pulled. If any
   * images must be downloaded from a private registry which requires
   * credentials, then those credentials must be provided here.
   *
   * @param {moment.duration} [pool.resizeTimeout] The timeout for allocation of
   * compute nodes to the pool. This timeout applies only to manual scaling; it
   * has no effect when enableAutoScale is set to true. The default value is 15
   * minutes. The minimum value is 5 minutes. If you specify a value less than 5
   * minutes, the Batch service returns an error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request).
   *
   * @param {number} [pool.targetDedicatedNodes] The desired number of dedicated
   * compute nodes in the pool. This property must not be specified if
   * enableAutoScale is set to true. If enableAutoScale is set to false, then you
   * must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
   *
   * @param {number} [pool.targetLowPriorityNodes] The desired number of
   * low-priority compute nodes in the pool. This property must not be specified
   * if enableAutoScale is set to true. If enableAutoScale is set to false, then
   * you must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
   *
   * @param {boolean} [pool.enableAutoScale] Whether the pool size should
   * automatically adjust over time. If false, at least one of
   * targetDedicateNodes and targetLowPriorityNodes must be specified. If true,
   * the autoScaleFormula property is required and the pool automatically resizes
   * according to the formula. The default value is false.
   *
   * @param {string} [pool.autoScaleFormula] A formula for the desired number of
   * compute nodes in the pool. This property must not be specified if
   * enableAutoScale is set to false. It is required if enableAutoScale is set to
   * true. The formula is checked for validity before the pool is created. If the
   * formula is not valid, the Batch service rejects the request with detailed
   * error information. For more information about specifying this formula, see
   * 'Automatically scale compute nodes in an Azure Batch pool'
   * (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
   *
   * @param {moment.duration} [pool.autoScaleEvaluationInterval] The time
   * interval at which to automatically adjust the pool size according to the
   * autoscale formula. The default value is 15 minutes. The minimum and maximum
   * value are 5 minutes and 168 hours respectively. If you specify a value less
   * than 5 minutes or greater than 168 hours, the Batch service returns an
   * error; if you are calling the REST API directly, the HTTP status code is 400
   * (Bad Request).
   *
   * @param {boolean} [pool.enableInterNodeCommunication] Whether the pool
   * permits direct communication between nodes. Enabling inter-node
   * communication limits the maximum size of the pool due to deployment
   * restrictions on the nodes of the pool. This may result in the pool not
   * reaching its desired size. The default value is false.
   *
   * @param {object} [pool.networkConfiguration] The network configuration for
   * the pool.
   *
   * @param {string} [pool.networkConfiguration.subnetId] The ARM resource
   * identifier of the virtual network subnet which the compute nodes of the pool
   * will join. This is of the form
   * /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
   * The virtual network must be in the same region and subscription as the Azure
   * Batch account. The specified subnet should have enough free IP addresses to
   * accommodate the number of nodes in the pool. If the subnet doesn't have
   * enough free IP addresses, the pool will partially allocate compute nodes,
   * and a resize error will occur. The 'MicrosoftAzureBatch' service principal
   * must have the 'Classic Virtual Machine Contributor' Role-Based Access
   * Control (RBAC) role for the specified VNet. The specified subnet must allow
   * communication from the Azure Batch service to be able to schedule tasks on
   * the compute nodes. This can be verified by checking if the specified VNet
   * has any associated Network Security Groups (NSG). If communication to the
   * compute nodes in the specified subnet is denied by an NSG, then the Batch
   * service will set the state of the compute nodes to unusable. For pools
   * created with virtualMachineConfiguration only ARM virtual networks
   * ('Microsoft.Network/virtualNetworks') are supported, but for pools created
   * with cloudServiceConfiguration both ARM and classic virtual networks are
   * supported. If the specified VNet has any associated Network Security Groups
   * (NSG), then a few reserved system ports must be enabled for inbound
   * communication. For pools created with a virtual machine configuration,
   * enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
   * Windows. For pools created with a cloud service configuration, enable ports
   * 10100, 20100, and 30100. Also enable outbound connections to Azure Storage
   * on port 443. For more details see:
   * https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
   *
   * @param {object} [pool.networkConfiguration.endpointConfiguration] The
   * configuration for endpoints on compute nodes in the Batch pool. Pool
   * endpoint configuration is only supported on pools with the
   * virtualMachineConfiguration property.
   *
   * @param {array}
   * pool.networkConfiguration.endpointConfiguration.inboundNATPools A list of
   * inbound NAT pools that can be used to address specific ports on an
   * individual compute node externally. The maximum number of inbound NAT pools
   * per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded
   * the request fails with HTTP status code 400.
   *
   * @param {object} [pool.startTask] A task specified to run on each compute
   * node as it joins the pool. The task runs when the node is added to the pool
   * or when the node is restarted.
   *
   * @param {string} pool.startTask.commandLine The command line of the start
   * task. The command line does not run under a shell, and therefore cannot take
   * advantage of shell features such as environment variable expansion. If you
   * want to take advantage of such features, you should invoke the shell in the
   * command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c
   * MyCommand" in Linux.
   *
   * @param {object} [pool.startTask.containerSettings] The settings for the
   * container under which the start task runs. When this is specified, all
   * directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure
   * Batch directories on the node) are mapped into the container, all task
   * environment variables are mapped into the container, and the task command
   * line is executed in the container.
   *
   * @param {string} [pool.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string} pool.startTask.containerSettings.imageName The image to use
   * to create the container in which the task will run. This is the full image
   * reference, as would be specified to "docker pull". If no tag is provided as
   * part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object} [pool.startTask.containerSettings.registry] The private
   * registry which contains the container image. This setting can be omitted if
   * was already provided at pool creation.
   *
   * @param {string} [pool.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string} pool.startTask.containerSettings.registry.userName The user
   * name to log into the registry server.
   *
   * @param {string} pool.startTask.containerSettings.registry.password The
   * password to log into the registry server.
   *
   * @param {array} [pool.startTask.resourceFiles] A list of files that the Batch
   * service will download to the compute node before running the command line.
   * Files listed under this element are located in the task's working directory.
   *
   * @param {array} [pool.startTask.environmentSettings] A list of environment
   * variable settings for the start task.
   *
   * @param {object} [pool.startTask.userIdentity] The user identity under which
   * the start task runs. If omitted, the task runs as a non-administrative user
   * unique to the task.
   *
   * @param {string} [pool.startTask.userIdentity.userName] The name of the user
   * identity under which the task is run. The userName and autoUser properties
   * are mutually exclusive; you must specify one but not both.
   *
   * @param {object} [pool.startTask.userIdentity.autoUser] The auto user under
   * which the task is run. The userName and autoUser properties are mutually
   * exclusive; you must specify one but not both.
   *
   * @param {string} [pool.startTask.userIdentity.autoUser.scope] The scope for
   * the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string} [pool.startTask.userIdentity.autoUser.elevationLevel] The
   * elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [pool.startTask.maxTaskRetryCount] The maximum number of
   * times the task may be retried. The Batch service retries a task if its exit
   * code is nonzero. Note that this value specifically controls the number of
   * retries. The Batch service will try the task once, and may then retry up to
   * this limit. For example, if the maximum retry count is 3, Batch tries the
   * task up to 4 times (one initial try and 3 retries). If the maximum retry
   * count is 0, the Batch service does not retry the task. If the maximum retry
   * count is -1, the Batch service retries the task without limit.
   *
   * @param {boolean} [pool.startTask.waitForSuccess] Whether the Batch service
   * should wait for the start task to complete successfully (that is, to exit
   * with exit code 0) before scheduling any tasks on the compute node. If true
   * and the start task fails on a compute node, the Batch service retries the
   * start task up to its maximum retry count (maxTaskRetryCount). If the task
   * has still not completed successfully after all retries, then the Batch
   * service marks the compute node unusable, and will not schedule tasks to it.
   * This condition can be detected via the node state and failure info details.
   * If false, the Batch service will not wait for the start task to complete. In
   * this case, other tasks can start executing on the compute node while the
   * start task is still running; and even if the start task fails, new tasks
   * will continue to be scheduled on the node. The default is false.
   *
   * @param {array} [pool.certificateReferences] The list of certificates to be
   * installed on each compute node in the pool. For Windows compute nodes, the
   * Batch service installs the certificates to the specified certificate store
   * and location. For Linux compute nodes, the certificates are stored in a
   * directory inside the task working directory and an environment variable
   * AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this
   * location. For certificates with visibility of 'remoteUser', a 'certs'
   * directory is created in the user's home directory (e.g.,
   * /home/{user-name}/certs) and certificates are placed in that directory.
   *
   * @param {array} [pool.applicationPackageReferences] The list of application
   * packages to be installed on each compute node in the pool.
   *
   * @param {array} [pool.applicationLicenses] The list of application licenses
   * the Batch service will make available on each compute node in the pool. The
   * list of application licenses must be a subset of available Batch service
   * application licenses. If a license is requested which is not supported, pool
   * creation will fail.
   *
   * @param {number} [pool.maxTasksPerNode] The maximum number of tasks that can
   * run concurrently on a single compute node in the pool. The default value is
   * 1. The maximum value of this setting depends on the size of the compute
   * nodes in the pool (the vmSize setting).
   *
   * @param {object} [pool.taskSchedulingPolicy] How tasks are distributed across
   * compute nodes in a pool.
   *
   * @param {string} pool.taskSchedulingPolicy.nodeFillType How tasks are
   * distributed across compute nodes in a pool. Values are:
   *
   * pack - As many tasks as possible (maxTasksPerNode) should be assigned to
   * each node in the pool before any tasks are assigned to the next node in the
   * pool.
   * spread - Tasks should be assigned evenly across all nodes in the pool.
   * Possible values include: 'spread', 'pack'
   *
   * @param {array} [pool.userAccounts] The list of user accounts to be created
   * on each node in the pool.
   *
   * @param {array} [pool.metadata] A list of name-value pairs associated with
   * the pool as metadata. The Batch service does not assign any meaning to
   * metadata; it is solely for the use of user code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolAddOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolAddOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolAddOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolAddOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolAddOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  add(pool, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._add(pool, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._add(pool, options, optionalCallback);
    }
  }

  /**
   * @summary Lists all of the pools in the specified account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.poolListOptions.filter] An OData $filter clause.
   * For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
   *
   * @param {string} [options.poolListOptions.select] An OData $select clause.
   *
   * @param {string} [options.poolListOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.poolListOptions.maxResults] The maximum number of
   * items to return in the response. A maximum of 1000 pools can be returned.
   *
   * @param {number} [options.poolListOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolListOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists all of the pools in the specified account.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.poolListOptions.filter] An OData $filter clause.
   * For more information on constructing this filter, see
   * https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
   *
   * @param {string} [options.poolListOptions.select] An OData $select clause.
   *
   * @param {string} [options.poolListOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.poolListOptions.maxResults] The maximum number of
   * items to return in the response. A maximum of 1000 pools can be returned.
   *
   * @param {number} [options.poolListOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolListOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudPoolListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudPoolListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a pool from the specified account.
   *
   * When you request that a pool be deleted, the following actions occur: the
   * pool state is set to deleting; any ongoing resize operation on the pool are
   * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
   * running on existing nodes are terminated and requeued (as if a resize pool
   * operation had been requested with the default requeue option); finally, the
   * pool is removed from the system. Because running tasks are requeued, the
   * user can rerun these tasks by updating their job to target a different pool.
   * The tasks can then run on the new pool. If you want to override the requeue
   * behavior, then you should call resize pool explicitly to shrink the pool to
   * zero size before deleting the pool. If you call an Update, Patch or Delete
   * API on a pool in the deleting state, it will fail with HTTP status code 409
   * with error code PoolBeingDeleted.
   *
   * @param {string} poolId The ID of the pool to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolDeleteMethodOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has not been modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(poolId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(poolId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a pool from the specified account.
   *
   * When you request that a pool be deleted, the following actions occur: the
   * pool state is set to deleting; any ongoing resize operation on the pool are
   * stopped; the Batch service starts resizing the pool to zero nodes; any tasks
   * running on existing nodes are terminated and requeued (as if a resize pool
   * operation had been requested with the default requeue option); finally, the
   * pool is removed from the system. Because running tasks are requeued, the
   * user can rerun these tasks by updating their job to target a different pool.
   * The tasks can then run on the new pool. If you want to override the requeue
   * behavior, then you should call resize pool explicitly to shrink the pool to
   * zero size before deleting the pool. If you call an Update, Patch or Delete
   * API on a pool in the deleting state, it will fail with HTTP status code 409
   * with error code PoolBeingDeleted.
   *
   * @param {string} poolId The ID of the pool to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolDeleteMethodOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolDeleteMethodOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolDeleteMethodOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolDeleteMethodOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolDeleteMethodOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolDeleteMethodOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolDeleteMethodOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolDeleteMethodOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolDeleteMethodOptions.ifUnmodifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has not been modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(poolId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(poolId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(poolId, options, optionalCallback);
    }
  }

  /**
   * Gets basic properties of a pool.
   *
   * @param {string} poolId The ID of the pool to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolExistsOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolExistsOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolExistsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolExistsOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolExistsOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Boolean>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  existsWithHttpOperationResponse(poolId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._exists(poolId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets basic properties of a pool.
   *
   * @param {string} poolId The ID of the pool to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolExistsOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolExistsOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolExistsOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolExistsOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolExistsOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolExistsOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolExistsOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolExistsOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolExistsOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Boolean} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {boolean} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  exists(poolId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._exists(poolId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._exists(poolId, options, optionalCallback);
    }
  }

  /**
   * Gets information about the specified pool.
   *
   * @param {string} poolId The ID of the pool to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolGetOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.poolGetOptions.select] An OData $select clause.
   *
   * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.poolGetOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolGetOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolGetOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolGetOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolGetOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolGetOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudPool>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(poolId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(poolId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets information about the specified pool.
   *
   * @param {string} poolId The ID of the pool to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolGetOptions] Additional parameters for the
   * operation
   *
   * @param {string} [options.poolGetOptions.select] An OData $select clause.
   *
   * @param {string} [options.poolGetOptions.expand] An OData $expand clause.
   *
   * @param {number} [options.poolGetOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolGetOptions.clientRequestId] The caller-generated
   * request identity, in the form of a GUID with no decoration such as curly
   * braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolGetOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolGetOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolGetOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolGetOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolGetOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolGetOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudPool} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudPool} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(poolId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(poolId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(poolId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the properties of the specified pool.
   *
   * This only replaces the pool properties specified in the request. For
   * example, if the pool has a start task associated with it, and a request does
   * not specify a start task element, then the pool keeps the existing start
   * task.
   *
   * @param {string} poolId The ID of the pool to update.
   *
   * @param {object} poolPatchParameter The parameters for the request.
   *
   * @param {object} [poolPatchParameter.startTask] A task to run on each compute
   * node as it joins the pool. The task runs when the node is added to the pool
   * or when the node is restarted. If this element is present, it overwrites any
   * existing start task. If omitted, any existing start task is left unchanged.
   *
   * @param {string} poolPatchParameter.startTask.commandLine The command line of
   * the start task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux.
   *
   * @param {object} [poolPatchParameter.startTask.containerSettings] The
   * settings for the container under which the start task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all task environment variables are mapped into the container, and the task
   * command line is executed in the container.
   *
   * @param {string}
   * [poolPatchParameter.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string} poolPatchParameter.startTask.containerSettings.imageName The
   * image to use to create the container in which the task will run. This is the
   * full image reference, as would be specified to "docker pull". If no tag is
   * provided as part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object} [poolPatchParameter.startTask.containerSettings.registry]
   * The private registry which contains the container image. This setting can be
   * omitted if was already provided at pool creation.
   *
   * @param {string}
   * [poolPatchParameter.startTask.containerSettings.registry.registryServer] The
   * registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * poolPatchParameter.startTask.containerSettings.registry.userName The user
   * name to log into the registry server.
   *
   * @param {string}
   * poolPatchParameter.startTask.containerSettings.registry.password The
   * password to log into the registry server.
   *
   * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
   * that the Batch service will download to the compute node before running the
   * command line. Files listed under this element are located in the task's
   * working directory.
   *
   * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
   * environment variable settings for the start task.
   *
   * @param {object} [poolPatchParameter.startTask.userIdentity] The user
   * identity under which the start task runs. If omitted, the task runs as a
   * non-administrative user unique to the task.
   *
   * @param {string} [poolPatchParameter.startTask.userIdentity.userName] The
   * name of the user identity under which the task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object} [poolPatchParameter.startTask.userIdentity.autoUser] The
   * auto user under which the task is run. The userName and autoUser properties
   * are mutually exclusive; you must specify one but not both.
   *
   * @param {string} [poolPatchParameter.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [poolPatchParameter.startTask.userIdentity.autoUser.elevationLevel] The
   * elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
   * number of times the task may be retried. The Batch service retries a task if
   * its exit code is nonzero. Note that this value specifically controls the
   * number of retries. The Batch service will try the task once, and may then
   * retry up to this limit. For example, if the maximum retry count is 3, Batch
   * tries the task up to 4 times (one initial try and 3 retries). If the maximum
   * retry count is 0, the Batch service does not retry the task. If the maximum
   * retry count is -1, the Batch service retries the task without limit.
   *
   * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
   * Batch service should wait for the start task to complete successfully (that
   * is, to exit with exit code 0) before scheduling any tasks on the compute
   * node. If true and the start task fails on a compute node, the Batch service
   * retries the start task up to its maximum retry count (maxTaskRetryCount). If
   * the task has still not completed successfully after all retries, then the
   * Batch service marks the compute node unusable, and will not schedule tasks
   * to it. This condition can be detected via the node state and failure info
   * details. If false, the Batch service will not wait for the start task to
   * complete. In this case, other tasks can start executing on the compute node
   * while the start task is still running; and even if the start task fails, new
   * tasks will continue to be scheduled on the node. The default is false.
   *
   * @param {array} [poolPatchParameter.certificateReferences] A list of
   * certificates to be installed on each compute node in the pool. If this
   * element is present, it replaces any existing certificate references
   * configured on the pool. If omitted, any existing certificate references are
   * left unchanged. For Windows compute nodes, the Batch service installs the
   * certificates to the specified certificate store and location. For Linux
   * compute nodes, the certificates are stored in a directory inside the task
   * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
   * supplied to the task to query for this location. For certificates with
   * visibility of 'remoteUser', a 'certs' directory is created in the user's
   * home directory (e.g., /home/{user-name}/certs) and certificates are placed
   * in that directory.
   *
   * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
   * application packages to be installed on each compute node in the pool.
   * Changes to application package references affect all new compute nodes
   * joining the pool, but do not affect compute nodes that are already in the
   * pool until they are rebooted or reimaged. If this element is present, it
   * replaces any existing application package references. If you specify an
   * empty collection, then all application package references are removed from
   * the pool. If omitted, any existing application package references are left
   * unchanged.
   *
   * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
   * associated with the pool as metadata. If this element is present, it
   * replaces any existing metadata configured on the pool. If you specify an
   * empty collection, any metadata is removed from the pool. If omitted, any
   * existing metadata is left unchanged.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolPatchOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolPatchOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolPatchOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolPatchOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  patchWithHttpOperationResponse(poolId, poolPatchParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._patch(poolId, poolPatchParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the properties of the specified pool.
   *
   * This only replaces the pool properties specified in the request. For
   * example, if the pool has a start task associated with it, and a request does
   * not specify a start task element, then the pool keeps the existing start
   * task.
   *
   * @param {string} poolId The ID of the pool to update.
   *
   * @param {object} poolPatchParameter The parameters for the request.
   *
   * @param {object} [poolPatchParameter.startTask] A task to run on each compute
   * node as it joins the pool. The task runs when the node is added to the pool
   * or when the node is restarted. If this element is present, it overwrites any
   * existing start task. If omitted, any existing start task is left unchanged.
   *
   * @param {string} poolPatchParameter.startTask.commandLine The command line of
   * the start task. The command line does not run under a shell, and therefore
   * cannot take advantage of shell features such as environment variable
   * expansion. If you want to take advantage of such features, you should invoke
   * the shell in the command line, for example using "cmd /c MyCommand" in
   * Windows or "/bin/sh -c MyCommand" in Linux.
   *
   * @param {object} [poolPatchParameter.startTask.containerSettings] The
   * settings for the container under which the start task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all task environment variables are mapped into the container, and the task
   * command line is executed in the container.
   *
   * @param {string}
   * [poolPatchParameter.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string} poolPatchParameter.startTask.containerSettings.imageName The
   * image to use to create the container in which the task will run. This is the
   * full image reference, as would be specified to "docker pull". If no tag is
   * provided as part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object} [poolPatchParameter.startTask.containerSettings.registry]
   * The private registry which contains the container image. This setting can be
   * omitted if was already provided at pool creation.
   *
   * @param {string}
   * [poolPatchParameter.startTask.containerSettings.registry.registryServer] The
   * registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * poolPatchParameter.startTask.containerSettings.registry.userName The user
   * name to log into the registry server.
   *
   * @param {string}
   * poolPatchParameter.startTask.containerSettings.registry.password The
   * password to log into the registry server.
   *
   * @param {array} [poolPatchParameter.startTask.resourceFiles] A list of files
   * that the Batch service will download to the compute node before running the
   * command line. Files listed under this element are located in the task's
   * working directory.
   *
   * @param {array} [poolPatchParameter.startTask.environmentSettings] A list of
   * environment variable settings for the start task.
   *
   * @param {object} [poolPatchParameter.startTask.userIdentity] The user
   * identity under which the start task runs. If omitted, the task runs as a
   * non-administrative user unique to the task.
   *
   * @param {string} [poolPatchParameter.startTask.userIdentity.userName] The
   * name of the user identity under which the task is run. The userName and
   * autoUser properties are mutually exclusive; you must specify one but not
   * both.
   *
   * @param {object} [poolPatchParameter.startTask.userIdentity.autoUser] The
   * auto user under which the task is run. The userName and autoUser properties
   * are mutually exclusive; you must specify one but not both.
   *
   * @param {string} [poolPatchParameter.startTask.userIdentity.autoUser.scope]
   * The scope for the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [poolPatchParameter.startTask.userIdentity.autoUser.elevationLevel] The
   * elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [poolPatchParameter.startTask.maxTaskRetryCount] The maximum
   * number of times the task may be retried. The Batch service retries a task if
   * its exit code is nonzero. Note that this value specifically controls the
   * number of retries. The Batch service will try the task once, and may then
   * retry up to this limit. For example, if the maximum retry count is 3, Batch
   * tries the task up to 4 times (one initial try and 3 retries). If the maximum
   * retry count is 0, the Batch service does not retry the task. If the maximum
   * retry count is -1, the Batch service retries the task without limit.
   *
   * @param {boolean} [poolPatchParameter.startTask.waitForSuccess] Whether the
   * Batch service should wait for the start task to complete successfully (that
   * is, to exit with exit code 0) before scheduling any tasks on the compute
   * node. If true and the start task fails on a compute node, the Batch service
   * retries the start task up to its maximum retry count (maxTaskRetryCount). If
   * the task has still not completed successfully after all retries, then the
   * Batch service marks the compute node unusable, and will not schedule tasks
   * to it. This condition can be detected via the node state and failure info
   * details. If false, the Batch service will not wait for the start task to
   * complete. In this case, other tasks can start executing on the compute node
   * while the start task is still running; and even if the start task fails, new
   * tasks will continue to be scheduled on the node. The default is false.
   *
   * @param {array} [poolPatchParameter.certificateReferences] A list of
   * certificates to be installed on each compute node in the pool. If this
   * element is present, it replaces any existing certificate references
   * configured on the pool. If omitted, any existing certificate references are
   * left unchanged. For Windows compute nodes, the Batch service installs the
   * certificates to the specified certificate store and location. For Linux
   * compute nodes, the certificates are stored in a directory inside the task
   * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
   * supplied to the task to query for this location. For certificates with
   * visibility of 'remoteUser', a 'certs' directory is created in the user's
   * home directory (e.g., /home/{user-name}/certs) and certificates are placed
   * in that directory.
   *
   * @param {array} [poolPatchParameter.applicationPackageReferences] A list of
   * application packages to be installed on each compute node in the pool.
   * Changes to application package references affect all new compute nodes
   * joining the pool, but do not affect compute nodes that are already in the
   * pool until they are rebooted or reimaged. If this element is present, it
   * replaces any existing application package references. If you specify an
   * empty collection, then all application package references are removed from
   * the pool. If omitted, any existing application package references are left
   * unchanged.
   *
   * @param {array} [poolPatchParameter.metadata] A list of name-value pairs
   * associated with the pool as metadata. If this element is present, it
   * replaces any existing metadata configured on the pool. If you specify an
   * empty collection, any metadata is removed from the pool. If omitted, any
   * existing metadata is left unchanged.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolPatchOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolPatchOptions.timeout] The maximum time that the
   * server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolPatchOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolPatchOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolPatchOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolPatchOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolPatchOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolPatchOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolPatchOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  patch(poolId, poolPatchParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._patch(poolId, poolPatchParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._patch(poolId, poolPatchParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Disables automatic scaling for a pool.
   *
   * @param {string} poolId The ID of the pool on which to disable automatic
   * scaling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolDisableAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableAutoScaleWithHttpOperationResponse(poolId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disableAutoScale(poolId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Disables automatic scaling for a pool.
   *
   * @param {string} poolId The ID of the pool on which to disable automatic
   * scaling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolDisableAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolDisableAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolDisableAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolDisableAutoScaleOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolDisableAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disableAutoScale(poolId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disableAutoScale(poolId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disableAutoScale(poolId, options, optionalCallback);
    }
  }

  /**
   * @summary Enables automatic scaling for a pool.
   *
   * You cannot enable automatic scaling on a pool if a resize operation is in
   * progress on the pool. If automatic scaling of the pool is currently
   * disabled, you must specify a valid autoscale formula as part of the request.
   * If automatic scaling of the pool is already enabled, you may specify a new
   * autoscale formula and/or a new evaluation interval. You cannot call this API
   * for the same pool more than once every 30 seconds.
   *
   * @param {string} poolId The ID of the pool on which to enable automatic
   * scaling.
   *
   * @param {object} poolEnableAutoScaleParameter The parameters for the request.
   *
   * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
   * for the desired number of compute nodes in the pool. The formula is checked
   * for validity before it is applied to the pool. If the formula is not valid,
   * the Batch service rejects the request with detailed error information. For
   * more information about specifying this formula, see Automatically scale
   * compute nodes in an Azure Batch pool
   * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
   *
   * @param {moment.duration}
   * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
   * at which to automatically adjust the pool size according to the autoscale
   * formula. The default value is 15 minutes. The minimum and maximum value are
   * 5 minutes and 168 hours respectively. If you specify a value less than 5
   * minutes or greater than 168 hours, the Batch service rejects the request
   * with an invalid property value error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request). If you specify a new
   * interval, then the existing autoscale evaluation schedule will be stopped
   * and a new autoscale evaluation schedule will be started, with its starting
   * time being the time when this request was issued.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolEnableAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag
   * value associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has been modified since the specified time.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has not been modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableAutoScaleWithHttpOperationResponse(poolId, poolEnableAutoScaleParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enableAutoScale(poolId, poolEnableAutoScaleParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enables automatic scaling for a pool.
   *
   * You cannot enable automatic scaling on a pool if a resize operation is in
   * progress on the pool. If automatic scaling of the pool is currently
   * disabled, you must specify a valid autoscale formula as part of the request.
   * If automatic scaling of the pool is already enabled, you may specify a new
   * autoscale formula and/or a new evaluation interval. You cannot call this API
   * for the same pool more than once every 30 seconds.
   *
   * @param {string} poolId The ID of the pool on which to enable automatic
   * scaling.
   *
   * @param {object} poolEnableAutoScaleParameter The parameters for the request.
   *
   * @param {string} [poolEnableAutoScaleParameter.autoScaleFormula] The formula
   * for the desired number of compute nodes in the pool. The formula is checked
   * for validity before it is applied to the pool. If the formula is not valid,
   * the Batch service rejects the request with detailed error information. For
   * more information about specifying this formula, see Automatically scale
   * compute nodes in an Azure Batch pool
   * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
   *
   * @param {moment.duration}
   * [poolEnableAutoScaleParameter.autoScaleEvaluationInterval] The time interval
   * at which to automatically adjust the pool size according to the autoscale
   * formula. The default value is 15 minutes. The minimum and maximum value are
   * 5 minutes and 168 hours respectively. If you specify a value less than 5
   * minutes or greater than 168 hours, the Batch service rejects the request
   * with an invalid property value error; if you are calling the REST API
   * directly, the HTTP status code is 400 (Bad Request). If you specify a new
   * interval, then the existing autoscale evaluation schedule will be stopped
   * and a new autoscale evaluation schedule will be started, with its starting
   * time being the time when this request was issued.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolEnableAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolEnableAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolEnableAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolEnableAutoScaleOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {string} [options.poolEnableAutoScaleOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolEnableAutoScaleOptions.ifNoneMatch] An ETag
   * value associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ifModifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has been modified since the specified time.
   *
   * @param {date} [options.poolEnableAutoScaleOptions.ifUnmodifiedSince] A
   * timestamp indicating the last modified time of the resource known to the
   * client. The operation will be performed only if the resource on the service
   * has not been modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enableAutoScale(poolId, poolEnableAutoScaleParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enableAutoScale(poolId, poolEnableAutoScaleParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enableAutoScale(poolId, poolEnableAutoScaleParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the result of evaluating an automatic scaling formula on the
   * pool.
   *
   * This API is primarily for validating an autoscale formula, as it simply
   * returns the result without applying the formula to the pool. The pool must
   * have auto scaling enabled in order to evaluate a formula.
   *
   * @param {string} poolId The ID of the pool on which to evaluate the automatic
   * scaling formula.
   *
   * @param {string} autoScaleFormula The formula for the desired number of
   * compute nodes in the pool. The formula is validated and its results
   * calculated, but it is not applied to the pool. To apply the formula to the
   * pool, 'Enable automatic scaling on a pool'. For more information about
   * specifying this formula, see Automatically scale compute nodes in an Azure
   * Batch pool
   * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AutoScaleRun>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  evaluateAutoScaleWithHttpOperationResponse(poolId, autoScaleFormula, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._evaluateAutoScale(poolId, autoScaleFormula, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the result of evaluating an automatic scaling formula on the
   * pool.
   *
   * This API is primarily for validating an autoscale formula, as it simply
   * returns the result without applying the formula to the pool. The pool must
   * have auto scaling enabled in order to evaluate a formula.
   *
   * @param {string} poolId The ID of the pool on which to evaluate the automatic
   * scaling formula.
   *
   * @param {string} autoScaleFormula The formula for the desired number of
   * compute nodes in the pool. The formula is validated and its results
   * calculated, but it is not applied to the pool. To apply the formula to the
   * pool, 'Enable automatic scaling on a pool'. For more information about
   * specifying this formula, see Automatically scale compute nodes in an Azure
   * Batch pool
   * (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolEvaluateAutoScaleOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolEvaluateAutoScaleOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolEvaluateAutoScaleOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolEvaluateAutoScaleOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolEvaluateAutoScaleOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AutoScaleRun} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AutoScaleRun} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  evaluateAutoScale(poolId, autoScaleFormula, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._evaluateAutoScale(poolId, autoScaleFormula, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._evaluateAutoScale(poolId, autoScaleFormula, options, optionalCallback);
    }
  }

  /**
   * @summary Changes the number of compute nodes that are assigned to a pool.
   *
   * You can only resize a pool when its allocation state is steady. If the pool
   * is already resizing, the request fails with status code 409. When you resize
   * a pool, the pool's allocation state changes from steady to resizing. You
   * cannot resize pools which are configured for automatic scaling. If you try
   * to do this, the Batch service returns an error 409. If you resize a pool
   * downwards, the Batch service chooses which nodes to remove. To remove
   * specific nodes, use the pool remove nodes API instead.
   *
   * @param {string} poolId The ID of the pool to resize.
   *
   * @param {object} poolResizeParameter The parameters for the request.
   *
   * @param {number} [poolResizeParameter.targetDedicatedNodes] The desired
   * number of dedicated compute nodes in the pool.
   *
   * @param {number} [poolResizeParameter.targetLowPriorityNodes] The desired
   * number of low-priority compute nodes in the pool.
   *
   * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
   * allocation of compute nodes to the pool or removal of compute nodes from the
   * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service returns an error;
   * if you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request).
   *
   * @param {string} [poolResizeParameter.nodeDeallocationOption] Determines what
   * to do with a node and its running task(s) if the pool size is decreasing.
   * The default value is requeue. Possible values include: 'requeue',
   * 'terminate', 'taskCompletion', 'retainedData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolResizeOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolResizeOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolResizeOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolResizeOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolResizeOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resizeWithHttpOperationResponse(poolId, poolResizeParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resize(poolId, poolResizeParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Changes the number of compute nodes that are assigned to a pool.
   *
   * You can only resize a pool when its allocation state is steady. If the pool
   * is already resizing, the request fails with status code 409. When you resize
   * a pool, the pool's allocation state changes from steady to resizing. You
   * cannot resize pools which are configured for automatic scaling. If you try
   * to do this, the Batch service returns an error 409. If you resize a pool
   * downwards, the Batch service chooses which nodes to remove. To remove
   * specific nodes, use the pool remove nodes API instead.
   *
   * @param {string} poolId The ID of the pool to resize.
   *
   * @param {object} poolResizeParameter The parameters for the request.
   *
   * @param {number} [poolResizeParameter.targetDedicatedNodes] The desired
   * number of dedicated compute nodes in the pool.
   *
   * @param {number} [poolResizeParameter.targetLowPriorityNodes] The desired
   * number of low-priority compute nodes in the pool.
   *
   * @param {moment.duration} [poolResizeParameter.resizeTimeout] The timeout for
   * allocation of compute nodes to the pool or removal of compute nodes from the
   * pool. The default value is 15 minutes. The minimum value is 5 minutes. If
   * you specify a value less than 5 minutes, the Batch service returns an error;
   * if you are calling the REST API directly, the HTTP status code is 400 (Bad
   * Request).
   *
   * @param {string} [poolResizeParameter.nodeDeallocationOption] Determines what
   * to do with a node and its running task(s) if the pool size is decreasing.
   * The default value is requeue. Possible values include: 'requeue',
   * 'terminate', 'taskCompletion', 'retainedData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolResizeOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolResizeOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolResizeOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolResizeOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolResizeOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolResizeOptions.ifMatch] An ETag value associated
   * with the version of the resource known to the client. The operation will be
   * performed only if the resource's current ETag on the service exactly matches
   * the value specified by the client.
   *
   * @param {string} [options.poolResizeOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolResizeOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolResizeOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resize(poolId, poolResizeParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resize(poolId, poolResizeParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resize(poolId, poolResizeParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Stops an ongoing resize operation on the pool.
   *
   * This does not restore the pool to its previous state before the resize
   * operation: it only stops any further changes being made, and the pool
   * maintains its current state. After stopping, the pool stabilizes at the
   * number of nodes it was at when the stop operation was done. During the stop
   * operation, the pool allocation state changes first to stopping and then to
   * steady. A resize operation need not be an explicit resize pool request; this
   * API can also be used to halt the initial sizing of the pool when it is
   * created.
   *
   * @param {string} poolId The ID of the pool whose resizing you want to stop.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolStopResizeOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolStopResizeOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolStopResizeOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopResizeWithHttpOperationResponse(poolId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopResize(poolId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops an ongoing resize operation on the pool.
   *
   * This does not restore the pool to its previous state before the resize
   * operation: it only stops any further changes being made, and the pool
   * maintains its current state. After stopping, the pool stabilizes at the
   * number of nodes it was at when the stop operation was done. During the stop
   * operation, the pool allocation state changes first to stopping and then to
   * steady. A resize operation need not be an explicit resize pool request; this
   * API can also be used to halt the initial sizing of the pool when it is
   * created.
   *
   * @param {string} poolId The ID of the pool whose resizing you want to stop.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolStopResizeOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolStopResizeOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolStopResizeOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolStopResizeOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolStopResizeOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolStopResizeOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolStopResizeOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolStopResizeOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolStopResizeOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopResize(poolId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopResize(poolId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopResize(poolId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the properties of the specified pool.
   *
   * This fully replaces all the updateable properties of the pool. For example,
   * if the pool has a start task associated with it and if start task is not
   * specified with this request, then the Batch service will remove the existing
   * start task.
   *
   * @param {string} poolId The ID of the pool to update.
   *
   * @param {object} poolUpdatePropertiesParameter The parameters for the
   * request.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
   * each compute node as it joins the pool. The task runs when the node is added
   * to the pool or when the node is restarted. If this element is present, it
   * overwrites any existing start task. If omitted, any existing start task is
   * removed from the pool.
   *
   * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
   * command line of the start task. The command line does not run under a shell,
   * and therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask.containerSettings]
   * The settings for the container under which the start task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all task environment variables are mapped into the container, and the task
   * command line is executed in the container.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.imageName The
   * image to use to create the container in which the task will run. This is the
   * full image reference, as would be specified to "docker pull". If no tag is
   * provided as part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.registry] The
   * private registry which contains the container image. This setting can be
   * omitted if was already provided at pool creation.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
   * list of files that the Batch service will download to the compute node
   * before running the command line. Files listed under this element are located
   * in the task's working directory.
   *
   * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
   * A list of environment variable settings for the start task.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask.userIdentity] The
   * user identity under which the start task runs. If omitted, the task runs as
   * a non-administrative user unique to the task.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.userName] The name of
   * the user identity under which the task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {object}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser] The auto
   * user under which the task is run. The userName and autoUser properties are
   * mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.scope] The
   * scope for the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
   * The maximum number of times the task may be retried. The Batch service
   * retries a task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the task. If the maximum retry count is -1, the Batch service retries the
   * task without limit.
   *
   * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
   * Whether the Batch service should wait for the start task to complete
   * successfully (that is, to exit with exit code 0) before scheduling any tasks
   * on the compute node. If true and the start task fails on a compute node, the
   * Batch service retries the start task up to its maximum retry count
   * (maxTaskRetryCount). If the task has still not completed successfully after
   * all retries, then the Batch service marks the compute node unusable, and
   * will not schedule tasks to it. This condition can be detected via the node
   * state and failure info details. If false, the Batch service will not wait
   * for the start task to complete. In this case, other tasks can start
   * executing on the compute node while the start task is still running; and
   * even if the start task fails, new tasks will continue to be scheduled on the
   * node. The default is false.
   *
   * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
   * certificates to be installed on each compute node in the pool. This list
   * replaces any existing certificate references configured on the pool. If you
   * specify an empty collection, any existing certificate references are removed
   * from the pool. For Windows compute nodes, the Batch service installs the
   * certificates to the specified certificate store and location. For Linux
   * compute nodes, the certificates are stored in a directory inside the task
   * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
   * supplied to the task to query for this location. For certificates with
   * visibility of 'remoteUser', a 'certs' directory is created in the user's
   * home directory (e.g., /home/{user-name}/certs) and certificates are placed
   * in that directory.
   *
   * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
   * list of application packages to be installed on each compute node in the
   * pool. The list replaces any existing application package references on the
   * pool. Changes to application package references affect all new compute nodes
   * joining the pool, but do not affect compute nodes that are already in the
   * pool until they are rebooted or reimaged. If omitted, or if you specify an
   * empty collection, any existing application packages references are removed
   * from the pool.
   *
   * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
   * pairs associated with the pool as metadata. This list replaces any existing
   * metadata configured on the pool. If omitted, or if you specify an empty
   * collection, any existing metadata is removed from the pool.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolUpdatePropertiesOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updatePropertiesWithHttpOperationResponse(poolId, poolUpdatePropertiesParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateProperties(poolId, poolUpdatePropertiesParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the properties of the specified pool.
   *
   * This fully replaces all the updateable properties of the pool. For example,
   * if the pool has a start task associated with it and if start task is not
   * specified with this request, then the Batch service will remove the existing
   * start task.
   *
   * @param {string} poolId The ID of the pool to update.
   *
   * @param {object} poolUpdatePropertiesParameter The parameters for the
   * request.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask] A task to run on
   * each compute node as it joins the pool. The task runs when the node is added
   * to the pool or when the node is restarted. If this element is present, it
   * overwrites any existing start task. If omitted, any existing start task is
   * removed from the pool.
   *
   * @param {string} poolUpdatePropertiesParameter.startTask.commandLine The
   * command line of the start task. The command line does not run under a shell,
   * and therefore cannot take advantage of shell features such as environment
   * variable expansion. If you want to take advantage of such features, you
   * should invoke the shell in the command line, for example using "cmd /c
   * MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask.containerSettings]
   * The settings for the container under which the start task runs. When this is
   * specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the
   * root of Azure Batch directories on the node) are mapped into the container,
   * all task environment variables are mapped into the container, and the task
   * command line is executed in the container.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.containerRunOptions]
   * Additional options to the container create command. These additional options
   * are supplied as arguments to the "docker create" command, in addition to
   * those controlled by the Batch Service.
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.imageName The
   * image to use to create the container in which the task will run. This is the
   * full image reference, as would be specified to "docker pull". If no tag is
   * provided as part of the image name, the tag ":latest" is used as a default.
   *
   * @param {object}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.registry] The
   * private registry which contains the container image. This setting can be
   * omitted if was already provided at pool creation.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.containerSettings.registry.registryServer]
   * The registry URL. If omitted, the default is "docker.io".
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.registry.userName
   * The user name to log into the registry server.
   *
   * @param {string}
   * poolUpdatePropertiesParameter.startTask.containerSettings.registry.password
   * The password to log into the registry server.
   *
   * @param {array} [poolUpdatePropertiesParameter.startTask.resourceFiles] A
   * list of files that the Batch service will download to the compute node
   * before running the command line. Files listed under this element are located
   * in the task's working directory.
   *
   * @param {array} [poolUpdatePropertiesParameter.startTask.environmentSettings]
   * A list of environment variable settings for the start task.
   *
   * @param {object} [poolUpdatePropertiesParameter.startTask.userIdentity] The
   * user identity under which the start task runs. If omitted, the task runs as
   * a non-administrative user unique to the task.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.userName] The name of
   * the user identity under which the task is run. The userName and autoUser
   * properties are mutually exclusive; you must specify one but not both.
   *
   * @param {object}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser] The auto
   * user under which the task is run. The userName and autoUser properties are
   * mutually exclusive; you must specify one but not both.
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.scope] The
   * scope for the auto user Values are:
   *
   * pool - specifies that the task runs as the common auto user account which is
   * created on every node in a pool.
   * task - specifies that the service should create a new user for the task.
   * The default value is task. Possible values include: 'task', 'pool'
   *
   * @param {string}
   * [poolUpdatePropertiesParameter.startTask.userIdentity.autoUser.elevationLevel]
   * The elevation level of the auto user. nonAdmin - The auto user is a standard
   * user without elevated access. admin - The auto user is a user with elevated
   * access and operates with full Administrator permissions. The default value
   * is nonAdmin. Possible values include: 'nonAdmin', 'admin'
   *
   * @param {number} [poolUpdatePropertiesParameter.startTask.maxTaskRetryCount]
   * The maximum number of times the task may be retried. The Batch service
   * retries a task if its exit code is nonzero. Note that this value
   * specifically controls the number of retries. The Batch service will try the
   * task once, and may then retry up to this limit. For example, if the maximum
   * retry count is 3, Batch tries the task up to 4 times (one initial try and 3
   * retries). If the maximum retry count is 0, the Batch service does not retry
   * the task. If the maximum retry count is -1, the Batch service retries the
   * task without limit.
   *
   * @param {boolean} [poolUpdatePropertiesParameter.startTask.waitForSuccess]
   * Whether the Batch service should wait for the start task to complete
   * successfully (that is, to exit with exit code 0) before scheduling any tasks
   * on the compute node. If true and the start task fails on a compute node, the
   * Batch service retries the start task up to its maximum retry count
   * (maxTaskRetryCount). If the task has still not completed successfully after
   * all retries, then the Batch service marks the compute node unusable, and
   * will not schedule tasks to it. This condition can be detected via the node
   * state and failure info details. If false, the Batch service will not wait
   * for the start task to complete. In this case, other tasks can start
   * executing on the compute node while the start task is still running; and
   * even if the start task fails, new tasks will continue to be scheduled on the
   * node. The default is false.
   *
   * @param {array} poolUpdatePropertiesParameter.certificateReferences A list of
   * certificates to be installed on each compute node in the pool. This list
   * replaces any existing certificate references configured on the pool. If you
   * specify an empty collection, any existing certificate references are removed
   * from the pool. For Windows compute nodes, the Batch service installs the
   * certificates to the specified certificate store and location. For Linux
   * compute nodes, the certificates are stored in a directory inside the task
   * working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is
   * supplied to the task to query for this location. For certificates with
   * visibility of 'remoteUser', a 'certs' directory is created in the user's
   * home directory (e.g., /home/{user-name}/certs) and certificates are placed
   * in that directory.
   *
   * @param {array} poolUpdatePropertiesParameter.applicationPackageReferences A
   * list of application packages to be installed on each compute node in the
   * pool. The list replaces any existing application package references on the
   * pool. Changes to application package references affect all new compute nodes
   * joining the pool, but do not affect compute nodes that are already in the
   * pool until they are rebooted or reimaged. If omitted, or if you specify an
   * empty collection, any existing application packages references are removed
   * from the pool.
   *
   * @param {array} poolUpdatePropertiesParameter.metadata A list of name-value
   * pairs associated with the pool as metadata. This list replaces any existing
   * metadata configured on the pool. If omitted, or if you specify an empty
   * collection, any existing metadata is removed from the pool.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolUpdatePropertiesOptions] Additional parameters
   * for the operation
   *
   * @param {number} [options.poolUpdatePropertiesOptions.timeout] The maximum
   * time that the server can spend processing the request, in seconds. The
   * default is 30 seconds.
   *
   * @param {uuid} [options.poolUpdatePropertiesOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolUpdatePropertiesOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolUpdatePropertiesOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateProperties(poolId, poolUpdatePropertiesParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateProperties(poolId, poolUpdatePropertiesParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateProperties(poolId, poolUpdatePropertiesParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Upgrades the operating system of the specified pool.
   *
   * During an upgrade, the Batch service upgrades each compute node in the pool.
   * When a compute node is chosen for upgrade, any tasks running on that node
   * are removed from the node and returned to the queue to be rerun later (or on
   * a different compute node). The node will be unavailable until the upgrade is
   * complete. This operation results in temporarily reduced pool capacity as
   * nodes are taken out of service to be upgraded. Although the Batch service
   * tries to avoid upgrading all compute nodes at the same time, it does not
   * guarantee to do this (particularly on small pools); therefore, the pool may
   * be temporarily unavailable to run tasks. When this operation runs, the pool
   * state changes to upgrading. When all compute nodes have finished upgrading,
   * the pool state returns to active. While the upgrade is in progress, the
   * pool's currentOSVersion reflects the OS version that nodes are upgrading
   * from, and targetOSVersion reflects the OS version that nodes are upgrading
   * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
   * OS version now running on all nodes. This operation can only be invoked on
   * pools created with the cloudServiceConfiguration property.
   *
   * @param {string} poolId The ID of the pool to upgrade.
   *
   * @param {string} targetOSVersion The Azure Guest OS version to be installed
   * on the virtual machines in the pool.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolUpgradeOSOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  upgradeOSWithHttpOperationResponse(poolId, targetOSVersion, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._upgradeOS(poolId, targetOSVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Upgrades the operating system of the specified pool.
   *
   * During an upgrade, the Batch service upgrades each compute node in the pool.
   * When a compute node is chosen for upgrade, any tasks running on that node
   * are removed from the node and returned to the queue to be rerun later (or on
   * a different compute node). The node will be unavailable until the upgrade is
   * complete. This operation results in temporarily reduced pool capacity as
   * nodes are taken out of service to be upgraded. Although the Batch service
   * tries to avoid upgrading all compute nodes at the same time, it does not
   * guarantee to do this (particularly on small pools); therefore, the pool may
   * be temporarily unavailable to run tasks. When this operation runs, the pool
   * state changes to upgrading. When all compute nodes have finished upgrading,
   * the pool state returns to active. While the upgrade is in progress, the
   * pool's currentOSVersion reflects the OS version that nodes are upgrading
   * from, and targetOSVersion reflects the OS version that nodes are upgrading
   * to. Once the upgrade is complete, currentOSVersion is updated to reflect the
   * OS version now running on all nodes. This operation can only be invoked on
   * pools created with the cloudServiceConfiguration property.
   *
   * @param {string} poolId The ID of the pool to upgrade.
   *
   * @param {string} targetOSVersion The Azure Guest OS version to be installed
   * on the virtual machines in the pool.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolUpgradeOSOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.poolUpgradeOSOptions.timeout] The maximum time that
   * the server can spend processing the request, in seconds. The default is 30
   * seconds.
   *
   * @param {uuid} [options.poolUpgradeOSOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolUpgradeOSOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolUpgradeOSOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolUpgradeOSOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolUpgradeOSOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolUpgradeOSOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolUpgradeOSOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  upgradeOS(poolId, targetOSVersion, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._upgradeOS(poolId, targetOSVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._upgradeOS(poolId, targetOSVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Removes compute nodes from the specified pool.
   *
   * This operation can only run when the allocation state of the pool is steady.
   * When this operation runs, the allocation state changes from steady to
   * resizing.
   *
   * @param {string} poolId The ID of the pool from which you want to remove
   * nodes.
   *
   * @param {object} nodeRemoveParameter The parameters for the request.
   *
   * @param {array} nodeRemoveParameter.nodeList A list containing the IDs of the
   * compute nodes to be removed from the specified pool.
   *
   * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
   * removal of compute nodes to the pool. The default value is 15 minutes. The
   * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
   * Batch service returns an error; if you are calling the REST API directly,
   * the HTTP status code is 400 (Bad Request).
   *
   * @param {string} [nodeRemoveParameter.nodeDeallocationOption] Determines what
   * to do with a node and its running task(s) after it has been selected for
   * deallocation. The default value is requeue. Possible values include:
   * 'requeue', 'terminate', 'taskCompletion', 'retainedData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolRemoveNodesOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeNodesWithHttpOperationResponse(poolId, nodeRemoveParameter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeNodes(poolId, nodeRemoveParameter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes compute nodes from the specified pool.
   *
   * This operation can only run when the allocation state of the pool is steady.
   * When this operation runs, the allocation state changes from steady to
   * resizing.
   *
   * @param {string} poolId The ID of the pool from which you want to remove
   * nodes.
   *
   * @param {object} nodeRemoveParameter The parameters for the request.
   *
   * @param {array} nodeRemoveParameter.nodeList A list containing the IDs of the
   * compute nodes to be removed from the specified pool.
   *
   * @param {moment.duration} [nodeRemoveParameter.resizeTimeout] The timeout for
   * removal of compute nodes to the pool. The default value is 15 minutes. The
   * minimum value is 5 minutes. If you specify a value less than 5 minutes, the
   * Batch service returns an error; if you are calling the REST API directly,
   * the HTTP status code is 400 (Bad Request).
   *
   * @param {string} [nodeRemoveParameter.nodeDeallocationOption] Determines what
   * to do with a node and its running task(s) after it has been selected for
   * deallocation. The default value is requeue. Possible values include:
   * 'requeue', 'terminate', 'taskCompletion', 'retainedData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolRemoveNodesOptions] Additional parameters for
   * the operation
   *
   * @param {number} [options.poolRemoveNodesOptions.timeout] The maximum time
   * that the server can spend processing the request, in seconds. The default is
   * 30 seconds.
   *
   * @param {uuid} [options.poolRemoveNodesOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolRemoveNodesOptions.returnClientRequestId]
   * Whether the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolRemoveNodesOptions.ocpDate] The time the request
   * was issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {string} [options.poolRemoveNodesOptions.ifMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service exactly matches the value specified by the client.
   *
   * @param {string} [options.poolRemoveNodesOptions.ifNoneMatch] An ETag value
   * associated with the version of the resource known to the client. The
   * operation will be performed only if the resource's current ETag on the
   * service does not match the value specified by the client.
   *
   * @param {date} [options.poolRemoveNodesOptions.ifModifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has been
   * modified since the specified time.
   *
   * @param {date} [options.poolRemoveNodesOptions.ifUnmodifiedSince] A timestamp
   * indicating the last modified time of the resource known to the client. The
   * operation will be performed only if the resource on the service has not been
   * modified since the specified time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeNodes(poolId, nodeRemoveParameter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeNodes(poolId, nodeRemoveParameter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeNodes(poolId, nodeRemoveParameter, options, optionalCallback);
    }
  }

  /**
   * @summary Lists the usage metrics, aggregated by pool across individual time
   * intervals, for the specified account.
   *
   * If you do not specify a $filter clause including a poolId, the response
   * includes all pools that existed in the account in the time range of the
   * returned aggregation intervals. If you do not specify a $filter clause
   * including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only
   * the last aggregation interval is returned.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListUsageMetricsNextOptions] Additional
   * parameters for the operation
   *
   * @param {uuid} [options.poolListUsageMetricsNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolListUsageMetricsNextOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListUsageMetricsNextOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PoolListUsageMetricsResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsageMetricsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsageMetricsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists the usage metrics, aggregated by pool across individual time
   * intervals, for the specified account.
   *
   * If you do not specify a $filter clause including a poolId, the response
   * includes all pools that existed in the account in the time range of the
   * returned aggregation intervals. If you do not specify a $filter clause
   * including a startTime or endTime these filters default to the start and end
   * times of the last aggregation interval currently available; that is, only
   * the last aggregation interval is returned.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListUsageMetricsNextOptions] Additional
   * parameters for the operation
   *
   * @param {uuid} [options.poolListUsageMetricsNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean}
   * [options.poolListUsageMetricsNextOptions.returnClientRequestId] Whether the
   * server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListUsageMetricsNextOptions.ocpDate] The time the
   * request was issued. Client libraries typically set this to the current
   * system clock time; set it explicitly if you are calling the REST API
   * directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PoolListUsageMetricsResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PoolListUsageMetricsResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsageMetricsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsageMetricsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsageMetricsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists all of the pools in the specified account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListNextOptions] Additional parameters for the
   * operation
   *
   * @param {uuid} [options.poolListNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CloudPoolListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists all of the pools in the specified account.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.poolListNextOptions] Additional parameters for the
   * operation
   *
   * @param {uuid} [options.poolListNextOptions.clientRequestId] The
   * caller-generated request identity, in the form of a GUID with no decoration
   * such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
   *
   * @param {boolean} [options.poolListNextOptions.returnClientRequestId] Whether
   * the server should return the client-request-id in the response.
   *
   * @param {date} [options.poolListNextOptions.ocpDate] The time the request was
   * issued. Client libraries typically set this to the current system clock
   * time; set it explicitly if you are calling the REST API directly.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CloudPoolListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CloudPoolListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = Pool;
