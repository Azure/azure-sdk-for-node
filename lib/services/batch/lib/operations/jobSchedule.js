/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.16.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var msRestAzure = require('ms-rest-azure');
var WebResource = msRest.WebResource;

/**
 * @class
 * JobSchedule
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the BatchServiceClient.
 * Initializes a new instance of the JobSchedule class.
 * @constructor
 *
 * @param {BatchServiceClient} client Reference to the service client.
 */
function JobSchedule(client) {
  this.client = client;
}

/**
 * Checks the specified job schedule exists.
 *
 * @param {string} jobScheduleId The id of the job schedule which you want to
 * check.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleExistsOptions] Additional parameters
 * for the operation
 * 
 * @param {string} [options.jobScheduleExistsOptions.select] Sets an OData
 * $select clause.
 * 
 * @param {number} [options.jobScheduleExistsOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleExistsOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleExistsOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleExistsOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleExistsOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleExistsOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleExistsOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleExistsOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {boolean} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.exists = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleExistsOptions = (options && options.jobScheduleExistsOptions !== undefined) ? options.jobScheduleExistsOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var select;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      select = jobScheduleExistsOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      timeout = jobScheduleExistsOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      clientRequestId = jobScheduleExistsOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      returnClientRequestId = jobScheduleExistsOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      ocpDate = jobScheduleExistsOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      ifMatch = jobScheduleExistsOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      ifNoneMatch = jobScheduleExistsOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      ifModifiedSince = jobScheduleExistsOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleExistsOptions !== null && jobScheduleExistsOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleExistsOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    result = (statusCode === 200);

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Deletes a job schedule from the specified account.
 *
 * @param {string} jobScheduleId The id of the job schedule to delete.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleDeleteMethodOptions] Additional
 * parameters for the operation
 * 
 * @param {number} [options.jobScheduleDeleteMethodOptions.timeout] Sets the
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleDeleteMethodOptions.clientRequestId]
 * Caller generated request identity, in the form of a GUID with no
 * decoration such as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobScheduleDeleteMethodOptions.returnClientRequestId] Specifies
 * if the server should return the client-request-id identifier in the
 * response.
 * 
 * @param {date} [options.jobScheduleDeleteMethodOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleDeleteMethodOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleDeleteMethodOptions.ifNoneMatch] An
 * ETag is specified. Specify this header to perform the operation only if
 * the resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleDeleteMethodOptions.ifModifiedSince]
 * Specify this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleDeleteMethodOptions.ifUnmodifiedSince]
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.deleteMethod = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleDeleteMethodOptions = (options && options.jobScheduleDeleteMethodOptions !== undefined) ? options.jobScheduleDeleteMethodOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      timeout = jobScheduleDeleteMethodOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      clientRequestId = jobScheduleDeleteMethodOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      returnClientRequestId = jobScheduleDeleteMethodOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      ocpDate = jobScheduleDeleteMethodOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      ifMatch = jobScheduleDeleteMethodOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      ifNoneMatch = jobScheduleDeleteMethodOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      ifModifiedSince = jobScheduleDeleteMethodOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleDeleteMethodOptions !== null && jobScheduleDeleteMethodOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleDeleteMethodOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets information about the specified job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to get.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleGetOptions] Additional parameters for
 * the operation
 * 
 * @param {string} [options.jobScheduleGetOptions.select] Sets an OData
 * $select clause.
 * 
 * @param {string} [options.jobScheduleGetOptions.expand] Sets an OData
 * $expand clause.
 * 
 * @param {number} [options.jobScheduleGetOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleGetOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleGetOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleGetOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {string} [options.jobScheduleGetOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleGetOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleGetOptions.ifModifiedSince] Specify this
 * header to perform the operation only if the resource has been modified
 * since the specified date/time.
 * 
 * @param {date} [options.jobScheduleGetOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobSchedule} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.get = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleGetOptions = (options && options.jobScheduleGetOptions !== undefined) ? options.jobScheduleGetOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var select;
  var expand;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      select = jobScheduleGetOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      expand = jobScheduleGetOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      timeout = jobScheduleGetOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      clientRequestId = jobScheduleGetOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      returnClientRequestId = jobScheduleGetOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      ocpDate = jobScheduleGetOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      ifMatch = jobScheduleGetOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      ifNoneMatch = jobScheduleGetOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      ifModifiedSince = jobScheduleGetOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleGetOptions !== null && jobScheduleGetOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleGetOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobSchedule']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Updates the properties of the specified job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to update.
 * 
 * @param {object} jobSchedulePatchParameter The parameters for the request.
 * 
 * @param {object} [jobSchedulePatchParameter.schedule] Sets the schedule
 * according to which jobs will be created. If you do not specify this
 * element, the existing schedule is not modified.
 * 
 * @param {date} [jobSchedulePatchParameter.schedule.doNotRunUntil] Gets or
 * sets the earliest time at which any job may be created under this job
 * schedule. If you do not specify a doNotRunUntil time, the schedule becomes
 * ready to create jobs immediately.
 * 
 * @param {date} [jobSchedulePatchParameter.schedule.doNotRunAfter] Gets or
 * sets a time after which no job will be created under this job schedule.
 * The schedule will move to the completed state as soon as this deadline is
 * past and there is no active job under this job schedule.
 * 
 * @param {moment.duration} [jobSchedulePatchParameter.schedule.startWindow]
 * Gets or sets the time interval, starting from the time at which the
 * schedule indicates a job should be created, within which a job must be
 * created.  If a job is not created within the startWindow interval, then
 * the 'opportunity' is lost; no job will be created until the next
 * recurrence of the schedule.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.schedule.recurrenceInterval] Gets or sets the
 * time interval between the start times of two successive jobs under the job
 * schedule. A job schedule can have at most one active job under it at any
 * given time.
 * 
 * @param {object} [jobSchedulePatchParameter.jobSpecification] Sets the
 * details of the jobs to be created on this schedule.
 * 
 * @param {number} [jobSchedulePatchParameter.jobSpecification.priority] Gets
 * or sets the priority of jobs created under this schedule. Priority values
 * can range from -1000 to 1000, with -1000 being the lowest priority and
 * 1000 being the highest priority. The default value is 0.
 * 
 * @param {string} [jobSchedulePatchParameter.jobSpecification.displayName]
 * Gets or sets the display name for jobs created under this schedule. It
 * need not be unique and can contain any Unicode characters up to a maximum
 * length of 1024.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.usesTaskDependencies] Gets or
 * sets the flag that determines if this job will use tasks with dependencies.
 * 
 * @param {object} [jobSchedulePatchParameter.jobSpecification.constraints]
 * Gets or sets the execution constraints for jobs created under this
 * schedule.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.constraints.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the job may run, measured from
 * the time the job starts. If the job does not complete within the time
 * limit, the Batch service terminates it and any tasks that are still
 * running.
 * 
 * @param {number}
 * [jobSchedulePatchParameter.jobSpecification.constraints.maxTaskRetryCount]
 * Gets or sets the maximum number of times each task may be retried. The
 * Batch service retries a task if its exit code is nonzero.
 * 
 * @param {object} [jobSchedulePatchParameter.jobSpecification.jobManagerTask]
 * Gets or sets the details of a Job Manager task to be launched when a job
 * is started under this schedule.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.id] Gets or
 * sets a string that uniquely identifies the Job Manager task. A GUID is
 * recommended.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.displayName]
 * Gets or sets the display name of the Job Manager task.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.commandLine]
 * Gets or sets the command line of the Job Manager task.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Manager
 * task.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.constraints]
 * Gets or sets constraints that apply to the Job Manager task.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.killJobOnCompletion]
 * Gets or sets whether completion of the Job Manager task signifies
 * completion of the entire job.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.runElevated]
 * Gets or sets whether to run the Job Manager task in elevated mode. The
 * default value is false.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobManagerTask.runExclusive]
 * Gets or sets whether the Job Manager task requires exclusive use of the
 * compute node where it runs.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask] Gets or
 * sets the Job Preparation task for jobs created under this schedule.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.id] Gets or
 * sets a string that uniquely identifies the job preparation task within the
 * job. The id can contain any combination of alphanumeric characters
 * including hyphens and underscores and cannot contain more than 64
 * characters.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.commandLine]
 * Gets or sets the command line of the Job Preparation task.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job
 * Preparation task.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints]
 * Gets or sets constraints that apply to the Job Preparation task..
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the task may run, measured from
 * the time the task starts. If the task does not complete within the time
 * limit, the Batch service terminates it.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.retentionTime]
 * Gets or sets the minimum time to retain the working directory for the task
 * on the compute node where it ran. After this time, the Batch service may
 * delete the working directory and all its contents. The default is infinite.
 * 
 * @param {number}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried. The
 * Batch service retries a task if its exit code is nonzero.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.waitForSuccess]
 * Gets or sets whether the Batch Service should wait for the Job Preparation
 * task to complete successfully before scheduling any other tasks of the job
 * on the compute node.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.runElevated]
 * Gets or sets whether to run the Job Preparation task in elevated mode. The
 * default value is false.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
 * Gets or sets whether the Batch service should rerun the Job Preparation
 * task after a compute node reboots. The default value is true.
 * 
 * @param {object} [jobSchedulePatchParameter.jobSpecification.jobReleaseTask]
 * Gets or sets the Job Release task for jobs created under this schedule.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.id] Gets or
 * sets a string that uniquely identifies the Job Release task within the
 * job. The id can contain any combination of alphanumeric characters
 * including hyphens and underscores and cannot contain more than 64
 * characters.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.commandLine]
 * Gets or sets the command line of the Job Release task.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Release
 * task.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the Job Release task may run on
 * a given compute node, measured from the time the task starts. If the task
 * does not complete within the time limit, the Batch service terminates it.
 * The default value is 15 minutes.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.retentionTime]
 * Gets or sets the minimum time to retain the working directory for the Job
 * Release task on the compute node.  After this time, the Batch service may
 * delete the working directory and all its contents. The default is infinite.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.jobReleaseTask.runElevated]
 * Gets or sets whether to run the Job Release task in elevated mode. The
 * default value is false.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.commonEnvironmentSettings]
 * Gets or sets a list of common environment variable settings.  These
 * environment variables are set for all tasks in jobs created under this
 * schedule (including the Job Manager, Job Preparation and Job Release
 * tasks).
 * 
 * @param {object} [jobSchedulePatchParameter.jobSpecification.poolInfo] Gets
 * or sets the pool on which the Batch service runs the tasks of jobs created
 * under this schedule.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.poolId] Gets or sets
 * the id of an existing pool. All the tasks of the job will run on the
 * specified pool. You must specify either PoolId or AutoPoolSpecification,
 * but not both.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification]
 * Gets or sets characteristics for a temporary 'auto pool.' The Batch
 * service will create this auto pool and run all the tasks of the job on it,
 * and will delete the pool once the job has completed. You must specify
 * either PoolId or AutoPoolSpecification, but not both.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
 * Gets or sets a prefix to be added to the unique identifier when a pool is
 * automatically created. The prefix can be up to 20 characters long.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption]
 * Gets or sets the minimum lifetime of created auto pools, and how multiple
 * jobs on a schedule are assigned to pools. Possible values include:
 * 'jobschedule', 'job', 'unmapped'
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
 * Gets or sets whether to keep an auto pool alive after its lifetime expires.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool]
 * Gets or sets the pool specification for the auto pool.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
 * Gets or sets the display name for the pool.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize]
 * Gets or sets the size of the virtual machines in the pool. All VMs in a
 * pool are the same size.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.osFamily]
 * Gets or sets the Azure Guest OS family to be installed on the virtual
 * machines in the pool.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetOSVersion]
 * Gets or sets the Azure Guest OS version to be installed on the virtual
 * machines in the pool.
 * 
 * @param {number}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
 * Gets or sets the maximum number of tasks that can run concurrently on a
 * single compute node in the pool.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * Gets or sets how tasks are distributed among compute nodes in the pool.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType]
 * Gets or sets how tasks should be distributed across compute nodes.
 * Possible values include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
 * Gets or sets the timeout for allocation of compute nodes to the pool.
 * 
 * @param {number}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicated]
 * Gets or sets the desired number of compute nodes in the pool.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Gets or sets whether the pool size should automatically adjust over time.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * Gets or sets the formula for the desired number of compute nodes in the
 * pool.
 * 
 * @param {moment.duration}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * Gets or sets a time interval for the desired AutoScale evaluation period
 * in the pool.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Gets or sets whether the pool permits direct communication between nodes.
 * 
 * @param {object}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
 * Gets or sets a task to run on each compute node as it joins the pool. The
 * task runs when the node is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine]
 * Gets or sets the command line of the start task.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.runElevated]
 * Gets or sets whether to run the start task in elevated mode. The default
 * value is false.
 * 
 * @param {number}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried.
 * 
 * @param {boolean}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Gets or sets whether the Batch Service should wait for the start task to
 * complete successfully (that is, to exit with exit code 0) before
 * scheduling any tasks on the compute node.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * Gets or sets a list of certificates to be installed on each compute node
 * in the pool.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * Gets or sets the list of application packages to be installed on each
 * compute node in the pool.
 * 
 * @param {array}
 * [jobSchedulePatchParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
 * Gets or sets a list of name-value pairs associated with the pool as
 * metadata.
 * 
 * @param {array} [jobSchedulePatchParameter.jobSpecification.metadata] Gets
 * or sets a list of name-value pairs associated with each job created under
 * this schedule as metadata.
 * 
 * @param {array} [jobSchedulePatchParameter.metadata] Sets a list of
 * name-value pairs associated with the job schedule as metadata.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobSchedulePatchOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.jobSchedulePatchOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobSchedulePatchOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobSchedulePatchOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobSchedulePatchOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobSchedulePatchOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobSchedulePatchOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobSchedulePatchOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobSchedulePatchOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.patch = function (jobScheduleId, jobSchedulePatchParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobSchedulePatchOptions = (options && options.jobSchedulePatchOptions !== undefined) ? options.jobSchedulePatchOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (jobSchedulePatchParameter === null || jobSchedulePatchParameter === undefined) {
      throw new Error('jobSchedulePatchParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      timeout = jobSchedulePatchOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      clientRequestId = jobSchedulePatchOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      returnClientRequestId = jobSchedulePatchOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      ocpDate = jobSchedulePatchOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      ifMatch = jobSchedulePatchOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      ifNoneMatch = jobSchedulePatchOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      ifModifiedSince = jobSchedulePatchOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobSchedulePatchOptions !== null && jobSchedulePatchOptions !== undefined)
    {
      ifUnmodifiedSince = jobSchedulePatchOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobSchedulePatchParameter !== null && jobSchedulePatchParameter !== undefined) {
      var requestModelMapper = new client.models['JobSchedulePatchParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobSchedulePatchParameter, 'jobSchedulePatchParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobSchedulePatchParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Updates the properties of the specified job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to update.
 * 
 * @param {object} jobScheduleUpdateParameter The parameters for the request.
 * 
 * @param {object} [jobScheduleUpdateParameter.schedule] Sets the schedule
 * according to which jobs will be created. If you do not specify this
 * element, it is equivalent to passing the default schedule: that is, a
 * single job scheduled to run immediately.
 * 
 * @param {date} [jobScheduleUpdateParameter.schedule.doNotRunUntil] Gets or
 * sets the earliest time at which any job may be created under this job
 * schedule. If you do not specify a doNotRunUntil time, the schedule becomes
 * ready to create jobs immediately.
 * 
 * @param {date} [jobScheduleUpdateParameter.schedule.doNotRunAfter] Gets or
 * sets a time after which no job will be created under this job schedule.
 * The schedule will move to the completed state as soon as this deadline is
 * past and there is no active job under this job schedule.
 * 
 * @param {moment.duration} [jobScheduleUpdateParameter.schedule.startWindow]
 * Gets or sets the time interval, starting from the time at which the
 * schedule indicates a job should be created, within which a job must be
 * created.  If a job is not created within the startWindow interval, then
 * the 'opportunity' is lost; no job will be created until the next
 * recurrence of the schedule.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.schedule.recurrenceInterval] Gets or sets the
 * time interval between the start times of two successive jobs under the job
 * schedule. A job schedule can have at most one active job under it at any
 * given time.
 * 
 * @param {object} [jobScheduleUpdateParameter.jobSpecification] Sets details
 * of the jobs to be created on this schedule.
 * 
 * @param {number} [jobScheduleUpdateParameter.jobSpecification.priority] Gets
 * or sets the priority of jobs created under this schedule. Priority values
 * can range from -1000 to 1000, with -1000 being the lowest priority and
 * 1000 being the highest priority. The default value is 0.
 * 
 * @param {string} [jobScheduleUpdateParameter.jobSpecification.displayName]
 * Gets or sets the display name for jobs created under this schedule. It
 * need not be unique and can contain any Unicode characters up to a maximum
 * length of 1024.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.usesTaskDependencies] Gets or
 * sets the flag that determines if this job will use tasks with dependencies.
 * 
 * @param {object} [jobScheduleUpdateParameter.jobSpecification.constraints]
 * Gets or sets the execution constraints for jobs created under this
 * schedule.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.constraints.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the job may run, measured from
 * the time the job starts. If the job does not complete within the time
 * limit, the Batch service terminates it and any tasks that are still
 * running.
 * 
 * @param {number}
 * [jobScheduleUpdateParameter.jobSpecification.constraints.maxTaskRetryCount]
 * Gets or sets the maximum number of times each task may be retried. The
 * Batch service retries a task if its exit code is nonzero.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask] Gets or sets
 * the details of a Job Manager task to be launched when a job is started
 * under this schedule.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.id] Gets or
 * sets a string that uniquely identifies the Job Manager task. A GUID is
 * recommended.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.displayName]
 * Gets or sets the display name of the Job Manager task.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.commandLine]
 * Gets or sets the command line of the Job Manager task.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Manager
 * task.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.constraints]
 * Gets or sets constraints that apply to the Job Manager task.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.killJobOnCompletion]
 * Gets or sets whether completion of the Job Manager task signifies
 * completion of the entire job.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.runElevated]
 * Gets or sets whether to run the Job Manager task in elevated mode. The
 * default value is false.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobManagerTask.runExclusive]
 * Gets or sets whether the Job Manager task requires exclusive use of the
 * compute node where it runs.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask] Gets or
 * sets the Job Preparation task for jobs created under this schedule.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.id] Gets
 * or sets a string that uniquely identifies the job preparation task within
 * the job. The id can contain any combination of alphanumeric characters
 * including hyphens and underscores and cannot contain more than 64
 * characters.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.commandLine]
 * Gets or sets the command line of the Job Preparation task.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job
 * Preparation task.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints]
 * Gets or sets constraints that apply to the Job Preparation task..
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the task may run, measured from
 * the time the task starts. If the task does not complete within the time
 * limit, the Batch service terminates it.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.retentionTime]
 * Gets or sets the minimum time to retain the working directory for the task
 * on the compute node where it ran. After this time, the Batch service may
 * delete the working directory and all its contents. The default is infinite.
 * 
 * @param {number}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried. The
 * Batch service retries a task if its exit code is nonzero.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.waitForSuccess]
 * Gets or sets whether the Batch Service should wait for the Job Preparation
 * task to complete successfully before scheduling any other tasks of the job
 * on the compute node.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.runElevated]
 * Gets or sets whether to run the Job Preparation task in elevated mode. The
 * default value is false.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
 * Gets or sets whether the Batch service should rerun the Job Preparation
 * task after a compute node reboots. The default value is true.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask] Gets or sets
 * the Job Release task for jobs created under this schedule.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.id] Gets or
 * sets a string that uniquely identifies the Job Release task within the
 * job. The id can contain any combination of alphanumeric characters
 * including hyphens and underscores and cannot contain more than 64
 * characters.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.commandLine]
 * Gets or sets the command line of the Job Release task.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Release
 * task.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the Job Release task may run on
 * a given compute node, measured from the time the task starts. If the task
 * does not complete within the time limit, the Batch service terminates it.
 * The default value is 15 minutes.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.retentionTime]
 * Gets or sets the minimum time to retain the working directory for the Job
 * Release task on the compute node.  After this time, the Batch service may
 * delete the working directory and all its contents. The default is infinite.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.jobReleaseTask.runElevated]
 * Gets or sets whether to run the Job Release task in elevated mode. The
 * default value is false.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.commonEnvironmentSettings]
 * Gets or sets a list of common environment variable settings.  These
 * environment variables are set for all tasks in jobs created under this
 * schedule (including the Job Manager, Job Preparation and Job Release
 * tasks).
 * 
 * @param {object} [jobScheduleUpdateParameter.jobSpecification.poolInfo] Gets
 * or sets the pool on which the Batch service runs the tasks of jobs created
 * under this schedule.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.poolId] Gets or sets
 * the id of an existing pool. All the tasks of the job will run on the
 * specified pool. You must specify either PoolId or AutoPoolSpecification,
 * but not both.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification]
 * Gets or sets characteristics for a temporary 'auto pool.' The Batch
 * service will create this auto pool and run all the tasks of the job on it,
 * and will delete the pool once the job has completed. You must specify
 * either PoolId or AutoPoolSpecification, but not both.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
 * Gets or sets a prefix to be added to the unique identifier when a pool is
 * automatically created. The prefix can be up to 20 characters long.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption]
 * Gets or sets the minimum lifetime of created auto pools, and how multiple
 * jobs on a schedule are assigned to pools. Possible values include:
 * 'jobschedule', 'job', 'unmapped'
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
 * Gets or sets whether to keep an auto pool alive after its lifetime expires.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool]
 * Gets or sets the pool specification for the auto pool.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
 * Gets or sets the display name for the pool.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize]
 * Gets or sets the size of the virtual machines in the pool. All VMs in a
 * pool are the same size.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.osFamily]
 * Gets or sets the Azure Guest OS family to be installed on the virtual
 * machines in the pool.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetOSVersion]
 * Gets or sets the Azure Guest OS version to be installed on the virtual
 * machines in the pool.
 * 
 * @param {number}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
 * Gets or sets the maximum number of tasks that can run concurrently on a
 * single compute node in the pool.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * Gets or sets how tasks are distributed among compute nodes in the pool.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType]
 * Gets or sets how tasks should be distributed across compute nodes.
 * Possible values include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
 * Gets or sets the timeout for allocation of compute nodes to the pool.
 * 
 * @param {number}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicated]
 * Gets or sets the desired number of compute nodes in the pool.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Gets or sets whether the pool size should automatically adjust over time.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * Gets or sets the formula for the desired number of compute nodes in the
 * pool.
 * 
 * @param {moment.duration}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * Gets or sets a time interval for the desired AutoScale evaluation period
 * in the pool.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Gets or sets whether the pool permits direct communication between nodes.
 * 
 * @param {object}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
 * Gets or sets a task to run on each compute node as it joins the pool. The
 * task runs when the node is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine]
 * Gets or sets the command line of the start task.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.runElevated]
 * Gets or sets whether to run the start task in elevated mode. The default
 * value is false.
 * 
 * @param {number}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried.
 * 
 * @param {boolean}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Gets or sets whether the Batch Service should wait for the start task to
 * complete successfully (that is, to exit with exit code 0) before
 * scheduling any tasks on the compute node.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * Gets or sets a list of certificates to be installed on each compute node
 * in the pool.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * Gets or sets the list of application packages to be installed on each
 * compute node in the pool.
 * 
 * @param {array}
 * [jobScheduleUpdateParameter.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
 * Gets or sets a list of name-value pairs associated with the pool as
 * metadata.
 * 
 * @param {array} [jobScheduleUpdateParameter.jobSpecification.metadata] Gets
 * or sets a list of name-value pairs associated with each job created under
 * this schedule as metadata.
 * 
 * @param {array} [jobScheduleUpdateParameter.metadata] Sets a list of
 * name-value pairs associated with the job schedule as metadata. If you do
 * not specify this element, it takes the default value of an empty list; in
 * effect, any existing metadata is deleted.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleUpdateOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.jobScheduleUpdateOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleUpdateOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleUpdateOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleUpdateOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleUpdateOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleUpdateOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleUpdateOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleUpdateOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.update = function (jobScheduleId, jobScheduleUpdateParameter, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleUpdateOptions = (options && options.jobScheduleUpdateOptions !== undefined) ? options.jobScheduleUpdateOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (jobScheduleUpdateParameter === null || jobScheduleUpdateParameter === undefined) {
      throw new Error('jobScheduleUpdateParameter cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      timeout = jobScheduleUpdateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      clientRequestId = jobScheduleUpdateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      returnClientRequestId = jobScheduleUpdateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      ocpDate = jobScheduleUpdateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      ifMatch = jobScheduleUpdateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      ifNoneMatch = jobScheduleUpdateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      ifModifiedSince = jobScheduleUpdateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleUpdateOptions !== null && jobScheduleUpdateOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleUpdateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (jobScheduleUpdateParameter !== null && jobScheduleUpdateParameter !== undefined) {
      var requestModelMapper = new client.models['JobScheduleUpdateParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, jobScheduleUpdateParameter, 'jobScheduleUpdateParameter');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(jobScheduleUpdateParameter, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Disables a job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to disable.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleDisableOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.jobScheduleDisableOptions.timeout] Sets the
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleDisableOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleDisableOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleDisableOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleDisableOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleDisableOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleDisableOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleDisableOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.disable = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleDisableOptions = (options && options.jobScheduleDisableOptions !== undefined) ? options.jobScheduleDisableOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      timeout = jobScheduleDisableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      clientRequestId = jobScheduleDisableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      returnClientRequestId = jobScheduleDisableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      ocpDate = jobScheduleDisableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      ifMatch = jobScheduleDisableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      ifNoneMatch = jobScheduleDisableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      ifModifiedSince = jobScheduleDisableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleDisableOptions !== null && jobScheduleDisableOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleDisableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}/disable';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 204) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Enables a job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to enable.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleEnableOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.jobScheduleEnableOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleEnableOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleEnableOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleEnableOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleEnableOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleEnableOptions.ifNoneMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleEnableOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleEnableOptions.ifUnmodifiedSince] Specify
 * this header to perform the operation only if the resource has not been
 * modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.enable = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleEnableOptions = (options && options.jobScheduleEnableOptions !== undefined) ? options.jobScheduleEnableOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      timeout = jobScheduleEnableOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      clientRequestId = jobScheduleEnableOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      returnClientRequestId = jobScheduleEnableOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      ocpDate = jobScheduleEnableOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      ifMatch = jobScheduleEnableOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      ifNoneMatch = jobScheduleEnableOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      ifModifiedSince = jobScheduleEnableOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleEnableOptions !== null && jobScheduleEnableOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleEnableOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}/enable';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 204) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Terminates a job schedule.
 *
 * @param {string} jobScheduleId The id of the job schedule to terminates.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleTerminateOptions] Additional parameters
 * for the operation
 * 
 * @param {number} [options.jobScheduleTerminateOptions.timeout] Sets the
 * maximum time that the server can spend processing the request, in seconds.
 * The default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleTerminateOptions.clientRequestId]
 * Caller generated request identity, in the form of a GUID with no
 * decoration such as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean}
 * [options.jobScheduleTerminateOptions.returnClientRequestId] Specifies if
 * the server should return the client-request-id identifier in the response.
 * 
 * @param {date} [options.jobScheduleTerminateOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {string} [options.jobScheduleTerminateOptions.ifMatch] An ETag is
 * specified. Specify this header to perform the operation only if the
 * resource's ETag is an exact match as specified.
 * 
 * @param {string} [options.jobScheduleTerminateOptions.ifNoneMatch] An ETag
 * is specified. Specify this header to perform the operation only if the
 * resource's ETag does not match the specified ETag.
 * 
 * @param {date} [options.jobScheduleTerminateOptions.ifModifiedSince] Specify
 * this header to perform the operation only if the resource has been
 * modified since the specified date/time.
 * 
 * @param {date} [options.jobScheduleTerminateOptions.ifUnmodifiedSince]
 * Specify this header to perform the operation only if the resource has not
 * been modified since the specified date/time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.terminate = function (jobScheduleId, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleTerminateOptions = (options && options.jobScheduleTerminateOptions !== undefined) ? options.jobScheduleTerminateOptions : undefined;
  // Validate
  try {
    if (jobScheduleId === null || jobScheduleId === undefined || typeof jobScheduleId.valueOf() !== 'string') {
      throw new Error('jobScheduleId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  var ifMatch;
  var ifNoneMatch;
  var ifModifiedSince;
  var ifUnmodifiedSince;
  try {
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      timeout = jobScheduleTerminateOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      clientRequestId = jobScheduleTerminateOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      returnClientRequestId = jobScheduleTerminateOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      ocpDate = jobScheduleTerminateOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      ifMatch = jobScheduleTerminateOptions.ifMatch;
      if (ifMatch !== null && ifMatch !== undefined && typeof ifMatch.valueOf() !== 'string') {
        throw new Error('ifMatch must be of type string.');
      }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      ifNoneMatch = jobScheduleTerminateOptions.ifNoneMatch;
      if (ifNoneMatch !== null && ifNoneMatch !== undefined && typeof ifNoneMatch.valueOf() !== 'string') {
        throw new Error('ifNoneMatch must be of type string.');
      }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      ifModifiedSince = jobScheduleTerminateOptions.ifModifiedSince;
      if (ifModifiedSince && !(ifModifiedSince instanceof Date || 
          (typeof ifModifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifModifiedSince))))) {
            throw new Error('ifModifiedSince must be of type date.');
          }
    }
    if (jobScheduleTerminateOptions !== null && jobScheduleTerminateOptions !== undefined)
    {
      ifUnmodifiedSince = jobScheduleTerminateOptions.ifUnmodifiedSince;
      if (ifUnmodifiedSince && !(ifUnmodifiedSince instanceof Date || 
          (typeof ifUnmodifiedSince.valueOf() === 'string' && !isNaN(Date.parse(ifUnmodifiedSince))))) {
            throw new Error('ifUnmodifiedSince must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules/{jobScheduleId}/terminate';
  requestUrl = requestUrl.replace('{jobScheduleId}', encodeURIComponent(jobScheduleId));
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if (ifMatch !== undefined && ifMatch !== null) {
    httpRequest.headers['If-Match'] = ifMatch;
  }
  if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
    httpRequest.headers['If-None-Match'] = ifNoneMatch;
  }
  if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
    httpRequest.headers['If-Modified-Since'] = ifModifiedSince.toUTCString();
  }
  if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
    httpRequest.headers['If-Unmodified-Since'] = ifUnmodifiedSince.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 202) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Adds a job schedule to the specified account.
 *
 * @param {object} cloudJobSchedule Specifies the job schedule to be added.
 * 
 * @param {string} [cloudJobSchedule.id] Gets or sets a string that uniquely
 * identifies the schedule within the account. A GUID is recommended.
 * 
 * @param {string} [cloudJobSchedule.displayName] Gets or sets the display
 * name for the schedule.
 * 
 * @param {object} [cloudJobSchedule.schedule] Gets or sets the schedule
 * according to which jobs will be created.
 * 
 * @param {date} [cloudJobSchedule.schedule.doNotRunUntil] Gets or sets the
 * earliest time at which any job may be created under this job schedule. If
 * you do not specify a doNotRunUntil time, the schedule becomes ready to
 * create jobs immediately.
 * 
 * @param {date} [cloudJobSchedule.schedule.doNotRunAfter] Gets or sets a time
 * after which no job will be created under this job schedule.  The schedule
 * will move to the completed state as soon as this deadline is past and
 * there is no active job under this job schedule.
 * 
 * @param {moment.duration} [cloudJobSchedule.schedule.startWindow] Gets or
 * sets the time interval, starting from the time at which the schedule
 * indicates a job should be created, within which a job must be created.  If
 * a job is not created within the startWindow interval, then the
 * 'opportunity' is lost; no job will be created until the next recurrence of
 * the schedule.
 * 
 * @param {moment.duration} [cloudJobSchedule.schedule.recurrenceInterval]
 * Gets or sets the time interval between the start times of two successive
 * jobs under the job schedule. A job schedule can have at most one active
 * job under it at any given time.
 * 
 * @param {object} [cloudJobSchedule.jobSpecification] Gets or sets the
 * details of the jobs to be created on this schedule.
 * 
 * @param {number} [cloudJobSchedule.jobSpecification.priority] Gets or sets
 * the priority of jobs created under this schedule. Priority values can
 * range from -1000 to 1000, with -1000 being the lowest priority and 1000
 * being the highest priority. The default value is 0.
 * 
 * @param {string} [cloudJobSchedule.jobSpecification.displayName] Gets or
 * sets the display name for jobs created under this schedule. It need not be
 * unique and can contain any Unicode characters up to a maximum length of
 * 1024.
 * 
 * @param {boolean} [cloudJobSchedule.jobSpecification.usesTaskDependencies]
 * Gets or sets the flag that determines if this job will use tasks with
 * dependencies.
 * 
 * @param {object} [cloudJobSchedule.jobSpecification.constraints] Gets or
 * sets the execution constraints for jobs created under this schedule.
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.constraints.maxWallClockTime] Gets or
 * sets the maximum elapsed time that the job may run, measured from the time
 * the job starts. If the job does not complete within the time limit, the
 * Batch service terminates it and any tasks that are still running.
 * 
 * @param {number}
 * [cloudJobSchedule.jobSpecification.constraints.maxTaskRetryCount] Gets or
 * sets the maximum number of times each task may be retried. The Batch
 * service retries a task if its exit code is nonzero.
 * 
 * @param {object} [cloudJobSchedule.jobSpecification.jobManagerTask] Gets or
 * sets the details of a Job Manager task to be launched when a job is
 * started under this schedule.
 * 
 * @param {string} [cloudJobSchedule.jobSpecification.jobManagerTask.id] Gets
 * or sets a string that uniquely identifies the Job Manager task. A GUID is
 * recommended.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.displayName] Gets or
 * sets the display name of the Job Manager task.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.commandLine] Gets or
 * sets the command line of the Job Manager task.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.resourceFiles] Gets or
 * sets a list of files that Batch will download to the compute node before
 * running the command line.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Manager
 * task.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.constraints] Gets or
 * sets constraints that apply to the Job Manager task.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.killJobOnCompletion]
 * Gets or sets whether completion of the Job Manager task signifies
 * completion of the entire job.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.runElevated] Gets or
 * sets whether to run the Job Manager task in elevated mode. The default
 * value is false.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobManagerTask.runExclusive] Gets or
 * sets whether the Job Manager task requires exclusive use of the compute
 * node where it runs.
 * 
 * @param {object} [cloudJobSchedule.jobSpecification.jobPreparationTask] Gets
 * or sets the Job Preparation task for jobs created under this schedule.
 * 
 * @param {string} [cloudJobSchedule.jobSpecification.jobPreparationTask.id]
 * Gets or sets a string that uniquely identifies the job preparation task
 * within the job. The id can contain any combination of alphanumeric
 * characters including hyphens and underscores and cannot contain more than
 * 64 characters.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.commandLine] Gets or
 * sets the command line of the Job Preparation task.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.resourceFiles] Gets
 * or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job
 * Preparation task.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints] Gets or
 * sets constraints that apply to the Job Preparation task..
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.maxWallClockTime]
 * Gets or sets the maximum elapsed time that the task may run, measured from
 * the time the task starts. If the task does not complete within the time
 * limit, the Batch service terminates it.
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.retentionTime]
 * Gets or sets the minimum time to retain the working directory for the task
 * on the compute node where it ran. After this time, the Batch service may
 * delete the working directory and all its contents. The default is infinite.
 * 
 * @param {number}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.constraints.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried. The
 * Batch service retries a task if its exit code is nonzero.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.waitForSuccess] Gets
 * or sets whether the Batch Service should wait for the Job Preparation task
 * to complete successfully before scheduling any other tasks of the job on
 * the compute node.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.runElevated] Gets or
 * sets whether to run the Job Preparation task in elevated mode. The default
 * value is false.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobPreparationTask.rerunOnNodeRebootAfterSuccess]
 * Gets or sets whether the Batch service should rerun the Job Preparation
 * task after a compute node reboots. The default value is true.
 * 
 * @param {object} [cloudJobSchedule.jobSpecification.jobReleaseTask] Gets or
 * sets the Job Release task for jobs created under this schedule.
 * 
 * @param {string} [cloudJobSchedule.jobSpecification.jobReleaseTask.id] Gets
 * or sets a string that uniquely identifies the Job Release task within the
 * job. The id can contain any combination of alphanumeric characters
 * including hyphens and underscores and cannot contain more than 64
 * characters.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.commandLine] Gets or
 * sets the command line of the Job Release task.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.resourceFiles] Gets or
 * sets a list of files that Batch will download to the compute node before
 * running the command line.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the Job Release
 * task.
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.maxWallClockTime] Gets
 * or sets the maximum elapsed time that the Job Release task may run on a
 * given compute node, measured from the time the task starts. If the task
 * does not complete within the time limit, the Batch service terminates it.
 * The default value is 15 minutes.
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.retentionTime] Gets or
 * sets the minimum time to retain the working directory for the Job Release
 * task on the compute node.  After this time, the Batch service may delete
 * the working directory and all its contents. The default is infinite.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.jobReleaseTask.runElevated] Gets or
 * sets whether to run the Job Release task in elevated mode. The default
 * value is false.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.commonEnvironmentSettings] Gets or sets
 * a list of common environment variable settings.  These environment
 * variables are set for all tasks in jobs created under this schedule
 * (including the Job Manager, Job Preparation and Job Release tasks).
 * 
 * @param {object} [cloudJobSchedule.jobSpecification.poolInfo] Gets or sets
 * the pool on which the Batch service runs the tasks of jobs created under
 * this schedule.
 * 
 * @param {string} [cloudJobSchedule.jobSpecification.poolInfo.poolId] Gets or
 * sets the id of an existing pool. All the tasks of the job will run on the
 * specified pool. You must specify either PoolId or AutoPoolSpecification,
 * but not both.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification] Gets or
 * sets characteristics for a temporary 'auto pool.' The Batch service will
 * create this auto pool and run all the tasks of the job on it, and will
 * delete the pool once the job has completed. You must specify either PoolId
 * or AutoPoolSpecification, but not both.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.autoPoolIdPrefix]
 * Gets or sets a prefix to be added to the unique identifier when a pool is
 * automatically created. The prefix can be up to 20 characters long.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.poolLifetimeOption]
 * Gets or sets the minimum lifetime of created auto pools, and how multiple
 * jobs on a schedule are assigned to pools. Possible values include:
 * 'jobschedule', 'job', 'unmapped'
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.keepAlive]
 * Gets or sets whether to keep an auto pool alive after its lifetime expires.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool]
 * Gets or sets the pool specification for the auto pool.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.displayName]
 * Gets or sets the display name for the pool.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.vmSize]
 * Gets or sets the size of the virtual machines in the pool. All VMs in a
 * pool are the same size.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.osFamily]
 * Gets or sets the Azure Guest OS family to be installed on the virtual
 * machines in the pool.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.targetOSVersion]
 * Gets or sets the Azure Guest OS version to be installed on the virtual
 * machines in the pool.
 * 
 * @param {number}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.maxTasksPerNode]
 * Gets or sets the maximum number of tasks that can run concurrently on a
 * single compute node in the pool.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy]
 * Gets or sets how tasks are distributed among compute nodes in the pool.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.taskSchedulingPolicy.nodeFillType]
 * Gets or sets how tasks should be distributed across compute nodes.
 * Possible values include: 'spread', 'pack', 'unmapped'
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.resizeTimeout]
 * Gets or sets the timeout for allocation of compute nodes to the pool.
 * 
 * @param {number}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.targetDedicated]
 * Gets or sets the desired number of compute nodes in the pool.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.enableAutoScale]
 * Gets or sets whether the pool size should automatically adjust over time.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleFormula]
 * Gets or sets the formula for the desired number of compute nodes in the
 * pool.
 * 
 * @param {moment.duration}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.autoScaleEvaluationInterval]
 * Gets or sets a time interval for the desired AutoScale evaluation period
 * in the pool.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.enableInterNodeCommunication]
 * Gets or sets whether the pool permits direct communication between nodes.
 * 
 * @param {object}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask]
 * Gets or sets a task to run on each compute node as it joins the pool. The
 * task runs when the node is added to the pool or when the node is restarted.
 * 
 * @param {string}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.commandLine]
 * Gets or sets the command line of the start task.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.resourceFiles]
 * Gets or sets a list of files that Batch will download to the compute node
 * before running the command line.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.environmentSettings]
 * Gets or sets a list of environment variable settings for the start task.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.runElevated]
 * Gets or sets whether to run the start task in elevated mode. The default
 * value is false.
 * 
 * @param {number}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.maxTaskRetryCount]
 * Gets or sets the maximum number of times the task may be retried.
 * 
 * @param {boolean}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.startTask.waitForSuccess]
 * Gets or sets whether the Batch Service should wait for the start task to
 * complete successfully (that is, to exit with exit code 0) before
 * scheduling any tasks on the compute node.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.certificateReferences]
 * Gets or sets a list of certificates to be installed on each compute node
 * in the pool.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.applicationPackageReferences]
 * Gets or sets the list of application packages to be installed on each
 * compute node in the pool.
 * 
 * @param {array}
 * [cloudJobSchedule.jobSpecification.poolInfo.autoPoolSpecification.pool.metadata]
 * Gets or sets a list of name-value pairs associated with the pool as
 * metadata.
 * 
 * @param {array} [cloudJobSchedule.jobSpecification.metadata] Gets or sets a
 * list of name-value pairs associated with each job created under this
 * schedule as metadata.
 * 
 * @param {array} [cloudJobSchedule.metadata] Gets or sets a list of
 * name-value pairs associated with the schedule as metadata.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleAddOptions] Additional parameters for
 * the operation
 * 
 * @param {number} [options.jobScheduleAddOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleAddOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleAddOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleAddOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.add = function (cloudJobSchedule, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleAddOptions = (options && options.jobScheduleAddOptions !== undefined) ? options.jobScheduleAddOptions : undefined;
  // Validate
  try {
    if (cloudJobSchedule === null || cloudJobSchedule === undefined) {
      throw new Error('cloudJobSchedule cannot be null or undefined.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined)
    {
      timeout = jobScheduleAddOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined)
    {
      clientRequestId = jobScheduleAddOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined)
    {
      returnClientRequestId = jobScheduleAddOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleAddOptions !== null && jobScheduleAddOptions !== undefined)
    {
      ocpDate = jobScheduleAddOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (cloudJobSchedule !== null && cloudJobSchedule !== undefined) {
      var requestModelMapper = new client.models['JobScheduleAddParameter']().mapper();
      requestModel = client.serialize(requestModelMapper, cloudJobSchedule, 'cloudJobSchedule');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the ' + 
        'payload - "%s"', error.message, util.inspect(cloudJobSchedule, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 201) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Lists all of the job schedules in the specified account.
 *
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleListOptions] Additional parameters for
 * the operation
 * 
 * @param {string} [options.jobScheduleListOptions.filter] Sets an OData
 * $filter clause.
 * 
 * @param {string} [options.jobScheduleListOptions.select] Sets an OData
 * $select clause.
 * 
 * @param {string} [options.jobScheduleListOptions.expand] Sets an OData
 * $expand clause.
 * 
 * @param {number} [options.jobScheduleListOptions.maxResults] Sets the
 * maximum number of items to return in the response.
 * 
 * @param {number} [options.jobScheduleListOptions.timeout] Sets the maximum
 * time that the server can spend processing the request, in seconds. The
 * default is 30 seconds.
 * 
 * @param {string} [options.jobScheduleListOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleListOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleListOptions.ocpDate] The time the request
 * was issued. If not specified, this header will be automatically populated
 * with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobScheduleListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.list = function (options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleListOptions = (options && options.jobScheduleListOptions !== undefined) ? options.jobScheduleListOptions : undefined;
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var filter;
  var select;
  var expand;
  var maxResults;
  var timeout;
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      filter = jobScheduleListOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      select = jobScheduleListOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      expand = jobScheduleListOptions.expand;
      if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
        throw new Error('expand must be of type string.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      maxResults = jobScheduleListOptions.maxResults;
      if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
        throw new Error('maxResults must be of type number.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      timeout = jobScheduleListOptions.timeout;
      if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
        throw new Error('timeout must be of type number.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      clientRequestId = jobScheduleListOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      returnClientRequestId = jobScheduleListOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleListOptions !== null && jobScheduleListOptions !== undefined)
    {
      ocpDate = jobScheduleListOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//jobschedules';
  var queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('maxresults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobScheduleListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Lists all of the job schedules in the specified account.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.jobScheduleListNextOptions] Additional parameters
 * for the operation
 * 
 * @param {string} [options.jobScheduleListNextOptions.clientRequestId] Caller
 * generated request identity, in the form of a GUID with no decoration such
 * as curly braces e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
 * 
 * @param {boolean} [options.jobScheduleListNextOptions.returnClientRequestId]
 * Specifies if the server should return the client-request-id identifier in
 * the response.
 * 
 * @param {date} [options.jobScheduleListNextOptions.ocpDate] The time the
 * request was issued. If not specified, this header will be automatically
 * populated with the current system clock time.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link CloudJobScheduleListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
JobSchedule.prototype.listNext = function (nextPageLink, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var jobScheduleListNextOptions = (options && options.jobScheduleListNextOptions !== undefined) ? options.jobScheduleListNextOptions : undefined;
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  var clientRequestId;
  var returnClientRequestId;
  var ocpDate;
  try {
    if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined)
    {
      clientRequestId = jobScheduleListNextOptions.clientRequestId;
      if (clientRequestId !== null && clientRequestId !== undefined && typeof clientRequestId.valueOf() !== 'string') {
        throw new Error('clientRequestId must be of type string.');
      }
    }
    if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined)
    {
      returnClientRequestId = jobScheduleListNextOptions.returnClientRequestId;
      if (returnClientRequestId !== null && returnClientRequestId !== undefined && typeof returnClientRequestId !== 'boolean') {
        throw new Error('returnClientRequestId must be of type boolean.');
      }
    }
    if (jobScheduleListNextOptions !== null && jobScheduleListNextOptions !== undefined)
    {
      ocpDate = jobScheduleListNextOptions.ocpDate;
      if (ocpDate && !(ocpDate instanceof Date || 
          (typeof ocpDate.valueOf() === 'string' && !isNaN(Date.parse(ocpDate))))) {
            throw new Error('ocpDate must be of type date.');
          }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if (clientRequestId !== undefined && clientRequestId !== null) {
    httpRequest.headers['client-request-id'] = clientRequestId;
  }
  if (returnClientRequestId !== undefined && returnClientRequestId !== null) {
    httpRequest.headers['return-client-request-id'] = returnClientRequestId.toString();
  }
  if (ocpDate !== undefined && ocpDate !== null) {
    httpRequest.headers['ocp-date'] = ocpDate.toUTCString();
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['BatchError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['CloudJobScheduleListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};


module.exports = JobSchedule;
