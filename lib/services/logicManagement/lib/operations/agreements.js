/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * Gets a list of integration account agreements.
 *
 * @param {string} resourceGroupName The resource group name.
 *
 * @param {string} integrationAccountName The integration account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.top] The number of items to be included in the
 * result.
 *
 * @param {string} [options.filter] The filter to apply on the operation.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IntegrationAccountAgreementListResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByIntegrationAccounts(resourceGroupName, integrationAccountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let top = (options && options.top !== undefined) ? options.top : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (integrationAccountName === null || integrationAccountName === undefined || typeof integrationAccountName.valueOf() !== 'string') {
      throw new Error('integrationAccountName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (top !== null && top !== undefined && typeof top !== 'number') {
      throw new Error('top must be of type number.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{integrationAccountName}', encodeURIComponent(integrationAccountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IntegrationAccountAgreementListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets an integration account agreement.
 *
 * @param {string} resourceGroupName The resource group name.
 *
 * @param {string} integrationAccountName The integration account name.
 *
 * @param {string} agreementName The integration account agreement name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IntegrationAccountAgreement} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(resourceGroupName, integrationAccountName, agreementName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (integrationAccountName === null || integrationAccountName === undefined || typeof integrationAccountName.valueOf() !== 'string') {
      throw new Error('integrationAccountName cannot be null or undefined and it must be of type string.');
    }
    if (agreementName === null || agreementName === undefined || typeof agreementName.valueOf() !== 'string') {
      throw new Error('agreementName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{integrationAccountName}', encodeURIComponent(integrationAccountName));
  requestUrl = requestUrl.replace('{agreementName}', encodeURIComponent(agreementName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IntegrationAccountAgreement']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Creates or updates an integration account agreement.
 *
 * @param {string} resourceGroupName The resource group name.
 *
 * @param {string} integrationAccountName The integration account name.
 *
 * @param {string} agreementName The integration account agreement name.
 *
 * @param {object} agreement The integration account agreement.
 *
 * @param {object} [agreement.metadata] The metadata.
 *
 * @param {string} agreement.agreementType The agreement type. Possible values
 * include: 'NotSpecified', 'AS2', 'X12', 'Edifact'
 *
 * @param {string} agreement.hostPartner The integration account partner that
 * is set as host partner for this agreement.
 *
 * @param {string} agreement.guestPartner The integration account partner that
 * is set as guest partner for this agreement.
 *
 * @param {object} agreement.hostIdentity The business identity of the host
 * partner.
 *
 * @param {object} agreement.guestIdentity The business identity of the guest
 * partner.
 *
 * @param {object} agreement.content The agreement content.
 *
 * @param {object} [agreement.content.aS2] The AS2 agreement content.
 *
 * @param {object} agreement.content.aS2.receiveAgreement The AS2 one-way
 * receive agreement.
 *
 * @param {object} agreement.content.aS2.sendAgreement The AS2 one-way send
 * agreement.
 *
 * @param {object} agreement.content.aS2.sendAgreement.senderBusinessIdentity
 * The sender business identity
 *
 * @param {object} agreement.content.aS2.sendAgreement.receiverBusinessIdentity
 * The receiver business identity
 *
 * @param {object} agreement.content.aS2.sendAgreement.protocolSettings The AS2
 * protocol settings.
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings
 * The message connection settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.ignoreCertificateNameMismatch
 * The value indicating whether to ignore mismatch in certificate name.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.supportHttpStatusCodeContinue
 * The value indicating whether to support HTTP status code 'CONTINUE'.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.keepHttpConnectionAlive
 * The value indicating whether to keep the connection alive.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.unfoldHttpHeaders
 * The value indicating whether to unfold the HTTP headers.
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings
 * The acknowledgement connection settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.ignoreCertificateNameMismatch
 * The value indicating whether to ignore mismatch in certificate name.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.supportHttpStatusCodeContinue
 * The value indicating whether to support HTTP status code 'CONTINUE'.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.keepHttpConnectionAlive
 * The value indicating whether to keep the connection alive.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.unfoldHttpHeaders
 * The value indicating whether to unfold the HTTP headers.
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings The MDN
 * settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.needMdn The
 * value indicating whether to send or request a MDN.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signMdn The
 * value indicating whether the MDN needs to be signed or not.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendMdnAsynchronously
 * The value indicating whether to send the asynchronous MDN.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.receiptDeliveryUrl]
 * The receipt delivery URL.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.dispositionNotificationTo]
 * The disposition notification to header value.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signOutboundMdnIfOptional
 * The value indicating whether to sign the outbound MDN if optional.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.mdnText]
 * The MDN text.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendInboundMdnToMessageBox
 * The value indicating whether to send inbound MDN to message box.
 *
 * @param {string}
 * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.micHashingAlgorithm
 * The signing or hashing algorithm. Possible values include: 'NotSpecified',
 * 'None', 'MD5', 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings The
 * security settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.overrideGroupSigningCertificate
 * The value indicating whether to send or request a MDN.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.signingCertificateName]
 * The name of the signing certificate.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.encryptionCertificateName]
 * The name of the encryption certificate.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundEncodedMessages
 * The value indicating whether to enable NRR for inbound encoded messages.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundDecodedMessages
 * The value indicating whether to enable NRR for inbound decoded messages.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundMdn
 * The value indicating whether to enable NRR for outbound MDN.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundEncodedMessages
 * The value indicating whether to enable NRR for outbound encoded messages.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundDecodedMessages
 * The value indicating whether to enable NRR for outbound decoded messages.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundMdn
 * The value indicating whether to enable NRR for inbound MDN.
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.sha2AlgorithmFormat]
 * The Sha2 algorithm format. Valid values are Sha2, ShaHashSize,
 * ShaHyphenHashSize, Sha2UnderscoreHashSize.
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings The
 * validation settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.overrideMessageProperties
 * The value indicating whether to override incoming message properties with
 * those in agreement.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptMessage
 * The value indicating whether the message has to be encrypted.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signMessage
 * The value indicating whether the message has to be signed.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.compressMessage
 * The value indicating whether the message has to be compressed.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkDuplicateMessage
 * The value indicating whether to check for duplicate message.
 *
 * @param {number}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.interchangeDuplicatesValidityDays
 * The number of days to look back for duplicate interchange.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnSend
 * The value indicating whether to check for certificate revocation list on
 * send.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnReceive
 * The value indicating whether to check for certificate revocation list on
 * receive.
 *
 * @param {string}
 * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptionAlgorithm
 * The encryption algorithm. Possible values include: 'NotSpecified', 'None',
 * 'DES3', 'RC2', 'AES128', 'AES192', 'AES256'
 *
 * @param {string}
 * [agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signingAlgorithm]
 * The signing algorithm. Possible values include: 'NotSpecified', 'Default',
 * 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings The
 * envelope settings.
 *
 * @param {string}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.messageContentType
 * The message content type.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.transmitFileNameInMimeHeader
 * The value indicating whether to transmit file name in mime header.
 *
 * @param {string}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.fileNameTemplate
 * The template for file name.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.suspendMessageOnFileNameGenerationError
 * The value indicating whether to suspend message on file name generation
 * error.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.autogenerateFileName
 * The value indicating whether to auto generate file name.
 *
 * @param {object}
 * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings The error
 * settings.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.suspendDuplicateMessage
 * The value indicating whether to suspend duplicate message.
 *
 * @param {boolean}
 * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.resendIfMdnNotReceived
 * The value indicating whether to resend message If MDN is not received.
 *
 * @param {object} [agreement.content.x12] The X12 agreement content.
 *
 * @param {object} agreement.content.x12.receiveAgreement The X12 one-way
 * receive agreement.
 *
 * @param {object} agreement.content.x12.sendAgreement The X12 one-way send
 * agreement.
 *
 * @param {object} agreement.content.x12.sendAgreement.senderBusinessIdentity
 * The sender business identity
 *
 * @param {object} agreement.content.x12.sendAgreement.receiverBusinessIdentity
 * The receiver business identity
 *
 * @param {object} agreement.content.x12.sendAgreement.protocolSettings The X12
 * protocol settings.
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings The
 * X12 validation settings.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
 * The value indicating whether to validate character set in the message.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
 * The value indicating whether to check for duplicate interchange control
 * number.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
 * The validity period of interchange control number.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
 * The value indicating whether to check for duplicate group control number.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
 * The value indicating whether to check for duplicate transaction set control
 * number.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
 * The value indicating whether to Whether to validate EDI types.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
 * The value indicating whether to Whether to validate XSD types.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
 * The value indicating whether to allow leading and trailing spaces and
 * zeroes.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
 * The value indicating whether to trim leading and trailing spaces and zeroes.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
 * The trailing separator policy. Possible values include: 'NotSpecified',
 * 'NotAllowed', 'Optional', 'Mandatory'
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings The X12
 * framing settings.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
 * The data element separator.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.componentSeparator
 * The component separator.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceSeparatorsInPayload
 * The value indicating whether to replace separators in payload.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceCharacter
 * The replacement character.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminator
 * The segment terminator.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.characterSet
 * The X12 character set. Possible values include: 'NotSpecified', 'Basic',
 * 'Extended', 'UTF8'
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
 * The segment terminator suffix. Possible values include: 'NotSpecified',
 * 'None', 'CR', 'LF', 'CRLF'
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings The
 * X12 envelope settings.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlStandardsId
 * The controls standards id.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.useControlStandardsIdAsRepetitionCharacter
 * The value indicating whether to use control standards id as repetition
 * character.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.senderApplicationId
 * The sender application id.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.receiverApplicationId
 * The receiver application id.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlVersionNumber
 * The control version number.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
 * The interchange  control number lower bound.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
 * The interchange  control number upper bound.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
 * The value indicating whether to rollover interchange control number.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
 * The value indicating whether to enable default group headers.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
 * The functional group id.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
 * The group control number lower bound.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
 * The group control number upper bound.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
 * The value indicating whether to rollover group control number.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderAgencyCode
 * The group header agency code.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderVersion
 * The group header version.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
 * The transaction set control number lower bound.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
 * The transaction set control number upper bound.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
 * The value indicating whether to rollover transaction set control number.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
 * The transaction set control number prefix.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
 * The transaction set control number suffix.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
 * The value indicating whether to overwrite existing transaction set control
 * number.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderDateFormat
 * The group header date format. Possible values include: 'NotSpecified',
 * 'CCYYMMDD', 'YYMMDD'
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderTimeFormat
 * The group header time format. Possible values include: 'NotSpecified',
 * 'HHMM', 'HHMMSS', 'HHMMSSdd', 'HHMMSSd'
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.usageIndicator
 * The usage indicator. Possible values include: 'NotSpecified', 'Test',
 * 'Information', 'Production'
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings
 * The X12 acknowledgment settings.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
 * The value indicating whether technical acknowledgement is needed.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
 * The value indicating whether to batch the technical acknowledgements.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
 * The value indicating whether functional acknowledgement is needed.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.functionalAcknowledgementVersion]
 * The functional acknowledgement version.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
 * The value indicating whether to batch functional acknowledgements.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needImplementationAcknowledgement
 * The value indicating whether implementation acknowledgement is needed.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.implementationAcknowledgementVersion]
 * The implementation acknowledgement version.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchImplementationAcknowledgements
 * The value indicating whether to batch implementation acknowledgements.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
 * The value indicating whether a loop is needed for valid messages.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
 * The value indicating whether to send synchronous acknowledgement.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
 * The acknowledgement control number prefix.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
 * The acknowledgement control number suffix.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
 * The acknowledgement control number lower bound.
 *
 * @param {number}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
 * The acknowledgement control number upper bound.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
 * The value indicating whether to rollover acknowledgement control number.
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.messageFilter The X12
 * message filter.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.messageFilter.messageFilterType
 * The message filter type. Possible values include: 'NotSpecified', 'Include',
 * 'Exclude'
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.securitySettings The
 * X12 security settings.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationQualifier
 * The authorization qualifier.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationValue]
 * The authorization value.
 *
 * @param {string}
 * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.securityQualifier
 * The security qualifier.
 *
 * @param {string}
 * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.passwordValue]
 * The password value.
 *
 * @param {object}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings The
 * X12 processing settings.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
 * The value indicating whether to mask security information.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.convertImpliedDecimal
 * The value indicating whether to convert numerical type to implied decimal.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.preserveInterchange
 * The value indicating whether to preserve interchange.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
 * The value indicating whether to suspend interchange on error.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
 * The value indicating whether to create empty xml tags for trailing
 * separators.
 *
 * @param {boolean}
 * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
 * The value indicating whether to use dot as decimal separator.
 *
 * @param {array}
 * [agreement.content.x12.sendAgreement.protocolSettings.envelopeOverrides] The
 * X12 envelope override settings.
 *
 * @param {array}
 * [agreement.content.x12.sendAgreement.protocolSettings.validationOverrides]
 * The X12 validation override settings.
 *
 * @param {array}
 * [agreement.content.x12.sendAgreement.protocolSettings.messageFilterList] The
 * X12 message filter list.
 *
 * @param {array}
 * agreement.content.x12.sendAgreement.protocolSettings.schemaReferences The
 * X12 schema references.
 *
 * @param {array}
 * [agreement.content.x12.sendAgreement.protocolSettings.x12DelimiterOverrides]
 * The X12 delimiter override settings.
 *
 * @param {object} [agreement.content.edifact] The EDIFACT agreement content.
 *
 * @param {object} agreement.content.edifact.receiveAgreement The EDIFACT
 * one-way receive agreement.
 *
 * @param {object} agreement.content.edifact.sendAgreement The EDIFACT one-way
 * send agreement.
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.senderBusinessIdentity The sender
 * business identity
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.receiverBusinessIdentity The
 * receiver business identity
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.qualifier
 * The business identity qualifier e.g. as2identity, ZZ, ZZZ, 31, 32
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.value The
 * user defined business identity value.
 *
 * @param {object} agreement.content.edifact.sendAgreement.protocolSettings The
 * EDIFACT protocol settings.
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings
 * The EDIFACT validation settings.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
 * The value indicating whether to validate character set in the message.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
 * The value indicating whether to check for duplicate interchange control
 * number.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
 * The validity period of interchange control number.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
 * The value indicating whether to check for duplicate group control number.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
 * The value indicating whether to check for duplicate transaction set control
 * number.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
 * The value indicating whether to Whether to validate EDI types.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
 * The value indicating whether to Whether to validate XSD types.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
 * The value indicating whether to allow leading and trailing spaces and
 * zeroes.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
 * The value indicating whether to trim leading and trailing spaces and zeroes.
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
 * The trailing separator policy. Possible values include: 'NotSpecified',
 * 'NotAllowed', 'Optional', 'Mandatory'
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings The
 * EDIFACT framing settings.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.serviceCodeListDirectoryVersion]
 * The service code list directory version.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterEncoding]
 * The character encoding.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.protocolVersion
 * The protocol version.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
 * The data element separator.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.componentSeparator
 * The component separator.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminator
 * The segment terminator.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.releaseIndicator
 * The release indicator.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.repetitionSeparator
 * The repetition separator.
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterSet
 * The EDIFACT frame setting characterSet. Possible values include:
 * 'NotSpecified', 'UNOB', 'UNOA', 'UNOC', 'UNOD', 'UNOE', 'UNOF', 'UNOG',
 * 'UNOH', 'UNOI', 'UNOJ', 'UNOK', 'UNOX', 'UNOY', 'KECA'
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.decimalPointIndicator
 * The EDIFACT frame setting decimal indicator. Possible values include:
 * 'NotSpecified', 'Comma', 'Decimal'
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
 * The EDIFACT frame setting segment terminator suffix. Possible values
 * include: 'NotSpecified', 'None', 'CR', 'LF', 'CRLF'
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings
 * The EDIFACT envelope settings.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupAssociationAssignedCode]
 * The group association assigned code.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.communicationAgreementId]
 * The communication agreement id.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applyDelimiterStringAdvice
 * The value indicating whether to apply delimiter string advice.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.createGroupingSegments
 * The value indicating whether to create grouping segments.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
 * The value indicating whether to enable default group headers.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordValue]
 * The recipient reference password value.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordQualifier]
 * The recipient reference password qualifier.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applicationReferenceId]
 * The application reference id.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.processingPriorityCode]
 * The processing priority code.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
 * The interchange control number lower bound.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
 * The interchange control number upper bound.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
 * The value indicating whether to rollover interchange control number.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberPrefix]
 * The interchange control number prefix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberSuffix]
 * The interchange control number suffix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderReverseRoutingAddress]
 * The sender reverse routing address.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverReverseRoutingAddress]
 * The receiver reverse routing address.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
 * The functional group id.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControllingAgencyCode]
 * The group controlling agency code.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageVersion]
 * The group message version.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageRelease]
 * The group message release.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
 * The group control number lower bound.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
 * The group control number upper bound.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
 * The value indicating whether to rollover group control number.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberPrefix]
 * The group control number prefix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberSuffix]
 * The group control number suffix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverQualifier]
 * The group application receiver qualifier.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverId]
 * The group application receiver id.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderQualifier]
 * The group application sender qualifier.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderId]
 * The group application sender id.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationPassword]
 * The group application password.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
 * The value indicating whether to overwrite existing transaction set control
 * number.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
 * The transaction set control number prefix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
 * The transaction set control number suffix.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
 * The transaction set control number lower bound.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
 * The transaction set control number upper bound.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
 * The value indicating whether to rollover transaction set control number.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.isTestInterchange
 * The value indicating whether the message is a test interchange.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalIdentification]
 * The sender internal identification.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalSubIdentification]
 * The sender internal sub identification.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalIdentification]
 * The receiver internal identification.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalSubIdentification]
 * The receiver internal sub identification.
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings
 * The EDIFACT acknowledgement settings.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
 * The value indicating whether technical acknowledgement is needed.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
 * The value indicating whether to batch the technical acknowledgements.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
 * The value indicating whether functional acknowledgement is needed.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
 * The value indicating whether to batch functional acknowledgements.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
 * The value indicating whether a loop is needed for valid messages.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
 * The value indicating whether to send synchronous acknowledgement.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
 * The acknowledgement control number prefix.
 *
 * @param {string}
 * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
 * The acknowledgement control number suffix.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
 * The acknowledgement control number lower bound.
 *
 * @param {number}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
 * The acknowledgement control number upper bound.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
 * The value indicating whether to rollover acknowledgement control number.
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter The
 * EDIFACT message filter.
 *
 * @param {string}
 * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter.messageFilterType
 * The message filter type. Possible values include: 'NotSpecified', 'Include',
 * 'Exclude'
 *
 * @param {object}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings
 * The EDIFACT processing Settings.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
 * The value indicating whether to mask security information.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.preserveInterchange
 * The value indicating whether to preserve interchange.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
 * The value indicating whether to suspend interchange on error.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
 * The value indicating whether to create empty xml tags for trailing
 * separators.
 *
 * @param {boolean}
 * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
 * The value indicating whether to use dot as decimal separator.
 *
 * @param {array}
 * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeOverrides]
 * The EDIFACT envelope override settings.
 *
 * @param {array}
 * [agreement.content.edifact.sendAgreement.protocolSettings.messageFilterList]
 * The EDIFACT message filter list.
 *
 * @param {array}
 * agreement.content.edifact.sendAgreement.protocolSettings.schemaReferences
 * The EDIFACT schema references.
 *
 * @param {array}
 * [agreement.content.edifact.sendAgreement.protocolSettings.validationOverrides]
 * The EDIFACT validation override settings.
 *
 * @param {array}
 * [agreement.content.edifact.sendAgreement.protocolSettings.edifactDelimiterOverrides]
 * The EDIFACT delimiter override settings.
 *
 * @param {string} [agreement.location] The resource location.
 *
 * @param {object} [agreement.tags] The resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IntegrationAccountAgreement} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (integrationAccountName === null || integrationAccountName === undefined || typeof integrationAccountName.valueOf() !== 'string') {
      throw new Error('integrationAccountName cannot be null or undefined and it must be of type string.');
    }
    if (agreementName === null || agreementName === undefined || typeof agreementName.valueOf() !== 'string') {
      throw new Error('agreementName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (agreement === null || agreement === undefined) {
      throw new Error('agreement cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{integrationAccountName}', encodeURIComponent(integrationAccountName));
  requestUrl = requestUrl.replace('{agreementName}', encodeURIComponent(agreementName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (agreement !== null && agreement !== undefined) {
      let requestModelMapper = new client.models['IntegrationAccountAgreement']().mapper();
      requestModel = client.serialize(requestModelMapper, agreement, 'agreement');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(agreement, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IntegrationAccountAgreement']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IntegrationAccountAgreement']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an integration account agreement.
 *
 * @param {string} resourceGroupName The resource group name.
 *
 * @param {string} integrationAccountName The integration account name.
 *
 * @param {string} agreementName The integration account agreement name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(resourceGroupName, integrationAccountName, agreementName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (integrationAccountName === null || integrationAccountName === undefined || typeof integrationAccountName.valueOf() !== 'string') {
      throw new Error('integrationAccountName cannot be null or undefined and it must be of type string.');
    }
    if (agreementName === null || agreementName === undefined || typeof agreementName.valueOf() !== 'string') {
      throw new Error('agreementName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{integrationAccountName}', encodeURIComponent(integrationAccountName));
  requestUrl = requestUrl.replace('{agreementName}', encodeURIComponent(agreementName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets a list of integration account agreements.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IntegrationAccountAgreementListResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByIntegrationAccountsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IntegrationAccountAgreementListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a Agreements. */
class Agreements {
  /**
   * Create a Agreements.
   * @param {LogicManagementClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._listByIntegrationAccounts = _listByIntegrationAccounts;
    this._get = _get;
    this._createOrUpdate = _createOrUpdate;
    this._deleteMethod = _deleteMethod;
    this._listByIntegrationAccountsNext = _listByIntegrationAccountsNext;
  }

  /**
   * Gets a list of integration account agreements.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] The number of items to be included in the
   * result.
   *
   * @param {string} [options.filter] The filter to apply on the operation.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IntegrationAccountAgreementListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByIntegrationAccountsWithHttpOperationResponse(resourceGroupName, integrationAccountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByIntegrationAccounts(resourceGroupName, integrationAccountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets a list of integration account agreements.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] The number of items to be included in the
   * result.
   *
   * @param {string} [options.filter] The filter to apply on the operation.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IntegrationAccountAgreementListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IntegrationAccountAgreementListResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByIntegrationAccounts(resourceGroupName, integrationAccountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByIntegrationAccounts(resourceGroupName, integrationAccountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByIntegrationAccounts(resourceGroupName, integrationAccountName, options, optionalCallback);
    }
  }

  /**
   * Gets an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IntegrationAccountAgreement>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(resourceGroupName, integrationAccountName, agreementName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(resourceGroupName, integrationAccountName, agreementName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IntegrationAccountAgreement} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IntegrationAccountAgreement} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(resourceGroupName, integrationAccountName, agreementName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(resourceGroupName, integrationAccountName, agreementName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(resourceGroupName, integrationAccountName, agreementName, options, optionalCallback);
    }
  }

  /**
   * Creates or updates an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} agreement The integration account agreement.
   *
   * @param {object} [agreement.metadata] The metadata.
   *
   * @param {string} agreement.agreementType The agreement type. Possible values
   * include: 'NotSpecified', 'AS2', 'X12', 'Edifact'
   *
   * @param {string} agreement.hostPartner The integration account partner that
   * is set as host partner for this agreement.
   *
   * @param {string} agreement.guestPartner The integration account partner that
   * is set as guest partner for this agreement.
   *
   * @param {object} agreement.hostIdentity The business identity of the host
   * partner.
   *
   * @param {object} agreement.guestIdentity The business identity of the guest
   * partner.
   *
   * @param {object} agreement.content The agreement content.
   *
   * @param {object} [agreement.content.aS2] The AS2 agreement content.
   *
   * @param {object} agreement.content.aS2.receiveAgreement The AS2 one-way
   * receive agreement.
   *
   * @param {object} agreement.content.aS2.sendAgreement The AS2 one-way send
   * agreement.
   *
   * @param {object} agreement.content.aS2.sendAgreement.senderBusinessIdentity
   * The sender business identity
   *
   * @param {object} agreement.content.aS2.sendAgreement.receiverBusinessIdentity
   * The receiver business identity
   *
   * @param {object} agreement.content.aS2.sendAgreement.protocolSettings The AS2
   * protocol settings.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings
   * The message connection settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.ignoreCertificateNameMismatch
   * The value indicating whether to ignore mismatch in certificate name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.supportHttpStatusCodeContinue
   * The value indicating whether to support HTTP status code 'CONTINUE'.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.keepHttpConnectionAlive
   * The value indicating whether to keep the connection alive.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.unfoldHttpHeaders
   * The value indicating whether to unfold the HTTP headers.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings
   * The acknowledgement connection settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.ignoreCertificateNameMismatch
   * The value indicating whether to ignore mismatch in certificate name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.supportHttpStatusCodeContinue
   * The value indicating whether to support HTTP status code 'CONTINUE'.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.keepHttpConnectionAlive
   * The value indicating whether to keep the connection alive.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.unfoldHttpHeaders
   * The value indicating whether to unfold the HTTP headers.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings The MDN
   * settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.needMdn The
   * value indicating whether to send or request a MDN.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signMdn The
   * value indicating whether the MDN needs to be signed or not.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendMdnAsynchronously
   * The value indicating whether to send the asynchronous MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.receiptDeliveryUrl]
   * The receipt delivery URL.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.dispositionNotificationTo]
   * The disposition notification to header value.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signOutboundMdnIfOptional
   * The value indicating whether to sign the outbound MDN if optional.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.mdnText]
   * The MDN text.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendInboundMdnToMessageBox
   * The value indicating whether to send inbound MDN to message box.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.micHashingAlgorithm
   * The signing or hashing algorithm. Possible values include: 'NotSpecified',
   * 'None', 'MD5', 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings The
   * security settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.overrideGroupSigningCertificate
   * The value indicating whether to send or request a MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.signingCertificateName]
   * The name of the signing certificate.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.encryptionCertificateName]
   * The name of the encryption certificate.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundEncodedMessages
   * The value indicating whether to enable NRR for inbound encoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundDecodedMessages
   * The value indicating whether to enable NRR for inbound decoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundMdn
   * The value indicating whether to enable NRR for outbound MDN.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundEncodedMessages
   * The value indicating whether to enable NRR for outbound encoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundDecodedMessages
   * The value indicating whether to enable NRR for outbound decoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundMdn
   * The value indicating whether to enable NRR for inbound MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.sha2AlgorithmFormat]
   * The Sha2 algorithm format. Valid values are Sha2, ShaHashSize,
   * ShaHyphenHashSize, Sha2UnderscoreHashSize.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings The
   * validation settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.overrideMessageProperties
   * The value indicating whether to override incoming message properties with
   * those in agreement.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptMessage
   * The value indicating whether the message has to be encrypted.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signMessage
   * The value indicating whether the message has to be signed.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.compressMessage
   * The value indicating whether the message has to be compressed.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkDuplicateMessage
   * The value indicating whether to check for duplicate message.
   *
   * @param {number}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.interchangeDuplicatesValidityDays
   * The number of days to look back for duplicate interchange.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnSend
   * The value indicating whether to check for certificate revocation list on
   * send.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnReceive
   * The value indicating whether to check for certificate revocation list on
   * receive.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptionAlgorithm
   * The encryption algorithm. Possible values include: 'NotSpecified', 'None',
   * 'DES3', 'RC2', 'AES128', 'AES192', 'AES256'
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signingAlgorithm]
   * The signing algorithm. Possible values include: 'NotSpecified', 'Default',
   * 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings The
   * envelope settings.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.messageContentType
   * The message content type.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.transmitFileNameInMimeHeader
   * The value indicating whether to transmit file name in mime header.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.fileNameTemplate
   * The template for file name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.suspendMessageOnFileNameGenerationError
   * The value indicating whether to suspend message on file name generation
   * error.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.autogenerateFileName
   * The value indicating whether to auto generate file name.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings The error
   * settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.suspendDuplicateMessage
   * The value indicating whether to suspend duplicate message.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.resendIfMdnNotReceived
   * The value indicating whether to resend message If MDN is not received.
   *
   * @param {object} [agreement.content.x12] The X12 agreement content.
   *
   * @param {object} agreement.content.x12.receiveAgreement The X12 one-way
   * receive agreement.
   *
   * @param {object} agreement.content.x12.sendAgreement The X12 one-way send
   * agreement.
   *
   * @param {object} agreement.content.x12.sendAgreement.senderBusinessIdentity
   * The sender business identity
   *
   * @param {object} agreement.content.x12.sendAgreement.receiverBusinessIdentity
   * The receiver business identity
   *
   * @param {object} agreement.content.x12.sendAgreement.protocolSettings The X12
   * protocol settings.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings The
   * X12 validation settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
   * The value indicating whether to validate character set in the message.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
   * The value indicating whether to check for duplicate interchange control
   * number.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
   * The validity period of interchange control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
   * The value indicating whether to check for duplicate group control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
   * The value indicating whether to check for duplicate transaction set control
   * number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
   * The value indicating whether to Whether to validate EDI types.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
   * The value indicating whether to Whether to validate XSD types.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to allow leading and trailing spaces and
   * zeroes.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to trim leading and trailing spaces and zeroes.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
   * The trailing separator policy. Possible values include: 'NotSpecified',
   * 'NotAllowed', 'Optional', 'Mandatory'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings The X12
   * framing settings.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
   * The data element separator.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.componentSeparator
   * The component separator.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceSeparatorsInPayload
   * The value indicating whether to replace separators in payload.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceCharacter
   * The replacement character.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminator
   * The segment terminator.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.characterSet
   * The X12 character set. Possible values include: 'NotSpecified', 'Basic',
   * 'Extended', 'UTF8'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
   * The segment terminator suffix. Possible values include: 'NotSpecified',
   * 'None', 'CR', 'LF', 'CRLF'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings The
   * X12 envelope settings.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlStandardsId
   * The controls standards id.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.useControlStandardsIdAsRepetitionCharacter
   * The value indicating whether to use control standards id as repetition
   * character.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.senderApplicationId
   * The sender application id.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.receiverApplicationId
   * The receiver application id.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlVersionNumber
   * The control version number.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
   * The interchange  control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
   * The interchange  control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
   * The value indicating whether to rollover interchange control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
   * The value indicating whether to enable default group headers.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
   * The functional group id.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
   * The group control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
   * The group control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
   * The value indicating whether to rollover group control number.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderAgencyCode
   * The group header agency code.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderVersion
   * The group header version.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
   * The transaction set control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
   * The transaction set control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
   * The value indicating whether to rollover transaction set control number.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
   * The transaction set control number prefix.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
   * The transaction set control number suffix.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
   * The value indicating whether to overwrite existing transaction set control
   * number.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderDateFormat
   * The group header date format. Possible values include: 'NotSpecified',
   * 'CCYYMMDD', 'YYMMDD'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderTimeFormat
   * The group header time format. Possible values include: 'NotSpecified',
   * 'HHMM', 'HHMMSS', 'HHMMSSdd', 'HHMMSSd'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.usageIndicator
   * The usage indicator. Possible values include: 'NotSpecified', 'Test',
   * 'Information', 'Production'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings
   * The X12 acknowledgment settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
   * The value indicating whether technical acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
   * The value indicating whether to batch the technical acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
   * The value indicating whether functional acknowledgement is needed.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.functionalAcknowledgementVersion]
   * The functional acknowledgement version.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
   * The value indicating whether to batch functional acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needImplementationAcknowledgement
   * The value indicating whether implementation acknowledgement is needed.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.implementationAcknowledgementVersion]
   * The implementation acknowledgement version.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchImplementationAcknowledgements
   * The value indicating whether to batch implementation acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
   * The value indicating whether a loop is needed for valid messages.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
   * The value indicating whether to send synchronous acknowledgement.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
   * The acknowledgement control number prefix.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
   * The acknowledgement control number suffix.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
   * The acknowledgement control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
   * The acknowledgement control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
   * The value indicating whether to rollover acknowledgement control number.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.messageFilter The X12
   * message filter.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.messageFilter.messageFilterType
   * The message filter type. Possible values include: 'NotSpecified', 'Include',
   * 'Exclude'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings The
   * X12 security settings.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationQualifier
   * The authorization qualifier.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationValue]
   * The authorization value.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.securityQualifier
   * The security qualifier.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.passwordValue]
   * The password value.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings The
   * X12 processing settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
   * The value indicating whether to mask security information.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.convertImpliedDecimal
   * The value indicating whether to convert numerical type to implied decimal.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.preserveInterchange
   * The value indicating whether to preserve interchange.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
   * The value indicating whether to suspend interchange on error.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
   * The value indicating whether to create empty xml tags for trailing
   * separators.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
   * The value indicating whether to use dot as decimal separator.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeOverrides] The
   * X12 envelope override settings.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.validationOverrides]
   * The X12 validation override settings.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.messageFilterList] The
   * X12 message filter list.
   *
   * @param {array}
   * agreement.content.x12.sendAgreement.protocolSettings.schemaReferences The
   * X12 schema references.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.x12DelimiterOverrides]
   * The X12 delimiter override settings.
   *
   * @param {object} [agreement.content.edifact] The EDIFACT agreement content.
   *
   * @param {object} agreement.content.edifact.receiveAgreement The EDIFACT
   * one-way receive agreement.
   *
   * @param {object} agreement.content.edifact.sendAgreement The EDIFACT one-way
   * send agreement.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.senderBusinessIdentity The sender
   * business identity
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity The
   * receiver business identity
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.qualifier
   * The business identity qualifier e.g. as2identity, ZZ, ZZZ, 31, 32
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.value The
   * user defined business identity value.
   *
   * @param {object} agreement.content.edifact.sendAgreement.protocolSettings The
   * EDIFACT protocol settings.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings
   * The EDIFACT validation settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
   * The value indicating whether to validate character set in the message.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
   * The value indicating whether to check for duplicate interchange control
   * number.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
   * The validity period of interchange control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
   * The value indicating whether to check for duplicate group control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
   * The value indicating whether to check for duplicate transaction set control
   * number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
   * The value indicating whether to Whether to validate EDI types.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
   * The value indicating whether to Whether to validate XSD types.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to allow leading and trailing spaces and
   * zeroes.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to trim leading and trailing spaces and zeroes.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
   * The trailing separator policy. Possible values include: 'NotSpecified',
   * 'NotAllowed', 'Optional', 'Mandatory'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings The
   * EDIFACT framing settings.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.serviceCodeListDirectoryVersion]
   * The service code list directory version.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterEncoding]
   * The character encoding.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.protocolVersion
   * The protocol version.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
   * The data element separator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.componentSeparator
   * The component separator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminator
   * The segment terminator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.releaseIndicator
   * The release indicator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.repetitionSeparator
   * The repetition separator.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterSet
   * The EDIFACT frame setting characterSet. Possible values include:
   * 'NotSpecified', 'UNOB', 'UNOA', 'UNOC', 'UNOD', 'UNOE', 'UNOF', 'UNOG',
   * 'UNOH', 'UNOI', 'UNOJ', 'UNOK', 'UNOX', 'UNOY', 'KECA'
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.decimalPointIndicator
   * The EDIFACT frame setting decimal indicator. Possible values include:
   * 'NotSpecified', 'Comma', 'Decimal'
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
   * The EDIFACT frame setting segment terminator suffix. Possible values
   * include: 'NotSpecified', 'None', 'CR', 'LF', 'CRLF'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings
   * The EDIFACT envelope settings.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupAssociationAssignedCode]
   * The group association assigned code.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.communicationAgreementId]
   * The communication agreement id.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applyDelimiterStringAdvice
   * The value indicating whether to apply delimiter string advice.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.createGroupingSegments
   * The value indicating whether to create grouping segments.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
   * The value indicating whether to enable default group headers.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordValue]
   * The recipient reference password value.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordQualifier]
   * The recipient reference password qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applicationReferenceId]
   * The application reference id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.processingPriorityCode]
   * The processing priority code.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
   * The interchange control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
   * The interchange control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
   * The value indicating whether to rollover interchange control number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberPrefix]
   * The interchange control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberSuffix]
   * The interchange control number suffix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderReverseRoutingAddress]
   * The sender reverse routing address.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverReverseRoutingAddress]
   * The receiver reverse routing address.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
   * The functional group id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControllingAgencyCode]
   * The group controlling agency code.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageVersion]
   * The group message version.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageRelease]
   * The group message release.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
   * The group control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
   * The group control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
   * The value indicating whether to rollover group control number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberPrefix]
   * The group control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberSuffix]
   * The group control number suffix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverQualifier]
   * The group application receiver qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverId]
   * The group application receiver id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderQualifier]
   * The group application sender qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderId]
   * The group application sender id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationPassword]
   * The group application password.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
   * The value indicating whether to overwrite existing transaction set control
   * number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
   * The transaction set control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
   * The transaction set control number suffix.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
   * The transaction set control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
   * The transaction set control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
   * The value indicating whether to rollover transaction set control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.isTestInterchange
   * The value indicating whether the message is a test interchange.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalIdentification]
   * The sender internal identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalSubIdentification]
   * The sender internal sub identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalIdentification]
   * The receiver internal identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalSubIdentification]
   * The receiver internal sub identification.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings
   * The EDIFACT acknowledgement settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
   * The value indicating whether technical acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
   * The value indicating whether to batch the technical acknowledgements.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
   * The value indicating whether functional acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
   * The value indicating whether to batch functional acknowledgements.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
   * The value indicating whether a loop is needed for valid messages.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
   * The value indicating whether to send synchronous acknowledgement.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
   * The acknowledgement control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
   * The acknowledgement control number suffix.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
   * The acknowledgement control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
   * The acknowledgement control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
   * The value indicating whether to rollover acknowledgement control number.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter The
   * EDIFACT message filter.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter.messageFilterType
   * The message filter type. Possible values include: 'NotSpecified', 'Include',
   * 'Exclude'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings
   * The EDIFACT processing Settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
   * The value indicating whether to mask security information.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.preserveInterchange
   * The value indicating whether to preserve interchange.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
   * The value indicating whether to suspend interchange on error.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
   * The value indicating whether to create empty xml tags for trailing
   * separators.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
   * The value indicating whether to use dot as decimal separator.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeOverrides]
   * The EDIFACT envelope override settings.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.messageFilterList]
   * The EDIFACT message filter list.
   *
   * @param {array}
   * agreement.content.edifact.sendAgreement.protocolSettings.schemaReferences
   * The EDIFACT schema references.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.validationOverrides]
   * The EDIFACT validation override settings.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.edifactDelimiterOverrides]
   * The EDIFACT delimiter override settings.
   *
   * @param {string} [agreement.location] The resource location.
   *
   * @param {object} [agreement.tags] The resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IntegrationAccountAgreement>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateWithHttpOperationResponse(resourceGroupName, integrationAccountName, agreementName, agreement, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Creates or updates an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} agreement The integration account agreement.
   *
   * @param {object} [agreement.metadata] The metadata.
   *
   * @param {string} agreement.agreementType The agreement type. Possible values
   * include: 'NotSpecified', 'AS2', 'X12', 'Edifact'
   *
   * @param {string} agreement.hostPartner The integration account partner that
   * is set as host partner for this agreement.
   *
   * @param {string} agreement.guestPartner The integration account partner that
   * is set as guest partner for this agreement.
   *
   * @param {object} agreement.hostIdentity The business identity of the host
   * partner.
   *
   * @param {object} agreement.guestIdentity The business identity of the guest
   * partner.
   *
   * @param {object} agreement.content The agreement content.
   *
   * @param {object} [agreement.content.aS2] The AS2 agreement content.
   *
   * @param {object} agreement.content.aS2.receiveAgreement The AS2 one-way
   * receive agreement.
   *
   * @param {object} agreement.content.aS2.sendAgreement The AS2 one-way send
   * agreement.
   *
   * @param {object} agreement.content.aS2.sendAgreement.senderBusinessIdentity
   * The sender business identity
   *
   * @param {object} agreement.content.aS2.sendAgreement.receiverBusinessIdentity
   * The receiver business identity
   *
   * @param {object} agreement.content.aS2.sendAgreement.protocolSettings The AS2
   * protocol settings.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings
   * The message connection settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.ignoreCertificateNameMismatch
   * The value indicating whether to ignore mismatch in certificate name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.supportHttpStatusCodeContinue
   * The value indicating whether to support HTTP status code 'CONTINUE'.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.keepHttpConnectionAlive
   * The value indicating whether to keep the connection alive.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.messageConnectionSettings.unfoldHttpHeaders
   * The value indicating whether to unfold the HTTP headers.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings
   * The acknowledgement connection settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.ignoreCertificateNameMismatch
   * The value indicating whether to ignore mismatch in certificate name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.supportHttpStatusCodeContinue
   * The value indicating whether to support HTTP status code 'CONTINUE'.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.keepHttpConnectionAlive
   * The value indicating whether to keep the connection alive.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.acknowledgementConnectionSettings.unfoldHttpHeaders
   * The value indicating whether to unfold the HTTP headers.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings The MDN
   * settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.needMdn The
   * value indicating whether to send or request a MDN.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signMdn The
   * value indicating whether the MDN needs to be signed or not.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendMdnAsynchronously
   * The value indicating whether to send the asynchronous MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.receiptDeliveryUrl]
   * The receipt delivery URL.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.dispositionNotificationTo]
   * The disposition notification to header value.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.signOutboundMdnIfOptional
   * The value indicating whether to sign the outbound MDN if optional.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.mdnText]
   * The MDN text.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.sendInboundMdnToMessageBox
   * The value indicating whether to send inbound MDN to message box.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.mdnSettings.micHashingAlgorithm
   * The signing or hashing algorithm. Possible values include: 'NotSpecified',
   * 'None', 'MD5', 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings The
   * security settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.overrideGroupSigningCertificate
   * The value indicating whether to send or request a MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.signingCertificateName]
   * The name of the signing certificate.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.encryptionCertificateName]
   * The name of the encryption certificate.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundEncodedMessages
   * The value indicating whether to enable NRR for inbound encoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundDecodedMessages
   * The value indicating whether to enable NRR for inbound decoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundMdn
   * The value indicating whether to enable NRR for outbound MDN.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundEncodedMessages
   * The value indicating whether to enable NRR for outbound encoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForOutboundDecodedMessages
   * The value indicating whether to enable NRR for outbound decoded messages.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.enableNrrForInboundMdn
   * The value indicating whether to enable NRR for inbound MDN.
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.securitySettings.sha2AlgorithmFormat]
   * The Sha2 algorithm format. Valid values are Sha2, ShaHashSize,
   * ShaHyphenHashSize, Sha2UnderscoreHashSize.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings The
   * validation settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.overrideMessageProperties
   * The value indicating whether to override incoming message properties with
   * those in agreement.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptMessage
   * The value indicating whether the message has to be encrypted.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signMessage
   * The value indicating whether the message has to be signed.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.compressMessage
   * The value indicating whether the message has to be compressed.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkDuplicateMessage
   * The value indicating whether to check for duplicate message.
   *
   * @param {number}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.interchangeDuplicatesValidityDays
   * The number of days to look back for duplicate interchange.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnSend
   * The value indicating whether to check for certificate revocation list on
   * send.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.checkCertificateRevocationListOnReceive
   * The value indicating whether to check for certificate revocation list on
   * receive.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.encryptionAlgorithm
   * The encryption algorithm. Possible values include: 'NotSpecified', 'None',
   * 'DES3', 'RC2', 'AES128', 'AES192', 'AES256'
   *
   * @param {string}
   * [agreement.content.aS2.sendAgreement.protocolSettings.validationSettings.signingAlgorithm]
   * The signing algorithm. Possible values include: 'NotSpecified', 'Default',
   * 'SHA1', 'SHA2256', 'SHA2384', 'SHA2512'
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings The
   * envelope settings.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.messageContentType
   * The message content type.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.transmitFileNameInMimeHeader
   * The value indicating whether to transmit file name in mime header.
   *
   * @param {string}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.fileNameTemplate
   * The template for file name.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.suspendMessageOnFileNameGenerationError
   * The value indicating whether to suspend message on file name generation
   * error.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.envelopeSettings.autogenerateFileName
   * The value indicating whether to auto generate file name.
   *
   * @param {object}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings The error
   * settings.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.suspendDuplicateMessage
   * The value indicating whether to suspend duplicate message.
   *
   * @param {boolean}
   * agreement.content.aS2.sendAgreement.protocolSettings.errorSettings.resendIfMdnNotReceived
   * The value indicating whether to resend message If MDN is not received.
   *
   * @param {object} [agreement.content.x12] The X12 agreement content.
   *
   * @param {object} agreement.content.x12.receiveAgreement The X12 one-way
   * receive agreement.
   *
   * @param {object} agreement.content.x12.sendAgreement The X12 one-way send
   * agreement.
   *
   * @param {object} agreement.content.x12.sendAgreement.senderBusinessIdentity
   * The sender business identity
   *
   * @param {object} agreement.content.x12.sendAgreement.receiverBusinessIdentity
   * The receiver business identity
   *
   * @param {object} agreement.content.x12.sendAgreement.protocolSettings The X12
   * protocol settings.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings The
   * X12 validation settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
   * The value indicating whether to validate character set in the message.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
   * The value indicating whether to check for duplicate interchange control
   * number.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
   * The validity period of interchange control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
   * The value indicating whether to check for duplicate group control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
   * The value indicating whether to check for duplicate transaction set control
   * number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
   * The value indicating whether to Whether to validate EDI types.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
   * The value indicating whether to Whether to validate XSD types.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to allow leading and trailing spaces and
   * zeroes.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to trim leading and trailing spaces and zeroes.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
   * The trailing separator policy. Possible values include: 'NotSpecified',
   * 'NotAllowed', 'Optional', 'Mandatory'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings The X12
   * framing settings.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
   * The data element separator.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.componentSeparator
   * The component separator.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceSeparatorsInPayload
   * The value indicating whether to replace separators in payload.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.replaceCharacter
   * The replacement character.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminator
   * The segment terminator.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.characterSet
   * The X12 character set. Possible values include: 'NotSpecified', 'Basic',
   * 'Extended', 'UTF8'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
   * The segment terminator suffix. Possible values include: 'NotSpecified',
   * 'None', 'CR', 'LF', 'CRLF'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings The
   * X12 envelope settings.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlStandardsId
   * The controls standards id.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.useControlStandardsIdAsRepetitionCharacter
   * The value indicating whether to use control standards id as repetition
   * character.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.senderApplicationId
   * The sender application id.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.receiverApplicationId
   * The receiver application id.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.controlVersionNumber
   * The control version number.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
   * The interchange  control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
   * The interchange  control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
   * The value indicating whether to rollover interchange control number.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
   * The value indicating whether to enable default group headers.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
   * The functional group id.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
   * The group control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
   * The group control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
   * The value indicating whether to rollover group control number.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderAgencyCode
   * The group header agency code.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderVersion
   * The group header version.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
   * The transaction set control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
   * The transaction set control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
   * The value indicating whether to rollover transaction set control number.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
   * The transaction set control number prefix.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
   * The transaction set control number suffix.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
   * The value indicating whether to overwrite existing transaction set control
   * number.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderDateFormat
   * The group header date format. Possible values include: 'NotSpecified',
   * 'CCYYMMDD', 'YYMMDD'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.groupHeaderTimeFormat
   * The group header time format. Possible values include: 'NotSpecified',
   * 'HHMM', 'HHMMSS', 'HHMMSSdd', 'HHMMSSd'
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.envelopeSettings.usageIndicator
   * The usage indicator. Possible values include: 'NotSpecified', 'Test',
   * 'Information', 'Production'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings
   * The X12 acknowledgment settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
   * The value indicating whether technical acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
   * The value indicating whether to batch the technical acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
   * The value indicating whether functional acknowledgement is needed.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.functionalAcknowledgementVersion]
   * The functional acknowledgement version.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
   * The value indicating whether to batch functional acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needImplementationAcknowledgement
   * The value indicating whether implementation acknowledgement is needed.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.implementationAcknowledgementVersion]
   * The implementation acknowledgement version.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.batchImplementationAcknowledgements
   * The value indicating whether to batch implementation acknowledgements.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
   * The value indicating whether a loop is needed for valid messages.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
   * The value indicating whether to send synchronous acknowledgement.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
   * The acknowledgement control number prefix.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
   * The acknowledgement control number suffix.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
   * The acknowledgement control number lower bound.
   *
   * @param {number}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
   * The acknowledgement control number upper bound.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
   * The value indicating whether to rollover acknowledgement control number.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.messageFilter The X12
   * message filter.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.messageFilter.messageFilterType
   * The message filter type. Possible values include: 'NotSpecified', 'Include',
   * 'Exclude'
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings The
   * X12 security settings.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationQualifier
   * The authorization qualifier.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.authorizationValue]
   * The authorization value.
   *
   * @param {string}
   * agreement.content.x12.sendAgreement.protocolSettings.securitySettings.securityQualifier
   * The security qualifier.
   *
   * @param {string}
   * [agreement.content.x12.sendAgreement.protocolSettings.securitySettings.passwordValue]
   * The password value.
   *
   * @param {object}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings The
   * X12 processing settings.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
   * The value indicating whether to mask security information.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.convertImpliedDecimal
   * The value indicating whether to convert numerical type to implied decimal.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.preserveInterchange
   * The value indicating whether to preserve interchange.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
   * The value indicating whether to suspend interchange on error.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
   * The value indicating whether to create empty xml tags for trailing
   * separators.
   *
   * @param {boolean}
   * agreement.content.x12.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
   * The value indicating whether to use dot as decimal separator.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.envelopeOverrides] The
   * X12 envelope override settings.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.validationOverrides]
   * The X12 validation override settings.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.messageFilterList] The
   * X12 message filter list.
   *
   * @param {array}
   * agreement.content.x12.sendAgreement.protocolSettings.schemaReferences The
   * X12 schema references.
   *
   * @param {array}
   * [agreement.content.x12.sendAgreement.protocolSettings.x12DelimiterOverrides]
   * The X12 delimiter override settings.
   *
   * @param {object} [agreement.content.edifact] The EDIFACT agreement content.
   *
   * @param {object} agreement.content.edifact.receiveAgreement The EDIFACT
   * one-way receive agreement.
   *
   * @param {object} agreement.content.edifact.sendAgreement The EDIFACT one-way
   * send agreement.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.senderBusinessIdentity The sender
   * business identity
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity The
   * receiver business identity
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.qualifier
   * The business identity qualifier e.g. as2identity, ZZ, ZZZ, 31, 32
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.receiverBusinessIdentity.value The
   * user defined business identity value.
   *
   * @param {object} agreement.content.edifact.sendAgreement.protocolSettings The
   * EDIFACT protocol settings.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings
   * The EDIFACT validation settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateCharacterSet
   * The value indicating whether to validate character set in the message.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateInterchangeControlNumber
   * The value indicating whether to check for duplicate interchange control
   * number.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.interchangeControlNumberValidityDays
   * The validity period of interchange control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateGroupControlNumber
   * The value indicating whether to check for duplicate group control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.checkDuplicateTransactionSetControlNumber
   * The value indicating whether to check for duplicate transaction set control
   * number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateEdiTypes
   * The value indicating whether to Whether to validate EDI types.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.validateXsdTypes
   * The value indicating whether to Whether to validate XSD types.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.allowLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to allow leading and trailing spaces and
   * zeroes.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trimLeadingAndTrailingSpacesAndZeroes
   * The value indicating whether to trim leading and trailing spaces and zeroes.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.validationSettings.trailingSeparatorPolicy
   * The trailing separator policy. Possible values include: 'NotSpecified',
   * 'NotAllowed', 'Optional', 'Mandatory'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings The
   * EDIFACT framing settings.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.serviceCodeListDirectoryVersion]
   * The service code list directory version.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterEncoding]
   * The character encoding.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.protocolVersion
   * The protocol version.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.dataElementSeparator
   * The data element separator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.componentSeparator
   * The component separator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminator
   * The segment terminator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.releaseIndicator
   * The release indicator.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.repetitionSeparator
   * The repetition separator.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.characterSet
   * The EDIFACT frame setting characterSet. Possible values include:
   * 'NotSpecified', 'UNOB', 'UNOA', 'UNOC', 'UNOD', 'UNOE', 'UNOF', 'UNOG',
   * 'UNOH', 'UNOI', 'UNOJ', 'UNOK', 'UNOX', 'UNOY', 'KECA'
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.decimalPointIndicator
   * The EDIFACT frame setting decimal indicator. Possible values include:
   * 'NotSpecified', 'Comma', 'Decimal'
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.framingSettings.segmentTerminatorSuffix
   * The EDIFACT frame setting segment terminator suffix. Possible values
   * include: 'NotSpecified', 'None', 'CR', 'LF', 'CRLF'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings
   * The EDIFACT envelope settings.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupAssociationAssignedCode]
   * The group association assigned code.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.communicationAgreementId]
   * The communication agreement id.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applyDelimiterStringAdvice
   * The value indicating whether to apply delimiter string advice.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.createGroupingSegments
   * The value indicating whether to create grouping segments.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.enableDefaultGroupHeaders
   * The value indicating whether to enable default group headers.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordValue]
   * The recipient reference password value.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.recipientReferencePasswordQualifier]
   * The recipient reference password qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.applicationReferenceId]
   * The application reference id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.processingPriorityCode]
   * The processing priority code.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberLowerBound
   * The interchange control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberUpperBound
   * The interchange control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverInterchangeControlNumber
   * The value indicating whether to rollover interchange control number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberPrefix]
   * The interchange control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.interchangeControlNumberSuffix]
   * The interchange control number suffix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderReverseRoutingAddress]
   * The sender reverse routing address.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverReverseRoutingAddress]
   * The receiver reverse routing address.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.functionalGroupId]
   * The functional group id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControllingAgencyCode]
   * The group controlling agency code.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageVersion]
   * The group message version.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupMessageRelease]
   * The group message release.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberLowerBound
   * The group control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberUpperBound
   * The group control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverGroupControlNumber
   * The value indicating whether to rollover group control number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberPrefix]
   * The group control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupControlNumberSuffix]
   * The group control number suffix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverQualifier]
   * The group application receiver qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationReceiverId]
   * The group application receiver id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderQualifier]
   * The group application sender qualifier.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationSenderId]
   * The group application sender id.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.groupApplicationPassword]
   * The group application password.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.overwriteExistingTransactionSetControlNumber
   * The value indicating whether to overwrite existing transaction set control
   * number.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberPrefix]
   * The transaction set control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberSuffix]
   * The transaction set control number suffix.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberLowerBound
   * The transaction set control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.transactionSetControlNumberUpperBound
   * The transaction set control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.rolloverTransactionSetControlNumber
   * The value indicating whether to rollover transaction set control number.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.isTestInterchange
   * The value indicating whether the message is a test interchange.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalIdentification]
   * The sender internal identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.senderInternalSubIdentification]
   * The sender internal sub identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalIdentification]
   * The receiver internal identification.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeSettings.receiverInternalSubIdentification]
   * The receiver internal sub identification.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings
   * The EDIFACT acknowledgement settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needTechnicalAcknowledgement
   * The value indicating whether technical acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchTechnicalAcknowledgements
   * The value indicating whether to batch the technical acknowledgements.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needFunctionalAcknowledgement
   * The value indicating whether functional acknowledgement is needed.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.batchFunctionalAcknowledgements
   * The value indicating whether to batch functional acknowledgements.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.needLoopForValidMessages
   * The value indicating whether a loop is needed for valid messages.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.sendSynchronousAcknowledgement
   * The value indicating whether to send synchronous acknowledgement.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberPrefix]
   * The acknowledgement control number prefix.
   *
   * @param {string}
   * [agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberSuffix]
   * The acknowledgement control number suffix.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberLowerBound
   * The acknowledgement control number lower bound.
   *
   * @param {number}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.acknowledgementControlNumberUpperBound
   * The acknowledgement control number upper bound.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.acknowledgementSettings.rolloverAcknowledgementControlNumber
   * The value indicating whether to rollover acknowledgement control number.
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter The
   * EDIFACT message filter.
   *
   * @param {string}
   * agreement.content.edifact.sendAgreement.protocolSettings.messageFilter.messageFilterType
   * The message filter type. Possible values include: 'NotSpecified', 'Include',
   * 'Exclude'
   *
   * @param {object}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings
   * The EDIFACT processing Settings.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.maskSecurityInfo
   * The value indicating whether to mask security information.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.preserveInterchange
   * The value indicating whether to preserve interchange.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.suspendInterchangeOnError
   * The value indicating whether to suspend interchange on error.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.createEmptyXmlTagsForTrailingSeparators
   * The value indicating whether to create empty xml tags for trailing
   * separators.
   *
   * @param {boolean}
   * agreement.content.edifact.sendAgreement.protocolSettings.processingSettings.useDotAsDecimalSeparator
   * The value indicating whether to use dot as decimal separator.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.envelopeOverrides]
   * The EDIFACT envelope override settings.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.messageFilterList]
   * The EDIFACT message filter list.
   *
   * @param {array}
   * agreement.content.edifact.sendAgreement.protocolSettings.schemaReferences
   * The EDIFACT schema references.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.validationOverrides]
   * The EDIFACT validation override settings.
   *
   * @param {array}
   * [agreement.content.edifact.sendAgreement.protocolSettings.edifactDelimiterOverrides]
   * The EDIFACT delimiter override settings.
   *
   * @param {string} [agreement.location] The resource location.
   *
   * @param {object} [agreement.tags] The resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IntegrationAccountAgreement} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IntegrationAccountAgreement} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options, optionalCallback);
    }
  }

  /**
   * Deletes an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(resourceGroupName, integrationAccountName, agreementName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(resourceGroupName, integrationAccountName, agreementName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an integration account agreement.
   *
   * @param {string} resourceGroupName The resource group name.
   *
   * @param {string} integrationAccountName The integration account name.
   *
   * @param {string} agreementName The integration account agreement name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(resourceGroupName, integrationAccountName, agreementName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(resourceGroupName, integrationAccountName, agreementName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(resourceGroupName, integrationAccountName, agreementName, options, optionalCallback);
    }
  }

  /**
   * Gets a list of integration account agreements.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IntegrationAccountAgreementListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByIntegrationAccountsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByIntegrationAccountsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets a list of integration account agreements.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IntegrationAccountAgreementListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IntegrationAccountAgreementListResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByIntegrationAccountsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByIntegrationAccountsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByIntegrationAccountsNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = Agreements;
