/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

/**
 * Defines an item in ChaosParametersDictionary of the Chaos Schedule.
 *
 */
class ChaosParametersDictionaryItem {
  /**
   * Create a ChaosParametersDictionaryItem.
   * @property {string} key The key identifying the Chaos Parameter in the
   * dictionary. This key is referenced by Chaos Schedule Jobs.
   * @property {object} value Defines all the parameters to configure a Chaos
   * run.
   * @property {string} [value.timeToRunInSeconds] Total time (in seconds) for
   * which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   * @property {number} [value.maxClusterStabilizationTimeoutInSeconds] The
   * maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each
   * iteration it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation
   * failed event.
   * @property {number} [value.maxConcurrentFaults] MaxConcurrentFaults is the
   * maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated
   * by a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   * @property {boolean} [value.enableMoveReplicaFaults] Enables or disables
   * the move primary and move secondary faults.
   * @property {number} [value.waitTimeBetweenFaultsInSeconds] Wait time (in
   * seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   * @property {number} [value.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   * @property {object} [value.clusterHealthPolicy] Passed-in cluster health
   * policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected
   * exception happens during fault execution--to provide the cluster with some
   * time to recuperate--Chaos will wait for 30 minutes before the next
   * health-check.
   * @property {boolean} [value.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   * @property {number} [value.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an
   * error. For example, to allow 10% of nodes to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that
   * can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes
   * over the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of
   * nodes. Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   * @property {number}
   * [value.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error.
   * For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over
   * the total number of application instances in the cluster, excluding
   * applications of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   * @property {array}
   * [value.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines a map
   * with max percentage unhealthy applications for specific application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage
   * used to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with
   * MaxPercentUnhealthyApplications set to 20% to tolerate some failures out
   * of the thousands of application instances.
   * The application type health policy map is used only if the cluster
   * manifest enables application type health evaluation using the
   * configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   * @property {object} [value.context] Describes a map, which is a collection
   * of (string, string) type key-value pairs. The map can be used to record
   * information about
   * the Chaos run. There cannot be more than 100 such pairs and each string
   * (key or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   * @property {object} [value.context.map] Describes a map that contains a
   * collection of ChaosContextMapItem's.
   * @property {object} [value.chaosTargetFilter] List of cluster entities to
   * target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types
   * or only to certain application instances. If ChaosTargetFilter is not
   * used, Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   * @property {array} [value.chaosTargetFilter.nodeTypeInclusionList] A list
   * of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the
   * nodes of these node types.
   * If a nodetype (say NodeTypeX) does not appear in the
   * NodeTypeInclusionList, then node level faults (like NodeRestart) will
   * never be enabled for the nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   * @property {array} [value.chaosTargetFilter.applicationInclusionList] A
   * list of application URI's to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas
   * of these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement
   * constraints and applicationX is absent from ApplicationInclusionList and
   * nodeTypeY is absent from NodeTypeInclusionList, then applicationX will
   * never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   */
  constructor() {
  }

  /**
   * Defines the metadata of ChaosParametersDictionaryItem
   *
   * @returns {object} metadata of ChaosParametersDictionaryItem
   *
   */
  mapper() {
    return {
      required: false,
      serializedName: 'ChaosParametersDictionaryItem',
      type: {
        name: 'Composite',
        className: 'ChaosParametersDictionaryItem',
        modelProperties: {
          key: {
            required: true,
            serializedName: 'Key',
            type: {
              name: 'String'
            }
          },
          value: {
            required: true,
            serializedName: 'Value',
            type: {
              name: 'Composite',
              className: 'ChaosParameters'
            }
          }
        }
      }
    };
  }
}

module.exports = ChaosParametersDictionaryItem;
