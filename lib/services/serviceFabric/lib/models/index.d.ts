/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as moment from "moment";


/**
 * @class
 * Initializes a new instance of the AadMetadata class.
 * @constructor
 * Azure Active Directory metadata used for secured connection to cluster.
 *
 * @property {string} [authority] The AAD authority url.
 * @property {string} [client] The AAD client application Id.
 * @property {string} [cluster] The AAD cluster application Id.
 * @property {string} [login] The AAD login url.
 * @property {string} [redirect] The client application redirect address.
 * @property {string} [tenant] The AAD tenant Id.
 */
export interface AadMetadata {
  authority?: string;
  client?: string;
  cluster?: string;
  login?: string;
  redirect?: string;
  tenant?: string;
}

/**
 * @class
 * Initializes a new instance of the AadMetadataObject class.
 * @constructor
 * Azure Active Directory metadata object used for secured connection to
 * cluster.
 *
 * @property {string} [type] The client authentication method.
 * @property {object} [metadata] Azure Active Directory metadata used for
 * secured connection to cluster.
 * @property {string} [metadata.authority] The AAD authority url.
 * @property {string} [metadata.client] The AAD client application Id.
 * @property {string} [metadata.cluster] The AAD cluster application Id.
 * @property {string} [metadata.login] The AAD login url.
 * @property {string} [metadata.redirect] The client application redirect
 * address.
 * @property {string} [metadata.tenant] The AAD tenant Id.
 */
export interface AadMetadataObject {
  type?: string;
  metadata?: AadMetadata;
}

/**
 * @class
 * Initializes a new instance of the AnalysisEventMetadata class.
 * @constructor
 * Metadata about an Analysis Event.
 *
 * @property {moment.duration} [delay] The analysis delay.
 * @property {moment.duration} [duration] The duration of analysis.
 */
export interface AnalysisEventMetadata {
  delay?: moment.Duration;
  duration?: moment.Duration;
}

/**
 * @class
 * Initializes a new instance of the FabricEvent class.
 * @constructor
 * Represents the base for all Fabric Events.
 *
 * @property {uuid} eventInstanceId The identifier for the FabricEvent
 * instance.
 * @property {date} timeStamp The time event was logged.
 * @property {boolean} [hasCorrelatedEvents] Shows there is existing related
 * events available.
 * @property {string} kind Polymorphic Discriminator
 */
export interface FabricEvent {
  eventInstanceId: string;
  timeStamp: Date;
  hasCorrelatedEvents?: boolean;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationEvent class.
 * @constructor
 * Represents the base for all Application Events.
 *
 * @property {string} applicationId The identity of the application. This is an
 * encoded representation of the application name. This is used in the REST
 * APIs to identify the application resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the application name is "fabric:/myapp/app1",
 * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 */
export interface ApplicationEvent extends FabricEvent {
  applicationId: string;
}

/**
 * @class
 * Initializes a new instance of the EntityHealthState class.
 * @constructor
 * A base type for the health state of various entities in the cluster. It
 * contains the aggregated health state.
 *
 * @property {string} [aggregatedHealthState] The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 */
export interface EntityHealthState {
  aggregatedHealthState?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthState class.
 * @constructor
 * Represents the health state of a service, which contains the service
 * identifier and its aggregated health state.
 *
 * @property {string} [serviceName] Name of the service whose health state is
 * represented by this object.
 */
export interface ServiceHealthState extends EntityHealthState {
  serviceName?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthState class.
 * @constructor
 * Represents the health state of a deployed application, which contains the
 * entity identifier and the aggregated health state.
 *
 * @property {string} [nodeName] Name of the node on which the service package
 * is deployed.
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 */
export interface DeployedApplicationHealthState extends EntityHealthState {
  nodeName?: string;
  applicationName?: string;
}

/**
 * @class
 * Initializes a new instance of the EntityHealth class.
 * @constructor
 * Health information common to all entities in the cluster. It contains the
 * aggregated health state, health events and unhealthy evaluation.
 *
 * @property {string} [aggregatedHealthState] The HealthState representing the
 * aggregated health state of the entity computed by Health Manager.
 * The health evaluation of the entity reflects all events reported on the
 * entity and its children (if any).
 * The aggregation is done by applying the desired health policy. Possible
 * values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {array} [healthEvents] The list of health events reported on the
 * entity.
 * @property {array} [unhealthyEvaluations] The unhealthy evaluations that show
 * why the current aggregated health state was returned by Health Manager.
 * @property {object} [healthStatistics] Shows the health statistics for all
 * children types of the queried entity.
 * @property {array} [healthStatistics.healthStateCountList] List of health
 * state counts per entity kind, which keeps track of how many children of the
 * queried entity are in Ok, Warning and Error state.
 */
export interface EntityHealth {
  aggregatedHealthState?: string;
  healthEvents?: HealthEvent[];
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  healthStatistics?: HealthStatistics;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealth class.
 * @constructor
 * Represents the health of the application. Contains the application
 * aggregated health state and the service and deployed application health
 * states.
 *
 * @property {string} [name] The name of the application, including the
 * 'fabric:' URI scheme.
 * @property {array} [serviceHealthStates] Service health states as found in
 * the health store.
 * @property {array} [deployedApplicationHealthStates] Deployed application
 * health states as found in the health store.
 */
export interface ApplicationHealth extends EntityHealth {
  name?: string;
  serviceHealthStates?: ServiceHealthState[];
  deployedApplicationHealthStates?: DeployedApplicationHealthState[];
}

/**
 * @class
 * Initializes a new instance of the HealthEvaluation class.
 * @constructor
 * Represents a health evaluation which describes the data and the algorithm
 * used by health manager to evaluate the health of an entity.
 *
 * @property {string} [aggregatedHealthState] The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 * @property {string} [description] Description of the health evaluation, which
 * represents a summary of the evaluation process.
 * @property {string} kind Polymorphic Discriminator
 */
export interface HealthEvaluation {
  aggregatedHealthState?: string;
  description?: string;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the HealthEvaluationWrapper class.
 * @constructor
 * Wrapper object for health evaluation.
 *
 * @property {object} [healthEvaluation] Represents a health evaluation which
 * describes the data and the algorithm used by health manager to evaluate the
 * health of an entity.
 * @property {string} [healthEvaluation.aggregatedHealthState] The health state
 * of a Service Fabric entity such as Cluster, Node, Application, Service,
 * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning',
 * 'Error', 'Unknown'
 * @property {string} [healthEvaluation.description] Description of the health
 * evaluation, which represents a summary of the evaluation process.
 * @property {string} [healthEvaluation.kind] Polymorphic Discriminator
 */
export interface HealthEvaluationWrapper {
  healthEvaluation?: HealthEvaluation;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthEvaluation class.
 * @constructor
 * Represents health evaluation for an application, containing information
 * about the data and the algorithm used by the health store to evaluate
 * health.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the application. The types of
 * the unhealthy evaluations can be DeployedApplicationsHealthEvaluation,
 * ServicesHealthEvaluation or EventHealthEvaluation.
 */
export interface ApplicationHealthEvaluation extends HealthEvaluation {
  applicationName?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeHealthPolicy class.
 * @constructor
 * Represents the health policy used to evaluate the health of services
 * belonging to a service type.
 *
 * @property {number} [maxPercentUnhealthyPartitionsPerService] The maximum
 * allowed percentage of unhealthy partitions per service. Allowed values are
 * Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero. Default value: 0 .
 * @property {number} [maxPercentUnhealthyReplicasPerPartition] The maximum
 * allowed percentage of unhealthy replicas per partition. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero. Default value: 0 .
 * @property {number} [maxPercentUnhealthyServices] The maximum maximum allowed
 * percentage of unhealthy services. Allowed values are Byte values from zero
 * to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero. Default value: 0 .
 */
export interface ServiceTypeHealthPolicy {
  maxPercentUnhealthyPartitionsPerService?: number;
  maxPercentUnhealthyReplicasPerPartition?: number;
  maxPercentUnhealthyServices?: number;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ServiceTypeHealthPolicyMap.
 *
 * @property {string} key The key of the service type health policy map item.
 * This is the name of the service type.
 * @property {object} value The value of the service type health policy map
 * item. This is the ServiceTypeHealthPolicy for this service type.
 * @property {number} [value.maxPercentUnhealthyPartitionsPerService] The
 * maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number} [value.maxPercentUnhealthyReplicasPerPartition] The
 * maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number} [value.maxPercentUnhealthyServices] The maximum maximum
 * allowed percentage of unhealthy services. Allowed values are Byte values
 * from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 */
export interface ServiceTypeHealthPolicyMapItem {
  key: string;
  value: ServiceTypeHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthPolicy class.
 * @constructor
 * Defines a health policy used to evaluate the health of an application or one
 * of its children entities.
 *
 * @property {boolean} [considerWarningAsError] Indicates whether warnings are
 * treated with the same severity as errors. Default value: false .
 * @property {number} [maxPercentUnhealthyDeployedApplications] The maximum
 * allowed percentage of unhealthy deployed applications. Allowed values are
 * Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero. Default value: 0 .
 * @property {object} [defaultServiceTypeHealthPolicy] The health policy used
 * by default to evaluate the health of a service type.
 * @property {number}
 * [defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService] The
 * maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition] The
 * maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices] The maximum
 * maximum allowed percentage of unhealthy services. Allowed values are Byte
 * values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [serviceTypeHealthPolicyMap] The map with service type
 * health policy per service type name. The map is empty by default.
 */
export interface ApplicationHealthPolicy {
  considerWarningAsError?: boolean;
  maxPercentUnhealthyDeployedApplications?: number;
  defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
  serviceTypeHealthPolicyMap?: ServiceTypeHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ApplicationHealthPolicyMap.
 *
 * @property {string} key The key of the application health policy map item.
 * This is the name of the application.
 * @property {object} value The value of the application health policy map
 * item. This is the ApplicationHealthPolicy for this application.
 * @property {boolean} [value.considerWarningAsError] Indicates whether
 * warnings are treated with the same severity as errors.
 * @property {number} [value.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object} [value.defaultServiceTypeHealthPolicy] The health policy
 * used by default to evaluate the health of a service type.
 * @property {number}
 * [value.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [value.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [value.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices] The
 * maximum maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [value.serviceTypeHealthPolicyMap] The map with service
 * type health policy per service type name. The map is empty by default.
 */
export interface ApplicationHealthPolicyMapItem {
  key: string;
  value: ApplicationHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthPolicies class.
 * @constructor
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 * @property {array} [applicationHealthPolicyMap] The wrapper that contains the
 * map with application health policies used to evaluate specific applications
 * in the cluster.
 */
export interface ApplicationHealthPolicies {
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthState class.
 * @constructor
 * Represents the health state of an application, which contains the
 * application identifier and the aggregated health state.
 *
 * @property {string} [name] The name of the application, including the
 * 'fabric:' URI scheme.
 */
export interface ApplicationHealthState extends EntityHealthState {
  name?: string;
}

/**
 * @class
 * Initializes a new instance of the EntityHealthStateChunk class.
 * @constructor
 * A base type for the health state chunk of various entities in the cluster.
 * It contains the aggregated health state.
 *
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 */
export interface EntityHealthStateChunk {
  healthState?: string;
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a stateful service replica or a
 * stateless service instance.
 * The replica health state contains the replica ID and its aggregated health
 * state.
 *
 * @property {string} [replicaOrInstanceId] Id of a stateful service replica or
 * a stateless service instance. This ID is used in the queries that apply to
 * both stateful and stateless services. It is used by Service Fabric to
 * uniquely identify a replica of a partition of a stateful service or an
 * instance of a stateless service partition. It is unique within a partition
 * and does not change for the lifetime of the replica or the instance. If a
 * stateful replica gets dropped and another replica gets created on the same
 * node for the same partition, it will get a different value for the ID. If a
 * stateless instance is failed over on the same or different node it will get
 * a different value for the ID.
 */
export interface ReplicaHealthStateChunk extends EntityHealthStateChunk {
  replicaOrInstanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealthStateChunkList class.
 * @constructor
 * The list of replica health state chunks that respect the input filters in
 * the chunk query. Returned by get cluster health state chunks query.
 *
 * @property {array} [items] The list of replica health state chunks that
 * respect the input filters in the chunk query.
 */
export interface ReplicaHealthStateChunkList {
  items?: ReplicaHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a partition, which contains the
 * partition ID, its aggregated health state and any replicas that respect the
 * filters in the cluster health chunk query description.
 *
 * @property {uuid} [partitionId] The Id of the partition.
 * @property {object} [replicaHealthStateChunks] The list of replica health
 * state chunks belonging to the partition that respect the filters in the
 * cluster health chunk query description.
 * @property {array} [replicaHealthStateChunks.items] The list of replica
 * health state chunks that respect the input filters in the chunk query.
 */
export interface PartitionHealthStateChunk extends EntityHealthStateChunk {
  partitionId?: string;
  replicaHealthStateChunks?: ReplicaHealthStateChunkList;
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthStateChunkList class.
 * @constructor
 * The list of partition health state chunks that respect the input filters in
 * the chunk query description.
 * Returned by get cluster health state chunks query as part of the parent
 * application hierarchy.
 *
 * @property {array} [items] The list of partition health state chunks that
 * respect the input filters in the chunk query.
 */
export interface PartitionHealthStateChunkList {
  items?: PartitionHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a service, which contains the service
 * name, its aggregated health state and any partitions that respect the
 * filters in the cluster health chunk query description.
 *
 * @property {string} [serviceName] The name of the service whose health state
 * chunk is provided in this object.
 * @property {object} [partitionHealthStateChunks] The list of partition health
 * state chunks belonging to the service that respect the filters in the
 * cluster health chunk query description.
 * @property {array} [partitionHealthStateChunks.items] The list of partition
 * health state chunks that respect the input filters in the chunk query.
 */
export interface ServiceHealthStateChunk extends EntityHealthStateChunk {
  serviceName?: string;
  partitionHealthStateChunks?: PartitionHealthStateChunkList;
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthStateChunkList class.
 * @constructor
 * The list of service health state chunks that respect the input filters in
 * the chunk query. Returned by get cluster health state chunks query.
 *
 * @property {array} [items] The list of service health state chunks that
 * respect the input filters in the chunk query.
 */
export interface ServiceHealthStateChunkList {
  items?: ServiceHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a deployed service package, which
 * contains the service manifest name and the service package aggregated health
 * state.
 *
 * @property {string} [serviceManifestName] The name of the service manifest.
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 */
export interface DeployedServicePackageHealthStateChunk extends EntityHealthStateChunk {
  serviceManifestName?: string;
  servicePackageActivationId?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealthStateChunkList class.
 * @constructor
 * The list of deployed service package health state chunks that respect the
 * input filters in the chunk query. Returned by get cluster health state
 * chunks query.
 *
 * @property {array} [items] The list of deployed service package health state
 * chunks that respect the input filters in the chunk query.
 */
export interface DeployedServicePackageHealthStateChunkList {
  items?: DeployedServicePackageHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a deployed application, which contains
 * the node where the application is deployed, the aggregated health state and
 * any deployed service packages that respect the chunk query description
 * filters.
 *
 * @property {string} [nodeName] The name of node where the application is
 * deployed.
 * @property {object} [deployedServicePackageHealthStateChunks] The list of
 * deployed service package health state chunks belonging to the deployed
 * application that respect the filters in the cluster health chunk query
 * description.
 * @property {array} [deployedServicePackageHealthStateChunks.items] The list
 * of deployed service package health state chunks that respect the input
 * filters in the chunk query.
 */
export interface DeployedApplicationHealthStateChunk extends EntityHealthStateChunk {
  nodeName?: string;
  deployedServicePackageHealthStateChunks?: DeployedServicePackageHealthStateChunkList;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthStateChunkList class.
 * @constructor
 * The list of deployed application health state chunks that respect the input
 * filters in the chunk query. Returned by get cluster health state chunks
 * query.
 *
 * @property {array} [items] The list of deployed application health state
 * chunks that respect the input filters in the chunk query.
 */
export interface DeployedApplicationHealthStateChunkList {
  items?: DeployedApplicationHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a application.
 * The application health state chunk contains the application name, its
 * aggregated health state and any children services and deployed applications
 * that respect the filters in cluster health chunk query description.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} [applicationTypeName] The application type name as
 * defined in the application manifest.
 * @property {object} [serviceHealthStateChunks] The list of service health
 * state chunks in the cluster that respect the filters in the cluster health
 * chunk query description.
 * @property {array} [serviceHealthStateChunks.items] The list of service
 * health state chunks that respect the input filters in the chunk query.
 * @property {object} [deployedApplicationHealthStateChunks] The list of
 * deployed application health state chunks in the cluster that respect the
 * filters in the cluster health chunk query description.
 * @property {array} [deployedApplicationHealthStateChunks.items] The list of
 * deployed application health state chunks that respect the input filters in
 * the chunk query.
 */
export interface ApplicationHealthStateChunk extends EntityHealthStateChunk {
  applicationName?: string;
  applicationTypeName?: string;
  serviceHealthStateChunks?: ServiceHealthStateChunkList;
  deployedApplicationHealthStateChunks?: DeployedApplicationHealthStateChunkList;
}

/**
 * @class
 * Initializes a new instance of the EntityHealthStateChunkList class.
 * @constructor
 * A base type for the list of health state chunks found in the cluster. It
 * contains the total number of health states that match the input filters.
 *
 * @property {number} [totalCount] Total number of entity health state objects
 * that match the specified filters from the cluster health chunk query
 * description.
 */
export interface EntityHealthStateChunkList {
  totalCount?: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthStateChunkList class.
 * @constructor
 * The list of application health state chunks in the cluster that respect the
 * input filters in the chunk query. Returned by get cluster health state
 * chunks query.
 *
 * @property {array} [items] The list of application health state chunks that
 * respect the input filters in the chunk query.
 */
export interface ApplicationHealthStateChunkList extends EntityHealthStateChunkList {
  items?: ApplicationHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a replica should be included
 * as a child of a partition in the cluster health chunk.
 * The replicas are only returned if the parent entities match a filter
 * specified in the cluster health chunk query description. The parent
 * partition, service and application must be included in the cluster health
 * chunk.
 * One filter can match zero, one or multiple replicas, depending on its
 * properties.
 *
 * @property {string} [replicaOrInstanceIdFilter] Id of the stateful service
 * replica or stateless service instance that matches the filter. The filter is
 * applied only to the specified replica, if it exists.
 * If the replica doesn't exist, no replica is returned in the cluster health
 * chunk based on this filter.
 * If the replica exists, it is included in the cluster health chunk if it
 * respects the other filter properties.
 * If not specified, all replicas that match the parent filters (if any) are
 * taken into consideration and matched against the other filter members, like
 * health state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the replicas. It allows selecting replicas if they match the desired health
 * states.
 * The possible values are integer value of one of the following health states.
 * Only replicas that match the filter are returned. All replicas are used to
 * evaluate the parent partition aggregated health state.
 * If not specified, default value is None, unless the replica ID is specified.
 * If the filter has default value and replica ID is specified, the matching
 * replica is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches replicas with
 * HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 */
export interface ReplicaHealthStateFilter {
  replicaOrInstanceIdFilter?: string;
  healthStateFilter?: number;
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a partition should be
 * included as a child of a service in the cluster health chunk.
 * The partitions are only returned if the parent entities match a filter
 * specified in the cluster health chunk query description. The parent service
 * and application must be included in the cluster health chunk.
 * One filter can match zero, one or multiple partitions, depending on its
 * properties.
 *
 * @property {uuid} [partitionIdFilter] ID of the partition that matches the
 * filter. The filter is applied only to the specified partition, if it exists.
 * If the partition doesn't exist, no partition is returned in the cluster
 * health chunk based on this filter.
 * If the partition exists, it is included in the cluster health chunk if it
 * respects the other filter properties.
 * If not specified, all partitions that match the parent filters (if any) are
 * taken into consideration and matched against the other filter members, like
 * health state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the partitions. It allows selecting partitions if they match the desired
 * health states.
 * The possible values are integer value of one of the following health states.
 * Only partitions that match the filter are returned. All partitions are used
 * to evaluate the cluster aggregated health state.
 * If not specified, default value is None, unless the partition ID is
 * specified. If the filter has default value and partition ID is specified,
 * the matching partition is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches partitions with
 * HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 * @property {array} [replicaFilters] Defines a list of filters that specify
 * which replicas to be included in the returned cluster health chunk as
 * children of the parent partition. The replicas are returned only if the
 * parent partition matches a filter.
 * If the list is empty, no replicas are returned. All the replicas are used to
 * evaluate the parent partition aggregated health state, regardless of the
 * input filters.
 * The partition filter may specify multiple replica filters.
 * For example, it can specify a filter to return all replicas with health
 * state Error and another filter to always include a replica identified by its
 * replica id.
 */
export interface PartitionHealthStateFilter {
  partitionIdFilter?: string;
  healthStateFilter?: number;
  replicaFilters?: ReplicaHealthStateFilter[];
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a service should be included
 * as a child of an application in the cluster health chunk.
 * The services are only returned if the parent application matches a filter
 * specified in the cluster health chunk query description.
 * One filter can match zero, one or multiple services, depending on its
 * properties.
 *
 * @property {string} [serviceNameFilter] The name of the service that matches
 * the filter. The filter is applied only to the specified service, if it
 * exists.
 * If the service doesn't exist, no service is returned in the cluster health
 * chunk based on this filter.
 * If the service exists, it is included as the application's child if the
 * health state matches the other filter properties.
 * If not specified, all services that match the parent filters (if any) are
 * taken into consideration and matched against the other filter members, like
 * health state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the services. It allows selecting services if they match the desired health
 * states.
 * The possible values are integer value of one of the following health states.
 * Only services that match the filter are returned. All services are used to
 * evaluate the cluster aggregated health state.
 * If not specified, default value is None, unless the service name is
 * specified. If the filter has default value and service name is specified,
 * the matching service is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches services with
 * HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 * @property {array} [partitionFilters] Defines a list of filters that specify
 * which partitions to be included in the returned cluster health chunk as
 * children of the service. The partitions are returned only if the parent
 * service matches a filter.
 * If the list is empty, no partitions are returned. All the partitions are
 * used to evaluate the parent service aggregated health state, regardless of
 * the input filters.
 * The service filter may specify multiple partition filters.
 * For example, it can specify a filter to return all partitions with health
 * state Error and another filter to always include a partition identified by
 * its partition ID.
 */
export interface ServiceHealthStateFilter {
  serviceNameFilter?: string;
  healthStateFilter?: number;
  partitionFilters?: PartitionHealthStateFilter[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a deployed service package
 * should be included as a child of a deployed application in the cluster
 * health chunk.
 * The deployed service packages are only returned if the parent entities match
 * a filter specified in the cluster health chunk query description. The parent
 * deployed application and its parent application must be included in the
 * cluster health chunk.
 * One filter can match zero, one or multiple deployed service packages,
 * depending on its properties.
 *
 * @property {string} [serviceManifestNameFilter] The name of the service
 * manifest which identifies the deployed service packages that matches the
 * filter.
 * If specified, the filter is applied only to the specified deployed service
 * packages, if any.
 * If no deployed service packages with specified manifest name exist, nothing
 * is returned in the cluster health chunk based on this filter.
 * If any deployed service package exists, they are included in the cluster
 * health chunk if it respects the other filter properties.
 * If not specified, all deployed service packages that match the parent
 * filters (if any) are taken into consideration and matched against the other
 * filter members, like health state filter.
 * @property {string} [servicePackageActivationIdFilter] The activation ID of a
 * deployed service package that matches the filter.
 * If not specified, the filter applies to all deployed service packages that
 * match the other parameters.
 * If specified, the filter matches only the deployed service package with the
 * specified activation ID.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the deployed service packages. It allows selecting deployed service packages
 * if they match the desired health states.
 * The possible values are integer value of one of the following health states.
 * Only deployed service packages that match the filter are returned. All
 * deployed service packages are used to evaluate the parent deployed
 * application aggregated health state.
 * If not specified, default value is None, unless the deployed service package
 * ID is specified. If the filter has default value and deployed service
 * package ID is specified, the matching deployed service package is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches deployed service
 * packages with HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 */
export interface DeployedServicePackageHealthStateFilter {
  serviceManifestNameFilter?: string;
  servicePackageActivationIdFilter?: string;
  healthStateFilter?: number;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a deployed application should
 * be included as a child of an application in the cluster health chunk.
 * The deployed applications are only returned if the parent application
 * matches a filter specified in the cluster health chunk query description.
 * One filter can match zero, one or multiple deployed applications, depending
 * on its properties.
 *
 * @property {string} [nodeNameFilter] The name of the node where the
 * application is deployed in order to match the filter.
 * If specified, the filter is applied only to the application deployed on the
 * specified node.
 * If the application is not deployed on the node with the specified name, no
 * deployed application is returned in the cluster health chunk based on this
 * filter.
 * Otherwise, the deployed application is included in the cluster health chunk
 * if it respects the other filter properties.
 * If not specified, all deployed applications that match the parent filters
 * (if any) are taken into consideration and matched against the other filter
 * members, like health state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the deployed applications. It allows selecting deployed applications if they
 * match the desired health states.
 * The possible values are integer value of one of the following health states.
 * Only deployed applications that match the filter are returned. All deployed
 * applications are used to evaluate the cluster aggregated health state.
 * If not specified, default value is None, unless the node name is specified.
 * If the filter has default value and node name is specified, the matching
 * deployed application is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches deployed applications
 * with HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 * @property {array} [deployedServicePackageFilters] Defines a list of filters
 * that specify which deployed service packages to be included in the returned
 * cluster health chunk as children of the parent deployed application. The
 * deployed service packages are returned only if the parent deployed
 * application matches a filter.
 * If the list is empty, no deployed service packages are returned. All the
 * deployed service packages are used to evaluate the parent deployed
 * application aggregated health state, regardless of the input filters.
 * The deployed application filter may specify multiple deployed service
 * package filters.
 * For example, it can specify a filter to return all deployed service packages
 * with health state Error and another filter to always include a deployed
 * service package on a node.
 */
export interface DeployedApplicationHealthStateFilter {
  nodeNameFilter?: string;
  healthStateFilter?: number;
  deployedServicePackageFilters?: DeployedServicePackageHealthStateFilter[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a application should be
 * included in the cluster health chunk.
 * One filter can match zero, one or multiple applications, depending on its
 * properties.
 *
 * @property {string} [applicationNameFilter] The name of the application that
 * matches the filter, as a fabric uri. The filter is applied only to the
 * specified application, if it exists.
 * If the application doesn't exist, no application is returned in the cluster
 * health chunk based on this filter.
 * If the application exists, it is included in the cluster health chunk if it
 * respects the other filter properties.
 * If not specified, all applications are matched against the other filter
 * members, like health state filter.
 * @property {string} [applicationTypeNameFilter] The name of the application
 * type that matches the filter.
 * If specified, the filter is applied only to applications of the selected
 * application type, if any exists.
 * If no applications of the specified application type exists, no application
 * is returned in the cluster health chunk based on this filter.
 * Each application of the specified application type is included in the
 * cluster health chunk if it respects the other filter properties.
 * If not specified, all applications are matched against the other filter
 * members, like health state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the applications. It allows selecting applications if they match the desired
 * health states.
 * The possible values are integer value of one of the following health states.
 * Only applications that match the filter are returned. All applications are
 * used to evaluate the cluster aggregated health state.
 * If not specified, default value is None, unless the application name or the
 * application type name are specified. If the filter has default value and
 * application name is specified, the matching application is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches applications with
 * HealthState value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 * @property {array} [serviceFilters] Defines a list of filters that specify
 * which services to be included in the returned cluster health chunk as
 * children of the application. The services are returned only if the parent
 * application matches a filter.
 * If the list is empty, no services are returned. All the services are used to
 * evaluate the parent application aggregated health state, regardless of the
 * input filters.
 * The application filter may specify multiple service filters.
 * For example, it can specify a filter to return all services with health
 * state Error and another filter to always include a service identified by its
 * service name.
 * @property {array} [deployedApplicationFilters] Defines a list of filters
 * that specify which deployed applications to be included in the returned
 * cluster health chunk as children of the application. The deployed
 * applications are returned only if the parent application matches a filter.
 * If the list is empty, no deployed applications are returned. All the
 * deployed applications are used to evaluate the parent application aggregated
 * health state, regardless of the input filters.
 * The application filter may specify multiple deployed application filters.
 * For example, it can specify a filter to return all deployed applications
 * with health state Error and another filter to always include a deployed
 * application on a specified node.
 */
export interface ApplicationHealthStateFilter {
  applicationNameFilter?: string;
  applicationTypeNameFilter?: string;
  healthStateFilter?: number;
  serviceFilters?: ServiceHealthStateFilter[];
  deployedApplicationFilters?: DeployedApplicationHealthStateFilter[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationParameter class.
 * @constructor
 * Describes an application parameter override to be applied when creating or
 * upgrading an application.
 *
 * @property {string} key The name of the parameter.
 * @property {string} value The value of the parameter.
 */
export interface ApplicationParameter {
  key: string;
  value: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationInfo class.
 * @constructor
 * Information about a Service Fabric application.
 *
 * @property {string} [id] The identity of the application. This is an encoded
 * representation of the application name. This is used in the REST APIs to
 * identify the application resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the application name is "fabric:/myapp/app1",
 * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 * @property {string} [name] The name of the application, including the
 * 'fabric:' URI scheme.
 * @property {string} [typeName] The application type name as defined in the
 * application manifest.
 * @property {string} [typeVersion] The version of the application type as
 * defined in the application manifest.
 * @property {string} [status] The status of the application. Possible values
 * include: 'Invalid', 'Ready', 'Upgrading', 'Creating', 'Deleting', 'Failed'
 * @property {array} [parameters] List of application parameters with
 * overridden values from their default values specified in the application
 * manifest.
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {string} [applicationDefinitionKind] The mechanism used to define
 * a Service Fabric application. Possible values include: 'Invalid',
 * 'ServiceFabricApplicationDescription', 'Compose'
 */
export interface ApplicationInfo {
  id?: string;
  name?: string;
  typeName?: string;
  typeVersion?: string;
  status?: string;
  parameters?: ApplicationParameter[];
  healthState?: string;
  applicationDefinitionKind?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationMetricDescription class.
 * @constructor
 * Describes capacity information for a custom resource balancing metric. This
 * can be used to limit the total consumption of this metric by the services of
 * this application.
 *
 * @property {string} [name] The name of the metric.
 * @property {number} [maximumCapacity] The maximum node capacity for Service
 * Fabric application.
 * This is the maximum Load for an instance of this application on a single
 * node. Even if the capacity of node is greater than this value, Service
 * Fabric will limit the total load of services within the application on each
 * node to this value.
 * If set to zero, capacity for this metric is unlimited on each node.
 * When creating a new application with application capacity defined, the
 * product of MaximumNodes and this value must always be smaller than or equal
 * to TotalApplicationCapacity.
 * When updating existing application with application capacity, the product of
 * MaximumNodes and this value must always be smaller than or equal to
 * TotalApplicationCapacity.
 * @property {number} [reservationCapacity] The node reservation capacity for
 * Service Fabric application.
 * This is the amount of load which is reserved on nodes which have instances
 * of this application.
 * If MinimumNodes is specified, then the product of these values will be the
 * capacity reserved in the cluster for the application.
 * If set to zero, no capacity is reserved for this metric.
 * When setting application capacity or when updating application capacity;
 * this value must be smaller than or equal to MaximumCapacity for each metric.
 * @property {number} [totalApplicationCapacity] The total metric capacity for
 * Service Fabric application.
 * This is the total metric capacity for this application in the cluster.
 * Service Fabric will try to limit the sum of loads of services within the
 * application to this value.
 * When creating a new application with application capacity defined, the
 * product of MaximumNodes and MaximumCapacity must always be smaller than or
 * equal to this value.
 */
export interface ApplicationMetricDescription {
  name?: string;
  maximumCapacity?: number;
  reservationCapacity?: number;
  totalApplicationCapacity?: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationLoadInfo class.
 * @constructor
 * Load Information about a Service Fabric application.
 *
 * @property {string} [id] The identity of the application. This is an encoded
 * representation of the application name. This is used in the REST APIs to
 * identify the application resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the application name is "fabric:/myapp/app1",
 * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 * @property {number} [minimumNodes] The minimum number of nodes for this
 * application.
 * It is the number of nodes where Service Fabric will reserve Capacity in the
 * cluster which equals to ReservedLoad * MinimumNodes for this Application
 * instance.
 * For applications that do not have application capacity defined this value
 * will be zero.
 * @property {number} [maximumNodes] The maximum number of nodes where this
 * application can be instantiated.
 * It is the number of nodes this application is allowed to span.
 * For applications that do not have application capacity defined this value
 * will be zero.
 * @property {number} [nodeCount] The number of nodes on which this application
 * is instantiated.
 * For applications that do not have application capacity defined this value
 * will be zero.
 * @property {array} [applicationLoadMetricInformation] List of application
 * capacity metric description.
 */
export interface ApplicationLoadInfo {
  id?: string;
  minimumNodes?: number;
  maximumNodes?: number;
  nodeCount?: number;
  applicationLoadMetricInformation?: ApplicationMetricDescription[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationNameInfo class.
 * @constructor
 * Information about the application name.
 *
 * @property {string} [id] The identity of the application. This is an encoded
 * representation of the application name. This is used in the REST APIs to
 * identify the application resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the application name is "fabric:/myapp/app1",
 * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 * @property {string} [name] The name of the application, including the
 * 'fabric:' URI scheme.
 */
export interface ApplicationNameInfo {
  id?: string;
  name?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationsHealthEvaluation class.
 * @constructor
 * Represents health evaluation for applications, containing health evaluations
 * for each unhealthy application that impacted current aggregated health
 * state.
 *
 * @property {number} [maxPercentUnhealthyApplications] Maximum allowed
 * percentage of unhealthy applications from the ClusterHealthPolicy.
 * @property {number} [totalCount] Total number of applications from the health
 * store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * ApplicationHealthEvaluation that impacted the aggregated health.
 */
export interface ApplicationsHealthEvaluation extends HealthEvaluation {
  maxPercentUnhealthyApplications?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeApplicationsHealthEvaluation class.
 * @constructor
 * Represents health evaluation for applications of a particular application
 * type. The application type applications evaluation can be returned when
 * cluster health evaluation returns unhealthy aggregated health state, either
 * Error or Warning. It contains health evaluations for each unhealthy
 * application of the included application type that impacted current
 * aggregated health state.
 *
 * @property {string} [applicationTypeName] The application type name as
 * defined in the application manifest.
 * @property {number} [maxPercentUnhealthyApplications] Maximum allowed
 * percentage of unhealthy applications for the application type, specified as
 * an entry in ApplicationTypeHealthPolicyMap.
 * @property {number} [totalCount] Total number of applications of the
 * application type found in the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * ApplicationHealthEvaluation of this application type that impacted the
 * aggregated health.
 */
export interface ApplicationTypeApplicationsHealthEvaluation extends HealthEvaluation {
  applicationTypeName?: string;
  maxPercentUnhealthyApplications?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ApplicationTypeHealthPolicyMap.
 *
 * @property {string} key The key of the application type health policy map
 * item. This is the name of the application type.
 * @property {number} value The value of the application type health policy map
 * item.
 * The max percent unhealthy applications allowed for the application type.
 * Must be between zero and 100.
 */
export interface ApplicationTypeHealthPolicyMapItem {
  key: string;
  value: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeInfo class.
 * @constructor
 * Information about an application type.
 *
 * @property {string} [name] The application type name as defined in the
 * application manifest.
 * @property {string} [version] The version of the application type as defined
 * in the application manifest.
 * @property {array} [defaultParameterList] List of application type parameters
 * that can be overridden when creating or updating the application.
 * @property {string} [status] The status of the application type. Possible
 * values include: 'Invalid', 'Provisioning', 'Available', 'Unprovisioning',
 * 'Failed'
 * @property {string} [statusDetails] Additional detailed information about the
 * status of the application type.
 * @property {string} [applicationTypeDefinitionKind] The mechanism used to
 * define a Service Fabric application type. Possible values include:
 * 'Invalid', 'ServiceFabricApplicationPackage', 'Compose'
 */
export interface ApplicationTypeInfo {
  name?: string;
  version?: string;
  defaultParameterList?: ApplicationParameter[];
  status?: string;
  statusDetails?: string;
  applicationTypeDefinitionKind?: string;
}

/**
 * @class
 * Initializes a new instance of the PagedApplicationTypeInfoList class.
 * @constructor
 * The list of application types that are provisioned or being provisioned in
 * the cluster. The list is paged when all of the results cannot fit in a
 * single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of application type information.
 */
export interface PagedApplicationTypeInfoList {
  continuationToken?: string;
  items?: ApplicationTypeInfo[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeManifest class.
 * @constructor
 * Contains the manifest describing an application type registered in a Service
 * Fabric cluster.
 *
 * @property {string} [manifest] The XML manifest as a string.
 */
export interface ApplicationTypeManifest {
  manifest?: string;
}

/**
 * @class
 * Initializes a new instance of the MonitoringPolicyDescription class.
 * @constructor
 * Describes the parameters for monitoring an upgrade in Monitored mode.
 *
 * @property {string} [failureAction] The compensating action to perform when a
 * Monitored upgrade encounters monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [healthCheckWaitDurationInMilliseconds] The amount of
 * time to wait after completing an upgrade domain before applying health
 * policies. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [healthCheckRetryTimeoutInMilliseconds] The amount of
 * time to retry health evaluation when the application or cluster is unhealthy
 * before FailureAction is executed. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [upgradeTimeoutInMilliseconds] The amount of time the
 * overall upgrade has to complete before FailureAction is executed. It is
 * first interpreted as a string representing an ISO 8601 duration. If that
 * fails, then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [upgradeDomainTimeoutInMilliseconds] The amount of time
 * each upgrade domain has to complete before FailureAction is executed. It is
 * first interpreted as a string representing an ISO 8601 duration. If that
 * fails, then it is interpreted as a number representing the total number of
 * milliseconds.
 */
export interface MonitoringPolicyDescription {
  failureAction?: string;
  healthCheckWaitDurationInMilliseconds?: string;
  healthCheckStableDurationInMilliseconds?: string;
  healthCheckRetryTimeoutInMilliseconds?: string;
  upgradeTimeoutInMilliseconds?: string;
  upgradeDomainTimeoutInMilliseconds?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeDescription class.
 * @constructor
 * Describes the parameters for an application upgrade. Note that upgrade
 * description replaces the existing application description. This means that
 * if the parameters are not specified, the existing parameters on the
 * applications will be overwritten with the empty parameters list. This would
 * result in the application using the default value of the parameters from the
 * application manifest. If you do not want to change any existing parameter
 * values, please get the application parameters first using the
 * GetApplicationInfo query and then supply those values as Parameters in this
 * ApplicationUpgradeDescription.
 *
 * @property {string} name The name of the target application, including the
 * 'fabric:' URI scheme.
 * @property {string} targetApplicationTypeVersion The target application type
 * version (found in the application manifest) for the application upgrade.
 * @property {array} parameters List of application parameters with overridden
 * values from their default values specified in the application manifest.
 * @property {string} upgradeKind The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {object} [monitoringPolicy] Describes the parameters for
 * monitoring an upgrade in Monitored mode.
 * @property {string} [monitoringPolicy.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [monitoringPolicy.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [applicationHealthPolicy] Defines a health policy used to
 * evaluate the health of an application or one of its children entities.
 * @property {boolean} [applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number}
 * [applicationHealthPolicy.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [applicationHealthPolicy.serviceTypeHealthPolicyMap] The
 * map with service type health policy per service type name. The map is empty
 * by default.
 */
export interface ApplicationUpgradeDescription {
  name: string;
  targetApplicationTypeVersion: string;
  parameters: ApplicationParameter[];
  upgradeKind: string;
  rollingUpgradeMode?: string;
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  forceRestart?: boolean;
  monitoringPolicy?: MonitoringPolicyDescription;
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the UpgradeDomainInfo class.
 * @constructor
 * Information about an upgrade domain.
 *
 * @property {string} [name] The name of the upgrade domain
 * @property {string} [state] The state of the upgrade domain. Possible values
 * include: 'Invalid', 'Pending', 'InProgress', 'Completed'
 */
export interface UpgradeDomainInfo {
  name?: string;
  state?: string;
}

/**
 * @class
 * Initializes a new instance of the SafetyCheck class.
 * @constructor
 * Represents a safety check performed by service fabric before continuing with
 * the operations. These checks ensure the availability of the service and the
 * reliability of the state.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface SafetyCheck {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the SafetyCheckWrapper class.
 * @constructor
 * A wrapper for the safety check object. Safety checks are performed by
 * service fabric before continuing with the operations. These checks ensure
 * the availability of the service and the reliability of the state.
 *
 * @property {object} [safetyCheck] Represents a safety check performed by
 * service fabric before continuing with the operations. These checks ensure
 * the availability of the service and the reliability of the state.
 * @property {string} [safetyCheck.kind] Polymorphic Discriminator
 */
export interface SafetyCheckWrapper {
  safetyCheck?: SafetyCheck;
}

/**
 * @class
 * Initializes a new instance of the NodeUpgradeProgressInfo class.
 * @constructor
 * Information about the upgrading node and its status
 *
 * @property {string} [nodeName] The name of a Service Fabric node.
 * @property {string} [upgradePhase] The state of the upgrading node. Possible
 * values include: 'Invalid', 'PreUpgradeSafetyCheck', 'Upgrading',
 * 'PostUpgradeSafetyCheck'
 * @property {array} [pendingSafetyChecks] List of pending safety checks
 */
export interface NodeUpgradeProgressInfo {
  nodeName?: string;
  upgradePhase?: string;
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * @class
 * Initializes a new instance of the CurrentUpgradeDomainProgressInfo class.
 * @constructor
 * Information about the current in-progress upgrade domain.
 *
 * @property {string} [domainName] The name of the upgrade domain
 * @property {array} [nodeUpgradeProgressList] List of upgrading nodes and
 * their statuses
 */
export interface CurrentUpgradeDomainProgressInfo {
  domainName?: string;
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @class
 * Initializes a new instance of the FailureUpgradeDomainProgressInfo class.
 * @constructor
 * Information about the upgrade domain progress at the time of upgrade
 * failure.
 *
 * @property {string} [domainName] The name of the upgrade domain
 * @property {array} [nodeUpgradeProgressList] List of upgrading nodes and
 * their statuses
 */
export interface FailureUpgradeDomainProgressInfo {
  domainName?: string;
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeProgressInfo class.
 * @constructor
 * Describes the parameters for an application upgrade.
 *
 * @property {string} [name] The name of the target application, including the
 * 'fabric:' URI scheme.
 * @property {string} [typeName] The application type name as defined in the
 * application manifest.
 * @property {string} [targetApplicationTypeVersion] The target application
 * type version (found in the application manifest) for the application
 * upgrade.
 * @property {array} [upgradeDomains] List of upgrade domains and their
 * statuses.
 * @property {string} [upgradeState] The state of the upgrade domain. Possible
 * values include: 'Invalid', 'RollingBackInProgress', 'RollingBackCompleted',
 * 'RollingForwardPending', 'RollingForwardInProgress',
 * 'RollingForwardCompleted', 'Failed'
 * @property {string} [nextUpgradeDomain] The name of the next upgrade domain
 * to be processed.
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {object} [upgradeDescription] Describes the parameters for an
 * application upgrade. Note that upgrade description replaces the existing
 * application description. This means that if the parameters are not
 * specified, the existing parameters on the applications will be overwritten
 * with the empty parameters list. This would result in the application using
 * the default value of the parameters from the application manifest. If you do
 * not want to change any existing parameter values, please get the application
 * parameters first using the GetApplicationInfo query and then supply those
 * values as Parameters in this ApplicationUpgradeDescription.
 * @property {string} [upgradeDescription.name] The name of the target
 * application, including the 'fabric:' URI scheme.
 * @property {string} [upgradeDescription.targetApplicationTypeVersion] The
 * target application type version (found in the application manifest) for the
 * application upgrade.
 * @property {array} [upgradeDescription.parameters] List of application
 * parameters with overridden values from their default values specified in the
 * application manifest.
 * @property {string} [upgradeDescription.upgradeKind] The kind of upgrade out
 * of the following possible values. Possible values include: 'Invalid',
 * 'Rolling'
 * @property {string} [upgradeDescription.rollingUpgradeMode] The mode used to
 * monitor health during a rolling upgrade. The values are UnmonitoredAuto,
 * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
 * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @property {number}
 * [upgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [upgradeDescription.forceRestart] If true, then
 * processes are forcefully restarted during upgrade even when the code version
 * has not changed (the upgrade only changes configuration or data).
 * @property {object} [upgradeDescription.monitoringPolicy] Describes the
 * parameters for monitoring an upgrade in Monitored mode.
 * @property {string} [upgradeDescription.monitoringPolicy.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [upgradeDescription.applicationHealthPolicy] Defines a
 * health policy used to evaluate the health of an application or one of its
 * children entities.
 * @property {boolean}
 * [upgradeDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number}
 * [upgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object}
 * [upgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @property {number}
 * [upgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [upgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [upgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array}
 * [upgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap] The
 * map with service type health policy per service type name. The map is empty
 * by default.
 * @property {string} [upgradeDurationInMilliseconds] The estimated total
 * amount of time spent processing the overall upgrade.
 * @property {string} [upgradeDomainDurationInMilliseconds] The estimated total
 * amount of time spent processing the current upgrade domain.
 * @property {array} [unhealthyEvaluations] List of health evaluations that
 * resulted in the current aggregated health state.
 * @property {object} [currentUpgradeDomainProgress] Information about the
 * current in-progress upgrade domain.
 * @property {string} [currentUpgradeDomainProgress.domainName] The name of the
 * upgrade domain
 * @property {array} [currentUpgradeDomainProgress.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 * @property {string} [startTimestampUtc] The estimated UTC datetime when the
 * upgrade started.
 * @property {string} [failureTimestampUtc] The estimated UTC datetime when the
 * upgrade failed and FailureAction was executed.
 * @property {string} [failureReason] The cause of an upgrade failure that
 * resulted in FailureAction being executed. Possible values include: 'None',
 * 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
 * 'OverallUpgradeTimeout'
 * @property {object} [upgradeDomainProgressAtFailure] Information about the
 * upgrade domain progress at the time of upgrade failure.
 * @property {string} [upgradeDomainProgressAtFailure.domainName] The name of
 * the upgrade domain
 * @property {array} [upgradeDomainProgressAtFailure.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 * @property {string} [upgradeStatusDetails] Additional detailed information
 * about the status of the pending upgrade.
 */
export interface ApplicationUpgradeProgressInfo {
  name?: string;
  typeName?: string;
  targetApplicationTypeVersion?: string;
  upgradeDomains?: UpgradeDomainInfo[];
  upgradeState?: string;
  nextUpgradeDomain?: string;
  rollingUpgradeMode?: string;
  upgradeDescription?: ApplicationUpgradeDescription;
  upgradeDurationInMilliseconds?: string;
  upgradeDomainDurationInMilliseconds?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  startTimestampUtc?: string;
  failureTimestampUtc?: string;
  failureReason?: string;
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  upgradeStatusDetails?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterConfiguration class.
 * @constructor
 * Information about the standalone cluster configuration.
 *
 * @property {string} [clusterConfiguration] The contents of the cluster
 * configuration file.
 */
export interface ClusterConfiguration {
  clusterConfiguration?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterEvent class.
 * @constructor
 * Represents the base for all Cluster Events.
 *
 */
export interface ClusterEvent extends FabricEvent {
}

/**
 * @class
 * Initializes a new instance of the NodeId class.
 * @constructor
 * An internal ID used by Service Fabric to uniquely identify a node. Node Id
 * is deterministically generated from node name.
 *
 * @property {string} [id] Value of the node Id. This is a 128 bit integer.
 */
export interface NodeId {
  id?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthState class.
 * @constructor
 * Represents the health state of a node, which contains the node identifier
 * and its aggregated health state.
 *
 * @property {string} [name] The name of a Service Fabric node.
 * @property {object} [id] An internal ID used by Service Fabric to uniquely
 * identify a node. Node Id is deterministically generated from node name.
 * @property {string} [id.id] Value of the node Id. This is a 128 bit integer.
 */
export interface NodeHealthState extends EntityHealthState {
  name?: string;
  id?: NodeId;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealth class.
 * @constructor
 * Represents the health of the cluster.
 * Contains the cluster aggregated health state, the cluster application and
 * node health states as well as the health events and the unhealthy
 * evaluations.
 *
 * @property {array} [nodeHealthStates] Cluster node health states as found in
 * the health store.
 * @property {array} [applicationHealthStates] Cluster application health
 * states as found in the health store.
 */
export interface ClusterHealth extends EntityHealth {
  nodeHealthStates?: NodeHealthState[];
  applicationHealthStates?: ApplicationHealthState[];
}

/**
 * @class
 * Initializes a new instance of the NodeHealthStateChunk class.
 * @constructor
 * Represents the health state chunk of a node, which contains the node name
 * and its aggregated health state.
 *
 * @property {string} [nodeName] The name of a Service Fabric node.
 */
export interface NodeHealthStateChunk extends EntityHealthStateChunk {
  nodeName?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthStateChunkList class.
 * @constructor
 * The list of node health state chunks in the cluster that respect the input
 * filters in the chunk query. Returned by get cluster health state chunks
 * query.
 *
 * @property {array} [items] The list of node health state chunks that respect
 * the input filters in the chunk query.
 */
export interface NodeHealthStateChunkList extends EntityHealthStateChunkList {
  items?: NodeHealthStateChunk[];
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthChunk class.
 * @constructor
 * Represents the health chunk of the cluster.
 * Contains the cluster aggregated health state, and the cluster entities that
 * respect the input filter.
 *
 * @property {string} [healthState] The HealthState representing the aggregated
 * health state of the cluster computed by Health Manager.
 * The health evaluation of the entity reflects all events reported on the
 * entity and its children (if any).
 * The aggregation is done by applying the desired cluster health policy and
 * the application health policies. Possible values include: 'Invalid', 'Ok',
 * 'Warning', 'Error', 'Unknown'
 * @property {object} [nodeHealthStateChunks] The list of node health state
 * chunks in the cluster that respect the filters in the cluster health chunk
 * query description.
 * @property {array} [nodeHealthStateChunks.items] The list of node health
 * state chunks that respect the input filters in the chunk query.
 * @property {object} [applicationHealthStateChunks] The list of application
 * health state chunks in the cluster that respect the filters in the cluster
 * health chunk query description.
 * @property {array} [applicationHealthStateChunks.items] The list of
 * application health state chunks that respect the input filters in the chunk
 * query.
 */
export interface ClusterHealthChunk {
  healthState?: string;
  nodeHealthStateChunks?: NodeHealthStateChunkList;
  applicationHealthStateChunks?: ApplicationHealthStateChunkList;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthStateFilter class.
 * @constructor
 * Defines matching criteria to determine whether a node should be included in
 * the returned cluster health chunk.
 * One filter can match zero, one or multiple nodes, depending on its
 * properties.
 * Can be specified in the cluster health chunk query description.
 *
 * @property {string} [nodeNameFilter] Name of the node that matches the
 * filter. The filter is applied only to the specified node, if it exists.
 * If the node doesn't exist, no node is returned in the cluster health chunk
 * based on this filter.
 * If the node exists, it is included in the cluster health chunk if the health
 * state matches the other filter properties.
 * If not specified, all nodes that match the parent filters (if any) are taken
 * into consideration and matched against the other filter members, like health
 * state filter.
 * @property {number} [healthStateFilter] The filter for the health state of
 * the nodes. It allows selecting nodes if they match the desired health
 * states.
 * The possible values are integer value of one of the following health states.
 * Only nodes that match the filter are returned. All nodes are used to
 * evaluate the cluster aggregated health state.
 * If not specified, default value is None, unless the node name is specified.
 * If the filter has default value and node name is specified, the matching
 * node is returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6, it matches nodes with HealthState
 * value of OK (2) and Warning (4).
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535. Default value: 0 .
 */
export interface NodeHealthStateFilter {
  nodeNameFilter?: string;
  healthStateFilter?: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthPolicy class.
 * @constructor
 * Defines a health policy used to evaluate the health of the cluster or of a
 * cluster node.
 *
 * @property {boolean} [considerWarningAsError] Indicates whether warnings are
 * treated with the same severity as errors. Default value: false .
 * @property {number} [maxPercentUnhealthyNodes] The maximum allowed percentage
 * of unhealthy nodes before reporting an error. For example, to allow 10% of
 * nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that. Default value: 0 .
 * @property {number} [maxPercentUnhealthyApplications] The maximum allowed
 * percentage of unhealthy applications before reporting an error. For example,
 * to allow 10% of applications to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero. Default value: 0 .
 * @property {array} [applicationTypeHealthPolicyMap] Defines a map with max
 * percentage unhealthy applications for specific application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 */
export interface ClusterHealthPolicy {
  considerWarningAsError?: boolean;
  maxPercentUnhealthyNodes?: number;
  maxPercentUnhealthyApplications?: number;
  applicationTypeHealthPolicyMap?: ApplicationTypeHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthChunkQueryDescription class.
 * @constructor
 * The cluster health chunk query description, which can specify the health
 * policies to evaluate cluster health and very expressive filters to select
 * which cluster entities to include in response.
 *
 * @property {array} [nodeFilters] Defines a list of filters that specify which
 * nodes to be included in the returned cluster health chunk.
 * If no filters are specified, no nodes are returned. All the nodes are used
 * to evaluate the cluster's aggregated health state, regardless of the input
 * filters.
 * The cluster health chunk query may specify multiple node filters.
 * For example, it can specify a filter to return all nodes with health state
 * Error and another filter to always include a node identified by its
 * NodeName.
 * @property {array} [applicationFilters] Defines a list of filters that
 * specify which applications to be included in the returned cluster health
 * chunk.
 * If no filters are specified, no applications are returned. All the
 * applications are used to evaluate the cluster's aggregated health state,
 * regardless of the input filters.
 * The cluster health chunk query may specify multiple application filters.
 * For example, it can specify a filter to return all applications with health
 * state Error and another filter to always include applications of a specified
 * application type.
 * @property {object} [clusterHealthPolicy] Defines a health policy used to
 * evaluate the health of the cluster or of a cluster node.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [applicationHealthPolicies] Defines the application
 * health policy map used to evaluate the health of an application or one of
 * its children entities.
 * @property {array} [applicationHealthPolicies.applicationHealthPolicyMap] The
 * wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 */
export interface ClusterHealthChunkQueryDescription {
  nodeFilters?: NodeHealthStateFilter[];
  applicationFilters?: ApplicationHealthStateFilter[];
  clusterHealthPolicy?: ClusterHealthPolicy;
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthPolicies class.
 * @constructor
 * Health policies to evaluate cluster health.
 *
 * @property {array} [applicationHealthPolicyMap] Defines a map that contains
 * specific application health policies for different applications.
 * Each entry specifies as key the application name and as value an
 * ApplicationHealthPolicy used to evaluate the application health.
 * If an application is not specified in the map, the application health
 * evaluation uses the ApplicationHealthPolicy found in its application
 * manifest or the default application health policy (if no health policy is
 * defined in the manifest).
 * The map is empty by default.
 * @property {object} [clusterHealthPolicy] Defines a health policy used to
 * evaluate the health of the cluster or of a cluster node.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 */
export interface ClusterHealthPolicies {
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
  clusterHealthPolicy?: ClusterHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ClusterManifest class.
 * @constructor
 * Information about the cluster manifest.
 *
 * @property {string} [manifest] The contents of the cluster manifest file.
 */
export interface ClusterManifest {
  manifest?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerApiRequestBody class.
 * @constructor
 * parameters for making container API call.
 *
 * @property {string} [httpVerb] HTTP verb of container REST API, defaults to
 * "GET"
 * @property {string} uriPath URI path of container REST API
 * @property {string} [contentType] Content type of container REST API request,
 * defaults to "application/json"
 * @property {string} [body] HTTP request body of container REST API
 */
export interface ContainerApiRequestBody {
  httpVerb?: string;
  uriPath: string;
  contentType?: string;
  body?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerApiResult class.
 * @constructor
 * Container API result.
 *
 * @property {number} status HTTP status code returned by the target container
 * API
 * @property {string} [contentType] HTTP content type
 * @property {string} [contentEncoding] HTTP content encoding
 * @property {string} [body] container API result body
 */
export interface ContainerApiResult {
  status: number;
  contentType?: string;
  contentEncoding?: string;
  body?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerApiResponse class.
 * @constructor
 * Response body that wraps container API result.
 *
 * @property {object} containerApiResult Container API result.
 * @property {number} [containerApiResult.status] HTTP status code returned by
 * the target container API
 * @property {string} [containerApiResult.contentType] HTTP content type
 * @property {string} [containerApiResult.contentEncoding] HTTP content
 * encoding
 * @property {string} [containerApiResult.body] container API result body
 */
export interface ContainerApiResponse {
  containerApiResult: ContainerApiResult;
}

/**
 * @class
 * Initializes a new instance of the ContainerInstanceEvent class.
 * @constructor
 * Represents the base for all Container Events.
 *
 */
export interface ContainerInstanceEvent extends FabricEvent {
}

/**
 * @class
 * Initializes a new instance of the DeactivationIntentDescription class.
 * @constructor
 * Describes the intent or reason for deactivating the node.
 *
 * @property {string} [deactivationIntent] Describes the intent or reason for
 * deactivating the node. The possible values are following. Possible values
 * include: 'Pause', 'Restart', 'RemoveData'
 */
export interface DeactivationIntentDescription {
  deactivationIntent?: string;
}

/**
 * @class
 * Initializes a new instance of the DeltaNodesCheckHealthEvaluation class.
 * @constructor
 * Represents health evaluation for delta nodes, containing health evaluations
 * for each unhealthy node that impacted current aggregated health state.
 * Can be returned during cluster upgrade when the aggregated health state of
 * the cluster is Warning or Error.
 *
 * @property {number} [baselineErrorCount] Number of nodes with aggregated
 * heath state Error in the health store at the beginning of the cluster
 * upgrade.
 * @property {number} [baselineTotalCount] Total number of nodes in the health
 * store at the beginning of the cluster upgrade.
 * @property {number} [maxPercentDeltaUnhealthyNodes] Maximum allowed
 * percentage of delta unhealthy nodes from the ClusterUpgradeHealthPolicy.
 * @property {number} [totalCount] Total number of nodes in the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state.
 * Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated
 * health.
 */
export interface DeltaNodesCheckHealthEvaluation extends HealthEvaluation {
  baselineErrorCount?: number;
  baselineTotalCount?: number;
  maxPercentDeltaUnhealthyNodes?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealthState class.
 * @constructor
 * Represents the health state of a deployed service package, containing the
 * entity identifier and the aggregated health state.
 *
 * @property {string} [nodeName] Name of the node on which the service package
 * is deployed.
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} [serviceManifestName] Name of the manifest describing the
 * service package.
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 */
export interface DeployedServicePackageHealthState extends EntityHealthState {
  nodeName?: string;
  applicationName?: string;
  serviceManifestName?: string;
  servicePackageActivationId?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealth class.
 * @constructor
 * Information about the health of an application deployed on a Service Fabric
 * node.
 *
 * @property {string} [name] Name of the application deployed on the node whose
 * health information is described by this object.
 * @property {string} [nodeName] Name of the node where this application is
 * deployed.
 * @property {array} [deployedServicePackageHealthStates] Deployed service
 * package health states for the current deployed application as found in the
 * health store.
 */
export interface DeployedApplicationHealth extends EntityHealth {
  name?: string;
  nodeName?: string;
  deployedServicePackageHealthStates?: DeployedServicePackageHealthState[];
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a deployed application, containing
 * information about the data and the algorithm used by the health store to
 * evaluate health.
 *
 * @property {string} [nodeName] Name of the node where the application is
 * deployed to.
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {array} [unhealthyEvaluations] List of  unhealthy evaluations that
 * led to the current aggregated health state of the deployed application.
 * The types of the unhealthy evaluations can be
 * DeployedServicePackagesHealthEvaluation or EventHealthEvaluation.
 */
export interface DeployedApplicationHealthEvaluation extends HealthEvaluation {
  nodeName?: string;
  applicationName?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationInfo class.
 * @constructor
 * Information about application deployed on the node.
 *
 * @property {string} [id] The identity of the application. This is an encoded
 * representation of the application name. This is used in the REST APIs to
 * identify the application resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the application name is "fabric:/myapp/app1",
 * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 * @property {string} [name] The name of the application, including the
 * 'fabric:' URI scheme.
 * @property {string} [typeName] The application type name as defined in the
 * application manifest.
 * @property {string} [status] The status of the application deployed on the
 * node. Following are the possible values. Possible values include: 'Invalid',
 * 'Downloading', 'Activating', 'Active', 'Upgrading', 'Deactivating'
 * @property {string} [workDirectory] The work directory of the application on
 * the node. The work directory can be used to store application data.
 * @property {string} [logDirectory] The log directory of the application on
 * the node. The log directory can be used to store application logs.
 * @property {string} [tempDirectory] The temp directory of the application on
 * the node. The code packages belonging to the application are forked with
 * this directory set as their temporary directory.
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 */
export interface DeployedApplicationInfo {
  id?: string;
  name?: string;
  typeName?: string;
  status?: string;
  workDirectory?: string;
  logDirectory?: string;
  tempDirectory?: string;
  healthState?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationsHealthEvaluation class.
 * @constructor
 * Represents health evaluation for deployed applications, containing health
 * evaluations for each unhealthy deployed application that impacted current
 * aggregated health state.
 * Can be returned when evaluating application health and the aggregated health
 * state is either Error or Warning.
 *
 * @property {number} [maxPercentUnhealthyDeployedApplications] Maximum allowed
 * percentage of unhealthy deployed applications from the
 * ApplicationHealthPolicy.
 * @property {number} [totalCount] Total number of deployed applications of the
 * application in the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * DeployedApplicationHealthEvaluation that impacted the aggregated health.
 */
export interface DeployedApplicationsHealthEvaluation extends HealthEvaluation {
  maxPercentUnhealthyDeployedApplications?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealth class.
 * @constructor
 * Information about the health of a service package for a specific application
 * deployed on a Service Fabric node.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} [serviceManifestName] Name of the service manifest.
 * @property {string} [nodeName] Name of the node where this service package is
 * deployed.
 */
export interface DeployedServicePackageHealth extends EntityHealth {
  applicationName?: string;
  serviceManifestName?: string;
  nodeName?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a deployed service package, containing
 * information about the data and the algorithm used by health store to
 * evaluate health. The evaluation is returned only when the aggregated health
 * state is either Error or Warning.
 *
 * @property {string} [nodeName] The name of a Service Fabric node.
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} [serviceManifestName] The name of the service manifest.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state. The type of the unhealthy
 * evaluations can be EventHealthEvaluation.
 */
export interface DeployedServicePackageHealthEvaluation extends HealthEvaluation {
  nodeName?: string;
  applicationName?: string;
  serviceManifestName?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackagesHealthEvaluation class.
 * @constructor
 * Represents health evaluation for deployed service packages, containing
 * health evaluations for each unhealthy deployed service package that impacted
 * current aggregated health state. Can be returned when evaluating deployed
 * application health and the aggregated health state is either Error or
 * Warning.
 *
 * @property {number} [totalCount] Total number of deployed service packages of
 * the deployed application in the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * DeployedServicePackageHealthEvaluation that impacted the aggregated health.
 */
export interface DeployedServicePackagesHealthEvaluation extends HealthEvaluation {
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the DeployedServiceReplicaInfo class.
 * @constructor
 * Information about a Service Fabric service replica deployed on a node.
 *
 * @property {string} [serviceName] The full name of the service with 'fabric:'
 * URI scheme.
 * @property {string} [serviceTypeName] Name of the service type as specified
 * in the service manifest.
 * @property {string} [serviceManifestName] The name of the service manifest in
 * which this service type is defined.
 * @property {string} [codePackageName] The name of the code package that hosts
 * this replica.
 * @property {uuid} [partitionId] An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 * @property {string} [replicaStatus] The status of a replica of a service.
 * Possible values include: 'Invalid', 'InBuild', 'Standby', 'Ready', 'Down',
 * 'Dropped'
 * @property {string} [address] The last address returned by the replica in
 * Open or ChangeRole.
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 * @property {string} [hostProcessId] Host process ID of the process that is
 * hosting the replica. This will be zero if the replica is down. In hyper-v
 * containers this host process ID will be from different kernel.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface DeployedServiceReplicaInfo {
  serviceName?: string;
  serviceTypeName?: string;
  serviceManifestName?: string;
  codePackageName?: string;
  partitionId?: string;
  replicaStatus?: string;
  address?: string;
  servicePackageActivationId?: string;
  hostProcessId?: string;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ReconfigurationInformation class.
 * @constructor
 * Information about current reconfiguration like phase, type, previous
 * configuration role of replica and reconfiguration start date time.
 *
 * @property {string} [previousConfigurationRole] Replica role before
 * reconfiguration started. Possible values include: 'Unknown', 'None',
 * 'Primary', 'IdleSecondary', 'ActiveSecondary'
 * @property {string} [reconfigurationPhase] Current phase of ongoing
 * reconfiguration. If no reconfiguration is taking place then this value will
 * be "None". Possible values include: 'Unknown', 'None', 'Phase0', 'Phase1',
 * 'Phase2', 'Phase3', 'Phase4', 'AbortPhaseZero'
 * @property {string} [reconfigurationType] Type of current ongoing
 * reconfiguration. If no reconfiguration is taking place then this value will
 * be "None". Possible values include: 'Unknown', 'SwapPrimary', 'Failover',
 * 'Other'
 * @property {date} [reconfigurationStartTimeUtc] Start time (in UTC) of the
 * ongoing reconfiguration. If no reconfiguration is taking place then this
 * value will be zero date-time.
 */
export interface ReconfigurationInformation {
  previousConfigurationRole?: string;
  reconfigurationPhase?: string;
  reconfigurationType?: string;
  reconfigurationStartTimeUtc?: Date;
}

/**
 * @class
 * Initializes a new instance of the DeployedStatefulServiceReplicaInfo class.
 * @constructor
 * Information about a stateful service replica deployed on a node.
 *
 * @property {string} [replicaId] Id of a stateful service replica. ReplicaId
 * is used by Service Fabric to uniquely identify a replica of a partition. It
 * is unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 * @property {string} [replicaRole] The role of a replica of a stateful
 * service. Possible values include: 'Unknown', 'None', 'Primary',
 * 'IdleSecondary', 'ActiveSecondary'
 * @property {object} [reconfigurationInformation] Information about current
 * reconfiguration like phase, type, previous configuration role of replica and
 * reconfiguration start date time.
 * @property {string} [reconfigurationInformation.previousConfigurationRole]
 * Replica role before reconfiguration started. Possible values include:
 * 'Unknown', 'None', 'Primary', 'IdleSecondary', 'ActiveSecondary'
 * @property {string} [reconfigurationInformation.reconfigurationPhase] Current
 * phase of ongoing reconfiguration. If no reconfiguration is taking place then
 * this value will be "None". Possible values include: 'Unknown', 'None',
 * 'Phase0', 'Phase1', 'Phase2', 'Phase3', 'Phase4', 'AbortPhaseZero'
 * @property {string} [reconfigurationInformation.reconfigurationType] Type of
 * current ongoing reconfiguration. If no reconfiguration is taking place then
 * this value will be "None". Possible values include: 'Unknown',
 * 'SwapPrimary', 'Failover', 'Other'
 * @property {date} [reconfigurationInformation.reconfigurationStartTimeUtc]
 * Start time (in UTC) of the ongoing reconfiguration. If no reconfiguration is
 * taking place then this value will be zero date-time.
 */
export interface DeployedStatefulServiceReplicaInfo extends DeployedServiceReplicaInfo {
  replicaId?: string;
  replicaRole?: string;
  reconfigurationInformation?: ReconfigurationInformation;
}

/**
 * @class
 * Initializes a new instance of the DeployedStatelessServiceInstanceInfo class.
 * @constructor
 * Information about a stateless service instance deployed on a node.
 *
 * @property {string} [instanceId] Id of a stateless service instance.
 * InstanceId is used by Service Fabric to uniquely identify an instance of a
 * partition of a stateless service. It is unique within a partition and does
 * not change for the lifetime of the instance. If the instance has failed over
 * on the same or different node, it will get a different value for the
 * InstanceId.
 */
export interface DeployedStatelessServiceInstanceInfo extends DeployedServiceReplicaInfo {
  instanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the HealthInformation class.
 * @constructor
 * Represents common health report information. It is included in all health
 * reports sent to health store and in all health events returned by health
 * queries.
 *
 * @property {string} sourceId The source name that identifies the
 * client/watchdog/system component that generated the health information.
 * @property {string} property The property of the health information. An
 * entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 * @property {string} healthState The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {moment.duration} [timeToLiveInMilliSeconds] The duration for
 * which this health report is valid. This field uses ISO8601 format for
 * specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 * @property {string} [description] The description of the health information.
 * It represents free text used to add human readable information about the
 * report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 * @property {string} [sequenceNumber] The sequence number for this health
 * report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 * @property {boolean} [removeWhenExpired] Value that indicates whether the
 * report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 */
export interface HealthInformation {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveInMilliSeconds?: moment.Duration;
  description?: string;
  sequenceNumber?: string;
  removeWhenExpired?: boolean;
}

/**
 * @class
 * Initializes a new instance of the HealthEvent class.
 * @constructor
 * Represents health information reported on a health entity, such as cluster,
 * application or node, with additional metadata added by the Health Manager.
 *
 * @property {boolean} [isExpired] Returns true if the health event is expired,
 * otherwise false.
 * @property {date} [sourceUtcTimestamp] The date and time when the health
 * report was sent by the source.
 * @property {date} [lastModifiedUtcTimestamp] The date and time when the
 * health report was last modified by the health store.
 * @property {date} [lastOkTransitionAt] If the current health state is 'Ok',
 * this property returns the time at which the health report was first reported
 * with 'Ok'.
 * For periodic reporting, many reports with the same state may have been
 * generated.
 * This property returns the date and time when the first 'Ok' health report
 * was received.
 *
 * If the current health state is 'Error' or 'Warning', returns the date and
 * time at which the health state was last in 'Ok', before transitioning to a
 * different state.
 *
 * If the health state was never 'Ok', the value will be zero date-time.
 * @property {date} [lastWarningTransitionAt] If the current health state is
 * 'Warning', this property returns the time at which the health report was
 * first reported with 'Warning'. For periodic reporting, many reports with the
 * same state may have been generated however, this property returns only the
 * date and time at the first 'Warning' health report was received.
 *
 * If the current health state is 'Ok' or 'Error', returns the date and time at
 * which the health state was last in 'Warning', before transitioning to a
 * different state.
 *
 * If the health state was never 'Warning', the value will be zero date-time.
 * @property {date} [lastErrorTransitionAt] If the current health state is
 * 'Error', this property returns the time at which the health report was first
 * reported with 'Error'. For periodic reporting, many reports with the same
 * state may have been generated however, this property returns only the date
 * and time at the first 'Error' health report was received.
 *
 * If the current health state is 'Ok' or 'Warning', returns the date and time
 * at which the health state was last in 'Error', before transitioning to a
 * different state.
 *
 * If the health state was never 'Error', the value will be zero date-time.
 */
export interface HealthEvent extends HealthInformation {
  isExpired?: boolean;
  sourceUtcTimestamp?: Date;
  lastModifiedUtcTimestamp?: Date;
  lastOkTransitionAt?: Date;
  lastWarningTransitionAt?: Date;
  lastErrorTransitionAt?: Date;
}

/**
 * @class
 * Initializes a new instance of the HealthStateCount class.
 * @constructor
 * Represents information about how many health entities are in Ok, Warning and
 * Error health state.
 *
 * @property {number} [okCount] The number of health entities with aggregated
 * health state Ok.
 * @property {number} [warningCount] The number of health entities with
 * aggregated health state Warning.
 * @property {number} [errorCount] The number of health entities with
 * aggregated health state Error.
 */
export interface HealthStateCount {
  okCount?: number;
  warningCount?: number;
  errorCount?: number;
}

/**
 * @class
 * Initializes a new instance of the EntityKindHealthStateCount class.
 * @constructor
 * Represents health state count for entities of the specified entity kind.
 *
 * @property {string} [entityKind] The entity kind for which health states are
 * evaluated. Possible values include: 'Invalid', 'Node', 'Partition',
 * 'Service', 'Application', 'Replica', 'DeployedApplication',
 * 'DeployedServicePackage', 'Cluster'
 * @property {object} [healthStateCount] The health state count for the
 * entities of the specified kind.
 * @property {number} [healthStateCount.okCount] The number of health entities
 * with aggregated health state Ok.
 * @property {number} [healthStateCount.warningCount] The number of health
 * entities with aggregated health state Warning.
 * @property {number} [healthStateCount.errorCount] The number of health
 * entities with aggregated health state Error.
 */
export interface EntityKindHealthStateCount {
  entityKind?: string;
  healthStateCount?: HealthStateCount;
}

/**
 * @class
 * Initializes a new instance of the HealthStatistics class.
 * @constructor
 * The health statistics of an entity, returned as part of the health query
 * result when the query description is configured to include statistics.
 * The statistics include health state counts for all children types of the
 * current entity.
 * For example, for cluster, the health statistics include health state counts
 * for nodes, applications, services, partitions, replicas, deployed
 * applications and deployed service packages.
 * For partition, the health statistics include health counts for replicas.
 *
 * @property {array} [healthStateCountList] List of health state counts per
 * entity kind, which keeps track of how many children of the queried entity
 * are in Ok, Warning and Error state.
 */
export interface HealthStatistics {
  healthStateCountList?: EntityKindHealthStateCount[];
}

/**
 * @class
 * Initializes a new instance of the Epoch class.
 * @constructor
 * An Epoch is a configuration number for the partition as a whole. When the
 * configuration of the replica set changes, for example when the Primary
 * replica changes, the operations that are replicated from the new Primary
 * replica are said to be a new Epoch from the ones which were sent by the old
 * Primary replica.
 *
 * @property {string} [configurationVersion] The current configuration number
 * of this Epoch. The configuration number is an increasing value that is
 * updated whenever the configuration of this replica set changes.
 * @property {string} [dataLossVersion] The current dataloss number of this
 * Epoch. The data loss number property is an increasing value which is updated
 * whenever data loss is suspected, as when loss of a quorum of replicas in the
 * replica set that includes the Primary replica.
 */
export interface Epoch {
  configurationVersion?: string;
  dataLossVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the BackupEpoch class.
 * @constructor
 * An Epoch is a configuration number for the partition as a whole. When the
 * configuration of the replica set changes, for example when the Primary
 * replica changes, the operations that are replicated from the new Primary
 * replica are said to be a new Epoch from the ones which were sent by the old
 * Primary replica.
 *
 * @property {string} [configurationNumber] The current configuration number of
 * this Epoch. The configuration number is an increasing value that is updated
 * whenever the configuration of this replica set changes.
 * @property {string} [dataLossNumber] The current dataloss number of this
 * Epoch. The data loss number property is an increasing value which is updated
 * whenever data loss is suspected, as when loss of a quorum of replicas in the
 * replica set that includes the Primary replica.
 */
export interface BackupEpoch {
  configurationNumber?: string;
  dataLossNumber?: string;
}

/**
 * @class
 * Initializes a new instance of the EventHealthEvaluation class.
 * @constructor
 * Represents health evaluation of a HealthEvent that was reported on the
 * entity.
 * The health evaluation is returned when evaluating health of an entity
 * results in Error or Warning.
 *
 * @property {boolean} [considerWarningAsError] Indicates whether warnings are
 * treated with the same severity as errors. The field is specified in the
 * health policy used to evaluate the entity.
 * @property {object} [unhealthyEvent] Represents health information reported
 * on a health entity, such as cluster, application or node, with additional
 * metadata added by the Health Manager.
 * @property {boolean} [unhealthyEvent.isExpired] Returns true if the health
 * event is expired, otherwise false.
 * @property {date} [unhealthyEvent.sourceUtcTimestamp] The date and time when
 * the health report was sent by the source.
 * @property {date} [unhealthyEvent.lastModifiedUtcTimestamp] The date and time
 * when the health report was last modified by the health store.
 * @property {date} [unhealthyEvent.lastOkTransitionAt] If the current health
 * state is 'Ok', this property returns the time at which the health report was
 * first reported with 'Ok'.
 * For periodic reporting, many reports with the same state may have been
 * generated.
 * This property returns the date and time when the first 'Ok' health report
 * was received.
 *
 * If the current health state is 'Error' or 'Warning', returns the date and
 * time at which the health state was last in 'Ok', before transitioning to a
 * different state.
 *
 * If the health state was never 'Ok', the value will be zero date-time.
 * @property {date} [unhealthyEvent.lastWarningTransitionAt] If the current
 * health state is 'Warning', this property returns the time at which the
 * health report was first reported with 'Warning'. For periodic reporting,
 * many reports with the same state may have been generated however, this
 * property returns only the date and time at the first 'Warning' health report
 * was received.
 *
 * If the current health state is 'Ok' or 'Error', returns the date and time at
 * which the health state was last in 'Warning', before transitioning to a
 * different state.
 *
 * If the health state was never 'Warning', the value will be zero date-time.
 * @property {date} [unhealthyEvent.lastErrorTransitionAt] If the current
 * health state is 'Error', this property returns the time at which the health
 * report was first reported with 'Error'. For periodic reporting, many reports
 * with the same state may have been generated however, this property returns
 * only the date and time at the first 'Error' health report was received.
 *
 * If the current health state is 'Ok' or 'Warning', returns the date and time
 * at which the health state was last in 'Error', before transitioning to a
 * different state.
 *
 * If the health state was never 'Error', the value will be zero date-time.
 */
export interface EventHealthEvaluation extends HealthEvaluation {
  considerWarningAsError?: boolean;
  unhealthyEvent?: HealthEvent;
}

/**
 * @class
 * Initializes a new instance of the FabricCodeVersionInfo class.
 * @constructor
 * Information about a Service Fabric code version.
 *
 * @property {string} [codeVersion] The product version of Service Fabric.
 */
export interface FabricCodeVersionInfo {
  codeVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the FabricConfigVersionInfo class.
 * @constructor
 * Information about a Service Fabric config version.
 *
 * @property {string} [configVersion] The config version of Service Fabric.
 */
export interface FabricConfigVersionInfo {
  configVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the FabricErrorError class.
 * @constructor
 * Error object containing error code and error message.
 *
 * @property {string} code Defines the fabric error codes that be returned as
 * part of the error object in response to Service Fabric API operations that
 * are not successful. Following are the error code values that can be returned
 * for a specific HTTP status code.
 *
 * - Possible values of the error code for HTTP status code 400 (Bad Request)
 * - "FABRIC_E_INVALID_PARTITION_KEY"
 * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_ADDRESS"
 * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
 * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_FABRIC_NOT_UPGRADING"
 * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_CONFIGURATION"
 * - "FABRIC_E_INVALID_NAME_URI"
 * - "FABRIC_E_PATH_TOO_LONG"
 * - "FABRIC_E_KEY_TOO_LARGE"
 * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
 * - "FABRIC_E_INVALID_ATOMIC_GROUP"
 * - "FABRIC_E_VALUE_EMPTY"
 * - "FABRIC_E_BACKUP_IS_ENABLED"
 * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
 * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
 * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
 * - "E_INVALIDARG"
 *
 * - Possible values of the error code for HTTP status code 404 (Not Found)
 * - "FABRIC_E_NODE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
 * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
 * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
 * - "FABRIC_E_PARTITION_NOT_FOUND"
 * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
 * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
 * - "FABRIC_E_DIRECTORY_NOT_FOUND"
 * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
 * - "FABRIC_E_FILE_NOT_FOUND"
 * - "FABRIC_E_NAME_DOES_NOT_EXIST"
 * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
 * - "FABRIC_E_ENUMERATION_COMPLETED"
 * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
 * - "FABRIC_E_KEY_NOT_FOUND"
 * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
 * - "FABRIC_E_BACKUP_NOT_ENABLED"
 * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
 * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 409 (Conflict)
 * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
 * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
 * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
 * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
 * - "FABRIC_E_FABRIC_VERSION_IN_USE"
 * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_NAME_ALREADY_EXISTS"
 * - "FABRIC_E_NAME_NOT_EMPTY"
 * - "FABRIC_E_PROPERTY_CHECK_FAILED"
 * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
 * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
 * - "FABRIC_E_HEALTH_STALE_REPORT"
 * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
 * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
 * - "FABRIC_E_INSTANCE_ID_MISMATCH"
 * - "FABRIC_E_BACKUP_IN_PROGRESS"
 * - "FABRIC_E_RESTORE_IN_PROGRESS"
 * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 413 (Request Entity
 * Too Large)
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 500 (Internal
 * Server Error)
 * - "FABRIC_E_NODE_IS_UP"
 * - "E_FAIL"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
 * - "ABRIC_E_VOLUME_NOT_FOUND"
 * - "SerializationError"
 *
 * - Possible values of the error code for HTTP status code 503 (Service
 * Unavailable)
 * - "FABRIC_E_NO_WRITE_QUORUM"
 * - "FABRIC_E_NOT_PRIMARY"
 * - "FABRIC_E_NOT_READY"
 * - "FABRIC_E_RECONFIGURATION_PENDING"
 * - "FABRIC_E_SERVICE_OFFLINE"
 * - "E_ABORT"
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 504 (Gateway
 * Timeout)
 * - "FABRIC_E_COMMUNICATION_ERROR"
 * - "FABRIC_E_OPERATION_NOT_COMPLETE"
 * - "FABRIC_E_TIMEOUT". Possible values include:
 * 'FABRIC_E_INVALID_PARTITION_KEY', 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_ADDRESS', 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * @property {string} [message] Error message.
 */
export interface FabricErrorError {
  code: string;
  message?: string;
}

/**
 * @class
 * Initializes a new instance of the FabricError class.
 * @constructor
 * The REST API operations for Service Fabric return standard HTTP status
 * codes. This type defines the additional information returned from the
 * Service Fabric API operations that are not successful.
 *
 * @property {object} error Error object containing error code and error
 * message.
 * @property {string} [error.code] Defines the fabric error codes that be
 * returned as part of the error object in response to Service Fabric API
 * operations that are not successful. Following are the error code values that
 * can be returned for a specific HTTP status code.
 *
 * - Possible values of the error code for HTTP status code 400 (Bad Request)
 * - "FABRIC_E_INVALID_PARTITION_KEY"
 * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_ADDRESS"
 * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
 * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_FABRIC_NOT_UPGRADING"
 * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_CONFIGURATION"
 * - "FABRIC_E_INVALID_NAME_URI"
 * - "FABRIC_E_PATH_TOO_LONG"
 * - "FABRIC_E_KEY_TOO_LARGE"
 * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
 * - "FABRIC_E_INVALID_ATOMIC_GROUP"
 * - "FABRIC_E_VALUE_EMPTY"
 * - "FABRIC_E_BACKUP_IS_ENABLED"
 * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
 * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
 * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
 * - "E_INVALIDARG"
 *
 * - Possible values of the error code for HTTP status code 404 (Not Found)
 * - "FABRIC_E_NODE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
 * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
 * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
 * - "FABRIC_E_PARTITION_NOT_FOUND"
 * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
 * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
 * - "FABRIC_E_DIRECTORY_NOT_FOUND"
 * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
 * - "FABRIC_E_FILE_NOT_FOUND"
 * - "FABRIC_E_NAME_DOES_NOT_EXIST"
 * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
 * - "FABRIC_E_ENUMERATION_COMPLETED"
 * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
 * - "FABRIC_E_KEY_NOT_FOUND"
 * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
 * - "FABRIC_E_BACKUP_NOT_ENABLED"
 * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
 * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 409 (Conflict)
 * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
 * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
 * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
 * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
 * - "FABRIC_E_FABRIC_VERSION_IN_USE"
 * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_NAME_ALREADY_EXISTS"
 * - "FABRIC_E_NAME_NOT_EMPTY"
 * - "FABRIC_E_PROPERTY_CHECK_FAILED"
 * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
 * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
 * - "FABRIC_E_HEALTH_STALE_REPORT"
 * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
 * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
 * - "FABRIC_E_INSTANCE_ID_MISMATCH"
 * - "FABRIC_E_BACKUP_IN_PROGRESS"
 * - "FABRIC_E_RESTORE_IN_PROGRESS"
 * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 413 (Request Entity
 * Too Large)
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 500 (Internal
 * Server Error)
 * - "FABRIC_E_NODE_IS_UP"
 * - "E_FAIL"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
 * - "ABRIC_E_VOLUME_NOT_FOUND"
 * - "SerializationError"
 *
 * - Possible values of the error code for HTTP status code 503 (Service
 * Unavailable)
 * - "FABRIC_E_NO_WRITE_QUORUM"
 * - "FABRIC_E_NOT_PRIMARY"
 * - "FABRIC_E_NOT_READY"
 * - "FABRIC_E_RECONFIGURATION_PENDING"
 * - "FABRIC_E_SERVICE_OFFLINE"
 * - "E_ABORT"
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 504 (Gateway
 * Timeout)
 * - "FABRIC_E_COMMUNICATION_ERROR"
 * - "FABRIC_E_OPERATION_NOT_COMPLETE"
 * - "FABRIC_E_TIMEOUT". Possible values include:
 * 'FABRIC_E_INVALID_PARTITION_KEY', 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_ADDRESS', 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * @property {string} [error.message] Error message.
 */
export interface FabricError {
  error: FabricErrorError;
}

/**
 * @class
 * Initializes a new instance of the ClusterConfigurationUpgradeStatusInfo class.
 * @constructor
 * Information about a standalone cluster configuration upgrade status.
 *
 * @property {string} [upgradeState] The state of the upgrade domain. Possible
 * values include: 'Invalid', 'RollingBackInProgress', 'RollingBackCompleted',
 * 'RollingForwardPending', 'RollingForwardInProgress',
 * 'RollingForwardCompleted', 'Failed'
 * @property {number} [progressStatus] The cluster manifest version.
 * @property {string} [configVersion] The cluster configuration version.
 * @property {string} [details] The cluster upgrade status details.
 */
export interface ClusterConfigurationUpgradeStatusInfo {
  upgradeState?: string;
  progressStatus?: number;
  configVersion?: string;
  details?: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionInformation class.
 * @constructor
 * Information about the partition identity, partitioning scheme and keys
 * supported by it.
 *
 * @property {uuid} [id] An internal ID used by Service Fabric to uniquely
 * identify a partition. This is a randomly generated GUID when the service was
 * created. The partition ID is unique and does not change for the lifetime of
 * the service. If the same service was deleted and recreated the IDs of its
 * partitions would be different.
 * @property {string} servicePartitionKind Polymorphic Discriminator
 */
export interface PartitionInformation {
  id?: string;
  servicePartitionKind: string;
}

/**
 * @class
 * Initializes a new instance of the Int64RangePartitionInformation class.
 * @constructor
 * Describes the partition information for the integer range that is based on
 * partition schemes.
 *
 * @property {string} [lowKey] Specifies the minimum key value handled by this
 * partition.
 * @property {string} [highKey] Specifies the maximum key value handled by this
 * partition.
 */
export interface Int64RangePartitionInformation extends PartitionInformation {
  lowKey?: string;
  highKey?: string;
}

/**
 * @class
 * Initializes a new instance of the NamedPartitionInformation class.
 * @constructor
 * Describes the partition information for the name as a string that is based
 * on partition schemes.
 *
 * @property {string} [name] Name of the partition.
 */
export interface NamedPartitionInformation extends PartitionInformation {
  name?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeDeactivationTaskId class.
 * @constructor
 * Identity of the task related to deactivation operation on the node.
 *
 * @property {string} [id] Value of the task id.
 * @property {string} [nodeDeactivationTaskType] The type of the task that
 * performed the node deactivation. Following are the possible values. Possible
 * values include: 'Invalid', 'Infrastructure', 'Repair', 'Client'
 */
export interface NodeDeactivationTaskId {
  id?: string;
  nodeDeactivationTaskType?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeDeactivationTask class.
 * @constructor
 * The task representing the deactivation operation on the node.
 *
 * @property {object} [nodeDeactivationTaskId] Identity of the task related to
 * deactivation operation on the node.
 * @property {string} [nodeDeactivationTaskId.id] Value of the task id.
 * @property {string} [nodeDeactivationTaskId.nodeDeactivationTaskType] The
 * type of the task that performed the node deactivation. Following are the
 * possible values. Possible values include: 'Invalid', 'Infrastructure',
 * 'Repair', 'Client'
 * @property {string} [nodeDeactivationIntent] The intent or the reason for
 * deactivating the node. Following are the possible values for it. Possible
 * values include: 'Invalid', 'Pause', 'Restart', 'RemoveData', 'RemoveNode'
 */
export interface NodeDeactivationTask {
  nodeDeactivationTaskId?: NodeDeactivationTaskId;
  nodeDeactivationIntent?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeDeactivationInfo class.
 * @constructor
 * Information about the node deactivation. This information is valid for a
 * node that is undergoing deactivation or has already been deactivated.
 *
 * @property {string} [nodeDeactivationIntent] The intent or the reason for
 * deactivating the node. Following are the possible values for it. Possible
 * values include: 'Invalid', 'Pause', 'Restart', 'RemoveData', 'RemoveNode'
 * @property {string} [nodeDeactivationStatus] The status of node deactivation
 * operation. Following are the possible values. Possible values include:
 * 'None', 'SafetyCheckInProgress', 'SafetyCheckComplete', 'Completed'
 * @property {array} [nodeDeactivationTask] List of tasks representing the
 * deactivation operation on the node.
 * @property {array} [pendingSafetyChecks] List of pending safety checks
 */
export interface NodeDeactivationInfo {
  nodeDeactivationIntent?: string;
  nodeDeactivationStatus?: string;
  nodeDeactivationTask?: NodeDeactivationTask[];
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * @class
 * Initializes a new instance of the NodeEvent class.
 * @constructor
 * Represents the base for all Node Events.
 *
 * @property {string} nodeName The name of a Service Fabric node.
 */
export interface NodeEvent extends FabricEvent {
  nodeName: string;
}

/**
 * @class
 * Initializes a new instance of the NodeHealth class.
 * @constructor
 * Information about the health of a Service Fabric node.
 *
 * @property {string} [name] Name of the node whose health information is
 * described by this object.
 */
export interface NodeHealth extends EntityHealth {
  name?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a node, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 * @property {string} [nodeName] The name of a Service Fabric node.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the node. The types of the
 * unhealthy evaluations can be EventHealthEvaluation.
 */
export interface NodeHealthEvaluation extends HealthEvaluation {
  nodeName?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the NodeInfo class.
 * @constructor
 * Information about a node in Service Fabric cluster.
 *
 * @property {string} [name] The name of a Service Fabric node.
 * @property {string} [ipAddressOrFQDN] The IP address or fully qualified
 * domain name of the node.
 * @property {string} [type] The type of the node.
 * @property {string} [codeVersion] The version of Service Fabric binaries that
 * the node is running.
 * @property {string} [configVersion] The version of Service Fabric cluster
 * manifest that the node is using.
 * @property {string} [nodeStatus] The status of the node. Possible values
 * include: 'Invalid', 'Up', 'Down', 'Enabling', 'Disabling', 'Disabled',
 * 'Unknown', 'Removed'
 * @property {string} [nodeUpTimeInSeconds] Time in seconds since the node has
 * been in NodeStatus Up. Value zero indicates that the node is not Up.
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {boolean} [isSeedNode] Indicates if the node is a seed node or
 * not. Returns true if the node is a seed node, otherwise false. A quorum of
 * seed nodes are required for proper operation of Service Fabric cluster.
 * @property {string} [upgradeDomain] The upgrade domain of the node.
 * @property {string} [faultDomain] The fault domain of the node.
 * @property {object} [id] An internal ID used by Service Fabric to uniquely
 * identify a node. Node Id is deterministically generated from node name.
 * @property {string} [id.id] Value of the node Id. This is a 128 bit integer.
 * @property {string} [instanceId] The ID representing the node instance. While
 * the ID of the node is deterministically generated from the node name and
 * remains same across restarts, the InstanceId changes every time node
 * restarts.
 * @property {object} [nodeDeactivationInfo] Information about the node
 * deactivation. This information is valid for a node that is undergoing
 * deactivation or has already been deactivated.
 * @property {string} [nodeDeactivationInfo.nodeDeactivationIntent] The intent
 * or the reason for deactivating the node. Following are the possible values
 * for it. Possible values include: 'Invalid', 'Pause', 'Restart',
 * 'RemoveData', 'RemoveNode'
 * @property {string} [nodeDeactivationInfo.nodeDeactivationStatus] The status
 * of node deactivation operation. Following are the possible values. Possible
 * values include: 'None', 'SafetyCheckInProgress', 'SafetyCheckComplete',
 * 'Completed'
 * @property {array} [nodeDeactivationInfo.nodeDeactivationTask] List of tasks
 * representing the deactivation operation on the node.
 * @property {array} [nodeDeactivationInfo.pendingSafetyChecks] List of pending
 * safety checks
 * @property {boolean} [isStopped] Indicates if the node is stopped by calling
 * stop node API or not. Returns true if the node is stopped, otherwise false.
 * @property {string} [nodeDownTimeInSeconds] Time in seconds since the node
 * has been in NodeStatus Down. Value zero indicates node is not NodeStatus
 * Down.
 * @property {date} [nodeUpAt] Date time in UTC when the node came up. If the
 * node has never been up then this value will be zero date time.
 * @property {date} [nodeDownAt] Date time in UTC when the node went down. If
 * node has never been down then this value will be zero date time.
 */
export interface NodeInfo {
  name?: string;
  ipAddressOrFQDN?: string;
  type?: string;
  codeVersion?: string;
  configVersion?: string;
  nodeStatus?: string;
  nodeUpTimeInSeconds?: string;
  healthState?: string;
  isSeedNode?: boolean;
  upgradeDomain?: string;
  faultDomain?: string;
  id?: NodeId;
  instanceId?: string;
  nodeDeactivationInfo?: NodeDeactivationInfo;
  isStopped?: boolean;
  nodeDownTimeInSeconds?: string;
  nodeUpAt?: Date;
  nodeDownAt?: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeLoadMetricInformation class.
 * @constructor
 * Represents data structure that contains load information for a certain
 * metric on a node.
 *
 * @property {string} [name] Name of the metric for which this load information
 * is provided.
 * @property {string} [nodeCapacity] Total capacity on the node for this
 * metric.
 * @property {string} [nodeLoad] Current load on the node for this metric.
 * @property {string} [nodeRemainingCapacity] The remaining capacity on the
 * node for this metric.
 * @property {boolean} [isCapacityViolation] Indicates if there is a capacity
 * violation for this metric on the node.
 * @property {string} [nodeBufferedCapacity] The value that indicates the
 * reserved capacity for this metric on the node.
 * @property {string} [nodeRemainingBufferedCapacity] The remaining reserved
 * capacity for this metric on the node.
 */
export interface NodeLoadMetricInformation {
  name?: string;
  nodeCapacity?: string;
  nodeLoad?: string;
  nodeRemainingCapacity?: string;
  isCapacityViolation?: boolean;
  nodeBufferedCapacity?: string;
  nodeRemainingBufferedCapacity?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeLoadInfo class.
 * @constructor
 * Information about load on a Service Fabric node. It holds a summary of all
 * metrics and their load on a node.
 *
 * @property {string} [nodeName] Name of the node for which the load
 * information is provided by this object.
 * @property {array} [nodeLoadMetricInformation] List that contains metrics and
 * their load information on this node.
 */
export interface NodeLoadInfo {
  nodeName?: string;
  nodeLoadMetricInformation?: NodeLoadMetricInformation[];
}

/**
 * @class
 * Initializes a new instance of the NodesHealthEvaluation class.
 * @constructor
 * Represents health evaluation for nodes, containing health evaluations for
 * each unhealthy node that impacted current aggregated health state. Can be
 * returned when evaluating cluster health and the aggregated health state is
 * either Error or Warning.
 *
 * @property {number} [maxPercentUnhealthyNodes] Maximum allowed percentage of
 * unhealthy nodes from the ClusterHealthPolicy.
 * @property {number} [totalCount] Total number of nodes found in the health
 * store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * NodeHealthEvaluation that impacted the aggregated health.
 */
export interface NodesHealthEvaluation extends HealthEvaluation {
  maxPercentUnhealthyNodes?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the PagedApplicationInfoList class.
 * @constructor
 * The list of applications in the cluster. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of application information.
 */
export interface PagedApplicationInfoList {
  continuationToken?: string;
  items?: ApplicationInfo[];
}

/**
 * @class
 * Initializes a new instance of the PagedDeployedApplicationInfoList class.
 * @constructor
 * The list of deployed applications in activating, downloading, or active
 * states on a node.
 * The list is paged when all of the results cannot fit in a single message.
 * The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of deployed application information.
 */
export interface PagedDeployedApplicationInfoList {
  continuationToken?: string;
  items?: DeployedApplicationInfo[];
}

/**
 * @class
 * Initializes a new instance of the PagedNodeInfoList class.
 * @constructor
 * The list of nodes in the cluster. The list is paged when all of the results
 * cannot fit in a single message. The next set of results can be obtained by
 * executing the same query with the continuation token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of node information.
 */
export interface PagedNodeInfoList {
  continuationToken?: string;
  items?: NodeInfo[];
}

/**
 * @class
 * Initializes a new instance of the ServicePartitionInfo class.
 * @constructor
 * Information about a partition of a Service Fabric service.
 *
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {string} [partitionStatus] The status of the service fabric
 * service partition. Possible values include: 'Invalid', 'Ready', 'NotReady',
 * 'InQuorumLoss', 'Reconfiguring', 'Deleting'
 * @property {object} [partitionInformation] Information about the partition
 * identity, partitioning scheme and keys supported by it.
 * @property {uuid} [partitionInformation.id] An internal ID used by Service
 * Fabric to uniquely identify a partition. This is a randomly generated GUID
 * when the service was created. The partition ID is unique and does not change
 * for the lifetime of the service. If the same service was deleted and
 * recreated the IDs of its partitions would be different.
 * @property {string} [partitionInformation.servicePartitionKind] Polymorphic
 * Discriminator
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ServicePartitionInfo {
  healthState?: string;
  partitionStatus?: string;
  partitionInformation?: PartitionInformation;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the PagedServicePartitionInfoList class.
 * @constructor
 * The list of partition in the cluster for a service. The list is paged when
 * all of the results cannot fit in a single message. The next set of results
 * can be obtained by executing the same query with the continuation token
 * provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of service partition information.
 */
export interface PagedServicePartitionInfoList {
  continuationToken?: string;
  items?: ServicePartitionInfo[];
}

/**
 * @class
 * Initializes a new instance of the ReplicaInfo class.
 * @constructor
 * Information about the identity, status, health, node name, uptime, and other
 * details about the replica.
 *
 * @property {string} [replicaStatus] The status of a replica of a service.
 * Possible values include: 'Invalid', 'InBuild', 'Standby', 'Ready', 'Down',
 * 'Dropped'
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {string} [nodeName] The name of a Service Fabric node.
 * @property {string} [address] The address the replica is listening on.
 * @property {string} [lastInBuildDurationInSeconds] The last in build duration
 * of the replica in seconds.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ReplicaInfo {
  replicaStatus?: string;
  healthState?: string;
  nodeName?: string;
  address?: string;
  lastInBuildDurationInSeconds?: string;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the PagedReplicaInfoList class.
 * @constructor
 * The list of replicas in the cluster for a given partition. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of replica information.
 */
export interface PagedReplicaInfoList {
  continuationToken?: string;
  items?: ReplicaInfo[];
}

/**
 * @class
 * Initializes a new instance of the ServiceInfo class.
 * @constructor
 * Information about a Service Fabric service.
 *
 * @property {string} [id] The identity of the service. This ID is an encoded
 * representation of the service name. This is used in the REST APIs to
 * identify the service resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the service name is "fabric:/myapp/app1/svc1",
 * the service identity would be "myapp~app1\~svc1" in 6.0+ and
 * "myapp/app1/svc1" in previous versions.
 * @property {string} [name] The full name of the service with 'fabric:' URI
 * scheme.
 * @property {string} [typeName] Name of the service type as specified in the
 * service manifest.
 * @property {string} [manifestVersion] The version of the service manifest.
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {string} [serviceStatus] The status of the application. Possible
 * values include: 'Unknown', 'Active', 'Upgrading', 'Deleting', 'Creating',
 * 'Failed'
 * @property {boolean} [isServiceGroup] Whether the service is in a service
 * group.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceInfo {
  id?: string;
  name?: string;
  typeName?: string;
  manifestVersion?: string;
  healthState?: string;
  serviceStatus?: string;
  isServiceGroup?: boolean;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the PagedServiceInfoList class.
 * @constructor
 * The list of services in the cluster for an application. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of service information.
 */
export interface PagedServiceInfoList {
  continuationToken?: string;
  items?: ServiceInfo[];
}

/**
 * @class
 * Initializes a new instance of the PartitionEvent class.
 * @constructor
 * Represents the base for all Partition Events.
 *
 * @property {uuid} partitionId An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 */
export interface PartitionEvent extends FabricEvent {
  partitionId: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionAnalysisEvent class.
 * @constructor
 * Represents the base for all Partition Analysis Events.
 *
 * @property {object} metadata Metadata about an Analysis Event.
 * @property {moment.duration} [metadata.delay] The analysis delay.
 * @property {moment.duration} [metadata.duration] The duration of analysis.
 */
export interface PartitionAnalysisEvent extends PartitionEvent {
  metadata: AnalysisEventMetadata;
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealthState class.
 * @constructor
 * Represents a base class for stateful service replica or stateless service
 * instance health state.
 *
 * @property {uuid} [partitionId] The ID of the partition to which this replica
 * belongs.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ReplicaHealthState extends EntityHealthState {
  partitionId?: string;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionHealth class.
 * @constructor
 * Information about the health of a Service Fabric partition.
 *
 * @property {uuid} [partitionId] ID of the partition whose health information
 * is described by this object.
 * @property {array} [replicaHealthStates] The list of replica health states
 * associated with the partition.
 */
export interface PartitionHealth extends EntityHealth {
  partitionId?: string;
  replicaHealthStates?: ReplicaHealthState[];
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a partition, containing information about
 * the data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 * @property {uuid} [partitionId] Id of the partition whose health evaluation
 * is described by this object.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the partition. The types of
 * the unhealthy evaluations can be ReplicasHealthEvaluation or
 * EventHealthEvaluation.
 */
export interface PartitionHealthEvaluation extends HealthEvaluation {
  partitionId?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthState class.
 * @constructor
 * Represents the health state of a partition, which contains the partition
 * identifier and its aggregated health state.
 *
 * @property {uuid} [partitionId] Id of the partition whose health state is
 * described by this object.
 */
export interface PartitionHealthState extends EntityHealthState {
  partitionId?: string;
}

/**
 * @class
 * Initializes a new instance of the ProvisionFabricDescription class.
 * @constructor
 * Describes the parameters for provisioning a cluster.
 *
 * @property {string} [codeFilePath] The cluster code package file path.
 * @property {string} [clusterManifestFilePath] The cluster manifest file path.
 */
export interface ProvisionFabricDescription {
  codeFilePath?: string;
  clusterManifestFilePath?: string;
}

/**
 * @class
 * Initializes a new instance of the ProvisionApplicationTypeDescriptionBase class.
 * @constructor
 * Represents the type of registration or provision requested, and if the
 * operation needs to be asynchronous or not. Supported types of provision
 * operations are from either image store or external store.
 *
 * @property {boolean} async Indicates whether or not provisioning should occur
 * asynchronously. When set to true, the provision operation returns when the
 * request is accepted by the system, and the provision operation continues
 * without any timeout limit. The default value is false. For large application
 * packages, we recommend setting the value to true.
 * @property {string} kind Polymorphic Discriminator
 */
export interface ProvisionApplicationTypeDescriptionBase {
  async: boolean;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ProvisionApplicationTypeDescription class.
 * @constructor
 * Describes the operation to register or provision an application type using
 * an application package uploaded to the Service Fabric image store.
 *
 * @property {string} applicationTypeBuildPath The relative path for the
 * application package in the image store specified during the prior upload
 * operation.
 * @property {string} [applicationPackageCleanupPolicy] The kind of action that
 * needs to be taken for cleaning up the application package after successful
 * provision. Possible values include: 'Invalid', 'Default', 'Automatic',
 * 'Manual'
 */
export interface ProvisionApplicationTypeDescription extends ProvisionApplicationTypeDescriptionBase {
  applicationTypeBuildPath: string;
  applicationPackageCleanupPolicy?: string;
}

/**
 * @class
 * Initializes a new instance of the ExternalStoreProvisionApplicationTypeDescription class.
 * @constructor
 * Describes the operation to register or provision an application type using
 * an application package from an external store instead of a package uploaded
 * to the Service Fabric image store.
 *
 * @property {string} applicationPackageDownloadUri The path to the '.sfpkg'
 * application package from where the application package can be downloaded
 * using HTTP or HTTPS protocols. The application package can be stored in an
 * external store that provides GET operation to download the file. Supported
 * protocols are HTTP and HTTPS, and the path must allow READ access.
 * @property {string} applicationTypeName The application type name represents
 * the name of the application type found in the application manifest.
 * @property {string} applicationTypeVersion The application type version
 * represents the version of the application type found in the application
 * manifest.
 */
export interface ExternalStoreProvisionApplicationTypeDescription extends ProvisionApplicationTypeDescriptionBase {
  applicationPackageDownloadUri: string;
  applicationTypeName: string;
  applicationTypeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the UnprovisionFabricDescription class.
 * @constructor
 * Describes the parameters for unprovisioning a cluster.
 *
 * @property {string} [codeVersion] The cluster code package version.
 * @property {string} [configVersion] The cluster manifest version.
 */
export interface UnprovisionFabricDescription {
  codeVersion?: string;
  configVersion?: string;
}

/**
 * @class
 * Initializes a new instance of the ResumeClusterUpgradeDescription class.
 * @constructor
 * Describes the parameters for resuming a cluster upgrade.
 *
 * @property {string} upgradeDomain The next upgrade domain for this cluster
 * upgrade.
 */
export interface ResumeClusterUpgradeDescription {
  upgradeDomain: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeHealthPolicyObject class.
 * @constructor
 * Defines a health policy used to evaluate the health of the cluster during a
 * cluster upgrade.
 *
 * @property {number} [maxPercentDeltaUnhealthyNodes] The maximum allowed
 * percentage of nodes health degradation allowed during cluster upgrades. The
 * delta is measured between the state of the nodes at the beginning of upgrade
 * and the state of the nodes at the time of the health evaluation. The check
 * is performed after every upgrade domain upgrade completion to make sure the
 * global state of the cluster is within tolerated limits. The default value is
 * 10%.
 * @property {number} [maxPercentUpgradeDomainDeltaUnhealthyNodes] The maximum
 * allowed percentage of upgrade domain nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the upgrade
 * domain nodes at the beginning of upgrade and the state of the upgrade domain
 * nodes at the time of the health evaluation. The check is performed after
 * every upgrade domain upgrade completion for all completed upgrade domains to
 * make sure the state of the upgrade domains is within tolerated limits. The
 * default value is 15%.
 */
export interface ClusterUpgradeHealthPolicyObject {
  maxPercentDeltaUnhealthyNodes?: number;
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
}

/**
 * @class
 * Initializes a new instance of the StartClusterUpgradeDescription class.
 * @constructor
 * Describes the parameters for starting a cluster upgrade.
 *
 * @property {string} [codeVersion] The cluster code version.
 * @property {string} [configVersion] The cluster configuration version.
 * @property {string} [upgradeKind] The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {object} [monitoringPolicy] Describes the parameters for
 * monitoring an upgrade in Monitored mode.
 * @property {string} [monitoringPolicy.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [monitoringPolicy.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [clusterHealthPolicy] Defines a health policy used to
 * evaluate the health of the cluster or of a cluster node.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {boolean} [enableDeltaHealthEvaluation] When true, enables delta
 * health evaluation rather than absolute health evaluation after completion of
 * each upgrade domain.
 * @property {object} [clusterUpgradeHealthPolicy] Defines a health policy used
 * to evaluate the health of the cluster during a cluster upgrade.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes] The maximum
 * allowed percentage of nodes health degradation allowed during cluster
 * upgrades. The delta is measured between the state of the nodes at the
 * beginning of upgrade and the state of the nodes at the time of the health
 * evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes] The
 * maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 * @property {object} [applicationHealthPolicyMap] Defines the application
 * health policy map used to evaluate the health of an application or one of
 * its children entities.
 * @property {array} [applicationHealthPolicyMap.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 */
export interface StartClusterUpgradeDescription {
  codeVersion?: string;
  configVersion?: string;
  upgradeKind?: string;
  rollingUpgradeMode?: string;
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  forceRestart?: boolean;
  monitoringPolicy?: MonitoringPolicyDescription;
  clusterHealthPolicy?: ClusterHealthPolicy;
  enableDeltaHealthEvaluation?: boolean;
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
}

/**
 * @class
 * Initializes a new instance of the RollingUpgradeUpdateDescription class.
 * @constructor
 * Describes the parameters for updating a rolling upgrade of application or
 * cluster.
 *
 * @property {string} rollingUpgradeMode The mode used to monitor health during
 * a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and
 * Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {number} [replicaSetCheckTimeoutInMilliseconds] The maximum amount
 * of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {string} [failureAction] The compensating action to perform when a
 * Monitored upgrade encounters monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [healthCheckWaitDurationInMilliseconds] The amount of
 * time to wait after completing an upgrade domain before applying health
 * policies. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [healthCheckRetryTimeoutInMilliseconds] The amount of
 * time to retry health evaluation when the application or cluster is unhealthy
 * before FailureAction is executed. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [upgradeTimeoutInMilliseconds] The amount of time the
 * overall upgrade has to complete before FailureAction is executed. It is
 * first interpreted as a string representing an ISO 8601 duration. If that
 * fails, then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [upgradeDomainTimeoutInMilliseconds] The amount of time
 * each upgrade domain has to complete before FailureAction is executed. It is
 * first interpreted as a string representing an ISO 8601 duration. If that
 * fails, then it is interpreted as a number representing the total number of
 * milliseconds.
 */
export interface RollingUpgradeUpdateDescription {
  rollingUpgradeMode: string;
  forceRestart?: boolean;
  replicaSetCheckTimeoutInMilliseconds?: number;
  failureAction?: string;
  healthCheckWaitDurationInMilliseconds?: string;
  healthCheckStableDurationInMilliseconds?: string;
  healthCheckRetryTimeoutInMilliseconds?: string;
  upgradeTimeoutInMilliseconds?: string;
  upgradeDomainTimeoutInMilliseconds?: string;
}

/**
 * @class
 * Initializes a new instance of the UpdateClusterUpgradeDescription class.
 * @constructor
 * Parameters for updating a cluster upgrade.
 *
 * @property {string} [upgradeKind] The type of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling',
 * 'Rolling_ForceRestart'. Default value: 'Rolling' .
 * @property {object} [updateDescription] Describes the parameters for updating
 * a rolling upgrade of application or cluster.
 * @property {string} [updateDescription.rollingUpgradeMode] The mode used to
 * monitor health during a rolling upgrade. The values are UnmonitoredAuto,
 * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
 * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @property {boolean} [updateDescription.forceRestart] If true, then processes
 * are forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @property {number} [updateDescription.replicaSetCheckTimeoutInMilliseconds]
 * The maximum amount of time to block processing of an upgrade domain and
 * prevent loss of availability when there are unexpected issues. When this
 * timeout expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 * @property {string} [updateDescription.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [updateDescription.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [updateDescription.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [updateDescription.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [updateDescription.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [updateDescription.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [clusterHealthPolicy] Defines a health policy used to
 * evaluate the health of the cluster or of a cluster node.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {boolean} [enableDeltaHealthEvaluation] When true, enables delta
 * health evaluation rather than absolute health evaluation after completion of
 * each upgrade domain.
 * @property {object} [clusterUpgradeHealthPolicy] Defines a health policy used
 * to evaluate the health of the cluster during a cluster upgrade.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes] The maximum
 * allowed percentage of nodes health degradation allowed during cluster
 * upgrades. The delta is measured between the state of the nodes at the
 * beginning of upgrade and the state of the nodes at the time of the health
 * evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes] The
 * maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 * @property {object} [applicationHealthPolicyMap] Defines the application
 * health policy map used to evaluate the health of an application or one of
 * its children entities.
 * @property {array} [applicationHealthPolicyMap.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 */
export interface UpdateClusterUpgradeDescription {
  upgradeKind?: string;
  updateDescription?: RollingUpgradeUpdateDescription;
  clusterHealthPolicy?: ClusterHealthPolicy;
  enableDeltaHealthEvaluation?: boolean;
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
}

/**
 * @class
 * Initializes a new instance of the PartitionSafetyCheck class.
 * @constructor
 * Represents a safety check for the service partition being performed by
 * service fabric before continuing with operations.
 *
 * @property {uuid} [partitionId] Id of the partition which is undergoing the
 * safety check.
 */
export interface PartitionSafetyCheck extends SafetyCheck {
  partitionId?: string;
}

/**
 * @class
 * Initializes a new instance of the EnsureAvailabilitySafetyCheck class.
 * @constructor
 * Safety check that waits to ensure the availability of the partition. It
 * waits until there are replicas available such that bringing down this
 * replica will not cause availability loss for the partition.
 *
 */
export interface EnsureAvailabilitySafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the EnsurePartitionQurumSafetyCheck class.
 * @constructor
 * Safety check that ensures that a quorum of replicas are not lost for a
 * partition.
 *
 */
export interface EnsurePartitionQurumSafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the SeedNodeSafetyCheck class.
 * @constructor
 * Represents a safety check for the seed nodes being performed by service
 * fabric before continuing with node level operations.
 *
 */
export interface SeedNodeSafetyCheck extends SafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the PartitionsHealthEvaluation class.
 * @constructor
 * Represents health evaluation for the partitions of a service, containing
 * health evaluations for each unhealthy partition that impacts current
 * aggregated health state. Can be returned when evaluating service health and
 * the aggregated health state is either Error or Warning.
 *
 * @property {number} [maxPercentUnhealthyPartitionsPerService] Maximum allowed
 * percentage of unhealthy partitions per service from the
 * ServiceTypeHealthPolicy.
 * @property {number} [totalCount] Total number of partitions of the service
 * from the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * PartitionHealthEvaluation that impacted the aggregated health.
 */
export interface PartitionsHealthEvaluation extends HealthEvaluation {
  maxPercentUnhealthyPartitionsPerService?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ReplicaEvent class.
 * @constructor
 * Represents the base for all Replica Events.
 *
 * @property {uuid} partitionId An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 * @property {number} replicaId Id of a stateful service replica. ReplicaId is
 * used by Service Fabric to uniquely identify a replica of a partition. It is
 * unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 */
export interface ReplicaEvent extends FabricEvent {
  partitionId: string;
  replicaId: number;
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealth class.
 * @constructor
 * Represents a base class for stateful service replica or stateless service
 * instance health.
 * Contains the replica aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 * @property {uuid} [partitionId] Id of the partition to which this replica
 * belongs.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ReplicaHealth extends EntityHealth {
  partitionId?: string;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ReplicaHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a replica, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 * @property {uuid} [partitionId] Id of the partition to which the replica
 * belongs.
 * @property {string} [replicaOrInstanceId] Id of a stateful service replica or
 * a stateless service instance. This ID is used in the queries that apply to
 * both stateful and stateless services. It is used by Service Fabric to
 * uniquely identify a replica of a partition of a stateful service or an
 * instance of a stateless service partition. It is unique within a partition
 * and does not change for the lifetime of the replica or the instance. If a
 * stateful replica gets dropped and another replica gets created on the same
 * node for the same partition, it will get a different value for the ID. If a
 * stateless instance is failed over on the same or different node it will get
 * a different value for the ID.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the replica. The types of the
 * unhealthy evaluations can be EventHealthEvaluation.
 */
export interface ReplicaHealthEvaluation extends HealthEvaluation {
  partitionId?: string;
  replicaOrInstanceId?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ReplicasHealthEvaluation class.
 * @constructor
 * Represents health evaluation for replicas, containing health evaluations for
 * each unhealthy replica that impacted current aggregated health state. Can be
 * returned when evaluating partition health and the aggregated health state is
 * either Error or Warning.
 *
 * @property {number} [maxPercentUnhealthyReplicasPerPartition] Maximum allowed
 * percentage of unhealthy replicas per partition from the
 * ApplicationHealthPolicy.
 * @property {number} [totalCount] Total number of replicas in the partition
 * from the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * ReplicaHealthEvaluation that impacted the aggregated health.
 */
export interface ReplicasHealthEvaluation extends HealthEvaluation {
  maxPercentUnhealthyReplicasPerPartition?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the RestartNodeDescription class.
 * @constructor
 * Describes the parameters to restart a Service Fabric node.
 *
 * @property {string} nodeInstanceId The instance ID of the target node. If
 * instance ID is specified the node is restarted only if it matches with the
 * current instance of the node. A default value of "0" would match any
 * instance ID. The instance ID can be obtained using get node query. Default
 * value: '0' .
 * @property {string} [createFabricDump] Specify True to create a dump of the
 * fabric node process. This is case-sensitive. Possible values include:
 * 'False', 'True'. Default value: 'False' .
 */
export interface RestartNodeDescription {
  nodeInstanceId: string;
  createFabricDump?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceEvent class.
 * @constructor
 * Represents the base for all Service Events.
 *
 * @property {string} serviceId The identity of the service. This ID is an
 * encoded representation of the service name. This is used in the REST APIs to
 * identify the service resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the service name is "fabric:/myapp/app1/svc1",
 * the service identity would be "myapp~app1\~svc1" in 6.0+ and
 * "myapp/app1/svc1" in previous versions.
 */
export interface ServiceEvent extends FabricEvent {
  serviceId: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceFromTemplateDescription class.
 * @constructor
 * Defines description for creating a Service Fabric service from a template
 * defined in the application manifest.
 *
 * @property {string} applicationName The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} serviceName The full name of the service with 'fabric:'
 * URI scheme.
 * @property {string} serviceTypeName Name of the service type as specified in
 * the service manifest.
 * @property {array} [initializationData] The initialization data for the newly
 * created service instance.
 * @property {string} [servicePackageActivationMode] The activation mode of
 * service package to be used for a service. Possible values include:
 * 'SharedProcess', 'ExclusiveProcess'
 * @property {string} [serviceDnsName] The DNS name of the service. It requires
 * the DNS system service to be enabled in Service Fabric cluster.
 */
export interface ServiceFromTemplateDescription {
  applicationName: string;
  serviceName: string;
  serviceTypeName: string;
  initializationData?: number[];
  servicePackageActivationMode?: string;
  serviceDnsName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthEvaluation class.
 * @constructor
 * Represents health evaluation for a service, containing information about the
 * data and the algorithm used by health store to evaluate health. The
 * evaluation is returned only when the aggregated health state is either Error
 * or Warning.
 *
 * @property {string} [serviceName] Name of the service whose health evaluation
 * is described by this object.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the service. The types of the
 * unhealthy evaluations can be PartitionsHealthEvaluation or
 * EventHealthEvaluation.
 */
export interface ServiceHealthEvaluation extends HealthEvaluation {
  serviceName?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ServiceHealth class.
 * @constructor
 * Information about the health of a Service Fabric service.
 *
 * @property {string} [name] The name of the service whose health information
 * is described by this object.
 * @property {array} [partitionHealthStates] The list of partition health
 * states associated with the service.
 */
export interface ServiceHealth extends EntityHealth {
  name?: string;
  partitionHealthStates?: PartitionHealthState[];
}

/**
 * @class
 * Initializes a new instance of the ServiceNameInfo class.
 * @constructor
 * Information about the service name.
 *
 * @property {string} [id] The identity of the service. This ID is an encoded
 * representation of the service name. This is used in the REST APIs to
 * identify the service resource.
 * Starting in version 6.0, hierarchical names are delimited with the "\~"
 * character. For example, if the service name is "fabric:/myapp/app1/svc1",
 * the service identity would be "myapp~app1\~svc1" in 6.0+ and
 * "myapp/app1/svc1" in previous versions.
 * @property {string} [name] The full name of the service with 'fabric:' URI
 * scheme.
 */
export interface ServiceNameInfo {
  id?: string;
  name?: string;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service.
 *
 * @property {string} type Polymorphic Discriminator
 */
export interface ServicePlacementPolicyDescription {
  type: string;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementInvalidDomainPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service
 * where a particular fault or upgrade domain should not be used for placement
 * of the instances or replicas of that service.
 *
 * @property {string} [domainName] The name of the domain that should not be
 * used for placement.
 */
export interface ServicePlacementInvalidDomainPolicyDescription extends ServicePlacementPolicyDescription {
  domainName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementNonPartiallyPlaceServicePolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service
 * where all replicas must be able to be placed in order for any replicas to be
 * created.
 *
 */
export interface ServicePlacementNonPartiallyPlaceServicePolicyDescription extends ServicePlacementPolicyDescription {
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementPreferPrimaryDomainPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service
 * where the service's Primary replicas should optimally be placed in a
 * particular domain.
 *
 * This placement policy is usually used with fault domains in scenarios where
 * the Service Fabric cluster is geographically distributed in order to
 * indicate that a service's primary replica should be located in a particular
 * fault domain, which in geo-distributed scenarios usually aligns with
 * regional or datacenter boundaries. Note that since this is an optimization
 * it is possible that the Primary replica may not end up located in this
 * domain due to failures, capacity limits, or other constraints.
 *
 * @property {string} [domainName] The name of the domain that should used for
 * placement as per this policy.
 */
export interface ServicePlacementPreferPrimaryDomainPolicyDescription extends ServicePlacementPolicyDescription {
  domainName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementRequiredDomainPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service
 * where the instances or replicas of that service must be placed in a
 * particular domain
 *
 * @property {string} [domainName] The name of the domain that should used for
 * placement as per this policy.
 */
export interface ServicePlacementRequiredDomainPolicyDescription extends ServicePlacementPolicyDescription {
  domainName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementRequireDomainDistributionPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service
 * where two replicas from the same partition should never be placed in the
 * same fault or upgrade domain.
 *
 * While this is not common it can expose the service to an increased risk of
 * concurrent failures due to unplanned outages or other cases of
 * subsequent/concurrent failures. As an example, consider a case where
 * replicas are deployed across different data center, with one replica per
 * location. In the event that one of the datacenters goes offline, normally
 * the replica that was placed in that datacenter will be packed into one of
 * the remaining datacenters. If this is not desirable then this policy should
 * be set.
 *
 * @property {string} [domainName] The name of the domain that should used for
 * placement as per this policy.
 */
export interface ServicePlacementRequireDomainDistributionPolicyDescription extends ServicePlacementPolicyDescription {
  domainName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServicesHealthEvaluation class.
 * @constructor
 * Represents health evaluation for services of a certain service type
 * belonging to an application, containing health evaluations for each
 * unhealthy service that impacted current aggregated health state. Can be
 * returned when evaluating application health and the aggregated health state
 * is either Error or Warning.
 *
 * @property {string} [serviceTypeName] Name of the service type of the
 * services.
 * @property {number} [maxPercentUnhealthyServices] Maximum allowed percentage
 * of unhealthy services from the ServiceTypeHealthPolicy.
 * @property {number} [totalCount] Total number of services of the current
 * service type in the application from the health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * ServiceHealthEvaluation that impacted the aggregated health.
 */
export interface ServicesHealthEvaluation extends HealthEvaluation {
  serviceTypeName?: string;
  maxPercentUnhealthyServices?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ServiceLoadMetricDescription class.
 * @constructor
 * Specifies a metric to load balance a service during runtime.
 *
 * @property {string} name The name of the metric. If the service chooses to
 * report load during runtime, the load metric name should match the name that
 * is specified in Name exactly. Note that metric names are case-sensitive.
 * @property {string} [weight] The service load metric relative weight,
 * compared to other metrics configured for this service, as a number. Possible
 * values include: 'Zero', 'Low', 'Medium', 'High'
 * @property {number} [primaryDefaultLoad] Used only for Stateful services. The
 * default amount of load, as a number, that this service creates for this
 * metric when it is a Primary replica.
 * @property {number} [secondaryDefaultLoad] Used only for Stateful services.
 * The default amount of load, as a number, that this service creates for this
 * metric when it is a Secondary replica.
 * @property {number} [defaultLoad] Used only for Stateless services. The
 * default amount of load, as a number, that this service creates for this
 * metric.
 */
export interface ServiceLoadMetricDescription {
  name: string;
  weight?: string;
  primaryDefaultLoad?: number;
  secondaryDefaultLoad?: number;
  defaultLoad?: number;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeExtensionDescription class.
 * @constructor
 * Describes extension of a service type defined in the service manifest.
 *
 * @property {string} [key] The name of the extension.
 * @property {string} [value] The extension value.
 */
export interface ServiceTypeExtensionDescription {
  key?: string;
  value?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeDescription class.
 * @constructor
 * Describes a service type defined in the service manifest of a provisioned
 * application type. The properties the ones defined in the service manifest.
 *
 * @property {boolean} [isStateful] Indicates whether the service type is a
 * stateful service type or a stateless service type. This property is true if
 * the service type is a stateful service type, false otherwise.
 * @property {string} [serviceTypeName] Name of the service type as specified
 * in the service manifest.
 * @property {string} [placementConstraints] The placement constraint to be
 * used when instantiating this service in a Service Fabric cluster.
 * @property {array} [loadMetrics] The service load metrics is given as an
 * array of ServiceLoadMetricDescription objects.
 * @property {array} [servicePlacementPolicies] List of service placement
 * policy descriptions.
 * @property {array} [extensions] List of service type extensions.
 * @property {string} kind Polymorphic Discriminator
 */
export interface ServiceTypeDescription {
  isStateful?: boolean;
  serviceTypeName?: string;
  placementConstraints?: string;
  loadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  extensions?: ServiceTypeExtensionDescription[];
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeInfo class.
 * @constructor
 * Information about a service type that is defined in a service manifest of a
 * provisioned application type.
 *
 * @property {object} [serviceTypeDescription] Describes a service type defined
 * in the service manifest of a provisioned application type. The properties
 * the ones defined in the service manifest.
 * @property {boolean} [serviceTypeDescription.isStateful] Indicates whether
 * the service type is a stateful service type or a stateless service type.
 * This property is true if the service type is a stateful service type, false
 * otherwise.
 * @property {string} [serviceTypeDescription.serviceTypeName] Name of the
 * service type as specified in the service manifest.
 * @property {string} [serviceTypeDescription.placementConstraints] The
 * placement constraint to be used when instantiating this service in a Service
 * Fabric cluster.
 * @property {array} [serviceTypeDescription.loadMetrics] The service load
 * metrics is given as an array of ServiceLoadMetricDescription objects.
 * @property {array} [serviceTypeDescription.servicePlacementPolicies] List of
 * service placement policy descriptions.
 * @property {array} [serviceTypeDescription.extensions] List of service type
 * extensions.
 * @property {string} [serviceTypeDescription.kind] Polymorphic Discriminator
 * @property {string} [serviceManifestName] The name of the service manifest in
 * which this service type is defined.
 * @property {string} [serviceManifestVersion] The version of the service
 * manifest in which this service type is defined.
 * @property {boolean} [isServiceGroup] Indicates whether the service is a
 * service group. If it is, the property value is true otherwise false.
 */
export interface ServiceTypeInfo {
  serviceTypeDescription?: ServiceTypeDescription;
  serviceManifestName?: string;
  serviceManifestVersion?: string;
  isServiceGroup?: boolean;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeManifest class.
 * @constructor
 * Contains the manifest describing a service type registered as part of an
 * application in a Service Fabric cluster.
 *
 * @property {string} [manifest] The XML manifest as a string.
 */
export interface ServiceTypeManifest {
  manifest?: string;
}

/**
 * @class
 * Initializes a new instance of the SingletonPartitionInformation class.
 * @constructor
 * Information about a partition that is singleton. The services with singleton
 * partitioning scheme are effectively non-partitioned. They only have one
 * partition.
 *
 */
export interface SingletonPartitionInformation extends PartitionInformation {
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceInfo class.
 * @constructor
 * Information about a stateful Service Fabric service.
 *
 * @property {boolean} [hasPersistedState] Whether the service has persisted
 * state.
 */
export interface StatefulServiceInfo extends ServiceInfo {
  hasPersistedState?: boolean;
}

/**
 * @class
 * Initializes a new instance of the StatefulServicePartitionInfo class.
 * @constructor
 * Information about a partition of a stateful Service Fabric service..
 *
 * @property {number} [targetReplicaSetSize] The target replica set size as a
 * number.
 * @property {number} [minReplicaSetSize] The minimum replica set size as a
 * number.
 * @property {moment.duration} [lastQuorumLossDuration] The duration for which
 * this partition was in quorum loss. If the partition is currently in quorum
 * loss, it returns the duration since it has been in that state. This field is
 * using ISO8601 format for specifying the duration.
 * @property {object} [currentConfigurationEpoch] An Epoch is a configuration
 * number for the partition as a whole. When the configuration of the replica
 * set changes, for example when the Primary replica changes, the operations
 * that are replicated from the new Primary replica are said to be a new Epoch
 * from the ones which were sent by the old Primary replica.
 * @property {string} [currentConfigurationEpoch.configurationVersion] The
 * current configuration number of this Epoch. The configuration number is an
 * increasing value that is updated whenever the configuration of this replica
 * set changes.
 * @property {string} [currentConfigurationEpoch.dataLossVersion] The current
 * dataloss number of this Epoch. The data loss number property is an
 * increasing value which is updated whenever data loss is suspected, as when
 * loss of a quorum of replicas in the replica set that includes the Primary
 * replica.
 */
export interface StatefulServicePartitionInfo extends ServicePartitionInfo {
  targetReplicaSetSize?: number;
  minReplicaSetSize?: number;
  lastQuorumLossDuration?: moment.Duration;
  currentConfigurationEpoch?: Epoch;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceReplicaHealth class.
 * @constructor
 * Represents the health of the stateful service replica.
 * Contains the replica aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 * @property {string} [replicaId] Id of a stateful service replica. ReplicaId
 * is used by Service Fabric to uniquely identify a replica of a partition. It
 * is unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 */
export interface StatefulServiceReplicaHealth extends ReplicaHealth {
  replicaId?: string;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceReplicaHealthState class.
 * @constructor
 * Represents the health state of the stateful service replica, which contains
 * the replica ID and the aggregated health state.
 *
 * @property {string} [replicaId] Id of a stateful service replica. ReplicaId
 * is used by Service Fabric to uniquely identify a replica of a partition. It
 * is unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 */
export interface StatefulServiceReplicaHealthState extends ReplicaHealthState {
  replicaId?: string;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceTypeDescription class.
 * @constructor
 * Describes a stateful service type defined in the service manifest of a
 * provisioned application type.
 *
 * @property {boolean} [hasPersistedState] A flag indicating whether this is a
 * persistent service which stores states on the local disk. If it is then the
 * value of this property is true, if not it is false.
 */
export interface StatefulServiceTypeDescription extends ServiceTypeDescription {
  hasPersistedState?: boolean;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceInfo class.
 * @constructor
 * Information about a stateless Service Fabric service.
 *
 */
export interface StatelessServiceInfo extends ServiceInfo {
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceInstanceHealth class.
 * @constructor
 * Represents the health of the stateless service instance.
 * Contains the instance aggregated health state, the health events and the
 * unhealthy evaluations.
 *
 * @property {string} [instanceId] Id of a stateless service instance.
 * InstanceId is used by Service Fabric to uniquely identify an instance of a
 * partition of a stateless service. It is unique within a partition and does
 * not change for the lifetime of the instance. If the instance has failed over
 * on the same or different node, it will get a different value for the
 * InstanceId.
 */
export interface StatelessServiceInstanceHealth extends ReplicaHealth {
  instanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceInstanceHealthState class.
 * @constructor
 * Represents the health state of the stateless service instance, which
 * contains the instance ID and the aggregated health state.
 *
 * @property {string} [replicaId] Id of the stateless service instance on the
 * wire this field is called ReplicaId.
 */
export interface StatelessServiceInstanceHealthState extends ReplicaHealthState {
  replicaId?: string;
}

/**
 * @class
 * Initializes a new instance of the StatelessServicePartitionInfo class.
 * @constructor
 * Information about a partition of a stateless Service Fabric service.
 *
 * @property {number} [instanceCount] Number of instances of this partition.
 */
export interface StatelessServicePartitionInfo extends ServicePartitionInfo {
  instanceCount?: number;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceTypeDescription class.
 * @constructor
 * Describes a stateless service type defined in the service manifest of a
 * provisioned application type.
 *
 * @property {boolean} [useImplicitHost] A flag indicating if this type is not
 * implemented and hosted by a user service process, but is implicitly hosted
 * by a system created process. This value is true for services using the guest
 * executable services, false otherwise.
 */
export interface StatelessServiceTypeDescription extends ServiceTypeDescription {
  useImplicitHost?: boolean;
}

/**
 * @class
 * Initializes a new instance of the SystemApplicationHealthEvaluation class.
 * @constructor
 * Represents health evaluation for the fabric:/System application, containing
 * information about the data and the algorithm used by health store to
 * evaluate health. The evaluation is returned only when the aggregated health
 * state of the cluster is either Error or Warning.
 *
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the current aggregated health state of the system application. The
 * types of the unhealthy evaluations can be
 * DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or
 * EventHealthEvaluation.
 */
export interface SystemApplicationHealthEvaluation extends HealthEvaluation {
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the UpgradeDomainDeltaNodesCheckHealthEvaluation class.
 * @constructor
 * Represents health evaluation for delta unhealthy cluster nodes in an upgrade
 * domain, containing health evaluations for each unhealthy node that impacted
 * current aggregated health state.
 * Can be returned during cluster upgrade when cluster aggregated health state
 * is Warning or Error.
 *
 * @property {string} [upgradeDomainName] Name of the upgrade domain where
 * nodes health is currently evaluated.
 * @property {number} [baselineErrorCount] Number of upgrade domain nodes with
 * aggregated heath state Error in the health store at the beginning of the
 * cluster upgrade.
 * @property {number} [baselineTotalCount] Total number of upgrade domain nodes
 * in the health store at the beginning of the cluster upgrade.
 * @property {number} [maxPercentDeltaUnhealthyNodes] Maximum allowed
 * percentage of upgrade domain delta unhealthy nodes from the
 * ClusterUpgradeHealthPolicy.
 * @property {number} [totalCount] Total number of upgrade domain nodes in the
 * health store.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * NodeHealthEvaluation that impacted the aggregated health.
 */
export interface UpgradeDomainDeltaNodesCheckHealthEvaluation extends HealthEvaluation {
  upgradeDomainName?: string;
  baselineErrorCount?: number;
  baselineTotalCount?: number;
  maxPercentDeltaUnhealthyNodes?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the UpgradeDomainNodesHealthEvaluation class.
 * @constructor
 * Represents health evaluation for cluster nodes in an upgrade domain,
 * containing health evaluations for each unhealthy node that impacted current
 * aggregated health state. Can be returned when evaluating cluster health
 * during cluster upgrade and the aggregated health state is either Error or
 * Warning.
 *
 * @property {string} [upgradeDomainName] Name of the upgrade domain where
 * nodes health is currently evaluated.
 * @property {number} [maxPercentUnhealthyNodes] Maximum allowed percentage of
 * unhealthy nodes from the ClusterHealthPolicy.
 * @property {number} [totalCount] Total number of nodes in the current upgrade
 * domain.
 * @property {array} [unhealthyEvaluations] List of unhealthy evaluations that
 * led to the aggregated health state. Includes all the unhealthy
 * NodeHealthEvaluation that impacted the aggregated health.
 */
export interface UpgradeDomainNodesHealthEvaluation extends HealthEvaluation {
  upgradeDomainName?: string;
  maxPercentUnhealthyNodes?: number;
  totalCount?: number;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * @class
 * Initializes a new instance of the WaitForInbuildReplicaSafetyCheck class.
 * @constructor
 * Safety check that waits for the replica build operation to finish. This
 * indicates that there is a replica that is going through the copy or is
 * providing data for building another replica. Bring the node down will abort
 * this copy operation which are typically expensive involving data movements.
 *
 */
export interface WaitForInbuildReplicaSafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the WaitForPrimaryPlacementSafetyCheck class.
 * @constructor
 * Safety check that waits for the primary replica that was moved out of the
 * node due to upgrade to be placed back again on that node.
 *
 */
export interface WaitForPrimaryPlacementSafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the WaitForPrimarySwapSafetyCheck class.
 * @constructor
 * Safety check that waits for the primary replica to be moved out of the node
 * before starting an upgrade to ensure the availability of the primary replica
 * for the partition.
 *
 */
export interface WaitForPrimarySwapSafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the WaitForReconfigurationSafetyCheck class.
 * @constructor
 * Safety check that waits for the current reconfiguration of the partition to
 * be completed before starting an upgrade.
 *
 */
export interface WaitForReconfigurationSafetyCheck extends PartitionSafetyCheck {
}

/**
 * @class
 * Initializes a new instance of the LoadMetricReport class.
 * @constructor
 * Represents the load metric report which contains the time metric was
 * reported, its name and value.
 *
 * @property {date} [lastReportedUtc] Gets the UTC time when the load was
 * reported.
 * @property {string} [name] The name of the load metric.
 * @property {string} [value] The value of the load metric.
 */
export interface LoadMetricReport {
  lastReportedUtc?: Date;
  name?: string;
  value?: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionLoadInformation class.
 * @constructor
 * Represents load information for a partition, which contains the primary and
 * secondary reported load metrics.
 * In case there is no load reported, PartitionLoadInformation will contain the
 * default load for the service of the partition.
 * For default loads, LoadMetricReport's LastReportedUtc is set to 0.
 *
 * @property {uuid} [partitionId] Id of the partition.
 * @property {array} [primaryLoadMetricReports] Array of load reports from the
 * primary replica for this partition.
 * @property {array} [secondaryLoadMetricReports] Array of aggregated load
 * reports from all secondary replicas for this partition.
 * Array only contains the latest reported load for each metric.
 */
export interface PartitionLoadInformation {
  partitionId?: string;
  primaryLoadMetricReports?: LoadMetricReport[];
  secondaryLoadMetricReports?: LoadMetricReport[];
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceReplicaInfo class.
 * @constructor
 * Represents a stateful service replica. This includes information about the
 * identity, role, status, health, node name, uptime, and other details about
 * the replica.
 *
 * @property {string} [replicaRole] The role of a replica of a stateful
 * service. Possible values include: 'Unknown', 'None', 'Primary',
 * 'IdleSecondary', 'ActiveSecondary'
 * @property {string} [replicaId] Id of a stateful service replica. ReplicaId
 * is used by Service Fabric to uniquely identify a replica of a partition. It
 * is unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 */
export interface StatefulServiceReplicaInfo extends ReplicaInfo {
  replicaRole?: string;
  replicaId?: string;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceInstanceInfo class.
 * @constructor
 * Represents a stateless service instance. This includes information about the
 * identity, status, health, node name, uptime, and other details about the
 * instance.
 *
 * @property {string} [instanceId] Id of a stateless service instance.
 * InstanceId is used by Service Fabric to uniquely identify an instance of a
 * partition of a stateless service. It is unique within a partition and does
 * not change for the lifetime of the instance. If the instance has failed over
 * on the same or different node, it will get a different value for the
 * InstanceId.
 */
export interface StatelessServiceInstanceInfo extends ReplicaInfo {
  instanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeDescriptionObject class.
 * @constructor
 * Represents a ServiceFabric cluster upgrade
 *
 * @property {string} [configVersion] The cluster configuration version
 * (specified in the cluster manifest).
 * @property {string} [codeVersion] The ServiceFabric code version of the
 * cluster.
 * @property {string} [upgradeKind] The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {boolean} [enableDeltaHealthEvaluation] When true, enables delta
 * health evaluation rather than absolute health evaluation after completion of
 * each upgrade domain.
 * @property {object} [monitoringPolicy] Describes the parameters for
 * monitoring an upgrade in Monitored mode.
 * @property {string} [monitoringPolicy.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [monitoringPolicy.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [clusterHealthPolicy] Defines a health policy used to
 * evaluate the health of the cluster or of a cluster node.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [clusterUpgradeHealthPolicy] Defines a health policy used
 * to evaluate the health of the cluster during a cluster upgrade.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes] The maximum
 * allowed percentage of nodes health degradation allowed during cluster
 * upgrades. The delta is measured between the state of the nodes at the
 * beginning of upgrade and the state of the nodes at the time of the health
 * evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 * @property {number}
 * [clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes] The
 * maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 * @property {array} [applicationHealthPolicyMap] Defines a map that contains
 * specific application health policies for different applications.
 * Each entry specifies as key the application name and as value an
 * ApplicationHealthPolicy used to evaluate the application health.
 * If an application is not specified in the map, the application health
 * evaluation uses the ApplicationHealthPolicy found in its application
 * manifest or the default application health policy (if no health policy is
 * defined in the manifest).
 * The map is empty by default.
 */
export interface ClusterUpgradeDescriptionObject {
  configVersion?: string;
  codeVersion?: string;
  upgradeKind?: string;
  rollingUpgradeMode?: string;
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  forceRestart?: boolean;
  enableDeltaHealthEvaluation?: boolean;
  monitoringPolicy?: MonitoringPolicyDescription;
  clusterHealthPolicy?: ClusterHealthPolicy;
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the FailedUpgradeDomainProgressObject class.
 * @constructor
 * The detailed upgrade progress for nodes in the current upgrade domain at the
 * point of failure.
 *
 * @property {string} [domainName] The name of the upgrade domain
 * @property {array} [nodeUpgradeProgressList] List of upgrading nodes and
 * their statuses
 */
export interface FailedUpgradeDomainProgressObject {
  domainName?: string;
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeProgressObject class.
 * @constructor
 * Information about a cluster upgrade.
 *
 * @property {string} [codeVersion] The ServiceFabric code version of the
 * cluster.
 * @property {string} [configVersion] The cluster configuration version
 * (specified in the cluster manifest).
 * @property {array} [upgradeDomains] List of upgrade domains and their
 * statuses.
 * @property {string} [upgradeState] The state of the upgrade domain. Possible
 * values include: 'Invalid', 'RollingBackInProgress', 'RollingBackCompleted',
 * 'RollingForwardPending', 'RollingForwardInProgress',
 * 'RollingForwardCompleted', 'Failed'
 * @property {string} [nextUpgradeDomain] The name of the next upgrade domain
 * to be processed.
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {object} [upgradeDescription] Represents a ServiceFabric cluster
 * upgrade
 * @property {string} [upgradeDescription.configVersion] The cluster
 * configuration version (specified in the cluster manifest).
 * @property {string} [upgradeDescription.codeVersion] The ServiceFabric code
 * version of the cluster.
 * @property {string} [upgradeDescription.upgradeKind] The kind of upgrade out
 * of the following possible values. Possible values include: 'Invalid',
 * 'Rolling'
 * @property {string} [upgradeDescription.rollingUpgradeMode] The mode used to
 * monitor health during a rolling upgrade. The values are UnmonitoredAuto,
 * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
 * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @property {number}
 * [upgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [upgradeDescription.forceRestart] If true, then
 * processes are forcefully restarted during upgrade even when the code version
 * has not changed (the upgrade only changes configuration or data).
 * @property {boolean} [upgradeDescription.enableDeltaHealthEvaluation] When
 * true, enables delta health evaluation rather than absolute health evaluation
 * after completion of each upgrade domain.
 * @property {object} [upgradeDescription.monitoringPolicy] Describes the
 * parameters for monitoring an upgrade in Monitored mode.
 * @property {string} [upgradeDescription.monitoringPolicy.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string}
 * [upgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [upgradeDescription.clusterHealthPolicy] Defines a health
 * policy used to evaluate the health of the cluster or of a cluster node.
 * @property {boolean}
 * [upgradeDescription.clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number}
 * [upgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number}
 * [upgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array}
 * [upgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [upgradeDescription.clusterUpgradeHealthPolicy] Defines a
 * health policy used to evaluate the health of the cluster during a cluster
 * upgrade.
 * @property {number}
 * [upgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
 * The maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the nodes at
 * the beginning of upgrade and the state of the nodes at the time of the
 * health evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 * @property {number}
 * [upgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 * @property {array} [upgradeDescription.applicationHealthPolicyMap] Defines a
 * map that contains specific application health policies for different
 * applications.
 * Each entry specifies as key the application name and as value an
 * ApplicationHealthPolicy used to evaluate the application health.
 * If an application is not specified in the map, the application health
 * evaluation uses the ApplicationHealthPolicy found in its application
 * manifest or the default application health policy (if no health policy is
 * defined in the manifest).
 * The map is empty by default.
 * @property {string} [upgradeDurationInMilliseconds] The estimated elapsed
 * time spent processing the current overall upgrade.
 * @property {string} [upgradeDomainDurationInMilliseconds] The estimated
 * elapsed time spent processing the current upgrade domain.
 * @property {array} [unhealthyEvaluations] List of health evaluations that
 * resulted in the current aggregated health state.
 * @property {object} [currentUpgradeDomainProgress] Information about the
 * current in-progress upgrade domain.
 * @property {string} [currentUpgradeDomainProgress.domainName] The name of the
 * upgrade domain
 * @property {array} [currentUpgradeDomainProgress.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 * @property {string} [startTimestampUtc] The start time of the upgrade in UTC.
 * @property {string} [failureTimestampUtc] The failure time of the upgrade in
 * UTC.
 * @property {string} [failureReason] The cause of an upgrade failure that
 * resulted in FailureAction being executed. Possible values include: 'None',
 * 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
 * 'OverallUpgradeTimeout'
 * @property {object} [upgradeDomainProgressAtFailure] The detailed upgrade
 * progress for nodes in the current upgrade domain at the point of failure.
 * @property {string} [upgradeDomainProgressAtFailure.domainName] The name of
 * the upgrade domain
 * @property {array} [upgradeDomainProgressAtFailure.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 */
export interface ClusterUpgradeProgressObject {
  codeVersion?: string;
  configVersion?: string;
  upgradeDomains?: UpgradeDomainInfo[];
  upgradeState?: string;
  nextUpgradeDomain?: string;
  rollingUpgradeMode?: string;
  upgradeDescription?: ClusterUpgradeDescriptionObject;
  upgradeDurationInMilliseconds?: string;
  upgradeDomainDurationInMilliseconds?: string;
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  startTimestampUtc?: string;
  failureTimestampUtc?: string;
  failureReason?: string;
  upgradeDomainProgressAtFailure?: FailedUpgradeDomainProgressObject;
}

/**
 * @class
 * Initializes a new instance of the ClusterConfigurationUpgradeDescription class.
 * @constructor
 * Describes the parameters for a standalone cluster configuration upgrade.
 *
 * @property {string} clusterConfig The cluster configuration.
 * @property {moment.duration} [healthCheckRetryTimeout] The length of time
 * between attempts to perform a health checks if the application or cluster is
 * not healthy. Default value: moment.duration('PT0H0M0S') .
 * @property {moment.duration} [healthCheckWaitDurationInSeconds] The length of
 * time to wait after completing an upgrade domain before starting the health
 * checks process. Default value: moment.duration('PT0H0M0S') .
 * @property {moment.duration} [healthCheckStableDurationInSeconds] The length
 * of time that the application or cluster must remain healthy. Default value:
 * moment.duration('PT0H0M0S') .
 * @property {moment.duration} [upgradeDomainTimeoutInSeconds] The timeout for
 * the upgrade domain. Default value: moment.duration('PT0H0M0S') .
 * @property {moment.duration} [upgradeTimeoutInSeconds] The upgrade timeout.
 * Default value: moment.duration('PT0H0M0S') .
 * @property {number} [maxPercentUnhealthyApplications] The maximum allowed
 * percentage of unhealthy applications during the upgrade. Allowed values are
 * integer values from zero to 100. Default value: 0 .
 * @property {number} [maxPercentUnhealthyNodes] The maximum allowed percentage
 * of unhealthy nodes during the upgrade. Allowed values are integer values
 * from zero to 100. Default value: 0 .
 * @property {number} [maxPercentDeltaUnhealthyNodes] The maximum allowed
 * percentage of delta health degradation during the upgrade. Allowed values
 * are integer values from zero to 100. Default value: 0 .
 * @property {number} [maxPercentUpgradeDomainDeltaUnhealthyNodes] The maximum
 * allowed percentage of upgrade domain delta health degradation during the
 * upgrade. Allowed values are integer values from zero to 100. Default value:
 * 0 .
 * @property {object} [applicationHealthPolicies] Defines the application
 * health policy map used to evaluate the health of an application or one of
 * its children entities.
 * @property {array} [applicationHealthPolicies.applicationHealthPolicyMap] The
 * wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 */
export interface ClusterConfigurationUpgradeDescription {
  clusterConfig: string;
  healthCheckRetryTimeout?: moment.Duration;
  healthCheckWaitDurationInSeconds?: moment.Duration;
  healthCheckStableDurationInSeconds?: moment.Duration;
  upgradeDomainTimeoutInSeconds?: moment.Duration;
  upgradeTimeoutInSeconds?: moment.Duration;
  maxPercentUnhealthyApplications?: number;
  maxPercentUnhealthyNodes?: number;
  maxPercentDeltaUnhealthyNodes?: number;
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * @class
 * Initializes a new instance of the UpgradeOrchestrationServiceState class.
 * @constructor
 * Service state of Service Fabric Upgrade Orchestration Service.
 *
 * @property {string} [serviceState] The state of Service Fabric Upgrade
 * Orchestration Service.
 */
export interface UpgradeOrchestrationServiceState {
  serviceState?: string;
}

/**
 * @class
 * Initializes a new instance of the UpgradeOrchestrationServiceStateSummary class.
 * @constructor
 * Service state summary of Service Fabric Upgrade Orchestration Service.
 *
 * @property {string} [currentCodeVersion] The current code version of the
 * cluster.
 * @property {string} [currentManifestVersion] The current manifest version of
 * the cluster.
 * @property {string} [targetCodeVersion] The target code version of  the
 * cluster.
 * @property {string} [targetManifestVersion] The target manifest version of
 * the cluster.
 * @property {string} [pendingUpgradeType] The type of the pending upgrade of
 * the cluster.
 */
export interface UpgradeOrchestrationServiceStateSummary {
  currentCodeVersion?: string;
  currentManifestVersion?: string;
  targetCodeVersion?: string;
  targetManifestVersion?: string;
  pendingUpgradeType?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeImageStorePath class.
 * @constructor
 * Path description for the application package in the image store specified
 * during the prior copy operation.
 *
 * @property {string} applicationTypeBuildPath The relative image store path to
 * the application package.
 */
export interface ApplicationTypeImageStorePath {
  applicationTypeBuildPath: string;
}

/**
 * @class
 * Initializes a new instance of the UnprovisionApplicationTypeDescriptionInfo class.
 * @constructor
 * Describes the operation to unregister or unprovision an application type and
 * its version that was registered with the Service Fabric.
 *
 * @property {string} applicationTypeVersion The version of the application
 * type as defined in the application manifest.
 * @property {boolean} [async] The flag indicating whether or not unprovision
 * should occur asynchronously. When set to true, the unprovision operation
 * returns when the request is accepted by the system, and the unprovision
 * operation continues without any timeout limit. The default value is false.
 * However, we recommend setting it to true for large application packages that
 * were provisioned.
 */
export interface UnprovisionApplicationTypeDescriptionInfo {
  applicationTypeVersion: string;
  async?: boolean;
}

/**
 * @class
 * Initializes a new instance of the CodePackageEntryPointStatistics class.
 * @constructor
 * Statistics about setup or main entry point  of a code package deployed on a
 * Service Fabric node.
 *
 * @property {string} [lastExitCode] The last exit code of the entry point.
 * @property {date} [lastActivationTime] The last time (in UTC) when Service
 * Fabric attempted to run the entry point.
 * @property {date} [lastExitTime] The last time (in UTC) when the entry point
 * finished running.
 * @property {date} [lastSuccessfulActivationTime] The last time (in UTC) when
 * the entry point ran successfully.
 * @property {date} [lastSuccessfulExitTime] The last time (in UTC) when the
 * entry point finished running gracefully.
 * @property {string} [activationCount] Number of times the entry point has
 * run.
 * @property {string} [activationFailureCount] Number of times the entry point
 * failed to run.
 * @property {string} [continuousActivationFailureCount] Number of times the
 * entry point continuously failed to run.
 * @property {string} [exitCount] Number of times the entry point finished
 * running.
 * @property {string} [exitFailureCount] Number of times the entry point failed
 * to exit gracefully.
 * @property {string} [continuousExitFailureCount] Number of times the entry
 * point continuously failed to exit gracefully.
 */
export interface CodePackageEntryPointStatistics {
  lastExitCode?: string;
  lastActivationTime?: Date;
  lastExitTime?: Date;
  lastSuccessfulActivationTime?: Date;
  lastSuccessfulExitTime?: Date;
  activationCount?: string;
  activationFailureCount?: string;
  continuousActivationFailureCount?: string;
  exitCount?: string;
  exitFailureCount?: string;
  continuousExitFailureCount?: string;
}

/**
 * @class
 * Initializes a new instance of the CodePackageEntryPoint class.
 * @constructor
 * Information about setup or main entry point of a code package deployed on a
 * Service Fabric node.
 *
 * @property {string} [entryPointLocation] The location of entry point
 * executable on the node.
 * @property {string} [processId] The process ID of the entry point.
 * @property {string} [runAsUserName] The user name under which entry point
 * executable is run on the node.
 * @property {object} [codePackageEntryPointStatistics] Statistics about setup
 * or main entry point  of a code package deployed on a Service Fabric node.
 * @property {string} [codePackageEntryPointStatistics.lastExitCode] The last
 * exit code of the entry point.
 * @property {date} [codePackageEntryPointStatistics.lastActivationTime] The
 * last time (in UTC) when Service Fabric attempted to run the entry point.
 * @property {date} [codePackageEntryPointStatistics.lastExitTime] The last
 * time (in UTC) when the entry point finished running.
 * @property {date}
 * [codePackageEntryPointStatistics.lastSuccessfulActivationTime] The last time
 * (in UTC) when the entry point ran successfully.
 * @property {date} [codePackageEntryPointStatistics.lastSuccessfulExitTime]
 * The last time (in UTC) when the entry point finished running gracefully.
 * @property {string} [codePackageEntryPointStatistics.activationCount] Number
 * of times the entry point has run.
 * @property {string} [codePackageEntryPointStatistics.activationFailureCount]
 * Number of times the entry point failed to run.
 * @property {string}
 * [codePackageEntryPointStatistics.continuousActivationFailureCount] Number of
 * times the entry point continuously failed to run.
 * @property {string} [codePackageEntryPointStatistics.exitCount] Number of
 * times the entry point finished running.
 * @property {string} [codePackageEntryPointStatistics.exitFailureCount] Number
 * of times the entry point failed to exit gracefully.
 * @property {string}
 * [codePackageEntryPointStatistics.continuousExitFailureCount] Number of times
 * the entry point continuously failed to exit gracefully.
 * @property {string} [status] Specifies the status of the code package entry
 * point deployed on a Service Fabric node. Possible values include: 'Invalid',
 * 'Pending', 'Starting', 'Started', 'Stopping', 'Stopped'
 * @property {date} [nextActivationTime] The time (in UTC) when the entry point
 * executable will be run next.
 * @property {string} [instanceId] The instance ID for current running entry
 * point. For a code package setup entry point (if specified) runs first and
 * after it finishes main entry point is started. Each time entry point
 * executable is run, its instance id will change.
 */
export interface CodePackageEntryPoint {
  entryPointLocation?: string;
  processId?: string;
  runAsUserName?: string;
  codePackageEntryPointStatistics?: CodePackageEntryPointStatistics;
  status?: string;
  nextActivationTime?: Date;
  instanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedCodePackageInfo class.
 * @constructor
 * Information about code package deployed on a Service Fabric node.
 *
 * @property {string} [name] The name of the code package.
 * @property {string} [version] The version of the code package specified in
 * service manifest.
 * @property {string} [serviceManifestName] The name of service manifest that
 * specified this code package.
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 * @property {string} [hostType] Specifies the type of host for main entry
 * point of a code package as specified in service manifest. Possible values
 * include: 'Invalid', 'ExeHost', 'ContainerHost'
 * @property {string} [hostIsolationMode] Specifies the isolation mode of main
 * entry point of a code package when it's host type is ContainerHost. This is
 * specified as part of container host policies in application manifest while
 * importing service manifest. Possible values include: 'None', 'Process',
 * 'HyperV'
 * @property {string} [status] Specifies the status of a deployed application
 * or service package on a Service Fabric node. Possible values include:
 * 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
 * 'Deactivating'
 * @property {string} [runFrequencyInterval] The interval at which code package
 * is run. This is used for periodic code package.
 * @property {object} [setupEntryPoint] Information about setup or main entry
 * point of a code package deployed on a Service Fabric node.
 * @property {string} [setupEntryPoint.entryPointLocation] The location of
 * entry point executable on the node.
 * @property {string} [setupEntryPoint.processId] The process ID of the entry
 * point.
 * @property {string} [setupEntryPoint.runAsUserName] The user name under which
 * entry point executable is run on the node.
 * @property {object} [setupEntryPoint.codePackageEntryPointStatistics]
 * Statistics about setup or main entry point  of a code package deployed on a
 * Service Fabric node.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.lastExitCode] The last exit
 * code of the entry point.
 * @property {date}
 * [setupEntryPoint.codePackageEntryPointStatistics.lastActivationTime] The
 * last time (in UTC) when Service Fabric attempted to run the entry point.
 * @property {date}
 * [setupEntryPoint.codePackageEntryPointStatistics.lastExitTime] The last time
 * (in UTC) when the entry point finished running.
 * @property {date}
 * [setupEntryPoint.codePackageEntryPointStatistics.lastSuccessfulActivationTime]
 * The last time (in UTC) when the entry point ran successfully.
 * @property {date}
 * [setupEntryPoint.codePackageEntryPointStatistics.lastSuccessfulExitTime] The
 * last time (in UTC) when the entry point finished running gracefully.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.activationCount] Number of
 * times the entry point has run.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.activationFailureCount]
 * Number of times the entry point failed to run.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.continuousActivationFailureCount]
 * Number of times the entry point continuously failed to run.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.exitCount] Number of times
 * the entry point finished running.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.exitFailureCount] Number of
 * times the entry point failed to exit gracefully.
 * @property {string}
 * [setupEntryPoint.codePackageEntryPointStatistics.continuousExitFailureCount]
 * Number of times the entry point continuously failed to exit gracefully.
 * @property {string} [setupEntryPoint.status] Specifies the status of the code
 * package entry point deployed on a Service Fabric node. Possible values
 * include: 'Invalid', 'Pending', 'Starting', 'Started', 'Stopping', 'Stopped'
 * @property {date} [setupEntryPoint.nextActivationTime] The time (in UTC) when
 * the entry point executable will be run next.
 * @property {string} [setupEntryPoint.instanceId] The instance ID for current
 * running entry point. For a code package setup entry point (if specified)
 * runs first and after it finishes main entry point is started. Each time
 * entry point executable is run, its instance id will change.
 * @property {object} [mainEntryPoint] Information about setup or main entry
 * point of a code package deployed on a Service Fabric node.
 * @property {string} [mainEntryPoint.entryPointLocation] The location of entry
 * point executable on the node.
 * @property {string} [mainEntryPoint.processId] The process ID of the entry
 * point.
 * @property {string} [mainEntryPoint.runAsUserName] The user name under which
 * entry point executable is run on the node.
 * @property {object} [mainEntryPoint.codePackageEntryPointStatistics]
 * Statistics about setup or main entry point  of a code package deployed on a
 * Service Fabric node.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.lastExitCode] The last exit
 * code of the entry point.
 * @property {date}
 * [mainEntryPoint.codePackageEntryPointStatistics.lastActivationTime] The last
 * time (in UTC) when Service Fabric attempted to run the entry point.
 * @property {date}
 * [mainEntryPoint.codePackageEntryPointStatistics.lastExitTime] The last time
 * (in UTC) when the entry point finished running.
 * @property {date}
 * [mainEntryPoint.codePackageEntryPointStatistics.lastSuccessfulActivationTime]
 * The last time (in UTC) when the entry point ran successfully.
 * @property {date}
 * [mainEntryPoint.codePackageEntryPointStatistics.lastSuccessfulExitTime] The
 * last time (in UTC) when the entry point finished running gracefully.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.activationCount] Number of
 * times the entry point has run.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.activationFailureCount]
 * Number of times the entry point failed to run.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.continuousActivationFailureCount]
 * Number of times the entry point continuously failed to run.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.exitCount] Number of times
 * the entry point finished running.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.exitFailureCount] Number of
 * times the entry point failed to exit gracefully.
 * @property {string}
 * [mainEntryPoint.codePackageEntryPointStatistics.continuousExitFailureCount]
 * Number of times the entry point continuously failed to exit gracefully.
 * @property {string} [mainEntryPoint.status] Specifies the status of the code
 * package entry point deployed on a Service Fabric node. Possible values
 * include: 'Invalid', 'Pending', 'Starting', 'Started', 'Stopping', 'Stopped'
 * @property {date} [mainEntryPoint.nextActivationTime] The time (in UTC) when
 * the entry point executable will be run next.
 * @property {string} [mainEntryPoint.instanceId] The instance ID for current
 * running entry point. For a code package setup entry point (if specified)
 * runs first and after it finishes main entry point is started. Each time
 * entry point executable is run, its instance id will change.
 */
export interface DeployedCodePackageInfo {
  name?: string;
  version?: string;
  serviceManifestName?: string;
  servicePackageActivationId?: string;
  hostType?: string;
  hostIsolationMode?: string;
  status?: string;
  runFrequencyInterval?: string;
  setupEntryPoint?: CodePackageEntryPoint;
  mainEntryPoint?: CodePackageEntryPoint;
}

/**
 * @class
 * Initializes a new instance of the ChaosContext class.
 * @constructor
 * Describes a map, which is a collection of (string, string) type key-value
 * pairs. The map can be used to record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 *
 * @property {object} [map] Describes a map that contains a collection of
 * ChaosContextMapItem's.
 */
export interface ChaosContext {
  map?: { [propertyName: string]: string };
}

/**
 * @class
 * Initializes a new instance of the ChaosTargetFilter class.
 * @constructor
 * Defines all filters for targeted Chaos faults, for example, faulting only
 * certain node types or faulting only certain applications.
 * If ChaosTargetFilter is not used, Chaos faults all cluster entities. If
 * ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter
 * specification. NodeTypeInclusionList and ApplicationInclusionList allow a
 * union semantics only. It is not possible to specify an intersection
 * of NodeTypeInclusionList and ApplicationInclusionList. For example, it is
 * not possible to specify "fault this application only when it is on that node
 * type."
 * Once an entity is included in either NodeTypeInclusionList or
 * ApplicationInclusionList, that entity cannot be excluded using
 * ChaosTargetFilter. Even if
 * applicationX does not appear in ApplicationInclusionList, in some Chaos
 * iteration applicationX can be faulted because it happens to be on a node of
 * nodeTypeY that is included
 * in NodeTypeInclusionList. If both NodeTypeInclusionList and
 * ApplicationInclusionList are null or empty, an ArgumentException is thrown.
 *
 * @property {array} [nodeTypeInclusionList] A list of node types to include in
 * Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 * @property {array} [applicationInclusionList] A list of application URI's to
 * include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 */
export interface ChaosTargetFilter {
  nodeTypeInclusionList?: string[];
  applicationInclusionList?: string[];
}

/**
 * @class
 * Initializes a new instance of the ChaosParameters class.
 * @constructor
 * Defines all the parameters to configure a Chaos run.
 *
 * @property {string} [timeToRunInSeconds] Total time (in seconds) for which
 * Chaos will run before automatically stopping. The maximum allowed value is
 * 4,294,967,295 (System.UInt32.MaxValue). Default value: '4294967295' .
 * @property {number} [maxClusterStabilizationTimeoutInSeconds] The maximum
 * amount of time to wait for all cluster entities to become stable and
 * healthy. Chaos executes in iterations and at the start of each iteration it
 * validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event. Default value: 60 .
 * @property {number} [maxConcurrentFaults] MaxConcurrentFaults is the maximum
 * number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults,
 * leading to inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up. Default value: 1 .
 * @property {boolean} [enableMoveReplicaFaults] Enables or disables the move
 * primary and move secondary faults. Default value: true .
 * @property {number} [waitTimeBetweenFaultsInSeconds] Wait time (in seconds)
 * between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up. Default value: 20 .
 * @property {number} [waitTimeBetweenIterationsInSeconds] Time-separation (in
 * seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate. Default value: 30
 * .
 * @property {object} [clusterHealthPolicy] Passed-in cluster health policy is
 * used to validate health of the cluster in between Chaos iterations. If the
 * cluster health is in error or if an unexpected exception happens during
 * fault execution--to provide the cluster with some time to recuperate--Chaos
 * will wait for 30 minutes before the next health-check.
 * @property {boolean} [clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number} [clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [context] Describes a map, which is a collection of
 * (string, string) type key-value pairs. The map can be used to record
 * information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 * @property {object} [context.map] Describes a map that contains a collection
 * of ChaosContextMapItem's.
 * @property {object} [chaosTargetFilter] List of cluster entities to target
 * for Chaos faults.
 * This filter can be used to target Chaos faults only to certain node types or
 * only to certain application instances. If ChaosTargetFilter is not used,
 * Chaos faults all cluster entities.
 * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter specification.
 * @property {array} [chaosTargetFilter.nodeTypeInclusionList] A list of node
 * types to include in Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 * @property {array} [chaosTargetFilter.applicationInclusionList] A list of
 * application URI's to include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 */
export interface ChaosParameters {
  timeToRunInSeconds?: string;
  maxClusterStabilizationTimeoutInSeconds?: number;
  maxConcurrentFaults?: number;
  enableMoveReplicaFaults?: boolean;
  waitTimeBetweenFaultsInSeconds?: number;
  waitTimeBetweenIterationsInSeconds?: number;
  clusterHealthPolicy?: ClusterHealthPolicy;
  context?: ChaosContext;
  chaosTargetFilter?: ChaosTargetFilter;
}

/**
 * @class
 * Initializes a new instance of the Chaos class.
 * @constructor
 * Contains a description of Chaos.
 *
 * @property {object} [chaosParameters] If Chaos is running, these are the
 * parameters Chaos is running with.
 * @property {string} [chaosParameters.timeToRunInSeconds] Total time (in
 * seconds) for which Chaos will run before automatically stopping. The maximum
 * allowed value is 4,294,967,295 (System.UInt32.MaxValue).
 * @property {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
 * The maximum amount of time to wait for all cluster entities to become stable
 * and healthy. Chaos executes in iterations and at the start of each iteration
 * it validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event.
 * @property {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults
 * is the maximum number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults,
 * leading to inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up.
 * @property {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
 * disables the move primary and move secondary faults.
 * @property {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait
 * time (in seconds) between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up.
 * @property {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
 * Time-separation (in seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate.
 * @property {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
 * health policy is used to validate health of the cluster in between Chaos
 * iterations. If the cluster health is in error or if an unexpected exception
 * happens during fault execution--to provide the cluster with some time to
 * recuperate--Chaos will wait for 30 minutes before the next health-check.
 * @property {boolean}
 * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
 * allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array}
 * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
 * a map with max percentage unhealthy applications for specific application
 * types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [chaosParameters.context] Describes a map, which is a
 * collection of (string, string) type key-value pairs. The map can be used to
 * record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 * @property {object} [chaosParameters.context.map] Describes a map that
 * contains a collection of ChaosContextMapItem's.
 * @property {object} [chaosParameters.chaosTargetFilter] List of cluster
 * entities to target for Chaos faults.
 * This filter can be used to target Chaos faults only to certain node types or
 * only to certain application instances. If ChaosTargetFilter is not used,
 * Chaos faults all cluster entities.
 * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter specification.
 * @property {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList]
 * A list of node types to include in Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 * @property {array}
 * [chaosParameters.chaosTargetFilter.applicationInclusionList] A list of
 * application URI's to include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 * @property {string} [status] Current status of the Chaos run. Possible values
 * include: 'Invalid', 'Running', 'Stopped'
 * @property {string} [scheduleStatus] Current status of the schedule. Possible
 * values include: 'Invalid', 'Stopped', 'Active', 'Expired', 'Pending'
 */
export interface Chaos {
  chaosParameters?: ChaosParameters;
  status?: string;
  scheduleStatus?: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosParametersDictionaryItem class.
 * @constructor
 * Defines an item in ChaosParametersDictionary of the Chaos Schedule.
 *
 * @property {string} key The key identifying the Chaos Parameter in the
 * dictionary. This key is referenced by Chaos Schedule Jobs.
 * @property {object} value Defines all the parameters to configure a Chaos
 * run.
 * @property {string} [value.timeToRunInSeconds] Total time (in seconds) for
 * which Chaos will run before automatically stopping. The maximum allowed
 * value is 4,294,967,295 (System.UInt32.MaxValue).
 * @property {number} [value.maxClusterStabilizationTimeoutInSeconds] The
 * maximum amount of time to wait for all cluster entities to become stable and
 * healthy. Chaos executes in iterations and at the start of each iteration it
 * validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event.
 * @property {number} [value.maxConcurrentFaults] MaxConcurrentFaults is the
 * maximum number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults,
 * leading to inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up.
 * @property {boolean} [value.enableMoveReplicaFaults] Enables or disables the
 * move primary and move secondary faults.
 * @property {number} [value.waitTimeBetweenFaultsInSeconds] Wait time (in
 * seconds) between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up.
 * @property {number} [value.waitTimeBetweenIterationsInSeconds]
 * Time-separation (in seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate.
 * @property {object} [value.clusterHealthPolicy] Passed-in cluster health
 * policy is used to validate health of the cluster in between Chaos
 * iterations. If the cluster health is in error or if an unexpected exception
 * happens during fault execution--to provide the cluster with some time to
 * recuperate--Chaos will wait for 30 minutes before the next health-check.
 * @property {boolean} [value.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number} [value.clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number}
 * [value.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
 * allowed percentage of unhealthy applications before reporting an error. For
 * example, to allow 10% of applications to be unhealthy, this value would be
 * 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array} [value.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [value.context] Describes a map, which is a collection of
 * (string, string) type key-value pairs. The map can be used to record
 * information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 * @property {object} [value.context.map] Describes a map that contains a
 * collection of ChaosContextMapItem's.
 * @property {object} [value.chaosTargetFilter] List of cluster entities to
 * target for Chaos faults.
 * This filter can be used to target Chaos faults only to certain node types or
 * only to certain application instances. If ChaosTargetFilter is not used,
 * Chaos faults all cluster entities.
 * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter specification.
 * @property {array} [value.chaosTargetFilter.nodeTypeInclusionList] A list of
 * node types to include in Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 * @property {array} [value.chaosTargetFilter.applicationInclusionList] A list
 * of application URI's to include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 */
export interface ChaosParametersDictionaryItem {
  key: string;
  value: ChaosParameters;
}

/**
 * @class
 * Initializes a new instance of the ChaosEvent class.
 * @constructor
 * Represents an event generated during a Chaos run.
 *
 * @property {date} timeStampUtc The UTC timestamp when this Chaos event was
 * generated.
 * @property {string} kind Polymorphic Discriminator
 */
export interface ChaosEvent {
  timeStampUtc: Date;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosEventWrapper class.
 * @constructor
 * Wrapper object for Chaos event.
 *
 * @property {object} [chaosEvent] Represents an event generated during a Chaos
 * run.
 * @property {date} [chaosEvent.timeStampUtc] The UTC timestamp when this Chaos
 * event was generated.
 * @property {string} [chaosEvent.kind] Polymorphic Discriminator
 */
export interface ChaosEventWrapper {
  chaosEvent?: ChaosEvent;
}

/**
 * @class
 * Initializes a new instance of the ChaosEventsSegment class.
 * @constructor
 * Contains the list of Chaos events and the continuation token to get the next
 * segment.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [history] List of Chaos events that meet the user-supplied
 * criteria.
 */
export interface ChaosEventsSegment {
  continuationToken?: string;
  history?: ChaosEventWrapper[];
}

/**
 * @class
 * Initializes a new instance of the ChaosScheduleJobActiveDaysOfWeek class.
 * @constructor
 * Defines the days of the week that a Chaos Schedule Job will run for.
 *
 * @property {boolean} [sunday] Indicates if the Chaos Schedule Job will run on
 * Sunday. Default value: false .
 * @property {boolean} [monday] Indicates if the Chaos Schedule Job will run on
 * Monday. Default value: false .
 * @property {boolean} [tuesday] Indicates if the Chaos Schedule Job will run
 * on Tuesday. Default value: false .
 * @property {boolean} [wednesday] Indicates if the Chaos Schedule Job will run
 * on Wednesday. Default value: false .
 * @property {boolean} [thursday] Indicates if the Chaos Schedule Job will run
 * on Thursday. Default value: false .
 * @property {boolean} [friday] Indicates if the Chaos Schedule Job will run on
 * Friday. Default value: false .
 * @property {boolean} [saturday] Indicates if the Chaos Schedule Job will run
 * on Saturday. Default value: false .
 */
export interface ChaosScheduleJobActiveDaysOfWeek {
  sunday?: boolean;
  monday?: boolean;
  tuesday?: boolean;
  wednesday?: boolean;
  thursday?: boolean;
  friday?: boolean;
  saturday?: boolean;
}

/**
 * @class
 * Initializes a new instance of the TimeOfDay class.
 * @constructor
 * Defines an hour and minute of the day specified in 24 hour time.
 *
 * @property {number} [hour] Represents the hour of the day. Value must be
 * between 0 and 23 inclusive.
 * @property {number} [minute] Represents the minute of the hour. Value must be
 * between 0 to 59 inclusive.
 */
export interface TimeOfDay {
  hour?: number;
  minute?: number;
}

/**
 * @class
 * Initializes a new instance of the TimeRange class.
 * @constructor
 * Defines a time range in a 24 hour day specified by a start and end time.
 *
 * @property {object} [startTime] Defines an hour and minute of the day
 * specified in 24 hour time.
 * @property {number} [startTime.hour] Represents the hour of the day. Value
 * must be between 0 and 23 inclusive.
 * @property {number} [startTime.minute] Represents the minute of the hour.
 * Value must be between 0 to 59 inclusive.
 * @property {object} [endTime] Defines an hour and minute of the day specified
 * in 24 hour time.
 * @property {number} [endTime.hour] Represents the hour of the day. Value must
 * be between 0 and 23 inclusive.
 * @property {number} [endTime.minute] Represents the minute of the hour. Value
 * must be between 0 to 59 inclusive.
 */
export interface TimeRange {
  startTime?: TimeOfDay;
  endTime?: TimeOfDay;
}

/**
 * @class
 * Initializes a new instance of the ChaosScheduleJob class.
 * @constructor
 * Defines a repetition rule and parameters of Chaos to be used with the Chaos
 * Schedule.
 *
 * @property {string} [chaosParameters] A reference to which Chaos Parameters
 * of the Chaos Schedule to use.
 * @property {object} [days] Defines the days of the week that a Chaos Schedule
 * Job will run for.
 * @property {boolean} [days.sunday] Indicates if the Chaos Schedule Job will
 * run on Sunday
 * @property {boolean} [days.monday] Indicates if the Chaos Schedule Job will
 * run on Monday
 * @property {boolean} [days.tuesday] Indicates if the Chaos Schedule Job will
 * run on Tuesday
 * @property {boolean} [days.wednesday] Indicates if the Chaos Schedule Job
 * will run on Wednesday
 * @property {boolean} [days.thursday] Indicates if the Chaos Schedule Job will
 * run on Thursday
 * @property {boolean} [days.friday] Indicates if the Chaos Schedule Job will
 * run on Friday
 * @property {boolean} [days.saturday] Indicates if the Chaos Schedule Job will
 * run on Saturday
 * @property {array} [times] A list of Time Ranges that specify when during
 * active days that this job will run. The times are interpreted as UTC.
 */
export interface ChaosScheduleJob {
  chaosParameters?: string;
  days?: ChaosScheduleJobActiveDaysOfWeek;
  times?: TimeRange[];
}

/**
 * @class
 * Initializes a new instance of the ChaosSchedule class.
 * @constructor
 * Defines the schedule used by Chaos.
 *
 * @property {date} [startDate] The date and time Chaos will start using this
 * schedule. Default value: new Date('1601-01-01T00:00:00Z') .
 * @property {date} [expiryDate] The date and time Chaos will continue to use
 * this schedule until. Default value: new Date('9999-12-31T23:59:59.999Z') .
 * @property {array} [chaosParametersDictionary] A mapping of string names to
 * Chaos Parameters to be referenced by Chaos Schedule Jobs.
 * @property {array} [jobs] A list of all Chaos Schedule Jobs that will be
 * automated by the schedule.
 */
export interface ChaosSchedule {
  startDate?: Date;
  expiryDate?: Date;
  chaosParametersDictionary?: ChaosParametersDictionaryItem[];
  jobs?: ChaosScheduleJob[];
}

/**
 * @class
 * Initializes a new instance of the ChaosScheduleDescription class.
 * @constructor
 * Defines the Chaos Schedule used by Chaos and the version of the Chaos
 * Schedule. The version value wraps back to 0 after surpassing 2,147,483,647.
 *
 * @property {number} [version] The version number of the Schedule.
 * @property {object} [schedule] Defines the schedule used by Chaos.
 * @property {date} [schedule.startDate] The date and time Chaos will start
 * using this schedule.
 * @property {date} [schedule.expiryDate] The date and time Chaos will continue
 * to use this schedule until.
 * @property {array} [schedule.chaosParametersDictionary] A mapping of string
 * names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
 * @property {array} [schedule.jobs] A list of all Chaos Schedule Jobs that
 * will be automated by the schedule.
 */
export interface ChaosScheduleDescription {
  version?: number;
  schedule?: ChaosSchedule;
}

/**
 * @class
 * Initializes a new instance of the ExecutingFaultsChaosEvent class.
 * @constructor
 * Describes a Chaos event that gets generated when Chaos has decided on the
 * faults for an iteration. This Chaos event contains the details of the faults
 * as a list of strings.
 *
 * @property {array} [faults] List of string description of the faults that
 * Chaos decided to execute in an iteration.
 */
export interface ExecutingFaultsChaosEvent extends ChaosEvent {
  faults?: string[];
}

/**
 * @class
 * Initializes a new instance of the StartedChaosEvent class.
 * @constructor
 * Describes a Chaos event that gets generated when Chaos is started.
 *
 * @property {object} [chaosParameters] Defines all the parameters to configure
 * a Chaos run.
 * @property {string} [chaosParameters.timeToRunInSeconds] Total time (in
 * seconds) for which Chaos will run before automatically stopping. The maximum
 * allowed value is 4,294,967,295 (System.UInt32.MaxValue).
 * @property {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
 * The maximum amount of time to wait for all cluster entities to become stable
 * and healthy. Chaos executes in iterations and at the start of each iteration
 * it validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event.
 * @property {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults
 * is the maximum number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults,
 * leading to inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up.
 * @property {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
 * disables the move primary and move secondary faults.
 * @property {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait
 * time (in seconds) between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up.
 * @property {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
 * Time-separation (in seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate.
 * @property {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
 * health policy is used to validate health of the cluster in between Chaos
 * iterations. If the cluster health is in error or if an unexpected exception
 * happens during fault execution--to provide the cluster with some time to
 * recuperate--Chaos will wait for 30 minutes before the next health-check.
 * @property {boolean}
 * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @property {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
 * allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @property {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @property {array}
 * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
 * a map with max percentage unhealthy applications for specific application
 * types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 * @property {object} [chaosParameters.context] Describes a map, which is a
 * collection of (string, string) type key-value pairs. The map can be used to
 * record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 * @property {object} [chaosParameters.context.map] Describes a map that
 * contains a collection of ChaosContextMapItem's.
 * @property {object} [chaosParameters.chaosTargetFilter] List of cluster
 * entities to target for Chaos faults.
 * This filter can be used to target Chaos faults only to certain node types or
 * only to certain application instances. If ChaosTargetFilter is not used,
 * Chaos faults all cluster entities.
 * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter specification.
 * @property {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList]
 * A list of node types to include in Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 * @property {array}
 * [chaosParameters.chaosTargetFilter.applicationInclusionList] A list of
 * application URI's to include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 */
export interface StartedChaosEvent extends ChaosEvent {
  chaosParameters?: ChaosParameters;
}

/**
 * @class
 * Initializes a new instance of the StoppedChaosEvent class.
 * @constructor
 * Describes a Chaos event that gets generated when Chaos stops because either
 * the user issued a stop or the time to run was up.
 *
 * @property {string} [reason] Describes why Chaos stopped. Chaos can stop
 * because of StopChaos API call or the timeToRun provided in ChaosParameters
 * is over.
 */
export interface StoppedChaosEvent extends ChaosEvent {
  reason?: string;
}

/**
 * @class
 * Initializes a new instance of the TestErrorChaosEvent class.
 * @constructor
 * Describes a Chaos event that gets generated when an unexpected event occurs
 * in the Chaos engine.
 * For example, due to the cluster snapshot being inconsistent, while faulting
 * an entity, Chaos found that the entity was already faulted -- which would be
 * an unexpected event.
 *
 * @property {string} [reason] Describes why TestErrorChaosEvent was generated.
 * For example, Chaos tries to fault a partition but finds that the partition
 * is no longer fault tolerant, then a TestErrorEvent gets generated with the
 * reason stating that the partition is not fault tolerant.
 */
export interface TestErrorChaosEvent extends ChaosEvent {
  reason?: string;
}

/**
 * @class
 * Initializes a new instance of the ValidationFailedChaosEvent class.
 * @constructor
 * Chaos event corresponding to a failure during validation.
 *
 * @property {string} [reason] Describes why the ValidationFailedChaosEvent was
 * generated. This may happen because more than MaxPercentUnhealthyNodes are
 * unhealthy for more than MaxClusterStabilizationTimeout. This reason will be
 * in the Reason property of the ValidationFailedChaosEvent as a string.
 */
export interface ValidationFailedChaosEvent extends ChaosEvent {
  reason?: string;
}

/**
 * @class
 * Initializes a new instance of the WaitingChaosEvent class.
 * @constructor
 * Describes a Chaos event that gets generated when Chaos is waiting for the
 * cluster to become ready for faulting, for example, Chaos may be waiting for
 * the on-going upgrade to finish.
 *
 * @property {string} [reason] Describes why the WaitingChaosEvent was
 * generated, for example, due to a cluster upgrade.
 */
export interface WaitingChaosEvent extends ChaosEvent {
  reason?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationCapacityDescription class.
 * @constructor
 * Describes capacity information for services of this application. This
 * description can be used for describing the following.
 * - Reserving the capacity for the services on the nodes
 * - Limiting the total number of nodes that services of this application can
 * run on
 * - Limiting the custom capacity metrics to limit the total consumption of
 * this metric by the services of this application
 *
 * @property {number} [minimumNodes] The minimum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. If this property is set to zero, no capacity will be reserved. The
 * value of this property cannot be more than the value of the MaximumNodes
 * property.
 * @property {number} [maximumNodes] The maximum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. By default, the value of this property is zero and it means that the
 * services can be placed on any node. Default value: 0 .
 * @property {array} [applicationMetrics] List of application capacity metric
 * description.
 */
export interface ApplicationCapacityDescription {
  minimumNodes?: number;
  maximumNodes?: number;
  applicationMetrics?: ApplicationMetricDescription[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationDescription class.
 * @constructor
 * Describes a Service Fabric application.
 *
 * @property {string} name The name of the application, including the 'fabric:'
 * URI scheme.
 * @property {string} typeName The application type name as defined in the
 * application manifest.
 * @property {string} typeVersion The version of the application type as
 * defined in the application manifest.
 * @property {array} [parameterList] List of application parameters with
 * overridden values from their default values specified in the application
 * manifest.
 * @property {object} [applicationCapacity] Describes capacity information for
 * services of this application. This description can be used for describing
 * the following.
 * - Reserving the capacity for the services on the nodes
 * - Limiting the total number of nodes that services of this application can
 * run on
 * - Limiting the custom capacity metrics to limit the total consumption of
 * this metric by the services of this application
 * @property {number} [applicationCapacity.minimumNodes] The minimum number of
 * nodes where Service Fabric will reserve capacity for this application. Note
 * that this does not mean that the services of this application will be placed
 * on all of those nodes. If this property is set to zero, no capacity will be
 * reserved. The value of this property cannot be more than the value of the
 * MaximumNodes property.
 * @property {number} [applicationCapacity.maximumNodes] The maximum number of
 * nodes where Service Fabric will reserve capacity for this application. Note
 * that this does not mean that the services of this application will be placed
 * on all of those nodes. By default, the value of this property is zero and it
 * means that the services can be placed on any node.
 * @property {array} [applicationCapacity.applicationMetrics] List of
 * application capacity metric description.
 */
export interface ApplicationDescription {
  name: string;
  typeName: string;
  typeVersion: string;
  parameterList?: ApplicationParameter[];
  applicationCapacity?: ApplicationCapacityDescription;
}

/**
 * @class
 * Initializes a new instance of the ComposeDeploymentStatusInfo class.
 * @constructor
 * Information about a Service Fabric compose deployment.
 *
 * @property {string} [name] The name of the deployment.
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} [status] The status of the compose deployment. Possible
 * values include: 'Invalid', 'Provisioning', 'Creating', 'Ready',
 * 'Unprovisioning', 'Deleting', 'Failed', 'Upgrading'
 * @property {string} [statusDetails] The status details of compose deployment
 * including failure message.
 */
export interface ComposeDeploymentStatusInfo {
  name?: string;
  applicationName?: string;
  status?: string;
  statusDetails?: string;
}

/**
 * @class
 * Initializes a new instance of the RegistryCredential class.
 * @constructor
 * Credential information to connect to container registry.
 *
 * @property {string} [registryUserName] The user name to connect to container
 * registry.
 * @property {string} [registryPassword] The password for supplied username to
 * connect to container registry.
 * @property {boolean} [passwordEncrypted] Indicates that supplied container
 * registry password is encrypted.
 */
export interface RegistryCredential {
  registryUserName?: string;
  registryPassword?: string;
  passwordEncrypted?: boolean;
}

/**
 * @class
 * Initializes a new instance of the ComposeDeploymentUpgradeDescription class.
 * @constructor
 * Describes the parameters for a compose deployment upgrade.
 *
 * @property {string} deploymentName The name of the deployment.
 * @property {string} composeFileContent The content of the compose file that
 * describes the deployment to create.
 * @property {object} [registryCredential] Credential information to connect to
 * container registry.
 * @property {string} [registryCredential.registryUserName] The user name to
 * connect to container registry.
 * @property {string} [registryCredential.registryPassword] The password for
 * supplied username to connect to container registry.
 * @property {boolean} [registryCredential.passwordEncrypted] Indicates that
 * supplied container registry password is encrypted.
 * @property {string} upgradeKind The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {object} [monitoringPolicy] Describes the parameters for
 * monitoring an upgrade in Monitored mode.
 * @property {string} [monitoringPolicy.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [monitoringPolicy.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [applicationHealthPolicy] Defines a health policy used to
 * evaluate the health of an application or one of its children entities.
 * @property {boolean} [applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number}
 * [applicationHealthPolicy.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [applicationHealthPolicy.serviceTypeHealthPolicyMap] The
 * map with service type health policy per service type name. The map is empty
 * by default.
 */
export interface ComposeDeploymentUpgradeDescription {
  deploymentName: string;
  composeFileContent: string;
  registryCredential?: RegistryCredential;
  upgradeKind: string;
  rollingUpgradeMode?: string;
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  forceRestart?: boolean;
  monitoringPolicy?: MonitoringPolicyDescription;
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ComposeDeploymentUpgradeProgressInfo class.
 * @constructor
 * Describes the parameters for a compose deployment upgrade.
 *
 * @property {string} [deploymentName] The name of the target deployment.
 * @property {string} [applicationName] The name of the target application,
 * including the 'fabric:' URI scheme.
 * @property {string} [upgradeState] The state of the compose deployment
 * upgrade. Possible values include: 'Invalid', 'ProvisioningTarget',
 * 'RollingForwardInProgress', 'RollingForwardPending',
 * 'UnprovisioningCurrent', 'RollingForwardCompleted', 'RollingBackInProgress',
 * 'UnprovisioningTarget', 'RollingBackCompleted', 'Failed'
 * @property {string} [upgradeStatusDetails] Additional detailed information
 * about the status of the pending upgrade.
 * @property {string} [upgradeKind] The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {string} [rollingUpgradeMode] The mode used to monitor health
 * during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual,
 * and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
 * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto' .
 * @property {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @property {number} [upgradeReplicaSetCheckTimeoutInSeconds] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @property {object} [monitoringPolicy] Describes the parameters for
 * monitoring an upgrade in Monitored mode.
 * @property {string} [monitoringPolicy.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [monitoringPolicy.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [monitoringPolicy.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [monitoringPolicy.upgradeDomainTimeoutInMilliseconds] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {object} [applicationHealthPolicy] Defines a health policy used to
 * evaluate the health of an application or one of its children entities.
 * @property {boolean} [applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number}
 * [applicationHealthPolicy.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [applicationHealthPolicy.serviceTypeHealthPolicyMap] The
 * map with service type health policy per service type name. The map is empty
 * by default.
 * @property {string} [targetApplicationTypeVersion] The target application
 * type version (found in the application manifest) for the application
 * upgrade.
 * @property {string} [upgradeDuration] The estimated amount of time that the
 * overall upgrade elapsed. It is first interpreted as a string representing an
 * ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string} [currentUpgradeDomainDuration] The estimated amount of
 * time spent processing current Upgrade Domain. It is first interpreted as a
 * string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @property {array} [applicationUnhealthyEvaluations] List of health
 * evaluations that resulted in the current aggregated health state.
 * @property {object} [currentUpgradeDomainProgress] Information about the
 * current in-progress upgrade domain.
 * @property {string} [currentUpgradeDomainProgress.domainName] The name of the
 * upgrade domain
 * @property {array} [currentUpgradeDomainProgress.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 * @property {string} [startTimestampUtc] The estimated UTC datetime when the
 * upgrade started.
 * @property {string} [failureTimestampUtc] The estimated UTC datetime when the
 * upgrade failed and FailureAction was executed.
 * @property {string} [failureReason] The cause of an upgrade failure that
 * resulted in FailureAction being executed. Possible values include: 'None',
 * 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
 * 'OverallUpgradeTimeout'
 * @property {object} [upgradeDomainProgressAtFailure] Information about the
 * upgrade domain progress at the time of upgrade failure.
 * @property {string} [upgradeDomainProgressAtFailure.domainName] The name of
 * the upgrade domain
 * @property {array} [upgradeDomainProgressAtFailure.nodeUpgradeProgressList]
 * List of upgrading nodes and their statuses
 * @property {string} [applicationUpgradeStatusDetails] Additional details of
 * application upgrade including failure message.
 */
export interface ComposeDeploymentUpgradeProgressInfo {
  deploymentName?: string;
  applicationName?: string;
  upgradeState?: string;
  upgradeStatusDetails?: string;
  upgradeKind?: string;
  rollingUpgradeMode?: string;
  forceRestart?: boolean;
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  monitoringPolicy?: MonitoringPolicyDescription;
  applicationHealthPolicy?: ApplicationHealthPolicy;
  targetApplicationTypeVersion?: string;
  upgradeDuration?: string;
  currentUpgradeDomainDuration?: string;
  applicationUnhealthyEvaluations?: HealthEvaluationWrapper[];
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  startTimestampUtc?: string;
  failureTimestampUtc?: string;
  failureReason?: string;
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  applicationUpgradeStatusDetails?: string;
}

/**
 * @class
 * Initializes a new instance of the PagedComposeDeploymentStatusInfoList class.
 * @constructor
 * The list of compose deployments in the cluster. The list is paged when all
 * of the results cannot fit in a single message. The next set of results can
 * be obtained by executing the same query with the continuation token provided
 * in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of compose deployment status information.
 */
export interface PagedComposeDeploymentStatusInfoList {
  continuationToken?: string;
  items?: ComposeDeploymentStatusInfo[];
}

/**
 * @class
 * Initializes a new instance of the CreateComposeDeploymentDescription class.
 * @constructor
 * Defines description for creating a Service Fabric compose deployment.
 *
 * @property {string} deploymentName The name of the deployment.
 * @property {string} composeFileContent The content of the compose file that
 * describes the deployment to create.
 * @property {object} [registryCredential] Credential information to connect to
 * container registry.
 * @property {string} [registryCredential.registryUserName] The user name to
 * connect to container registry.
 * @property {string} [registryCredential.registryPassword] The password for
 * supplied username to connect to container registry.
 * @property {boolean} [registryCredential.passwordEncrypted] Indicates that
 * supplied container registry password is encrypted.
 */
export interface CreateComposeDeploymentDescription {
  deploymentName: string;
  composeFileContent: string;
  registryCredential?: RegistryCredential;
}

/**
 * @class
 * Initializes a new instance of the DeployedServicePackageInfo class.
 * @constructor
 * Information about service package deployed on a Service Fabric node.
 *
 * @property {string} [name] The name of the service package as specified in
 * the service manifest.
 * @property {string} [version] The version of the service package specified in
 * service manifest.
 * @property {string} [status] Specifies the status of a deployed application
 * or service package on a Service Fabric node. Possible values include:
 * 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
 * 'Deactivating'
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 */
export interface DeployedServicePackageInfo {
  name?: string;
  version?: string;
  status?: string;
  servicePackageActivationId?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceCorrelationDescription class.
 * @constructor
 * Creates a particular correlation between services.
 *
 * @property {string} scheme The ServiceCorrelationScheme which describes the
 * relationship between this service and the service specified via ServiceName.
 * Possible values include: 'Invalid', 'Affinity', 'AlignedAffinity',
 * 'NonAlignedAffinity'
 * @property {string} serviceName The name of the service that the correlation
 * relationship is established with.
 */
export interface ServiceCorrelationDescription {
  scheme: string;
  serviceName: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionSchemeDescription class.
 * @constructor
 * Describes how the service is partitioned.
 *
 * @property {string} partitionScheme Polymorphic Discriminator
 */
export interface PartitionSchemeDescription {
  partitionScheme: string;
}

/**
 * @class
 * Initializes a new instance of the NamedPartitionSchemeDescription class.
 * @constructor
 * Describes the named partition scheme of the service.
 *
 * @property {number} count The number of partitions.
 * @property {array} names Array of size specified by the Count parameter,
 * for the names of the partitions.
 */
export interface NamedPartitionSchemeDescription extends PartitionSchemeDescription {
  count: number;
  names: string[];
}

/**
 * @class
 * Initializes a new instance of the SingletonPartitionSchemeDescription class.
 * @constructor
 * Describes the partition scheme of a singleton-partitioned, or
 * non-partitioned service.
 *
 */
export interface SingletonPartitionSchemeDescription extends PartitionSchemeDescription {
}

/**
 * @class
 * Initializes a new instance of the UniformInt64RangePartitionSchemeDescription class.
 * @constructor
 * Describes a partitioning scheme where an integer range is allocated evenly
 * across a number of partitions.
 *
 * @property {number} count The number of partitions.
 * @property {string} lowKey String indicating the lower bound of the partition
 * key range that
 * should be split between the partitions.
 * @property {string} highKey String indicating the upper bound of the
 * partition key range that
 * should be split between the partitions.
 */
export interface UniformInt64RangePartitionSchemeDescription extends PartitionSchemeDescription {
  count: number;
  lowKey: string;
  highKey: string;
}

/**
 * @class
 * Initializes a new instance of the ScalingTriggerDescription class.
 * @constructor
 * Describes the trigger for performing a scaling operation.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface ScalingTriggerDescription {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ScalingMechanismDescription class.
 * @constructor
 * Describes the mechanism for performing a scaling operation.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface ScalingMechanismDescription {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ScalingPolicyDescription class.
 * @constructor
 * Describes how the scaling should be performed
 *
 * @property {object} scalingTrigger Specifies the trigger associated with this
 * scaling policy
 * @property {string} [scalingTrigger.kind] Polymorphic Discriminator
 * @property {object} scalingMechanism Specifies the mechanism associated with
 * this scaling policy
 * @property {string} [scalingMechanism.kind] Polymorphic Discriminator
 */
export interface ScalingPolicyDescription {
  scalingTrigger: ScalingTriggerDescription;
  scalingMechanism: ScalingMechanismDescription;
}

/**
 * @class
 * Initializes a new instance of the ServiceDescription class.
 * @constructor
 * A ServiceDescription contains all of the information necessary to create a
 * service.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 * @property {string} serviceName The full name of the service with 'fabric:'
 * URI scheme.
 * @property {string} serviceTypeName Name of the service type as specified in
 * the service manifest.
 * @property {array} [initializationData] The initialization data as an array
 * of bytes. Initialization data is passed to service instances or replicas
 * when they are created.
 * @property {object} partitionDescription The partition description as an
 * object.
 * @property {string} [partitionDescription.partitionScheme] Polymorphic
 * Discriminator
 * @property {string} [placementConstraints] The placement constraints as a
 * string. Placement constraints are boolean expressions on node properties and
 * allow for restricting a service to particular nodes based on the service
 * requirements. For example, to place a service on nodes where NodeType is
 * blue specify the following: "NodeColor == blue)".
 * @property {array} [correlationScheme] The correlation scheme.
 * @property {array} [serviceLoadMetrics] The service load metrics.
 * @property {array} [servicePlacementPolicies] The service placement policies.
 * @property {string} [defaultMoveCost] The move cost for the service. Possible
 * values include: 'Zero', 'Low', 'Medium', 'High'
 * @property {boolean} [isDefaultMoveCostSpecified] Indicates if the
 * DefaultMoveCost property is specified.
 * @property {string} [servicePackageActivationMode] The activation mode of
 * service package to be used for a service. Possible values include:
 * 'SharedProcess', 'ExclusiveProcess'
 * @property {string} [serviceDnsName] The DNS name of the service. It requires
 * the DNS system service to be enabled in Service Fabric cluster.
 * @property {array} [scalingPolicies] Scaling policies for this service.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceDescription {
  applicationName?: string;
  serviceName: string;
  serviceTypeName: string;
  initializationData?: number[];
  partitionDescription: PartitionSchemeDescription;
  placementConstraints?: string;
  correlationScheme?: ServiceCorrelationDescription[];
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  defaultMoveCost?: string;
  isDefaultMoveCostSpecified?: boolean;
  servicePackageActivationMode?: string;
  serviceDnsName?: string;
  scalingPolicies?: ScalingPolicyDescription[];
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceDescription class.
 * @constructor
 * Describes a stateful service.
 *
 * @property {number} targetReplicaSetSize The target replica set size as a
 * number.
 * @property {number} minReplicaSetSize The minimum replica set size as a
 * number.
 * @property {boolean} hasPersistedState A flag indicating whether this is a
 * persistent service which stores states on the local disk. If it is then the
 * value of this property is true, if not it is false.
 * @property {number} [flags] Flags indicating whether other properties are
 * set. Each of the associated properties corresponds to a flag, specified
 * below, which, if set, indicate that the property is specified.
 * This property can be a combination of those flags obtained using bitwise
 * 'OR' operator.
 * For example, if the provided value is 6 then the flags for
 * QuorumLossWaitDuration (2) and StandByReplicaKeepDuration(4) are set.
 *
 * - None - Does not indicate any other properties are set. The value is zero.
 * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
 * property is set. The value is 1.
 * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
 * set. The value is 2.
 * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
 * property is set. The value is 4.
 * @property {number} [replicaRestartWaitDurationSeconds] The duration, in
 * seconds, between when a replica goes down and when a new replica is created.
 * @property {number} [quorumLossWaitDurationSeconds] The maximum duration, in
 * seconds, for which a partition is allowed to be in a state of quorum loss.
 * @property {number} [standByReplicaKeepDurationSeconds] The definition on how
 * long StandBy replicas should be maintained before being removed.
 */
export interface StatefulServiceDescription extends ServiceDescription {
  targetReplicaSetSize: number;
  minReplicaSetSize: number;
  hasPersistedState: boolean;
  flags?: number;
  replicaRestartWaitDurationSeconds?: number;
  quorumLossWaitDurationSeconds?: number;
  standByReplicaKeepDurationSeconds?: number;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceDescription class.
 * @constructor
 * Describes a stateless service.
 *
 * @property {number} instanceCount The instance count.
 */
export interface StatelessServiceDescription extends ServiceDescription {
  instanceCount: number;
}

/**
 * @class
 * Initializes a new instance of the ReplicatorQueueStatus class.
 * @constructor
 * Provides various statistics of the queue used in the service fabric
 * replicator.
 * Contains information about the service fabric replicator like the
 * replication/copy queue utilization, last acknowledgement received timestamp,
 * etc.
 * Depending on the role of the replicator, the properties in this type imply
 * different meanings.
 *
 * @property {number} [queueUtilizationPercentage] Represents the utilization
 * of the queue. A value of 0 indicates that the queue is empty and a value of
 * 100 indicates the queue is full.
 * @property {string} [queueMemorySize] Represents the virtual memory consumed
 * by the queue in bytes.
 * @property {string} [firstSequenceNumber] On a primary replicator, this is
 * semantically the sequence number of the operation for which all the
 * secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is the smallest sequence number of the
 * operation that is present in the queue.
 * @property {string} [completedSequenceNumber] On a primary replicator, this
 * is semantically the highest sequence number of the operation for which all
 * the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * that has been applied to the persistent state.
 * @property {string} [committedSequenceNumber] On a primary replicator, this
 * is semantically the highest sequence number of the operation for which a
 * write quorum of the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * of the in-order operation received from the primary.
 * @property {string} [lastSequenceNumber] Represents the latest sequence
 * number of the operation that is available in the queue.
 */
export interface ReplicatorQueueStatus {
  queueUtilizationPercentage?: number;
  queueMemorySize?: string;
  firstSequenceNumber?: string;
  completedSequenceNumber?: string;
  committedSequenceNumber?: string;
  lastSequenceNumber?: string;
}

/**
 * @class
 * Initializes a new instance of the ReplicatorStatus class.
 * @constructor
 * Represents a base class for primary or secondary replicator status.
 * Contains information about the service fabric replicator like the
 * replication/copy queue utilization, last acknowledgement received timestamp,
 * etc.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface ReplicatorStatus {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the RemoteReplicatorAcknowledgementDetail class.
 * @constructor
 * Provides various statistics of the acknowledgements that are being received
 * from the remote replicator.
 *
 * @property {string} [averageReceiveDuration] Represents the average duration
 * it takes for the remote replicator to receive an operation.
 * @property {string} [averageApplyDuration] Represents the average duration it
 * takes for the remote replicator to apply an operation. This usually entails
 * writing the operation to disk.
 * @property {string} [notReceivedCount] Represents the number of operations
 * not yet received by a remote replicator.
 * @property {string} [receivedAndNotAppliedCount] Represents the number of
 * operations received and not yet applied by a remote replicator.
 */
export interface RemoteReplicatorAcknowledgementDetail {
  averageReceiveDuration?: string;
  averageApplyDuration?: string;
  notReceivedCount?: string;
  receivedAndNotAppliedCount?: string;
}

/**
 * @class
 * Initializes a new instance of the RemoteReplicatorAcknowledgementStatus class.
 * @constructor
 * Provides details about the remote replicators from the primary replicator's
 * point of view.
 *
 * @property {object} [replicationStreamAcknowledgementDetail] Details about
 * the acknowledgements for operations that are part of the replication stream
 * data.
 * @property {string}
 * [replicationStreamAcknowledgementDetail.averageReceiveDuration] Represents
 * the average duration it takes for the remote replicator to receive an
 * operation.
 * @property {string}
 * [replicationStreamAcknowledgementDetail.averageApplyDuration] Represents the
 * average duration it takes for the remote replicator to apply an operation.
 * This usually entails writing the operation to disk.
 * @property {string} [replicationStreamAcknowledgementDetail.notReceivedCount]
 * Represents the number of operations not yet received by a remote replicator.
 * @property {string}
 * [replicationStreamAcknowledgementDetail.receivedAndNotAppliedCount]
 * Represents the number of operations received and not yet applied by a remote
 * replicator.
 * @property {object} [copyStreamAcknowledgementDetail] Details about the
 * acknowledgements for operations that are part of the copy stream data.
 * @property {string} [copyStreamAcknowledgementDetail.averageReceiveDuration]
 * Represents the average duration it takes for the remote replicator to
 * receive an operation.
 * @property {string} [copyStreamAcknowledgementDetail.averageApplyDuration]
 * Represents the average duration it takes for the remote replicator to apply
 * an operation. This usually entails writing the operation to disk.
 * @property {string} [copyStreamAcknowledgementDetail.notReceivedCount]
 * Represents the number of operations not yet received by a remote replicator.
 * @property {string}
 * [copyStreamAcknowledgementDetail.receivedAndNotAppliedCount] Represents the
 * number of operations received and not yet applied by a remote replicator.
 */
export interface RemoteReplicatorAcknowledgementStatus {
  replicationStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
  copyStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
}

/**
 * @class
 * Initializes a new instance of the RemoteReplicatorStatus class.
 * @constructor
 * Represents the state of the secondary replicator from the primary
 * replicators point of view.
 *
 * @property {string} [replicaId] Represents the replica ID of the remote
 * secondary replicator.
 * @property {date} [lastAcknowledgementProcessedTimeUtc] The last timestamp
 * (in UTC) when an acknowledgement from the secondary replicator was processed
 * on the primary.
 * UTC 0 represents an invalid value, indicating that no acknowledgement
 * messages were ever processed.
 * @property {string} [lastReceivedReplicationSequenceNumber] The highest
 * replication operation sequence number that the secondary has received from
 * the primary.
 * @property {string} [lastAppliedReplicationSequenceNumber] The highest
 * replication operation sequence number that the secondary has applied to its
 * state.
 * @property {boolean} [isInBuild] A value that indicates whether the secondary
 * replica is in the process of being built.
 * @property {string} [lastReceivedCopySequenceNumber] The highest copy
 * operation sequence number that the secondary has received from the primary.
 * A value of -1 implies that the secondary has received all copy operations.
 * @property {string} [lastAppliedCopySequenceNumber] The highest copy
 * operation sequence number that the secondary has applied to its state.
 * A value of -1 implies that the secondary has applied all copy operations and
 * the copy process is complete.
 * @property {object} [remoteReplicatorAcknowledgementStatus] Represents the
 * acknowledgment status for the remote secondary replicator.
 * @property {object}
 * [remoteReplicatorAcknowledgementStatus.replicationStreamAcknowledgementDetail]
 * Details about the acknowledgements for operations that are part of the
 * replication stream data.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.replicationStreamAcknowledgementDetail.averageReceiveDuration]
 * Represents the average duration it takes for the remote replicator to
 * receive an operation.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.replicationStreamAcknowledgementDetail.averageApplyDuration]
 * Represents the average duration it takes for the remote replicator to apply
 * an operation. This usually entails writing the operation to disk.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.replicationStreamAcknowledgementDetail.notReceivedCount]
 * Represents the number of operations not yet received by a remote replicator.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.replicationStreamAcknowledgementDetail.receivedAndNotAppliedCount]
 * Represents the number of operations received and not yet applied by a remote
 * replicator.
 * @property {object}
 * [remoteReplicatorAcknowledgementStatus.copyStreamAcknowledgementDetail]
 * Details about the acknowledgements for operations that are part of the copy
 * stream data.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.copyStreamAcknowledgementDetail.averageReceiveDuration]
 * Represents the average duration it takes for the remote replicator to
 * receive an operation.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.copyStreamAcknowledgementDetail.averageApplyDuration]
 * Represents the average duration it takes for the remote replicator to apply
 * an operation. This usually entails writing the operation to disk.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.copyStreamAcknowledgementDetail.notReceivedCount]
 * Represents the number of operations not yet received by a remote replicator.
 * @property {string}
 * [remoteReplicatorAcknowledgementStatus.copyStreamAcknowledgementDetail.receivedAndNotAppliedCount]
 * Represents the number of operations received and not yet applied by a remote
 * replicator.
 */
export interface RemoteReplicatorStatus {
  replicaId?: string;
  lastAcknowledgementProcessedTimeUtc?: Date;
  lastReceivedReplicationSequenceNumber?: string;
  lastAppliedReplicationSequenceNumber?: string;
  isInBuild?: boolean;
  lastReceivedCopySequenceNumber?: string;
  lastAppliedCopySequenceNumber?: string;
  remoteReplicatorAcknowledgementStatus?: RemoteReplicatorAcknowledgementStatus;
}

/**
 * @class
 * Initializes a new instance of the PrimaryReplicatorStatus class.
 * @constructor
 * Provides statistics about the Service Fabric Replicator, when it is
 * functioning in a Primary role.
 *
 * @property {object} [replicationQueueStatus] Details about the replication
 * queue on the primary replicator.
 * @property {number} [replicationQueueStatus.queueUtilizationPercentage]
 * Represents the utilization of the queue. A value of 0 indicates that the
 * queue is empty and a value of 100 indicates the queue is full.
 * @property {string} [replicationQueueStatus.queueMemorySize] Represents the
 * virtual memory consumed by the queue in bytes.
 * @property {string} [replicationQueueStatus.firstSequenceNumber] On a primary
 * replicator, this is semantically the sequence number of the operation for
 * which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is the smallest sequence number of the
 * operation that is present in the queue.
 * @property {string} [replicationQueueStatus.completedSequenceNumber] On a
 * primary replicator, this is semantically the highest sequence number of the
 * operation for which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * that has been applied to the persistent state.
 * @property {string} [replicationQueueStatus.committedSequenceNumber] On a
 * primary replicator, this is semantically the highest sequence number of the
 * operation for which a write quorum of the secondary replicas have sent an
 * acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * of the in-order operation received from the primary.
 * @property {string} [replicationQueueStatus.lastSequenceNumber] Represents
 * the latest sequence number of the operation that is available in the queue.
 * @property {array} [remoteReplicators] The status of all the active and idle
 * secondary replicators that the primary is aware of.
 */
export interface PrimaryReplicatorStatus extends ReplicatorStatus {
  replicationQueueStatus?: ReplicatorQueueStatus;
  remoteReplicators?: RemoteReplicatorStatus[];
}

/**
 * @class
 * Initializes a new instance of the SecondaryReplicatorStatus class.
 * @constructor
 * Provides statistics about the Service Fabric Replicator, when it is
 * functioning in a ActiveSecondary role.
 *
 * @property {object} [replicationQueueStatus] Details about the replication
 * queue on the secondary replicator.
 * @property {number} [replicationQueueStatus.queueUtilizationPercentage]
 * Represents the utilization of the queue. A value of 0 indicates that the
 * queue is empty and a value of 100 indicates the queue is full.
 * @property {string} [replicationQueueStatus.queueMemorySize] Represents the
 * virtual memory consumed by the queue in bytes.
 * @property {string} [replicationQueueStatus.firstSequenceNumber] On a primary
 * replicator, this is semantically the sequence number of the operation for
 * which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is the smallest sequence number of the
 * operation that is present in the queue.
 * @property {string} [replicationQueueStatus.completedSequenceNumber] On a
 * primary replicator, this is semantically the highest sequence number of the
 * operation for which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * that has been applied to the persistent state.
 * @property {string} [replicationQueueStatus.committedSequenceNumber] On a
 * primary replicator, this is semantically the highest sequence number of the
 * operation for which a write quorum of the secondary replicas have sent an
 * acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * of the in-order operation received from the primary.
 * @property {string} [replicationQueueStatus.lastSequenceNumber] Represents
 * the latest sequence number of the operation that is available in the queue.
 * @property {date} [lastReplicationOperationReceivedTimeUtc] The last
 * time-stamp (UTC) at which a replication operation was received from the
 * primary.
 * UTC 0 represents an invalid value, indicating that a replication operation
 * message was never received.
 * @property {boolean} [isInBuild] Value that indicates whether the replica is
 * currently being built.
 * @property {object} [copyQueueStatus] Details about the copy queue on the
 * secondary replicator.
 * @property {number} [copyQueueStatus.queueUtilizationPercentage] Represents
 * the utilization of the queue. A value of 0 indicates that the queue is empty
 * and a value of 100 indicates the queue is full.
 * @property {string} [copyQueueStatus.queueMemorySize] Represents the virtual
 * memory consumed by the queue in bytes.
 * @property {string} [copyQueueStatus.firstSequenceNumber] On a primary
 * replicator, this is semantically the sequence number of the operation for
 * which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is the smallest sequence number of the
 * operation that is present in the queue.
 * @property {string} [copyQueueStatus.completedSequenceNumber] On a primary
 * replicator, this is semantically the highest sequence number of the
 * operation for which all the secondary replicas have sent an acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * that has been applied to the persistent state.
 * @property {string} [copyQueueStatus.committedSequenceNumber] On a primary
 * replicator, this is semantically the highest sequence number of the
 * operation for which a write quorum of the secondary replicas have sent an
 * acknowledgement.
 * On a secondary replicator, this is semantically the highest sequence number
 * of the in-order operation received from the primary.
 * @property {string} [copyQueueStatus.lastSequenceNumber] Represents the
 * latest sequence number of the operation that is available in the queue.
 * @property {date} [lastCopyOperationReceivedTimeUtc] The last time-stamp
 * (UTC) at which a copy operation was received from the primary.
 * UTC 0 represents an invalid value, indicating that a copy operation message
 * was never received.
 * @property {date} [lastAcknowledgementSentTimeUtc] The last time-stamp (UTC)
 * at which an acknowledgment was sent to the primary replicator.
 * UTC 0 represents an invalid value, indicating that an acknowledgment message
 * was never sent.
 */
export interface SecondaryReplicatorStatus extends ReplicatorStatus {
  replicationQueueStatus?: ReplicatorQueueStatus;
  lastReplicationOperationReceivedTimeUtc?: Date;
  isInBuild?: boolean;
  copyQueueStatus?: ReplicatorQueueStatus;
  lastCopyOperationReceivedTimeUtc?: Date;
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * @class
 * Initializes a new instance of the SecondaryActiveReplicatorStatus class.
 * @constructor
 * Status of the secondary replicator when it is in active mode and is part of
 * the replica set.
 *
 */
export interface SecondaryActiveReplicatorStatus extends SecondaryReplicatorStatus {
}

/**
 * @class
 * Initializes a new instance of the SecondaryIdleReplicatorStatus class.
 * @constructor
 * Status of the secondary replicator when it is in idle mode and is being
 * built by the primary.
 *
 */
export interface SecondaryIdleReplicatorStatus extends SecondaryReplicatorStatus {
}

/**
 * @class
 * Initializes a new instance of the LoadMetricReportInfo class.
 * @constructor
 * Information about load reported by replica.
 *
 * @property {string} [name] The name of the metric.
 * @property {number} [value] The value of the load for the metric..
 * @property {date} [lastReportedUtc] The UTC time when the load is reported.
 */
export interface LoadMetricReportInfo {
  name?: string;
  value?: number;
  lastReportedUtc?: Date;
}

/**
 * @class
 * Initializes a new instance of the DeployedServiceReplicaDetailInfo class.
 * @constructor
 * Information about a Service Fabric service replica deployed on a node.
 *
 * @property {string} [serviceName] Full hierarchical name of the service in
 * URI format starting with `fabric:`.
 * @property {uuid} [partitionId] An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 * @property {string} [currentServiceOperation] Specifies the current active
 * life-cycle operation on a stateful service replica or stateless service
 * instance. Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole',
 * 'Close', 'Abort'
 * @property {date} [currentServiceOperationStartTimeUtc] The start time of the
 * current service operation in UTC format.
 * @property {array} [reportedLoad] List of load reported by replica.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface DeployedServiceReplicaDetailInfo {
  serviceName?: string;
  partitionId?: string;
  currentServiceOperation?: string;
  currentServiceOperationStartTimeUtc?: Date;
  reportedLoad?: LoadMetricReportInfo[];
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ReplicaStatusBase class.
 * @constructor
 * Information about the replica.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface ReplicaStatusBase {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the KeyValueStoreReplicaStatus class.
 * @constructor
 * Key value store related information for the replica.
 *
 * @property {string} [databaseRowCountEstimate] Value indicating the estimated
 * number of rows in the underlying database.
 * @property {string} [databaseLogicalSizeEstimate] Value indicating the
 * estimated size of the underlying database.
 * @property {string} [copyNotificationCurrentKeyFilter] Value indicating the
 * latest key-prefix filter applied to enumeration during the callback. Null if
 * there is no pending callback.
 * @property {string} [copyNotificationCurrentProgress] Value indicating the
 * latest number of keys enumerated during the callback. 0 if there is no
 * pending callback.
 * @property {string} [statusDetails] Value indicating the current status
 * details of the replica.
 */
export interface KeyValueStoreReplicaStatus extends ReplicaStatusBase {
  databaseRowCountEstimate?: string;
  databaseLogicalSizeEstimate?: string;
  copyNotificationCurrentKeyFilter?: string;
  copyNotificationCurrentProgress?: string;
  statusDetails?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedStatefulServiceReplicaDetailInfo class.
 * @constructor
 * Information about a stateful replica running in a code package. Note
 * DeployedServiceReplicaQueryResult will contain duplicate data like
 * ServiceKind, ServiceName, PartitionId and replicaId.
 *
 * @property {string} [replicaId] Id of a stateful service replica. ReplicaId
 * is used by Service Fabric to uniquely identify a replica of a partition. It
 * is unique within a partition and does not change for the lifetime of the
 * replica. If a replica gets dropped and another replica gets created on the
 * same node for the same partition, it will get a different value for the id.
 * Sometimes the id of a stateless service instance is also referred as a
 * replica id.
 * @property {string} [currentReplicatorOperation] Specifies the operation
 * currently being executed by the Replicator. Possible values include:
 * 'Invalid', 'None', 'Open', 'ChangeRole', 'UpdateEpoch', 'Close', 'Abort',
 * 'OnDataLoss', 'WaitForCatchup', 'Build'
 * @property {string} [readStatus] Specifies the access status of the
 * partition. Possible values include: 'Invalid', 'Granted',
 * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
 * @property {string} [writeStatus] Specifies the access status of the
 * partition. Possible values include: 'Invalid', 'Granted',
 * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
 * @property {object} [replicatorStatus] Represents a base class for primary or
 * secondary replicator status.
 * Contains information about the service fabric replicator like the
 * replication/copy queue utilization, last acknowledgement received timestamp,
 * etc.
 * @property {string} [replicatorStatus.kind] Polymorphic Discriminator
 * @property {object} [replicaStatus] Key value store related information for
 * the replica.
 * @property {string} [replicaStatus.databaseRowCountEstimate] Value indicating
 * the estimated number of rows in the underlying database.
 * @property {string} [replicaStatus.databaseLogicalSizeEstimate] Value
 * indicating the estimated size of the underlying database.
 * @property {string} [replicaStatus.copyNotificationCurrentKeyFilter] Value
 * indicating the latest key-prefix filter applied to enumeration during the
 * callback. Null if there is no pending callback.
 * @property {string} [replicaStatus.copyNotificationCurrentProgress] Value
 * indicating the latest number of keys enumerated during the callback. 0 if
 * there is no pending callback.
 * @property {string} [replicaStatus.statusDetails] Value indicating the
 * current status details of the replica.
 * @property {object} [deployedServiceReplicaQueryResult] Information about a
 * stateful service replica deployed on a node.
 * @property {string} [deployedServiceReplicaQueryResult.replicaId] Id of a
 * stateful service replica. ReplicaId is used by Service Fabric to uniquely
 * identify a replica of a partition. It is unique within a partition and does
 * not change for the lifetime of the replica. If a replica gets dropped and
 * another replica gets created on the same node for the same partition, it
 * will get a different value for the id. Sometimes the id of a stateless
 * service instance is also referred as a replica id.
 * @property {string} [deployedServiceReplicaQueryResult.replicaRole] The role
 * of a replica of a stateful service. Possible values include: 'Unknown',
 * 'None', 'Primary', 'IdleSecondary', 'ActiveSecondary'
 * @property {object}
 * [deployedServiceReplicaQueryResult.reconfigurationInformation] Information
 * about current reconfiguration like phase, type, previous configuration role
 * of replica and reconfiguration start date time.
 * @property {string}
 * [deployedServiceReplicaQueryResult.reconfigurationInformation.previousConfigurationRole]
 * Replica role before reconfiguration started. Possible values include:
 * 'Unknown', 'None', 'Primary', 'IdleSecondary', 'ActiveSecondary'
 * @property {string}
 * [deployedServiceReplicaQueryResult.reconfigurationInformation.reconfigurationPhase]
 * Current phase of ongoing reconfiguration. If no reconfiguration is taking
 * place then this value will be "None". Possible values include: 'Unknown',
 * 'None', 'Phase0', 'Phase1', 'Phase2', 'Phase3', 'Phase4', 'AbortPhaseZero'
 * @property {string}
 * [deployedServiceReplicaQueryResult.reconfigurationInformation.reconfigurationType]
 * Type of current ongoing reconfiguration. If no reconfiguration is taking
 * place then this value will be "None". Possible values include: 'Unknown',
 * 'SwapPrimary', 'Failover', 'Other'
 * @property {date}
 * [deployedServiceReplicaQueryResult.reconfigurationInformation.reconfigurationStartTimeUtc]
 * Start time (in UTC) of the ongoing reconfiguration. If no reconfiguration is
 * taking place then this value will be zero date-time.
 */
export interface DeployedStatefulServiceReplicaDetailInfo extends DeployedServiceReplicaDetailInfo {
  replicaId?: string;
  currentReplicatorOperation?: string;
  readStatus?: string;
  writeStatus?: string;
  replicatorStatus?: ReplicatorStatus;
  replicaStatus?: KeyValueStoreReplicaStatus;
  deployedServiceReplicaQueryResult?: DeployedStatefulServiceReplicaInfo;
}

/**
 * @class
 * Initializes a new instance of the DeployedStatelessServiceInstanceDetailInfo class.
 * @constructor
 * Information about a stateless instance running in a code package. Note that
 * DeployedServiceReplicaQueryResult will contain duplicate data like
 * ServiceKind, ServiceName, PartitionId and InstanceId.
 *
 * @property {string} [instanceId] Id of a stateless service instance.
 * InstanceId is used by Service Fabric to uniquely identify an instance of a
 * partition of a stateless service. It is unique within a partition and does
 * not change for the lifetime of the instance. If the instance has failed over
 * on the same or different node, it will get a different value for the
 * InstanceId.
 * @property {object} [deployedServiceReplicaQueryResult] Information about a
 * stateless service instance deployed on a node.
 * @property {string} [deployedServiceReplicaQueryResult.instanceId] Id of a
 * stateless service instance. InstanceId is used by Service Fabric to uniquely
 * identify an instance of a partition of a stateless service. It is unique
 * within a partition and does not change for the lifetime of the instance. If
 * the instance has failed over on the same or different node, it will get a
 * different value for the InstanceId.
 */
export interface DeployedStatelessServiceInstanceDetailInfo extends DeployedServiceReplicaDetailInfo {
  instanceId?: string;
  deployedServiceReplicaQueryResult?: DeployedStatelessServiceInstanceInfo;
}

/**
 * @class
 * Initializes a new instance of the ServiceUpdateDescription class.
 * @constructor
 * A ServiceUpdateDescription contains all of the information necessary to
 * update a service.
 *
 * @property {string} [flags] Flags indicating whether other properties are
 * set. Each of the associated properties corresponds to a flag, specified
 * below, which, if set, indicate that the property is specified.
 * This property can be a combination of those flags obtained using bitwise
 * 'OR' operator.
 * For example, if the provided value is 6 then the flags for
 * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
 *
 * - None - Does not indicate any other properties are set. The value is zero.
 * - TargetReplicaSetSize/InstanceCount - Indicates whether the
 * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
 * property (for Stateless services) is set. The value is 1.
 * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
 * property is set. The value is  2.
 * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
 * set. The value is 4.
 * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
 * property is set. The value is 8.
 * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
 * value is 16.
 * - PlacementConstraints - Indicates the PlacementConstraints property is set.
 * The value is 32.
 * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
 * set. The value is 64.
 * - Correlation - Indicates the CorrelationScheme property is set. The value
 * is 128.
 * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
 * 256.
 * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
 * is 512.
 * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
 * is 1024.
 * @property {string} [placementConstraints] The placement constraints as a
 * string. Placement constraints are boolean expressions on node properties and
 * allow for restricting a service to particular nodes based on the service
 * requirements. For example, to place a service on nodes where NodeType is
 * blue specify the following: "NodeColor == blue)".
 * @property {array} [correlationScheme] The correlation scheme.
 * @property {array} [loadMetrics] The service load metrics.
 * @property {array} [servicePlacementPolicies] The service placement policies.
 * @property {string} [defaultMoveCost] The move cost for the service. Possible
 * values include: 'Zero', 'Low', 'Medium', 'High'
 * @property {array} [scalingPolicies] Scaling policies for this service.
 * @property {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceUpdateDescription {
  flags?: string;
  placementConstraints?: string;
  correlationScheme?: ServiceCorrelationDescription[];
  loadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  defaultMoveCost?: string;
  scalingPolicies?: ScalingPolicyDescription[];
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceUpdateDescription class.
 * @constructor
 * Describes an update for a stateful service.
 *
 * @property {number} [targetReplicaSetSize] The target replica set size as a
 * number.
 * @property {number} [minReplicaSetSize] The minimum replica set size as a
 * number.
 * @property {string} [replicaRestartWaitDurationSeconds] The duration, in
 * seconds, between when a replica goes down and when a new replica is created.
 * @property {string} [quorumLossWaitDurationSeconds] The maximum duration, in
 * seconds, for which a partition is allowed to be in a state of quorum loss.
 * @property {string} [standByReplicaKeepDurationSeconds] The definition on how
 * long StandBy replicas should be maintained before being removed.
 */
export interface StatefulServiceUpdateDescription extends ServiceUpdateDescription {
  targetReplicaSetSize?: number;
  minReplicaSetSize?: number;
  replicaRestartWaitDurationSeconds?: string;
  quorumLossWaitDurationSeconds?: string;
  standByReplicaKeepDurationSeconds?: string;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceUpdateDescription class.
 * @constructor
 * Describes an update for a stateless service.
 *
 * @property {number} [instanceCount] The instance count.
 */
export interface StatelessServiceUpdateDescription extends ServiceUpdateDescription {
  instanceCount?: number;
}

/**
 * @class
 * Initializes a new instance of the FileVersion class.
 * @constructor
 * Information about the version of image store file.
 *
 * @property {string} [versionNumber] The current image store version number
 * for the file is used in image store for checking whether it need to be
 * updated.
 * @property {string} [epochDataLossNumber] The epoch data loss number of image
 * store replica when this file entry was updated or created.
 * @property {string} [epochConfigurationNumber] The epoch configuration
 * version number of the image store replica when this file entry was created
 * or updated.
 */
export interface FileVersion {
  versionNumber?: string;
  epochDataLossNumber?: string;
  epochConfigurationNumber?: string;
}

/**
 * @class
 * Initializes a new instance of the FileInfo class.
 * @constructor
 * Information about a image store file.
 *
 * @property {string} [fileSize] The size of file in bytes.
 * @property {object} [fileVersion] Information about the version of image
 * store file.
 * @property {string} [fileVersion.versionNumber] The current image store
 * version number for the file is used in image store for checking whether it
 * need to be updated.
 * @property {string} [fileVersion.epochDataLossNumber] The epoch data loss
 * number of image store replica when this file entry was updated or created.
 * @property {string} [fileVersion.epochConfigurationNumber] The epoch
 * configuration version number of the image store replica when this file entry
 * was created or updated.
 * @property {date} [modifiedDate] The date and time when the image store file
 * was last modified.
 * @property {string} [storeRelativePath] The file path relative to the image
 * store root path.
 */
export interface FileInfo {
  fileSize?: string;
  fileVersion?: FileVersion;
  modifiedDate?: Date;
  storeRelativePath?: string;
}

/**
 * @class
 * Initializes a new instance of the FolderInfo class.
 * @constructor
 * Information about a image store folder. It includes how many files this
 * folder contains and its image store relative path.
 *
 * @property {string} [storeRelativePath] The remote location within image
 * store. This path is relative to the image store root.
 * @property {string} [fileCount] The number of files from within the image
 * store folder.
 */
export interface FolderInfo {
  storeRelativePath?: string;
  fileCount?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageStoreContent class.
 * @constructor
 * Information about the image store content.
 *
 * @property {array} [storeFiles] The list of image store file info objects
 * represents files found under the given image store relative path.
 * @property {array} [storeFolders] The list of image store folder info objects
 * represents subfolders found under the given image store relative path.
 */
export interface ImageStoreContent {
  storeFiles?: FileInfo[];
  storeFolders?: FolderInfo[];
}

/**
 * @class
 * Initializes a new instance of the ImageStoreCopyDescription class.
 * @constructor
 * Information about how to copy image store content from one image store
 * relative path to another image store relative path.
 *
 * @property {string} remoteSource The relative path of source image store
 * content to be copied from.
 * @property {string} remoteDestination The relative path of destination image
 * store content to be copied to.
 * @property {array} [skipFiles] The list of the file names to be skipped for
 * copying.
 * @property {boolean} [checkMarkFile] Indicates whether to check mark file
 * during copying. The property is true if checking mark file is required,
 * false otherwise. The mark file is used to check whether the folder is well
 * constructed. If the property is true and mark file does not exist, the copy
 * is skipped.
 */
export interface ImageStoreCopyDescription {
  remoteSource: string;
  remoteDestination: string;
  skipFiles?: string[];
  checkMarkFile?: boolean;
}

/**
 * @class
 * Initializes a new instance of the RestartDeployedCodePackageDescription class.
 * @constructor
 * Defines description for restarting a deployed code package on Service Fabric
 * node.
 *
 * @property {string} serviceManifestName The name of service manifest that
 * specified this code package.
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 * @property {string} codePackageName The name of the code package defined in
 * the service manifest.
 * @property {string} codePackageInstanceId The instance ID for currently
 * running entry point. For a code package setup entry point (if specified)
 * runs first and after it finishes main entry point is started.
 * Each time entry point executable is run, its instance ID will change. If 0
 * is passed in as the code package instance ID, the API will restart the code
 * package with whatever instance ID it is currently running.
 * If an instance ID other than 0 is passed in, the API will restart the code
 * package only if the current Instance ID matches the passed in instance ID.
 * Note, passing in the exact instance ID (not 0) in the API is safer, because
 * if ensures at most one restart of the code package.
 */
export interface RestartDeployedCodePackageDescription {
  serviceManifestName: string;
  servicePackageActivationId?: string;
  codePackageName: string;
  codePackageInstanceId: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedServiceTypeInfo class.
 * @constructor
 * Information about service type deployed on a node, information such as the
 * status of the service type registration on a node.
 *
 * @property {string} [serviceTypeName] Name of the service type as specified
 * in the service manifest.
 * @property {string} [serviceManifestName] The name of the service manifest in
 * which this service type is defined.
 * @property {string} [codePackageName] The name of the code package that
 * registered the service type.
 * @property {string} [status] The status of the service type registration on
 * the node. Possible values include: 'Invalid', 'Disabled', 'Enabled',
 * 'Registered'
 * @property {string} [servicePackageActivationId] The ActivationId of a
 * deployed service package. If ServicePackageActivationMode specified at the
 * time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 */
export interface DeployedServiceTypeInfo {
  serviceTypeName?: string;
  serviceManifestName?: string;
  codePackageName?: string;
  status?: string;
  servicePackageActivationId?: string;
}

/**
 * @class
 * Initializes a new instance of the ResolvedServiceEndpoint class.
 * @constructor
 * Endpoint of a resolved service partition.
 *
 * @property {string} [kind] The role of the replica where the endpoint is
 * reported. Possible values include: 'Invalid', 'Stateless',
 * 'StatefulPrimary', 'StatefulSecondary'
 * @property {string} [address] The address of the endpoint. If the endpoint
 * has multiple listeners the address is a JSON object with one property per
 * listener with the value as the address of that listener.
 */
export interface ResolvedServiceEndpoint {
  kind?: string;
  address?: string;
}

/**
 * @class
 * Initializes a new instance of the ResolvedServicePartition class.
 * @constructor
 * Information about a service partition and its associated endpoints.
 *
 * @property {string} name The full name of the service with 'fabric:' URI
 * scheme.
 * @property {object} partitionInformation A representation of the resolved
 * partition.
 * @property {uuid} [partitionInformation.id] An internal ID used by Service
 * Fabric to uniquely identify a partition. This is a randomly generated GUID
 * when the service was created. The partition ID is unique and does not change
 * for the lifetime of the service. If the same service was deleted and
 * recreated the IDs of its partitions would be different.
 * @property {string} [partitionInformation.servicePartitionKind] Polymorphic
 * Discriminator
 * @property {array} endpoints List of resolved service endpoints of a service
 * partition.
 * @property {string} version The version of this resolved service partition
 * result. This version should be passed in the next time the ResolveService
 * call is made via the PreviousRspVersion query parameter.
 */
export interface ResolvedServicePartition {
  name: string;
  partitionInformation: PartitionInformation;
  endpoints: ResolvedServiceEndpoint[];
  version: string;
}

/**
 * @class
 * Initializes a new instance of the SelectedPartition class.
 * @constructor
 * This class returns information about the partition that the user-induced
 * operation acted upon.
 *
 * @property {string} [serviceName] The name of the service the partition
 * belongs to.
 * @property {uuid} [partitionId] An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 */
export interface SelectedPartition {
  serviceName?: string;
  partitionId?: string;
}

/**
 * @class
 * Initializes a new instance of the InvokeDataLossResult class.
 * @constructor
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 * @property {number} [errorCode] If OperationState is Completed, this is 0.
 * If OperationState is Faulted, this is an error code indicating the reason.
 * @property {object} [selectedPartition] This class returns information about
 * the partition that the user-induced operation acted upon.
 * @property {string} [selectedPartition.serviceName] The name of the service
 * the partition belongs to.
 * @property {uuid} [selectedPartition.partitionId] An internal ID used by
 * Service Fabric to uniquely identify a partition. This is a randomly
 * generated GUID when the service was created. The partition ID is unique and
 * does not change for the lifetime of the service. If the same service was
 * deleted and recreated the IDs of its partitions would be different.
 */
export interface InvokeDataLossResult {
  errorCode?: number;
  selectedPartition?: SelectedPartition;
}

/**
 * @class
 * Initializes a new instance of the InvokeQuorumLossResult class.
 * @constructor
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 * @property {number} [errorCode] If OperationState is Completed, this is 0.
 * If OperationState is Faulted, this is an error code indicating the reason.
 * @property {object} [selectedPartition] This class returns information about
 * the partition that the user-induced operation acted upon.
 * @property {string} [selectedPartition.serviceName] The name of the service
 * the partition belongs to.
 * @property {uuid} [selectedPartition.partitionId] An internal ID used by
 * Service Fabric to uniquely identify a partition. This is a randomly
 * generated GUID when the service was created. The partition ID is unique and
 * does not change for the lifetime of the service. If the same service was
 * deleted and recreated the IDs of its partitions would be different.
 */
export interface InvokeQuorumLossResult {
  errorCode?: number;
  selectedPartition?: SelectedPartition;
}

/**
 * @class
 * Initializes a new instance of the NodeResult class.
 * @constructor
 * Contains information about a node that was targeted by a user-induced
 * operation.
 *
 * @property {string} [nodeName] The name of a Service Fabric node.
 * @property {string} [nodeInstanceId] The node instance id.
 */
export interface NodeResult {
  nodeName?: string;
  nodeInstanceId?: string;
}

/**
 * @class
 * Initializes a new instance of the NodeTransitionResult class.
 * @constructor
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 * @property {number} [errorCode] If OperationState is Completed, this is 0.
 * If OperationState is Faulted, this is an error code indicating the reason.
 * @property {object} [nodeResult] Contains information about a node that was
 * targeted by a user-induced operation.
 * @property {string} [nodeResult.nodeName] The name of a Service Fabric node.
 * @property {string} [nodeResult.nodeInstanceId] The node instance id.
 */
export interface NodeTransitionResult {
  errorCode?: number;
  nodeResult?: NodeResult;
}

/**
 * @class
 * Initializes a new instance of the NodeTransitionProgress class.
 * @constructor
 * Information about an NodeTransition operation.  This class contains an
 * OperationState and a NodeTransitionResult.  The NodeTransitionResult is not
 * valid until OperationState
 * is Completed or Faulted.
 *
 * @property {string} [state] The state of the operation. Possible values
 * include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @property {object} [nodeTransitionResult] Represents information about an
 * operation in a terminal state (Completed or Faulted).
 * @property {number} [nodeTransitionResult.errorCode] If OperationState is
 * Completed, this is 0.  If OperationState is Faulted, this is an error code
 * indicating the reason.
 * @property {object} [nodeTransitionResult.nodeResult] Contains information
 * about a node that was targeted by a user-induced operation.
 * @property {string} [nodeTransitionResult.nodeResult.nodeName] The name of a
 * Service Fabric node.
 * @property {string} [nodeTransitionResult.nodeResult.nodeInstanceId] The node
 * instance id.
 */
export interface NodeTransitionProgress {
  state?: string;
  nodeTransitionResult?: NodeTransitionResult;
}

/**
 * @class
 * Initializes a new instance of the OperationStatus class.
 * @constructor
 * Contains the OperationId, OperationState, and OperationType for user-induced
 * operations.
 *
 * @property {uuid} [operationId] A GUID that identifies a call to this API.
 * This is also passed into the corresponding GetProgress API.
 * @property {string} [state] The state of the operation. Possible values
 * include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @property {string} [type] The type of the operation. Possible values
 * include: 'Invalid', 'PartitionDataLoss', 'PartitionQuorumLoss',
 * 'PartitionRestart', 'NodeTransition'
 */
export interface OperationStatus {
  operationId?: string;
  state?: string;
  type?: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionDataLossProgress class.
 * @constructor
 * Information about a partition data loss user-induced operation.
 *
 * @property {string} [state] The state of the operation. Possible values
 * include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @property {object} [invokeDataLossResult] Represents information about an
 * operation in a terminal state (Completed or Faulted).
 * @property {number} [invokeDataLossResult.errorCode] If OperationState is
 * Completed, this is 0.  If OperationState is Faulted, this is an error code
 * indicating the reason.
 * @property {object} [invokeDataLossResult.selectedPartition] This class
 * returns information about the partition that the user-induced operation
 * acted upon.
 * @property {string} [invokeDataLossResult.selectedPartition.serviceName] The
 * name of the service the partition belongs to.
 * @property {uuid} [invokeDataLossResult.selectedPartition.partitionId] An
 * internal ID used by Service Fabric to uniquely identify a partition. This is
 * a randomly generated GUID when the service was created. The partition ID is
 * unique and does not change for the lifetime of the service. If the same
 * service was deleted and recreated the IDs of its partitions would be
 * different.
 */
export interface PartitionDataLossProgress {
  state?: string;
  invokeDataLossResult?: InvokeDataLossResult;
}

/**
 * @class
 * Initializes a new instance of the PartitionQuorumLossProgress class.
 * @constructor
 * Information about a partition quorum loss user-induced operation.
 *
 * @property {string} [state] The state of the operation. Possible values
 * include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @property {object} [invokeQuorumLossResult] Represents information about an
 * operation in a terminal state (Completed or Faulted).
 * @property {number} [invokeQuorumLossResult.errorCode] If OperationState is
 * Completed, this is 0.  If OperationState is Faulted, this is an error code
 * indicating the reason.
 * @property {object} [invokeQuorumLossResult.selectedPartition] This class
 * returns information about the partition that the user-induced operation
 * acted upon.
 * @property {string} [invokeQuorumLossResult.selectedPartition.serviceName]
 * The name of the service the partition belongs to.
 * @property {uuid} [invokeQuorumLossResult.selectedPartition.partitionId] An
 * internal ID used by Service Fabric to uniquely identify a partition. This is
 * a randomly generated GUID when the service was created. The partition ID is
 * unique and does not change for the lifetime of the service. If the same
 * service was deleted and recreated the IDs of its partitions would be
 * different.
 */
export interface PartitionQuorumLossProgress {
  state?: string;
  invokeQuorumLossResult?: InvokeQuorumLossResult;
}

/**
 * @class
 * Initializes a new instance of the RestartPartitionResult class.
 * @constructor
 * Represents information about an operation in a terminal state (Completed or
 * Faulted).
 *
 * @property {number} [errorCode] If OperationState is Completed, this is 0.
 * If OperationState is Faulted, this is an error code indicating the reason.
 * @property {object} [selectedPartition] This class returns information about
 * the partition that the user-induced operation acted upon.
 * @property {string} [selectedPartition.serviceName] The name of the service
 * the partition belongs to.
 * @property {uuid} [selectedPartition.partitionId] An internal ID used by
 * Service Fabric to uniquely identify a partition. This is a randomly
 * generated GUID when the service was created. The partition ID is unique and
 * does not change for the lifetime of the service. If the same service was
 * deleted and recreated the IDs of its partitions would be different.
 */
export interface RestartPartitionResult {
  errorCode?: number;
  selectedPartition?: SelectedPartition;
}

/**
 * @class
 * Initializes a new instance of the PartitionRestartProgress class.
 * @constructor
 * Information about a partition restart user-induced operation.
 *
 * @property {string} [state] The state of the operation. Possible values
 * include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @property {object} [restartPartitionResult] Represents information about an
 * operation in a terminal state (Completed or Faulted).
 * @property {number} [restartPartitionResult.errorCode] If OperationState is
 * Completed, this is 0.  If OperationState is Faulted, this is an error code
 * indicating the reason.
 * @property {object} [restartPartitionResult.selectedPartition] This class
 * returns information about the partition that the user-induced operation
 * acted upon.
 * @property {string} [restartPartitionResult.selectedPartition.serviceName]
 * The name of the service the partition belongs to.
 * @property {uuid} [restartPartitionResult.selectedPartition.partitionId] An
 * internal ID used by Service Fabric to uniquely identify a partition. This is
 * a randomly generated GUID when the service was created. The partition ID is
 * unique and does not change for the lifetime of the service. If the same
 * service was deleted and recreated the IDs of its partitions would be
 * different.
 */
export interface PartitionRestartProgress {
  state?: string;
  restartPartitionResult?: RestartPartitionResult;
}

/**
 * @class
 * Initializes a new instance of the PackageSharingPolicyInfo class.
 * @constructor
 * Represents a policy for the package sharing.
 *
 * @property {string} [sharedPackageName] The name of code, configuration or
 * data package that should be shared.
 * @property {string} [packageSharingScope] Represents the scope for
 * PackageSharingPolicy. This is specified during DeployServicePackageToNode
 * operation. Possible values include: 'None', 'All', 'Code', 'Config', 'Data'
 */
export interface PackageSharingPolicyInfo {
  sharedPackageName?: string;
  packageSharingScope?: string;
}

/**
 * @class
 * Initializes a new instance of the DeployServicePackageToNodeDescription class.
 * @constructor
 * Defines description for downloading packages associated with a service
 * manifest to image cache on a Service Fabric node.
 *
 * @property {string} serviceManifestName The name of service manifest whose
 * packages need to be downloaded.
 * @property {string} applicationTypeName The application type name as defined
 * in the application manifest.
 * @property {string} applicationTypeVersion The version of the application
 * type as defined in the application manifest.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {array} [packageSharingPolicy] List of package sharing policy
 * information.
 */
export interface DeployServicePackageToNodeDescription {
  serviceManifestName: string;
  applicationTypeName: string;
  applicationTypeVersion: string;
  nodeName: string;
  packageSharingPolicy?: PackageSharingPolicyInfo[];
}

/**
 * @class
 * Initializes a new instance of the ResumeApplicationUpgradeDescription class.
 * @constructor
 * Describes the parameters for resuming an unmonitored manual Service Fabric
 * application upgrade
 *
 * @property {string} upgradeDomainName The name of the upgrade domain in which
 * to resume the upgrade.
 */
export interface ResumeApplicationUpgradeDescription {
  upgradeDomainName: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeUpdateDescription class.
 * @constructor
 * Describes the parameters for updating an ongoing application upgrade.
 *
 * @property {string} name The name of the application, including the 'fabric:'
 * URI scheme.
 * @property {string} upgradeKind The kind of upgrade out of the following
 * possible values. Possible values include: 'Invalid', 'Rolling'. Default
 * value: 'Rolling' .
 * @property {object} [applicationHealthPolicy] Defines a health policy used to
 * evaluate the health of an application or one of its children entities.
 * @property {boolean} [applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 * @property {number}
 * [applicationHealthPolicy.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @property {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 * @property {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 * @property {array} [applicationHealthPolicy.serviceTypeHealthPolicyMap] The
 * map with service type health policy per service type name. The map is empty
 * by default.
 * @property {object} [updateDescription] Describes the parameters for updating
 * a rolling upgrade of application or cluster.
 * @property {string} [updateDescription.rollingUpgradeMode] The mode used to
 * monitor health during a rolling upgrade. The values are UnmonitoredAuto,
 * UnmonitoredManual, and Monitored. Possible values include: 'Invalid',
 * 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @property {boolean} [updateDescription.forceRestart] If true, then processes
 * are forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @property {number} [updateDescription.replicaSetCheckTimeoutInMilliseconds]
 * The maximum amount of time to block processing of an upgrade domain and
 * prevent loss of availability when there are unexpected issues. When this
 * timeout expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 * @property {string} [updateDescription.failureAction] The compensating action
 * to perform when a Monitored upgrade encounters monitoring policy or health
 * policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @property {string} [updateDescription.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @property {string}
 * [updateDescription.healthCheckStableDurationInMilliseconds] The amount of
 * time that the application or cluster must remain healthy before the upgrade
 * proceeds to the next upgrade domain. It is first interpreted as a string
 * representing an ISO 8601 duration. If that fails, then it is interpreted as
 * a number representing the total number of milliseconds.
 * @property {string} [updateDescription.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @property {string} [updateDescription.upgradeTimeoutInMilliseconds] The
 * amount of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @property {string} [updateDescription.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 */
export interface ApplicationUpgradeUpdateDescription {
  name: string;
  upgradeKind: string;
  applicationHealthPolicy?: ApplicationHealthPolicy;
  updateDescription?: RollingUpgradeUpdateDescription;
}

/**
 * @class
 * Initializes a new instance of the NameDescription class.
 * @constructor
 * Describes a Service Fabric name.
 *
 * @property {string} name The Service Fabric name, including the 'fabric:' URI
 * scheme.
 */
export interface NameDescription {
  name: string;
}

/**
 * @class
 * Initializes a new instance of the PagedSubNameInfoList class.
 * @constructor
 * A paged list of Service Fabric names. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {boolean} [isConsistent] Indicates whether any name under the
 * given name has been modified during the enumeration. If there was a
 * modification, this property value is false.
 * @property {array} [subNames] List of the child names.
 */
export interface PagedSubNameInfoList {
  continuationToken?: string;
  isConsistent?: boolean;
  subNames?: string[];
}

/**
 * @class
 * Initializes a new instance of the PropertyValue class.
 * @constructor
 * Describes a Service Fabric property value.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface PropertyValue {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the BinaryPropertyValue class.
 * @constructor
 * Describes a Service Fabric property value of type Binary.
 *
 * @property {array} data Array of bytes to be sent as an integer array. Each
 * element of array is a number between 0 and 255.
 */
export interface BinaryPropertyValue extends PropertyValue {
  data: number[];
}

/**
 * @class
 * Initializes a new instance of the Int64PropertyValue class.
 * @constructor
 * Describes a Service Fabric property value of type Int64.
 *
 * @property {string} data The data of the property value.
 */
export interface Int64PropertyValue extends PropertyValue {
  data: string;
}

/**
 * @class
 * Initializes a new instance of the DoublePropertyValue class.
 * @constructor
 * Describes a Service Fabric property value of type Double.
 *
 * @property {number} data The data of the property value.
 */
export interface DoublePropertyValue extends PropertyValue {
  data: number;
}

/**
 * @class
 * Initializes a new instance of the StringPropertyValue class.
 * @constructor
 * Describes a Service Fabric property value of type String.
 *
 * @property {string} data The data of the property value.
 */
export interface StringPropertyValue extends PropertyValue {
  data: string;
}

/**
 * @class
 * Initializes a new instance of the GuidPropertyValue class.
 * @constructor
 * Describes a Service Fabric property value of type Guid.
 *
 * @property {uuid} data The data of the property value.
 */
export interface GuidPropertyValue extends PropertyValue {
  data: string;
}

/**
 * @class
 * Initializes a new instance of the PropertyMetadata class.
 * @constructor
 * The metadata associated with a property, including the property's name.
 *
 * @property {string} [typeId] The kind of property, determined by the type of
 * data. Following are the possible values. Possible values include: 'Invalid',
 * 'Binary', 'Int64', 'Double', 'String', 'Guid'
 * @property {string} [customTypeId] The property's custom type ID.
 * @property {string} [parent] The name of the parent Service Fabric Name for
 * the property. It could be thought of as the name-space/table under which the
 * property exists.
 * @property {number} [sizeInBytes] The length of the serialized property
 * value.
 * @property {date} [lastModifiedUtcTimestamp] Represents when the Property was
 * last modified. Only write operations will cause this field to be updated.
 * @property {string} [sequenceNumber] The version of the property. Every time
 * a property is modified, its sequence number is increased.
 */
export interface PropertyMetadata {
  typeId?: string;
  customTypeId?: string;
  parent?: string;
  sizeInBytes?: number;
  lastModifiedUtcTimestamp?: Date;
  sequenceNumber?: string;
}

/**
 * @class
 * Initializes a new instance of the PropertyInfo class.
 * @constructor
 * Information about a Service Fabric property.
 *
 * @property {string} name The name of the Service Fabric property.
 * @property {object} [value] Describes a Service Fabric property value.
 * @property {string} [value.kind] Polymorphic Discriminator
 * @property {object} metadata The metadata associated with a property,
 * including the property's name.
 * @property {string} [metadata.typeId] The kind of property, determined by the
 * type of data. Following are the possible values. Possible values include:
 * 'Invalid', 'Binary', 'Int64', 'Double', 'String', 'Guid'
 * @property {string} [metadata.customTypeId] The property's custom type ID.
 * @property {string} [metadata.parent] The name of the parent Service Fabric
 * Name for the property. It could be thought of as the name-space/table under
 * which the property exists.
 * @property {number} [metadata.sizeInBytes] The length of the serialized
 * property value.
 * @property {date} [metadata.lastModifiedUtcTimestamp] Represents when the
 * Property was last modified. Only write operations will cause this field to
 * be updated.
 * @property {string} [metadata.sequenceNumber] The version of the property.
 * Every time a property is modified, its sequence number is increased.
 */
export interface PropertyInfo {
  name: string;
  value?: PropertyValue;
  metadata: PropertyMetadata;
}

/**
 * @class
 * Initializes a new instance of the PagedPropertyInfoList class.
 * @constructor
 * The paged list of Service Fabric properties under a given name. The list is
 * paged when all of the results cannot fit in a single message. The next set
 * of results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {boolean} [isConsistent] Indicates whether any property under the
 * given name has been modified during the enumeration. If there was a
 * modification, this property value is false.
 * @property {array} [properties] List of property information.
 */
export interface PagedPropertyInfoList {
  continuationToken?: string;
  isConsistent?: boolean;
  properties?: PropertyInfo[];
}

/**
 * @class
 * Initializes a new instance of the PropertyDescription class.
 * @constructor
 * Description of a Service Fabric property.
 *
 * @property {string} propertyName The name of the Service Fabric property.
 * @property {string} [customTypeId] The property's custom type ID. Using this
 * property, the user is able to tag the type of the value of the property.
 * @property {object} value Describes a Service Fabric property value.
 * @property {string} [value.kind] Polymorphic Discriminator
 */
export interface PropertyDescription {
  propertyName: string;
  customTypeId?: string;
  value: PropertyValue;
}

/**
 * @class
 * Initializes a new instance of the PropertyBatchOperation class.
 * @constructor
 * Represents the base type for property operations that can be put into a
 * batch and submitted.
 *
 * @property {string} propertyName The name of the Service Fabric property.
 * @property {string} kind Polymorphic Discriminator
 */
export interface PropertyBatchOperation {
  propertyName: string;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the PropertyBatchDescriptionList class.
 * @constructor
 * Describes a list of property batch operations to be executed. Either all or
 * none of the operations will be committed.
 *
 * @property {array} [operations] A list of the property batch operations to be
 * executed.
 */
export interface PropertyBatchDescriptionList {
  operations?: PropertyBatchOperation[];
}

/**
 * @class
 * Initializes a new instance of the CheckExistsPropertyBatchOperation class.
 * @constructor
 * Represents a PropertyBatchOperation that compares the Boolean existence of a
 * property with the Exists argument.
 * The PropertyBatchOperation operation fails if the property's existence is
 * not equal to the Exists argument.
 * The CheckExistsPropertyBatchOperation is generally used as a precondition
 * for the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 * @property {boolean} exists Whether or not the property should exist for the
 * operation to pass.
 */
export interface CheckExistsPropertyBatchOperation extends PropertyBatchOperation {
  exists: boolean;
}

/**
 * @class
 * Initializes a new instance of the CheckSequencePropertyBatchOperation class.
 * @constructor
 * Compares the Sequence Number of a property with the SequenceNumber argument.
 * A property's sequence number can be thought of as that property's version.
 * Every time the property is modified, its sequence number is increased.
 * The sequence number can be found in a property's metadata.
 * The comparison fails if the sequence numbers are not equal.
 * CheckSequencePropertyBatchOperation is generally used as a precondition for
 * the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 * @property {string} sequenceNumber The expected sequence number.
 */
export interface CheckSequencePropertyBatchOperation extends PropertyBatchOperation {
  sequenceNumber: string;
}

/**
 * @class
 * Initializes a new instance of the CheckValuePropertyBatchOperation class.
 * @constructor
 * Represents a PropertyBatchOperation that compares the value of the property
 * with the expected value.
 * The CheckValuePropertyBatchOperation is generally used as a precondition for
 * the write operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 * @property {object} value The expected property value.
 * @property {string} [value.kind] Polymorphic Discriminator
 */
export interface CheckValuePropertyBatchOperation extends PropertyBatchOperation {
  value: PropertyValue;
}

/**
 * @class
 * Initializes a new instance of the DeletePropertyBatchOperation class.
 * @constructor
 * Represents a PropertyBatchOperation that deletes a specified property if it
 * exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 */
export interface DeletePropertyBatchOperation extends PropertyBatchOperation {
}

/**
 * @class
 * Initializes a new instance of the GetPropertyBatchOperation class.
 * @constructor
 * Represents a PropertyBatchOperation that gets the specified property if it
 * exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 * @property {boolean} [includeValue] Whether or not to return the property
 * value with the metadata.
 * True if values should be returned with the metadata; False to return only
 * property metadata. Default value: false .
 */
export interface GetPropertyBatchOperation extends PropertyBatchOperation {
  includeValue?: boolean;
}

/**
 * @class
 * Initializes a new instance of the PutPropertyBatchOperation class.
 * @constructor
 * Puts the specified property under the specified name.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 *
 * @property {object} value Describes a Service Fabric property value.
 * @property {string} [value.kind] Polymorphic Discriminator
 * @property {string} [customTypeId] The property's custom type ID. Using this
 * property, the user is able to tag the type of the value of the property.
 */
export interface PutPropertyBatchOperation extends PropertyBatchOperation {
  value: PropertyValue;
  customTypeId?: string;
}

/**
 * @class
 * Initializes a new instance of the PropertyBatchInfo class.
 * @constructor
 * Information about the results of a property batch.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface PropertyBatchInfo {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the SuccessfulPropertyBatchInfo class.
 * @constructor
 * Derived from PropertyBatchInfo. Represents the property batch succeeding.
 * Contains the results of any "Get" operations in the batch.
 *
 * @property {object} [properties] A map containing the properties that were
 * requested through any "Get" property batch operations. The key represents
 * the index of the "Get" operation in the original request, in string form.
 * The value is the property. If a property is not found, it will not be in the
 * map.
 */
export interface SuccessfulPropertyBatchInfo extends PropertyBatchInfo {
  properties?: { [propertyName: string]: PropertyInfo };
}

/**
 * @class
 * Initializes a new instance of the FailedPropertyBatchInfo class.
 * @constructor
 * Derived from PropertyBatchInfo. Represents the property batch failing.
 * Contains information about the specific batch failure.
 *
 * @property {string} [errorMessage] The error message of the failed operation.
 * Describes the exception thrown due to the first unsuccessful operation in
 * the property batch.
 * @property {number} [operationIndex] The index of the unsuccessful operation
 * in the property batch.
 */
export interface FailedPropertyBatchInfo extends PropertyBatchInfo {
  errorMessage?: string;
  operationIndex?: number;
}

/**
 * @class
 * Initializes a new instance of the BackupScheduleDescription class.
 * @constructor
 * Describes the backup schedule parameters.
 *
 * @property {string} scheduleKind Polymorphic Discriminator
 */
export interface BackupScheduleDescription {
  scheduleKind: string;
}

/**
 * @class
 * Initializes a new instance of the BackupStorageDescription class.
 * @constructor
 * Describes the parameters for the backup storage.
 *
 * @property {string} [friendlyName] Friendly name for this backup storage.
 * @property {string} storageKind Polymorphic Discriminator
 */
export interface BackupStorageDescription {
  friendlyName?: string;
  storageKind: string;
}

/**
 * @class
 * Initializes a new instance of the BackupPolicyDescription class.
 * @constructor
 * Describes a backup policy for configuring periodic backup.
 *
 * @property {string} name The unique name identifying this backup policy.
 * @property {boolean} autoRestoreOnDataLoss Specifies whether to trigger
 * restore automatically using the latest available backup in case the
 * partition experiences a data loss event.
 * @property {number} maxIncrementalBackups Defines the maximum number of
 * incremental backups to be taken between two full backups. This is just the
 * upper limit. A full backup may be taken before specified number of
 * incremental backups are completed in one of the following conditions
 * - The replica has never taken a full backup since it has become primary,
 * - Some of the log records since the last backup has been truncated, or
 * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
 * @property {object} schedule Describes the backup schedule parameters.
 * @property {string} [schedule.scheduleKind] Polymorphic Discriminator
 * @property {object} storage Describes the details of backup storage where to
 * store the periodic backups.
 * @property {string} [storage.friendlyName] Friendly name for this backup
 * storage.
 * @property {string} [storage.storageKind] Polymorphic Discriminator
 */
export interface BackupPolicyDescription {
  name: string;
  autoRestoreOnDataLoss: boolean;
  maxIncrementalBackups: number;
  schedule: BackupScheduleDescription;
  storage: BackupStorageDescription;
}

/**
 * @class
 * Initializes a new instance of the PagedBackupPolicyDescriptionList class.
 * @constructor
 * The list of backup policies configured in the cluster. The list is paged
 * when all of the results cannot fit in a single message. The next set of
 * results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] The list of backup policies information.
 */
export interface PagedBackupPolicyDescriptionList {
  continuationToken?: string;
  items?: BackupPolicyDescription[];
}

/**
 * @class
 * Initializes a new instance of the BackupConfigurationInfo class.
 * @constructor
 * Describes the backup configuration information.
 *
 * @property {string} [policyName] The name of the backup policy which is
 * applicable to this Service Fabric application or service or partition.
 * @property {string} [policyInheritedFrom] Specifies the scope at which the
 * backup policy is applied. Possible values include: 'Invalid', 'Partition',
 * 'Service', 'Application'
 * @property {object} [suspensionInfo] Describes the backup suspension details.
 * @property {boolean} [suspensionInfo.isSuspended] Indicates whether periodic
 * backup is suspended at this level or not.
 * @property {string} [suspensionInfo.suspensionInheritedFrom] Specifies the
 * scope at which the backup suspension was applied. Possible values include:
 * 'Invalid', 'Partition', 'Service', 'Application'
 * @property {string} kind Polymorphic Discriminator
 */
export interface BackupConfigurationInfo {
  policyName?: string;
  policyInheritedFrom?: string;
  suspensionInfo?: BackupSuspensionInfo;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationBackupConfigurationInfo class.
 * @constructor
 * Backup configuration information for a specific Service Fabric application
 * specifying what backup policy is being applied and suspend description, if
 * any.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 */
export interface ApplicationBackupConfigurationInfo extends BackupConfigurationInfo {
  applicationName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceBackupConfigurationInfo class.
 * @constructor
 * Backup configuration information for a specific Service Fabric service
 * specifying what backup policy is being applied and suspend description, if
 * any.
 *
 * @property {string} [serviceName] The full name of the service with 'fabric:'
 * URI scheme.
 */
export interface ServiceBackupConfigurationInfo extends BackupConfigurationInfo {
  serviceName?: string;
}

/**
 * @class
 * Initializes a new instance of the BackupSuspensionInfo class.
 * @constructor
 * Describes the backup suspension details.
 *
 * @property {boolean} [isSuspended] Indicates whether periodic backup is
 * suspended at this level or not.
 * @property {string} [suspensionInheritedFrom] Specifies the scope at which
 * the backup suspension was applied. Possible values include: 'Invalid',
 * 'Partition', 'Service', 'Application'
 */
export interface BackupSuspensionInfo {
  isSuspended?: boolean;
  suspensionInheritedFrom?: string;
}

/**
 * @class
 * Initializes a new instance of the PagedBackupConfigurationInfoList class.
 * @constructor
 * The list of backup configuration information. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of backup configuration information.
 */
export interface PagedBackupConfigurationInfoList {
  continuationToken?: string;
  items?: BackupConfigurationInfo[];
}

/**
 * @class
 * Initializes a new instance of the RestorePartitionDescription class.
 * @constructor
 * Specifies the parameters needed to trigger a restore of a specific
 * partition.
 *
 * @property {uuid} backupId Unique backup ID.
 * @property {string} backupLocation Location of the backup relative to the
 * backup storage specified/ configured.
 * @property {object} [backupStorage] Location of the backup from where the
 * partition will be restored.
 * @property {string} [backupStorage.friendlyName] Friendly name for this
 * backup storage.
 * @property {string} [backupStorage.storageKind] Polymorphic Discriminator
 */
export interface RestorePartitionDescription {
  backupId: string;
  backupLocation: string;
  backupStorage?: BackupStorageDescription;
}

/**
 * @class
 * Initializes a new instance of the RestoreProgressInfo class.
 * @constructor
 * Describes the progress of a restore operation on a partition.
 *
 * @property {string} [restoreState] Represents the current state of the
 * partition restore operation. Possible values include: 'Invalid', 'Accepted',
 * 'RestoreInProgress', 'Success', 'Failure', 'Timeout'
 * @property {date} [timeStampUtc] Timestamp when operation succeeded or
 * failed.
 * @property {object} [restoredEpoch] Describes the epoch at which the
 * partition is restored.
 * @property {string} [restoredEpoch.configurationNumber] The current
 * configuration number of this Epoch. The configuration number is an
 * increasing value that is updated whenever the configuration of this replica
 * set changes.
 * @property {string} [restoredEpoch.dataLossNumber] The current dataloss
 * number of this Epoch. The data loss number property is an increasing value
 * which is updated whenever data loss is suspected, as when loss of a quorum
 * of replicas in the replica set that includes the Primary replica.
 * @property {string} [restoredLsn] Restored LSN.
 * @property {object} [failureError] Denotes the failure encountered in
 * performing restore operation.
 * @property {string} [failureError.code] Defines the fabric error codes that
 * be returned as part of the error object in response to Service Fabric API
 * operations that are not successful. Following are the error code values that
 * can be returned for a specific HTTP status code.
 *
 * - Possible values of the error code for HTTP status code 400 (Bad Request)
 * - "FABRIC_E_INVALID_PARTITION_KEY"
 * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_ADDRESS"
 * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
 * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_FABRIC_NOT_UPGRADING"
 * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_CONFIGURATION"
 * - "FABRIC_E_INVALID_NAME_URI"
 * - "FABRIC_E_PATH_TOO_LONG"
 * - "FABRIC_E_KEY_TOO_LARGE"
 * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
 * - "FABRIC_E_INVALID_ATOMIC_GROUP"
 * - "FABRIC_E_VALUE_EMPTY"
 * - "FABRIC_E_BACKUP_IS_ENABLED"
 * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
 * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
 * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
 * - "E_INVALIDARG"
 *
 * - Possible values of the error code for HTTP status code 404 (Not Found)
 * - "FABRIC_E_NODE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
 * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
 * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
 * - "FABRIC_E_PARTITION_NOT_FOUND"
 * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
 * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
 * - "FABRIC_E_DIRECTORY_NOT_FOUND"
 * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
 * - "FABRIC_E_FILE_NOT_FOUND"
 * - "FABRIC_E_NAME_DOES_NOT_EXIST"
 * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
 * - "FABRIC_E_ENUMERATION_COMPLETED"
 * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
 * - "FABRIC_E_KEY_NOT_FOUND"
 * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
 * - "FABRIC_E_BACKUP_NOT_ENABLED"
 * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
 * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 409 (Conflict)
 * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
 * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
 * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
 * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
 * - "FABRIC_E_FABRIC_VERSION_IN_USE"
 * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_NAME_ALREADY_EXISTS"
 * - "FABRIC_E_NAME_NOT_EMPTY"
 * - "FABRIC_E_PROPERTY_CHECK_FAILED"
 * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
 * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
 * - "FABRIC_E_HEALTH_STALE_REPORT"
 * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
 * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
 * - "FABRIC_E_INSTANCE_ID_MISMATCH"
 * - "FABRIC_E_BACKUP_IN_PROGRESS"
 * - "FABRIC_E_RESTORE_IN_PROGRESS"
 * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 413 (Request Entity
 * Too Large)
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 500 (Internal
 * Server Error)
 * - "FABRIC_E_NODE_IS_UP"
 * - "E_FAIL"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
 * - "ABRIC_E_VOLUME_NOT_FOUND"
 * - "SerializationError"
 *
 * - Possible values of the error code for HTTP status code 503 (Service
 * Unavailable)
 * - "FABRIC_E_NO_WRITE_QUORUM"
 * - "FABRIC_E_NOT_PRIMARY"
 * - "FABRIC_E_NOT_READY"
 * - "FABRIC_E_RECONFIGURATION_PENDING"
 * - "FABRIC_E_SERVICE_OFFLINE"
 * - "E_ABORT"
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 504 (Gateway
 * Timeout)
 * - "FABRIC_E_COMMUNICATION_ERROR"
 * - "FABRIC_E_OPERATION_NOT_COMPLETE"
 * - "FABRIC_E_TIMEOUT". Possible values include:
 * 'FABRIC_E_INVALID_PARTITION_KEY', 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_ADDRESS', 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * @property {string} [failureError.message] Error message.
 */
export interface RestoreProgressInfo {
  restoreState?: string;
  timeStampUtc?: Date;
  restoredEpoch?: BackupEpoch;
  restoredLsn?: string;
  failureError?: FabricErrorError;
}

/**
 * @class
 * Initializes a new instance of the BackupPartitionDescription class.
 * @constructor
 * Describes the parameters for triggering partition's backup.
 *
 * @property {object} [backupStorage] Specifies the details of the backup
 * storage where to save the backup.
 * @property {string} [backupStorage.friendlyName] Friendly name for this
 * backup storage.
 * @property {string} [backupStorage.storageKind] Polymorphic Discriminator
 */
export interface BackupPartitionDescription {
  backupStorage?: BackupStorageDescription;
}

/**
 * @class
 * Initializes a new instance of the BackupInfo class.
 * @constructor
 * Represents a backup point which can be used to trigger a restore.
 *
 * @property {uuid} [backupId] Unique backup ID .
 * @property {uuid} [backupChainId] Unique backup chain ID. All backups part of
 * the same chain has the same backup chain id. A backup chain is comprised of
 * 1 full backup and multiple incremental backups.
 * @property {string} [applicationName] Name of the Service Fabric application
 * this partition backup belongs to.
 * @property {string} [serviceName] Name of the Service Fabric service this
 * partition backup belongs to.
 * @property {object} [partitionInformation] Information about the partition to
 * which this backup belongs to
 * @property {uuid} [partitionInformation.id] An internal ID used by Service
 * Fabric to uniquely identify a partition. This is a randomly generated GUID
 * when the service was created. The partition ID is unique and does not change
 * for the lifetime of the service. If the same service was deleted and
 * recreated the IDs of its partitions would be different.
 * @property {string} [partitionInformation.servicePartitionKind] Polymorphic
 * Discriminator
 * @property {string} [backupLocation] Location of the backup, relative to the
 * backup store.
 * @property {string} [backupType] Describes the type of backup, whether its
 * full or incremental. Possible values include: 'Invalid', 'Full',
 * 'Incremental'
 * @property {object} [epochOfLastBackupRecord] Epoch of the last record in
 * this backup.
 * @property {string} [epochOfLastBackupRecord.configurationNumber] The current
 * configuration number of this Epoch. The configuration number is an
 * increasing value that is updated whenever the configuration of this replica
 * set changes.
 * @property {string} [epochOfLastBackupRecord.dataLossNumber] The current
 * dataloss number of this Epoch. The data loss number property is an
 * increasing value which is updated whenever data loss is suspected, as when
 * loss of a quorum of replicas in the replica set that includes the Primary
 * replica.
 * @property {string} [lsnOfLastBackupRecord] LSN of the last record in this
 * backup.
 * @property {date} [creationTimeUtc] The date time when this backup was taken.
 * @property {object} [failureError] Denotes the failure encountered in getting
 * backup point information.
 * @property {string} [failureError.code] Defines the fabric error codes that
 * be returned as part of the error object in response to Service Fabric API
 * operations that are not successful. Following are the error code values that
 * can be returned for a specific HTTP status code.
 *
 * - Possible values of the error code for HTTP status code 400 (Bad Request)
 * - "FABRIC_E_INVALID_PARTITION_KEY"
 * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_ADDRESS"
 * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
 * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_FABRIC_NOT_UPGRADING"
 * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_CONFIGURATION"
 * - "FABRIC_E_INVALID_NAME_URI"
 * - "FABRIC_E_PATH_TOO_LONG"
 * - "FABRIC_E_KEY_TOO_LARGE"
 * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
 * - "FABRIC_E_INVALID_ATOMIC_GROUP"
 * - "FABRIC_E_VALUE_EMPTY"
 * - "FABRIC_E_BACKUP_IS_ENABLED"
 * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
 * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
 * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
 * - "E_INVALIDARG"
 *
 * - Possible values of the error code for HTTP status code 404 (Not Found)
 * - "FABRIC_E_NODE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
 * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
 * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
 * - "FABRIC_E_PARTITION_NOT_FOUND"
 * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
 * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
 * - "FABRIC_E_DIRECTORY_NOT_FOUND"
 * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
 * - "FABRIC_E_FILE_NOT_FOUND"
 * - "FABRIC_E_NAME_DOES_NOT_EXIST"
 * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
 * - "FABRIC_E_ENUMERATION_COMPLETED"
 * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
 * - "FABRIC_E_KEY_NOT_FOUND"
 * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
 * - "FABRIC_E_BACKUP_NOT_ENABLED"
 * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
 * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 409 (Conflict)
 * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
 * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
 * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
 * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
 * - "FABRIC_E_FABRIC_VERSION_IN_USE"
 * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_NAME_ALREADY_EXISTS"
 * - "FABRIC_E_NAME_NOT_EMPTY"
 * - "FABRIC_E_PROPERTY_CHECK_FAILED"
 * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
 * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
 * - "FABRIC_E_HEALTH_STALE_REPORT"
 * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
 * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
 * - "FABRIC_E_INSTANCE_ID_MISMATCH"
 * - "FABRIC_E_BACKUP_IN_PROGRESS"
 * - "FABRIC_E_RESTORE_IN_PROGRESS"
 * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 413 (Request Entity
 * Too Large)
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 500 (Internal
 * Server Error)
 * - "FABRIC_E_NODE_IS_UP"
 * - "E_FAIL"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
 * - "ABRIC_E_VOLUME_NOT_FOUND"
 * - "SerializationError"
 *
 * - Possible values of the error code for HTTP status code 503 (Service
 * Unavailable)
 * - "FABRIC_E_NO_WRITE_QUORUM"
 * - "FABRIC_E_NOT_PRIMARY"
 * - "FABRIC_E_NOT_READY"
 * - "FABRIC_E_RECONFIGURATION_PENDING"
 * - "FABRIC_E_SERVICE_OFFLINE"
 * - "E_ABORT"
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 504 (Gateway
 * Timeout)
 * - "FABRIC_E_COMMUNICATION_ERROR"
 * - "FABRIC_E_OPERATION_NOT_COMPLETE"
 * - "FABRIC_E_TIMEOUT". Possible values include:
 * 'FABRIC_E_INVALID_PARTITION_KEY', 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_ADDRESS', 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * @property {string} [failureError.message] Error message.
 */
export interface BackupInfo {
  backupId?: string;
  backupChainId?: string;
  applicationName?: string;
  serviceName?: string;
  partitionInformation?: PartitionInformation;
  backupLocation?: string;
  backupType?: string;
  epochOfLastBackupRecord?: BackupEpoch;
  lsnOfLastBackupRecord?: string;
  creationTimeUtc?: Date;
  failureError?: FabricErrorError;
}

/**
 * @class
 * Initializes a new instance of the PagedBackupInfoList class.
 * @constructor
 * The list of backups. The list is paged when all of the results cannot fit in
 * a single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of backup information.
 */
export interface PagedBackupInfoList {
  continuationToken?: string;
  items?: BackupInfo[];
}

/**
 * @class
 * Initializes a new instance of the AzureBlobBackupStorageDescription class.
 * @constructor
 * Describes the parameters for Azure blob store used for storing and
 * enumerating backups.
 *
 * @property {string} connectionString The connection string to connect to the
 * Azure blob store.
 * @property {string} containerName The name of the container in the blob store
 * to store and enumerate backups from.
 */
export interface AzureBlobBackupStorageDescription extends BackupStorageDescription {
  connectionString: string;
  containerName: string;
}

/**
 * @class
 * Initializes a new instance of the FileShareBackupStorageDescription class.
 * @constructor
 * Describes the parameters for file share storage used for storing or
 * enumerating backups.
 *
 * @property {string} path UNC path of the file share where to store or
 * enumerate backups from.
 * @property {string} [primaryUserName] Primary user name to access the file
 * share.
 * @property {string} [primaryPassword] Primary password to access the share
 * location.
 * @property {string} [secondaryUserName] Secondary user name to access the
 * file share.
 * @property {string} [secondaryPassword] Secondary password to access the
 * share location
 */
export interface FileShareBackupStorageDescription extends BackupStorageDescription {
  path: string;
  primaryUserName?: string;
  primaryPassword?: string;
  secondaryUserName?: string;
  secondaryPassword?: string;
}

/**
 * @class
 * Initializes a new instance of the FrequencyBasedBackupScheduleDescription class.
 * @constructor
 * Describes the frequency based backup schedule.
 *
 * @property {moment.duration} interval Defines the interval with which backups
 * are periodically taken. It should be specified in ISO8601 format. Timespan
 * in seconds is not supported and will be ignored while creating the policy.
 */
export interface FrequencyBasedBackupScheduleDescription extends BackupScheduleDescription {
  interval: moment.Duration;
}

/**
 * @class
 * Initializes a new instance of the TimeBasedBackupScheduleDescription class.
 * @constructor
 * Describes the time based backup schedule.
 *
 * @property {string} scheduleFrequencyType Describes the frequency with which
 * to run the time based backup schedule. Possible values include: 'Invalid',
 * 'Daily', 'Weekly'
 * @property {array} [runDays] List of days of a week when to trigger the
 * periodic backup. This is valid only when the backup schedule frequency type
 * is weekly.
 * @property {array} runTimes Represents the list of exact time during the day
 * in ISO8601 format. Like '19:00:00' will represent '7PM' during the day. Date
 * specified along with time will be ignored.
 */
export interface TimeBasedBackupScheduleDescription extends BackupScheduleDescription {
  scheduleFrequencyType: string;
  runDays?: string[];
  runTimes: Date[];
}

/**
 * @class
 * Initializes a new instance of the BackupProgressInfo class.
 * @constructor
 * Describes the progress of a partition's backup.
 *
 * @property {string} [backupState] Represents the current state of the
 * partition backup operation. Possible values include: 'Invalid', 'Accepted',
 * 'BackupInProgress', 'Success', 'Failure', 'Timeout'
 * @property {date} [timeStampUtc] TimeStamp in UTC when operation succeeded or
 * failed.
 * @property {uuid} [backupId] Unique ID of the newly created backup.
 * @property {string} [backupLocation] Location, relative to the backup store,
 * of the newly created backup.
 * @property {object} [epochOfLastBackupRecord] Specifies the epoch of the last
 * record included in backup.
 * @property {string} [epochOfLastBackupRecord.configurationNumber] The current
 * configuration number of this Epoch. The configuration number is an
 * increasing value that is updated whenever the configuration of this replica
 * set changes.
 * @property {string} [epochOfLastBackupRecord.dataLossNumber] The current
 * dataloss number of this Epoch. The data loss number property is an
 * increasing value which is updated whenever data loss is suspected, as when
 * loss of a quorum of replicas in the replica set that includes the Primary
 * replica.
 * @property {string} [lsnOfLastBackupRecord] The LSN of last record included
 * in backup.
 * @property {object} [failureError] Denotes the failure encountered in
 * performing backup operation.
 * @property {string} [failureError.code] Defines the fabric error codes that
 * be returned as part of the error object in response to Service Fabric API
 * operations that are not successful. Following are the error code values that
 * can be returned for a specific HTTP status code.
 *
 * - Possible values of the error code for HTTP status code 400 (Bad Request)
 * - "FABRIC_E_INVALID_PARTITION_KEY"
 * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_ADDRESS"
 * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
 * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_FABRIC_NOT_UPGRADING"
 * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
 * - "FABRIC_E_INVALID_CONFIGURATION"
 * - "FABRIC_E_INVALID_NAME_URI"
 * - "FABRIC_E_PATH_TOO_LONG"
 * - "FABRIC_E_KEY_TOO_LARGE"
 * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
 * - "FABRIC_E_INVALID_ATOMIC_GROUP"
 * - "FABRIC_E_VALUE_EMPTY"
 * - "FABRIC_E_BACKUP_IS_ENABLED"
 * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
 * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
 * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
 * - "E_INVALIDARG"
 *
 * - Possible values of the error code for HTTP status code 404 (Not Found)
 * - "FABRIC_E_NODE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
 * - "FABRIC_E_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
 * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
 * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
 * - "FABRIC_E_PARTITION_NOT_FOUND"
 * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
 * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
 * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
 * - "FABRIC_E_DIRECTORY_NOT_FOUND"
 * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
 * - "FABRIC_E_FILE_NOT_FOUND"
 * - "FABRIC_E_NAME_DOES_NOT_EXIST"
 * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
 * - "FABRIC_E_ENUMERATION_COMPLETED"
 * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
 * - "FABRIC_E_KEY_NOT_FOUND"
 * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
 * - "FABRIC_E_BACKUP_NOT_ENABLED"
 * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
 * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 409 (Conflict)
 * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
 * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
 * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
 * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
 * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
 * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
 * - "FABRIC_E_FABRIC_VERSION_IN_USE"
 * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
 * - "FABRIC_E_NAME_ALREADY_EXISTS"
 * - "FABRIC_E_NAME_NOT_EMPTY"
 * - "FABRIC_E_PROPERTY_CHECK_FAILED"
 * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
 * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
 * - "FABRIC_E_HEALTH_STALE_REPORT"
 * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
 * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
 * - "FABRIC_E_INSTANCE_ID_MISMATCH"
 * - "FABRIC_E_BACKUP_IN_PROGRESS"
 * - "FABRIC_E_RESTORE_IN_PROGRESS"
 * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
 *
 * - Possible values of the error code for HTTP status code 413 (Request Entity
 * Too Large)
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 500 (Internal
 * Server Error)
 * - "FABRIC_E_NODE_IS_UP"
 * - "E_FAIL"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
 * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
 * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
 * - "ABRIC_E_VOLUME_NOT_FOUND"
 * - "SerializationError"
 *
 * - Possible values of the error code for HTTP status code 503 (Service
 * Unavailable)
 * - "FABRIC_E_NO_WRITE_QUORUM"
 * - "FABRIC_E_NOT_PRIMARY"
 * - "FABRIC_E_NOT_READY"
 * - "FABRIC_E_RECONFIGURATION_PENDING"
 * - "FABRIC_E_SERVICE_OFFLINE"
 * - "E_ABORT"
 * - "FABRIC_E_VALUE_TOO_LARGE"
 *
 * - Possible values of the error code for HTTP status code 504 (Gateway
 * Timeout)
 * - "FABRIC_E_COMMUNICATION_ERROR"
 * - "FABRIC_E_OPERATION_NOT_COMPLETE"
 * - "FABRIC_E_TIMEOUT". Possible values include:
 * 'FABRIC_E_INVALID_PARTITION_KEY', 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_ADDRESS', 'FABRIC_E_APPLICATION_NOT_UPGRADING',
 * 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI',
 * 'FABRIC_E_PATH_TOO_LONG', 'FABRIC_E_KEY_TOO_LARGE',
 * 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY',
 * 'FABRIC_E_NODE_NOT_FOUND', 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_NOT_FOUND', 'FABRIC_E_SERVICE_TYPE_NOT_FOUND',
 * 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND',
 * 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND', 'FABRIC_E_PARTITION_NOT_FOUND',
 * 'FABRIC_E_REPLICA_DOES_NOT_EXIST', 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST',
 * 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
 * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST',
 * 'FABRIC_E_PROPERTY_DOES_NOT_EXIST', 'FABRIC_E_ENUMERATION_COMPLETED',
 * 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND', 'FABRIC_E_KEY_NOT_FOUND',
 * 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS',
 * 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE',
 * 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM',
 * 'FABRIC_E_NOT_PRIMARY', 'FABRIC_E_NOT_READY',
 * 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
 * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL',
 * 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
 * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
 * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
 * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
 * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_VOLUME_ALREADY_EXISTS', 'FABRIC_E_VOLUME_NOT_FOUND',
 * 'SerializationError'
 * @property {string} [failureError.message] Error message.
 */
export interface BackupProgressInfo {
  backupState?: string;
  timeStampUtc?: Date;
  backupId?: string;
  backupLocation?: string;
  epochOfLastBackupRecord?: BackupEpoch;
  lsnOfLastBackupRecord?: string;
  failureError?: FabricErrorError;
}

/**
 * @class
 * Initializes a new instance of the PartitionBackupConfigurationInfo class.
 * @constructor
 * Backup configuration information, for a specific partition, specifying what
 * backup policy is being applied and suspend description, if any.
 *
 * @property {string} [serviceName] The full name of the service with 'fabric:'
 * URI scheme.
 * @property {uuid} [partitionId] An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 */
export interface PartitionBackupConfigurationInfo extends BackupConfigurationInfo {
  serviceName?: string;
  partitionId?: string;
}

/**
 * @class
 * Initializes a new instance of the BackupEntity class.
 * @constructor
 * Describes the Service Fabric entity that is configured for backup.
 *
 * @property {string} entityKind Polymorphic Discriminator
 */
export interface BackupEntity {
  entityKind: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationBackupEntity class.
 * @constructor
 * Identifies the Service Fabric application which is being backed up.
 *
 * @property {string} [applicationName] The name of the application, including
 * the 'fabric:' URI scheme.
 */
export interface ApplicationBackupEntity extends BackupEntity {
  applicationName?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceBackupEntity class.
 * @constructor
 * Identifies the Service Fabric stateful service which is being backed up.
 *
 * @property {string} [serviceName] The full name of the service with 'fabric:'
 * URI scheme.
 */
export interface ServiceBackupEntity extends BackupEntity {
  serviceName?: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionBackupEntity class.
 * @constructor
 * Identifies the Service Fabric stateful partition which is being backed up.
 *
 * @property {string} [serviceName] The full name of the service with 'fabric:'
 * URI scheme.
 * @property {uuid} [partitionId] An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 */
export interface PartitionBackupEntity extends BackupEntity {
  serviceName?: string;
  partitionId?: string;
}

/**
 * @class
 * Initializes a new instance of the EnableBackupDescription class.
 * @constructor
 * Specifies the parameters needed to enable periodic backup.
 *
 * @property {string} backupPolicyName Name of the backup policy to be used for
 * enabling periodic backups.
 */
export interface EnableBackupDescription {
  backupPolicyName: string;
}

/**
 * @class
 * Initializes a new instance of the PagedBackupEntityList class.
 * @constructor
 * The list of backup entities that are being periodically backed. The list is
 * paged when all of the results cannot fit in a single message. The next set
 * of results can be obtained by executing the same query with the continuation
 * token provided in this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of backup entity information.
 */
export interface PagedBackupEntityList {
  continuationToken?: string;
  items?: BackupEntity[];
}

/**
 * @class
 * Initializes a new instance of the GetBackupByStorageQueryDescription class.
 * @constructor
 * Describes additional filters to be applied, while listing backups, and
 * backup storage details from where to fetch the backups.
 *
 * @property {date} [startDateTimeFilter] Specifies the start date time in
 * ISO8601 from which to enumerate backups. If not specified, backups are
 * enumerated from the beginning.
 * @property {date} [endDateTimeFilter] Specifies the end date time in ISO8601
 * till which to enumerate backups. If not specified, backups are enumerated
 * till the end.
 * @property {boolean} [latest] If specified as true, gets the most recent
 * backup (within the specified time range) for every partition under the
 * specified backup entity. Default value: false .
 * @property {object} storage Describes the parameters for the backup storage
 * from where to enumerate backups. This is optional and by default backups are
 * enumerated from the backup storage where this backup entity is currently
 * being backed up (as specified in backup policy). This parameter is useful to
 * be able to enumerate backups from another cluster where you may intend to
 * restore.
 * @property {string} [storage.friendlyName] Friendly name for this backup
 * storage.
 * @property {string} [storage.storageKind] Polymorphic Discriminator
 * @property {object} backupEntity Indicates the entity for which to enumerate
 * backups.
 * @property {string} [backupEntity.entityKind] Polymorphic Discriminator
 */
export interface GetBackupByStorageQueryDescription {
  startDateTimeFilter?: Date;
  endDateTimeFilter?: Date;
  latest?: boolean;
  storage: BackupStorageDescription;
  backupEntity: BackupEntity;
}

/**
 * @class
 * Initializes a new instance of the NodeImpact class.
 * @constructor
 * Describes the expected impact of a repair to a particular node.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} nodeName The name of the impacted node.
 * @property {string} [impactLevel] The level of impact expected. Possible
 * values include: 'Invalid', 'None', 'Restart', 'RemoveData', 'RemoveNode'
 */
export interface NodeImpact {
  nodeName: string;
  impactLevel?: string;
}

/**
 * @class
 * Initializes a new instance of the RepairImpactDescriptionBase class.
 * @constructor
 * Describes the expected impact of executing a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface RepairImpactDescriptionBase {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the NodeRepairImpactDescription class.
 * @constructor
 * Describes the expected impact of a repair on a set of nodes.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {array} [nodeImpactList] The list of nodes impacted by a repair
 * action and their respective expected impact.
 */
export interface NodeRepairImpactDescription extends RepairImpactDescriptionBase {
  nodeImpactList?: NodeImpact[];
}

/**
 * @class
 * Initializes a new instance of the RepairTargetDescriptionBase class.
 * @constructor
 * Describes the entities targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} kind Polymorphic Discriminator
 */
export interface RepairTargetDescriptionBase {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the NodeRepairTargetDescription class.
 * @constructor
 * Describes the list of nodes targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {array} [nodeNames] The list of nodes targeted by a repair action.
 */
export interface NodeRepairTargetDescription extends RepairTargetDescriptionBase {
  nodeNames?: string[];
}

/**
 * @class
 * Initializes a new instance of the RepairTaskHistory class.
 * @constructor
 * A record of the times when the repair task entered each state.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {date} [createdUtcTimestamp] The time when the repair task entered
 * the Created state.
 * @property {date} [claimedUtcTimestamp] The time when the repair task entered
 * the Claimed state.
 * @property {date} [preparingUtcTimestamp] The time when the repair task
 * entered the Preparing state.
 * @property {date} [approvedUtcTimestamp] The time when the repair task
 * entered the Approved state
 * @property {date} [executingUtcTimestamp] The time when the repair task
 * entered the Executing state
 * @property {date} [restoringUtcTimestamp] The time when the repair task
 * entered the Restoring state
 * @property {date} [completedUtcTimestamp] The time when the repair task
 * entered the Completed state
 * @property {date} [preparingHealthCheckStartUtcTimestamp] The time when the
 * repair task started the health check in the Preparing state.
 * @property {date} [preparingHealthCheckEndUtcTimestamp] The time when the
 * repair task completed the health check in the Preparing state.
 * @property {date} [restoringHealthCheckStartUtcTimestamp] The time when the
 * repair task started the health check in the Restoring state.
 * @property {date} [restoringHealthCheckEndUtcTimestamp] The time when the
 * repair task completed the health check in the Restoring state.
 */
export interface RepairTaskHistory {
  createdUtcTimestamp?: Date;
  claimedUtcTimestamp?: Date;
  preparingUtcTimestamp?: Date;
  approvedUtcTimestamp?: Date;
  executingUtcTimestamp?: Date;
  restoringUtcTimestamp?: Date;
  completedUtcTimestamp?: Date;
  preparingHealthCheckStartUtcTimestamp?: Date;
  preparingHealthCheckEndUtcTimestamp?: Date;
  restoringHealthCheckStartUtcTimestamp?: Date;
  restoringHealthCheckEndUtcTimestamp?: Date;
}

/**
 * @class
 * Initializes a new instance of the RepairTask class.
 * @constructor
 * Represents a repair task, which includes information about what kind of
 * repair was requested, what its progress is, and what its final result was.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} taskId The ID of the repair task.
 * @property {string} [version] The version of the repair task.
 * When creating a new repair task, the version must be set to zero.  When
 * updating a repair task,
 * the version is used for optimistic concurrency checks.  If the version is
 * set to zero, the update will not check for write conflicts.  If the version
 * is set to a non-zero value, then the
 * update will only succeed if the actual current version of the repair task
 * matches this value.
 * @property {string} [description] A description of the purpose of the repair
 * task, or other informational details.
 * May be set when the repair task is created, and is immutable once set.
 * @property {string} state The workflow state of the repair task. Valid
 * initial states are Created, Claimed, and Preparing. Possible values include:
 * 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved', 'Executing',
 * 'Restoring', 'Completed'
 * @property {number} [flags] A bitwise-OR of the following values, which gives
 * additional details about the status of the repair task.
 * - 1 - Cancellation of the repair has been requested
 * - 2 - Abort of the repair has been requested
 * - 4 - Approval of the repair was forced via client request
 * @property {string} action The requested repair action. Must be specified
 * when the repair task is created, and is immutable once set.
 * @property {object} [target] The target object determines what actions the
 * system will take to prepare for the impact of the repair, prior to approving
 * execution of the repair.
 * May be set when the repair task is created, and is immutable once set.
 * @property {string} [target.kind] Polymorphic Discriminator
 * @property {string} [executor] The name of the repair executor. Must be
 * specified in Claimed and later states, and is immutable once set.
 * @property {string} [executorData] A data string that the repair executor can
 * use to store its internal state.
 * @property {object} [impact] The impact object determines what actions the
 * system will take to prepare for the impact of the repair, prior to approving
 * execution of the repair.
 * Impact must be specified by the repair executor when transitioning to the
 * Preparing state, and is immutable once set.
 * @property {string} [impact.kind] Polymorphic Discriminator
 * @property {string} [resultStatus] A value describing the overall result of
 * the repair task execution. Must be specified in the Restoring and later
 * states, and is immutable once set. Possible values include: 'Invalid',
 * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
 * @property {number} [resultCode] A numeric value providing additional details
 * about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 * @property {string} [resultDetails] A string providing additional details
 * about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 * @property {object} [history] An object that contains timestamps of the
 * repair task's state transitions.
 * These timestamps are updated by the system, and cannot be directly modified.
 * @property {date} [history.createdUtcTimestamp] The time when the repair task
 * entered the Created state.
 * @property {date} [history.claimedUtcTimestamp] The time when the repair task
 * entered the Claimed state.
 * @property {date} [history.preparingUtcTimestamp] The time when the repair
 * task entered the Preparing state.
 * @property {date} [history.approvedUtcTimestamp] The time when the repair
 * task entered the Approved state
 * @property {date} [history.executingUtcTimestamp] The time when the repair
 * task entered the Executing state
 * @property {date} [history.restoringUtcTimestamp] The time when the repair
 * task entered the Restoring state
 * @property {date} [history.completedUtcTimestamp] The time when the repair
 * task entered the Completed state
 * @property {date} [history.preparingHealthCheckStartUtcTimestamp] The time
 * when the repair task started the health check in the Preparing state.
 * @property {date} [history.preparingHealthCheckEndUtcTimestamp] The time when
 * the repair task completed the health check in the Preparing state.
 * @property {date} [history.restoringHealthCheckStartUtcTimestamp] The time
 * when the repair task started the health check in the Restoring state.
 * @property {date} [history.restoringHealthCheckEndUtcTimestamp] The time when
 * the repair task completed the health check in the Restoring state.
 * @property {string} [preparingHealthCheckState] The workflow state of the
 * health check when the repair task is in the Preparing state. Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 * @property {string} [restoringHealthCheckState] The workflow state of the
 * health check when the repair task is in the Restoring state. Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 * @property {boolean} [performPreparingHealthCheck] A value to determine if
 * health checks will be performed when the repair task enters the Preparing
 * state.
 * @property {boolean} [performRestoringHealthCheck] A value to determine if
 * health checks will be performed when the repair task enters the Restoring
 * state.
 */
export interface RepairTask {
  taskId: string;
  version?: string;
  description?: string;
  state: string;
  flags?: number;
  action: string;
  target?: RepairTargetDescriptionBase;
  executor?: string;
  executorData?: string;
  impact?: RepairImpactDescriptionBase;
  resultStatus?: string;
  resultCode?: number;
  resultDetails?: string;
  history?: RepairTaskHistory;
  preparingHealthCheckState?: string;
  restoringHealthCheckState?: string;
  performPreparingHealthCheck?: boolean;
  performRestoringHealthCheck?: boolean;
}

/**
 * @class
 * Initializes a new instance of the RepairTaskApproveDescription class.
 * @constructor
 * Describes a request for forced approval of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} taskId The ID of the repair task.
 * @property {string} [version] The current version number of the repair task.
 * If non-zero, then the request will only succeed if this value matches the
 * actual current version of the repair task. If zero, then no version check is
 * performed.
 */
export interface RepairTaskApproveDescription {
  taskId: string;
  version?: string;
}

/**
 * @class
 * Initializes a new instance of the RepairTaskCancelDescription class.
 * @constructor
 * Describes a request to cancel a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} taskId The ID of the repair task.
 * @property {string} [version] The current version number of the repair task.
 * If non-zero, then the request will only succeed if this value matches the
 * actual current version of the repair task. If zero, then no version check is
 * performed.
 * @property {boolean} [requestAbort] _True_ if the repair should be stopped as
 * soon as possible even if it has already started executing. _False_ if the
 * repair should be cancelled only if execution has not yet started.
 */
export interface RepairTaskCancelDescription {
  taskId: string;
  version?: string;
  requestAbort?: boolean;
}

/**
 * @class
 * Initializes a new instance of the RepairTaskDeleteDescription class.
 * @constructor
 * Describes a request to delete a completed repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} taskId The ID of the completed repair task to be deleted.
 * @property {string} [version] The current version number of the repair task.
 * If non-zero, then the request will only succeed if this value matches the
 * actual current version of the repair task. If zero, then no version check is
 * performed.
 */
export interface RepairTaskDeleteDescription {
  taskId: string;
  version?: string;
}

/**
 * @class
 * Initializes a new instance of the RepairTaskUpdateHealthPolicyDescription class.
 * @constructor
 * Describes a request to update the health policy of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} taskId The ID of the repair task to be updated.
 * @property {string} [version] The current version number of the repair task.
 * If non-zero, then the request will only succeed if this value matches the
 * actual current value of the repair task. If zero, then no version check is
 * performed.
 * @property {boolean} [performPreparingHealthCheck] A boolean indicating if
 * health check is to be performed in the Preparing stage of the repair task.
 * If not specified the existing value should not be altered. Otherwise,
 * specify the desired new value.
 * @property {boolean} [performRestoringHealthCheck] A boolean indicating if
 * health check is to be performed in the Restoring stage of the repair task.
 * If not specified the existing value should not be altered. Otherwise,
 * specify the desired new value.
 */
export interface RepairTaskUpdateHealthPolicyDescription {
  taskId: string;
  version?: string;
  performPreparingHealthCheck?: boolean;
  performRestoringHealthCheck?: boolean;
}

/**
 * @class
 * Initializes a new instance of the RepairTaskUpdateInfo class.
 * @constructor
 * Describes the result of an operation that created or updated a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @property {string} version The new version of the repair task.
 */
export interface RepairTaskUpdateInfo {
  version: string;
}

/**
 * @class
 * Initializes a new instance of the UploadChunkRange class.
 * @constructor
 * Information about which portion of the file to upload.
 *
 * @property {string} [startPosition] The start position of the portion of the
 * file. It's represented by the number of bytes.
 * @property {string} [endPosition] The end position of the portion of the
 * file. It's represented by the number of bytes.
 */
export interface UploadChunkRange {
  startPosition?: string;
  endPosition?: string;
}

/**
 * @class
 * Initializes a new instance of the UploadSessionInfo class.
 * @constructor
 * Information about an image store upload session. A session is associated
 * with a relative path in the image store.
 *
 * @property {string} [storeRelativePath] The remote location within image
 * store. This path is relative to the image store root.
 * @property {uuid} [sessionId] A unique ID of the upload session. A session ID
 * can be reused only if the session was committed or removed.
 * @property {date} [modifiedDate] The date and time when the upload session
 * was last modified.
 * @property {string} [fileSize] The size in bytes of the uploading file.
 * @property {array} [expectedRanges] List of chunk ranges that image store has
 * not received yet.
 */
export interface UploadSessionInfo {
  storeRelativePath?: string;
  sessionId?: string;
  modifiedDate?: Date;
  fileSize?: string;
  expectedRanges?: UploadChunkRange[];
}

/**
 * @class
 * Initializes a new instance of the UploadSession class.
 * @constructor
 * Information about a image store upload session
 *
 * @property {array} [uploadSessions] When querying upload session by upload
 * session ID, the result contains only one upload session. When querying
 * upload session by image store relative path, the result might contain
 * multiple upload sessions.
 */
export interface UploadSession {
  uploadSessions?: UploadSessionInfo[];
}

/**
 * @class
 * Initializes a new instance of the ContainerLogs class.
 * @constructor
 * Container logs.
 *
 * @property {string} [content] Container logs.
 */
export interface ContainerLogs {
  content?: string;
}

/**
 * @class
 * Initializes a new instance of the AveragePartitionLoadScalingTrigger class.
 * @constructor
 * Represents a scaling trigger related to an average load of a metric/resource
 * of a partition.
 *
 * @property {string} metricName The name of the metric for which usage should
 * be tracked.
 * @property {string} lowerLoadThreshold The lower limit of the load below
 * which a scale in operation should be performed.
 * @property {string} upperLoadThreshold The upper limit of the load beyond
 * which a scale out operation should be performed.
 * @property {number} scaleIntervalInSeconds The period in seconds on which a
 * decision is made whether to scale or not.
 */
export interface AveragePartitionLoadScalingTrigger extends ScalingTriggerDescription {
  metricName: string;
  lowerLoadThreshold: string;
  upperLoadThreshold: string;
  scaleIntervalInSeconds: number;
}

/**
 * @class
 * Initializes a new instance of the AverageServiceLoadScalingTrigger class.
 * @constructor
 * Represents a scaling policy related to an average load of a metric/resource
 * of a service.
 *
 * @property {string} metricName The name of the metric for which usage should
 * be tracked.
 * @property {string} lowerLoadThreshold The lower limit of the load below
 * which a scale in operation should be performed.
 * @property {string} upperLoadThreshold The upper limit of the load beyond
 * which a scale out operation should be performed.
 * @property {number} scaleIntervalInSeconds The period in seconds on which a
 * decision is made whether to scale or not.
 */
export interface AverageServiceLoadScalingTrigger extends ScalingTriggerDescription {
  metricName: string;
  lowerLoadThreshold: string;
  upperLoadThreshold: string;
  scaleIntervalInSeconds: number;
}

/**
 * @class
 * Initializes a new instance of the PartitionInstanceCountScaleMechanism class.
 * @constructor
 * Represents a scaling mechanism for adding or removing instances of stateless
 * service partition.
 *
 * @property {number} minInstanceCount Minimum number of instances of the
 * partition.
 * @property {number} maxInstanceCount Maximum number of instances of the
 * partition.
 * @property {number} scaleIncrement The number of instances to add or remove
 * during a scaling operation.
 */
export interface PartitionInstanceCountScaleMechanism extends ScalingMechanismDescription {
  minInstanceCount: number;
  maxInstanceCount: number;
  scaleIncrement: number;
}

/**
 * @class
 * Initializes a new instance of the AddRemoveIncrementalNamedPartitionScalingMechanism class.
 * @constructor
 * Represents a scaling mechanism for adding or removing named partitions of a
 * stateless service. Partition names are in the format '0','1''N-1'
 *
 * @property {number} minPartitionCount Minimum number of named partitions of
 * the service.
 * @property {number} maxPartitionCount Maximum number of named partitions of
 * the service.
 * @property {number} scaleIncrement The number of instances to add or remove
 * during a scaling operation.
 */
export interface AddRemoveIncrementalNamedPartitionScalingMechanism extends ScalingMechanismDescription {
  minPartitionCount: number;
  maxPartitionCount: number;
  scaleIncrement: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationCreatedEvent class.
 * @constructor
 * Application Created event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} applicationTypeVersion Application type version.
 * @property {string} applicationDefinitionKind Application definition kind.
 */
export interface ApplicationCreatedEvent extends ApplicationEvent {
  applicationTypeName: string;
  applicationTypeVersion: string;
  applicationDefinitionKind: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationDeletedEvent class.
 * @constructor
 * Application Deleted event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} applicationTypeVersion Application type version.
 */
export interface ApplicationDeletedEvent extends ApplicationEvent {
  applicationTypeName: string;
  applicationTypeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthReportCreatedEvent class.
 * @constructor
 * Application Health Report Created event.
 *
 * @property {number} applicationInstanceId Id of Application instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ApplicationHealthReportCreatedEvent extends ApplicationEvent {
  applicationInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthReportExpiredEvent class.
 * @constructor
 * Application Health Report Expired event.
 *
 * @property {number} applicationInstanceId Id of Application instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ApplicationHealthReportExpiredEvent extends ApplicationEvent {
  applicationInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeCompleteEvent class.
 * @constructor
 * Application Upgrade Complete event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} applicationTypeVersion Application type version.
 * @property {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
 * milli-seconds.
 */
export interface ApplicationUpgradeCompleteEvent extends ApplicationEvent {
  applicationTypeName: string;
  applicationTypeVersion: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeDomainCompleteEvent class.
 * @constructor
 * Application Upgrade Domain Complete event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} currentApplicationTypeVersion Current Application type
 * version.
 * @property {string} applicationTypeVersion Target Application type version.
 * @property {string} upgradeState State of upgrade.
 * @property {string} upgradeDomains Upgrade domains.
 * @property {number} upgradeDomainElapsedTimeInMs Upgrade time of domain in
 * milli-seconds.
 */
export interface ApplicationUpgradeDomainCompleteEvent extends ApplicationEvent {
  applicationTypeName: string;
  currentApplicationTypeVersion: string;
  applicationTypeVersion: string;
  upgradeState: string;
  upgradeDomains: string;
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeRollbackCompleteEvent class.
 * @constructor
 * Application Upgrade Rollback Complete event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} applicationTypeVersion Application type version.
 * @property {string} failureReason Describes reason of failure.
 * @property {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
 * milli-seconds.
 */
export interface ApplicationUpgradeRollbackCompleteEvent extends ApplicationEvent {
  applicationTypeName: string;
  applicationTypeVersion: string;
  failureReason: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeRollbackStartEvent class.
 * @constructor
 * Application Upgrade Rollback Start event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} currentApplicationTypeVersion Current Application type
 * version.
 * @property {string} applicationTypeVersion Target Application type version.
 * @property {string} failureReason Describes reason of failure.
 * @property {number} overallUpgradeElapsedTimeInMs Overall upgrade time in
 * milli-seconds.
 */
export interface ApplicationUpgradeRollbackStartEvent extends ApplicationEvent {
  applicationTypeName: string;
  currentApplicationTypeVersion: string;
  applicationTypeVersion: string;
  failureReason: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradeStartEvent class.
 * @constructor
 * Application Upgrade Start event.
 *
 * @property {string} applicationTypeName Application type name.
 * @property {string} currentApplicationTypeVersion Current Application type
 * version.
 * @property {string} applicationTypeVersion Target Application type version.
 * @property {string} upgradeType Type of upgrade.
 * @property {string} rollingUpgradeMode Mode of upgrade.
 * @property {string} failureAction Action if failed.
 */
export interface ApplicationUpgradeStartEvent extends ApplicationEvent {
  applicationTypeName: string;
  currentApplicationTypeVersion: string;
  applicationTypeVersion: string;
  upgradeType: string;
  rollingUpgradeMode: string;
  failureAction: string;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthReportCreatedEvent class.
 * @constructor
 * Deployed Application Health Report Created event.
 *
 * @property {number} applicationInstanceId Id of Application instance.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface DeployedApplicationHealthReportCreatedEvent extends ApplicationEvent {
  applicationInstanceId: number;
  nodeName: string;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the DeployedApplicationHealthReportExpiredEvent class.
 * @constructor
 * Deployed Application Health Report Expired event.
 *
 * @property {number} applicationInstanceId Id of Application instance.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface DeployedApplicationHealthReportExpiredEvent extends ApplicationEvent {
  applicationInstanceId: number;
  nodeName: string;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ProcessDeactivatedEvent class.
 * @constructor
 * Process Deactivated event.
 *
 * @property {string} serviceName Name of Service.
 * @property {string} servicePackageName Name of Service package.
 * @property {string} servicePackageActivationId Activation Id of Service
 * package.
 * @property {boolean} isExclusive Indicates IsExclusive flag.
 * @property {string} codePackageName Name of Code package.
 * @property {string} entryPointType Type of EntryPoint.
 * @property {string} exeName Name of executable.
 * @property {number} processId Process Id.
 * @property {string} hostId Host Id.
 * @property {number} exitCode Exit code of process.
 * @property {boolean} unexpectedTermination Indicates if termination is
 * unexpected.
 * @property {date} startTime Start time of process.
 */
export interface ProcessDeactivatedEvent extends ApplicationEvent {
  serviceName: string;
  servicePackageName: string;
  servicePackageActivationId: string;
  isExclusive: boolean;
  codePackageName: string;
  entryPointType: string;
  exeName: string;
  processId: number;
  hostId: string;
  exitCode: number;
  unexpectedTermination: boolean;
  startTime: Date;
}

/**
 * @class
 * Initializes a new instance of the ContainerDeactivatedEvent class.
 * @constructor
 * Container Deactivated event.
 *
 * @property {string} serviceName Name of Service.
 * @property {string} servicePackageName Name of Service package.
 * @property {string} servicePackageActivationId Activation Id of Service
 * package.
 * @property {boolean} isExclusive Indicates IsExclusive flag.
 * @property {string} codePackageName Name of Code package.
 * @property {string} entryPointType Type of EntryPoint.
 * @property {string} imageName Name of Container image.
 * @property {string} containerName Name of Container.
 * @property {string} hostId Host Id.
 * @property {number} exitCode Exit code of process.
 * @property {boolean} unexpectedTermination Indicates if termination is
 * unexpected.
 * @property {date} startTime Start time of process.
 */
export interface ContainerDeactivatedEvent extends ApplicationEvent {
  serviceName: string;
  servicePackageName: string;
  servicePackageActivationId: string;
  isExclusive: boolean;
  codePackageName: string;
  entryPointType: string;
  imageName: string;
  containerName: string;
  hostId: string;
  exitCode: number;
  unexpectedTermination: boolean;
  startTime: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeAbortedEvent class.
 * @constructor
 * Node Aborted event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 */
export interface NodeAbortedEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the NodeAbortingEvent class.
 * @constructor
 * Node Aborting event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 */
export interface NodeAbortingEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the NodeAddedEvent class.
 * @constructor
 * Node Added event.
 *
 * @property {string} nodeId Id of Node.
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeType Type of Node.
 * @property {string} fabricVersion Fabric version.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} nodeCapacities Capacities.
 */
export interface NodeAddedEvent extends NodeEvent {
  nodeId: string;
  nodeInstance: number;
  nodeType: string;
  fabricVersion: string;
  ipAddressOrFQDN: string;
  nodeCapacities: string;
}

/**
 * @class
 * Initializes a new instance of the NodeCloseEvent class.
 * @constructor
 * Node Close event.
 *
 * @property {string} nodeId Id of Node.
 * @property {string} nodeInstance Id of Node instance.
 * @property {string} error Describes error.
 */
export interface NodeCloseEvent extends NodeEvent {
  nodeId: string;
  nodeInstance: string;
  error: string;
}

/**
 * @class
 * Initializes a new instance of the NodeClosingEvent class.
 * @constructor
 * Node Closing event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 */
export interface NodeClosingEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the NodeDeactivateCompleteEvent class.
 * @constructor
 * Node Deactivate Complete event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} effectiveDeactivateIntent Describes deactivate intent.
 * @property {string} batchIdsWithDeactivateIntent Batch Ids.
 * @property {date} startTime Start time.
 */
export interface NodeDeactivateCompleteEvent extends NodeEvent {
  nodeInstance: number;
  effectiveDeactivateIntent: string;
  batchIdsWithDeactivateIntent: string;
  startTime: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeDeactivateStartEvent class.
 * @constructor
 * Node Deactivate Start event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} batchId Batch Id.
 * @property {string} deactivateIntent Describes deactivate intent.
 */
export interface NodeDeactivateStartEvent extends NodeEvent {
  nodeInstance: number;
  batchId: string;
  deactivateIntent: string;
}

/**
 * @class
 * Initializes a new instance of the NodeDownEvent class.
 * @constructor
 * Node Down event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {date} lastNodeUpAt Time when Node was last up.
 */
export interface NodeDownEvent extends NodeEvent {
  nodeInstance: number;
  lastNodeUpAt: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthReportCreatedEvent class.
 * @constructor
 * Node Health Report Created event.
 *
 * @property {number} nodeInstanceId Id of Node instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface NodeHealthReportCreatedEvent extends NodeEvent {
  nodeInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeHealthReportExpiredEvent class.
 * @constructor
 * Node Health Report Expired event.
 *
 * @property {number} nodeInstanceId Id of Node instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface NodeHealthReportExpiredEvent extends NodeEvent {
  nodeInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the NodeOpenedSuccessEvent class.
 * @constructor
 * Node Opened Success event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 */
export interface NodeOpenedSuccessEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the NodeOpenFailedEvent class.
 * @constructor
 * Node Open Failed event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 * @property {string} error Describes the error.
 */
export interface NodeOpenFailedEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
  error: string;
}

/**
 * @class
 * Initializes a new instance of the NodeOpeningEvent class.
 * @constructor
 * Node Opening event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeId Id of Node.
 * @property {string} upgradeDomain Upgrade domain of Node.
 * @property {string} faultDomain Fault domain of Node.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} hostname Name of Host.
 * @property {boolean} isSeedNode Indicates if it is seed node.
 * @property {string} nodeVersion Version of Node.
 */
export interface NodeOpeningEvent extends NodeEvent {
  nodeInstance: number;
  nodeId: string;
  upgradeDomain: string;
  faultDomain: string;
  ipAddressOrFQDN: string;
  hostname: string;
  isSeedNode: boolean;
  nodeVersion: string;
}

/**
 * @class
 * Initializes a new instance of the NodeRemovedEvent class.
 * @constructor
 * Node Removed event.
 *
 * @property {string} nodeId Id of Node.
 * @property {number} nodeInstance Id of Node instance.
 * @property {string} nodeType Type of Node.
 * @property {string} fabricVersion Fabric version.
 * @property {string} ipAddressOrFQDN IP address or FQDN.
 * @property {string} nodeCapacities Capacities.
 */
export interface NodeRemovedEvent extends NodeEvent {
  nodeId: string;
  nodeInstance: number;
  nodeType: string;
  fabricVersion: string;
  ipAddressOrFQDN: string;
  nodeCapacities: string;
}

/**
 * @class
 * Initializes a new instance of the NodeUpEvent class.
 * @constructor
 * Node Up event.
 *
 * @property {number} nodeInstance Id of Node instance.
 * @property {date} lastNodeDownAt Time when Node was last down.
 */
export interface NodeUpEvent extends NodeEvent {
  nodeInstance: number;
  lastNodeDownAt: Date;
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthReportCreatedEvent class.
 * @constructor
 * Partition Health Report Created event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface PartitionHealthReportCreatedEvent extends PartitionEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the PartitionHealthReportExpiredEvent class.
 * @constructor
 * Partition Health Report Expired event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface PartitionHealthReportExpiredEvent extends PartitionEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the PartitionReconfigurationCompletedEvent class.
 * @constructor
 * Partition Reconfiguration Completed event.
 *
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} nodeInstanceId Id of Node instance.
 * @property {string} serviceType Type of Service.
 * @property {number} ccEpochDataLossVersion CcEpochDataLoss version.
 * @property {number} ccEpochConfigVersion CcEpochConfig version.
 * @property {string} reconfigType Type of reconfiguration.
 * @property {string} result Describes reconfiguration result.
 * @property {number} phase0DurationMs Duration of Phase0 in milli-seconds.
 * @property {number} phase1DurationMs Duration of Phase1 in milli-seconds.
 * @property {number} phase2DurationMs Duration of Phase2 in milli-seconds.
 * @property {number} phase3DurationMs Duration of Phase3 in milli-seconds.
 * @property {number} phase4DurationMs Duration of Phase4 in milli-seconds.
 * @property {number} totalDurationMs Total duration in milli-seconds.
 */
export interface PartitionReconfigurationCompletedEvent extends PartitionEvent {
  nodeName: string;
  nodeInstanceId: string;
  serviceType: string;
  ccEpochDataLossVersion: number;
  ccEpochConfigVersion: number;
  reconfigType: string;
  result: string;
  phase0DurationMs: number;
  phase1DurationMs: number;
  phase2DurationMs: number;
  phase3DurationMs: number;
  phase4DurationMs: number;
  totalDurationMs: number;
}

/**
 * @class
 * Initializes a new instance of the PartitionPrimaryMoveAnalysisEvent class.
 * @constructor
 * Partition Primary Move Analysis event.
 *
 * @property {date} whenMoveCompleted Time when the move was completed.
 * @property {string} previousNode The name of a Service Fabric node.
 * @property {string} currentNode The name of a Service Fabric node.
 * @property {string} moveReason Move reason.
 * @property {string} relevantTraces Relevant traces.
 */
export interface PartitionPrimaryMoveAnalysisEvent extends PartitionAnalysisEvent {
  whenMoveCompleted: Date;
  previousNode: string;
  currentNode: string;
  moveReason: string;
  relevantTraces: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceCreatedEvent class.
 * @constructor
 * Service Created event.
 *
 * @property {string} serviceTypeName Service type name.
 * @property {string} applicationName Application name.
 * @property {string} applicationTypeName Application type name.
 * @property {number} serviceInstance Id of Service instance.
 * @property {boolean} isStateful Indicates if Service is stateful.
 * @property {number} partitionCount Number of partitions.
 * @property {number} targetReplicaSetSize Size of target replicas set.
 * @property {number} minReplicaSetSize Minimum size of replicas set.
 * @property {string} servicePackageVersion Version of Service package.
 * @property {uuid} partitionId An internal ID used by Service Fabric to
 * uniquely identify a partition. This is a randomly generated GUID when the
 * service was created. The partition ID is unique and does not change for the
 * lifetime of the service. If the same service was deleted and recreated the
 * IDs of its partitions would be different.
 */
export interface ServiceCreatedEvent extends ServiceEvent {
  serviceTypeName: string;
  applicationName: string;
  applicationTypeName: string;
  serviceInstance: number;
  isStateful: boolean;
  partitionCount: number;
  targetReplicaSetSize: number;
  minReplicaSetSize: number;
  servicePackageVersion: string;
  partitionId: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceDeletedEvent class.
 * @constructor
 * Service Deleted event.
 *
 * @property {string} serviceTypeName Service type name.
 * @property {string} applicationName Application name.
 * @property {string} applicationTypeName Application type name.
 * @property {number} serviceInstance Id of Service instance.
 * @property {boolean} isStateful Indicates if Service is stateful.
 * @property {number} partitionCount Number of partitions.
 * @property {number} targetReplicaSetSize Size of target replicas set.
 * @property {number} minReplicaSetSize Minimum size of replicas set.
 * @property {string} servicePackageVersion Version of Service package.
 */
export interface ServiceDeletedEvent extends ServiceEvent {
  serviceTypeName: string;
  applicationName: string;
  applicationTypeName: string;
  serviceInstance: number;
  isStateful: boolean;
  partitionCount: number;
  targetReplicaSetSize: number;
  minReplicaSetSize: number;
  servicePackageVersion: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthReportCreatedEvent class.
 * @constructor
 * Service Health Report Created event.
 *
 * @property {number} instanceId Id of Service instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ServiceHealthReportCreatedEvent extends ServiceEvent {
  instanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ServiceHealthReportExpiredEvent class.
 * @constructor
 * Service Health Report Expired event.
 *
 * @property {number} instanceId Id of Service instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ServiceHealthReportExpiredEvent extends ServiceEvent {
  instanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the DeployedServiceHealthReportCreatedEvent class.
 * @constructor
 * Deployed Service Health Report Created event.
 *
 * @property {string} serviceManifestName Service manifest name.
 * @property {number} servicePackageInstanceId Id of Service package instance.
 * @property {string} servicePackageActivationId Id of Service package
 * activation.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} tTLTimespan Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface DeployedServiceHealthReportCreatedEvent extends ApplicationEvent {
  serviceManifestName: string;
  servicePackageInstanceId: number;
  servicePackageActivationId: string;
  nodeName: string;
  sourceId: string;
  property: string;
  healthState: string;
  tTLTimespan: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the DeployedServiceHealthReportExpiredEvent class.
 * @constructor
 * Deployed Service Health Report Expired event.
 *
 * @property {string} serviceManifest Service manifest name.
 * @property {number} servicePackageInstanceId Id of Service package instance.
 * @property {string} servicePackageActivationId Id of Service package
 * activation.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} tTLTimespan Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface DeployedServiceHealthReportExpiredEvent extends ApplicationEvent {
  serviceManifest: string;
  servicePackageInstanceId: number;
  servicePackageActivationId: string;
  nodeName: string;
  sourceId: string;
  property: string;
  healthState: string;
  tTLTimespan: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the StatefulReplicaHealthReportCreatedEvent class.
 * @constructor
 * Stateful Replica Health Report Created event.
 *
 * @property {number} replicaInstanceId Id of Replica instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface StatefulReplicaHealthReportCreatedEvent extends ReplicaEvent {
  replicaInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the StatefulReplicaHealthReportExpiredEvent class.
 * @constructor
 * Stateful Replica Health Report Expired event.
 *
 * @property {number} replicaInstanceId Id of Replica instance.
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface StatefulReplicaHealthReportExpiredEvent extends ReplicaEvent {
  replicaInstanceId: number;
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the StatelessReplicaHealthReportCreatedEvent class.
 * @constructor
 * Stateless Replica Health Report Created event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface StatelessReplicaHealthReportCreatedEvent extends ReplicaEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the StatelessReplicaHealthReportExpiredEvent class.
 * @constructor
 * Stateless Replica Health Report Expired event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface StatelessReplicaHealthReportExpiredEvent extends ReplicaEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthReportCreatedEvent class.
 * @constructor
 * Cluster Health Report Created event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ClusterHealthReportCreatedEvent extends ClusterEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthReportExpiredEvent class.
 * @constructor
 * Cluster Health Report Expired event.
 *
 * @property {string} sourceId Id of report source.
 * @property {string} property Describes the property.
 * @property {string} healthState Describes the property health state.
 * @property {number} timeToLiveMs Time to live in milli-seconds.
 * @property {number} sequenceNumber Sequence number of report.
 * @property {string} description Description of report.
 * @property {boolean} removeWhenExpired Indicates the removal when it expires.
 * @property {date} sourceUtcTimestamp Source time.
 */
export interface ClusterHealthReportExpiredEvent extends ClusterEvent {
  sourceId: string;
  property: string;
  healthState: string;
  timeToLiveMs: number;
  sequenceNumber: number;
  description: string;
  removeWhenExpired: boolean;
  sourceUtcTimestamp: Date;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeCompleteEvent class.
 * @constructor
 * Cluster Upgrade Complete event.
 *
 * @property {string} targetClusterVersion Target Cluster version.
 * @property {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
 * in milli-seconds.
 */
export interface ClusterUpgradeCompleteEvent extends ClusterEvent {
  targetClusterVersion: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeDomainCompleteEvent class.
 * @constructor
 * Cluster Upgrade Domain Complete event.
 *
 * @property {string} targetClusterVersion Target Cluster version.
 * @property {string} upgradeState State of upgrade.
 * @property {string} upgradeDomains Upgrade domains.
 * @property {number} upgradeDomainElapsedTimeInMs Duration of domain upgrade
 * in milli-seconds.
 */
export interface ClusterUpgradeDomainCompleteEvent extends ClusterEvent {
  targetClusterVersion: string;
  upgradeState: string;
  upgradeDomains: string;
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeRollbackCompleteEvent class.
 * @constructor
 * Cluster Upgrade Rollback Complete event.
 *
 * @property {string} targetClusterVersion Target Cluster version.
 * @property {string} failureReason Describes failure.
 * @property {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
 * in milli-seconds.
 */
export interface ClusterUpgradeRollbackCompleteEvent extends ClusterEvent {
  targetClusterVersion: string;
  failureReason: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeRollbackStartEvent class.
 * @constructor
 * Cluster Upgrade Rollback Start event.
 *
 * @property {string} targetClusterVersion Target Cluster version.
 * @property {string} failureReason Describes failure.
 * @property {number} overallUpgradeElapsedTimeInMs Overall duration of upgrade
 * in milli-seconds.
 */
export interface ClusterUpgradeRollbackStartEvent extends ClusterEvent {
  targetClusterVersion: string;
  failureReason: string;
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeStartEvent class.
 * @constructor
 * Cluster Upgrade Start event.
 *
 * @property {string} currentClusterVersion Current Cluster version.
 * @property {string} targetClusterVersion Target Cluster version.
 * @property {string} upgradeType Type of upgrade.
 * @property {string} rollingUpgradeMode Mode of upgrade.
 * @property {string} failureAction Action if failed.
 */
export interface ClusterUpgradeStartEvent extends ClusterEvent {
  currentClusterVersion: string;
  targetClusterVersion: string;
  upgradeType: string;
  rollingUpgradeMode: string;
  failureAction: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosStoppedEvent class.
 * @constructor
 * Chaos Stopped event.
 *
 * @property {string} reason Describes reason.
 */
export interface ChaosStoppedEvent extends ClusterEvent {
  reason: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosStartedEvent class.
 * @constructor
 * Chaos Started event.
 *
 * @property {number} maxConcurrentFaults Maximum number of concurrent faults.
 * @property {number} timeToRunInSeconds Time to run in seconds.
 * @property {number} maxClusterStabilizationTimeoutInSeconds Maximum timeout
 * for cluster stabilization in seconds.
 * @property {number} waitTimeBetweenIterationsInSeconds Wait time between
 * iterations in seconds.
 * @property {number} waitTimeBetweenFautlsInSeconds Wait time between faults
 * in seconds.
 * @property {boolean} moveReplicaFaultEnabled Indicates MoveReplica fault is
 * enabled.
 * @property {string} includedNodeTypeList List of included Node types.
 * @property {string} includedApplicationList List of included Applications.
 * @property {string} clusterHealthPolicy Health policy.
 * @property {string} chaosContext Chaos Context.
 */
export interface ChaosStartedEvent extends ClusterEvent {
  maxConcurrentFaults: number;
  timeToRunInSeconds: number;
  maxClusterStabilizationTimeoutInSeconds: number;
  waitTimeBetweenIterationsInSeconds: number;
  waitTimeBetweenFautlsInSeconds: number;
  moveReplicaFaultEnabled: boolean;
  includedNodeTypeList: string;
  includedApplicationList: string;
  clusterHealthPolicy: string;
  chaosContext: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRestartNodeFaultCompletedEvent class.
 * @constructor
 * Chaos Restart Node Fault Completed event.
 *
 * @property {number} nodeInstanceId Id of Node instance.
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 */
export interface ChaosRestartNodeFaultCompletedEvent extends NodeEvent {
  nodeInstanceId: number;
  faultGroupId: string;
  faultId: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRestartCodePackageFaultScheduledEvent class.
 * @constructor
 * Chaos Restart Code Package Fault Scheduled event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} serviceManifestName Service manifest name.
 * @property {string} codePackageName Code package name.
 * @property {string} servicePackageActivationId Id of Service package
 * activation.
 */
export interface ChaosRestartCodePackageFaultScheduledEvent extends ApplicationEvent {
  faultGroupId: string;
  faultId: string;
  nodeName: string;
  serviceManifestName: string;
  codePackageName: string;
  servicePackageActivationId: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRestartCodePackageFaultCompletedEvent class.
 * @constructor
 * Chaos Restart Code Package Fault Completed event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} nodeName The name of a Service Fabric node.
 * @property {string} serviceManifestName Service manifest name.
 * @property {string} codePackageName Code package name.
 * @property {string} servicePackageActivationId Id of Service package
 * activation.
 */
export interface ChaosRestartCodePackageFaultCompletedEvent extends ApplicationEvent {
  faultGroupId: string;
  faultId: string;
  nodeName: string;
  serviceManifestName: string;
  codePackageName: string;
  servicePackageActivationId: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRemoveReplicaFaultScheduledEvent class.
 * @constructor
 * Chaos Remove Replica Fault Scheduled event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} serviceUri Service name.
 */
export interface ChaosRemoveReplicaFaultScheduledEvent extends ReplicaEvent {
  faultGroupId: string;
  faultId: string;
  serviceUri: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRemoveReplicaFaultCompletedEvent class.
 * @constructor
 * Chaos Remove Replica Fault Completed event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} serviceUri Service name.
 */
export interface ChaosRemoveReplicaFaultCompletedEvent extends ReplicaEvent {
  faultGroupId: string;
  faultId: string;
  serviceUri: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosMoveSecondaryFaultScheduledEvent class.
 * @constructor
 * Chaos Move Secondary Fault Scheduled event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} serviceName Service name.
 * @property {string} sourceNode The name of a Service Fabric node.
 * @property {string} destinationNode The name of a Service Fabric node.
 * @property {boolean} forcedMove Indicates a forced move.
 */
export interface ChaosMoveSecondaryFaultScheduledEvent extends PartitionEvent {
  faultGroupId: string;
  faultId: string;
  serviceName: string;
  sourceNode: string;
  destinationNode: string;
  forcedMove: boolean;
}

/**
 * @class
 * Initializes a new instance of the ChaosMovePrimaryFaultScheduledEvent class.
 * @constructor
 * Chaos Move Primary Fault Scheduled event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} serviceName Service name.
 * @property {string} nodeTo The name of a Service Fabric node.
 * @property {boolean} forcedMove Indicates a forced move.
 */
export interface ChaosMovePrimaryFaultScheduledEvent extends PartitionEvent {
  faultGroupId: string;
  faultId: string;
  serviceName: string;
  nodeTo: string;
  forcedMove: boolean;
}

/**
 * @class
 * Initializes a new instance of the ChaosRestartReplicaFaultScheduledEvent class.
 * @constructor
 * Chaos Restart Replica Fault Scheduled event.
 *
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 * @property {string} serviceUri Service name.
 */
export interface ChaosRestartReplicaFaultScheduledEvent extends ReplicaEvent {
  faultGroupId: string;
  faultId: string;
  serviceUri: string;
}

/**
 * @class
 * Initializes a new instance of the ChaosRestartNodeFaultScheduledEvent class.
 * @constructor
 * Chaos Restart Node Fault Scheduled event.
 *
 * @property {number} nodeInstanceId Id of Node instance.
 * @property {uuid} faultGroupId Id of fault group.
 * @property {uuid} faultId Id of fault.
 */
export interface ChaosRestartNodeFaultScheduledEvent extends NodeEvent {
  nodeInstanceId: number;
  faultGroupId: string;
  faultId: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceDescription class.
 * @constructor
 * Describes a service fabric service resource.
 *
 * @property {string} osType The Operating system type required by the code in
 * service. Possible values include: 'Linux', 'Windows'
 * @property {array} codePackages Describes the set of code packages that forms
 * the service. A code package describes the container and the properties for
 * running it. All the code packages are started together on the same host and
 * share the same context (network, process etc.).
 * @property {array} [networkRefs] The names of the private networks that this
 * service needs to be part of.
 * @property {object} [diagnostics] Reference to sinks in
 * DiagnosticsDescription.
 * @property {boolean} [diagnostics.enabled] Status of whether or not sinks are
 * enabled.
 * @property {array} [diagnostics.sinkRefs] List of sinks to be used if
 * enabled. References the list of sinks in DiagnosticsDescription.
 * @property {string} [description] User readable description of the service.
 * @property {number} [replicaCount] The number of replicas of the service to
 * create. Defaults to 1 if not specified.
 * @property {string} [healthState] The health state of a Service Fabric entity
 * such as Cluster, Node, Application, Service, Partition, Replica etc.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @property {string} [status] Represents the status of the service. Possible
 * values include: 'Unknown', 'Active', 'Upgrading', 'Deleting', 'Creating',
 * 'Failed'
 * @property {string} name Service resource name.
 */
export interface ServiceResourceDescription {
  osType: string;
  codePackages: ContainerCodePackageProperties[];
  networkRefs?: NetworkRef[];
  diagnostics?: DiagnosticsRef;
  description?: string;
  replicaCount?: number;
  healthState?: string;
  readonly status?: string;
  name: string;
}

/**
 * @class
 * Initializes a new instance of the DiagnosticsSinkProperties class.
 * @constructor
 * Properties of a DiagnosticsSink.
 *
 * @property {string} [name] Name of the sink. This value is referenced by
 * DiagnosticsReferenceDescription
 * @property {string} [description] A description of the sink.
 * @property {string} kind Polymorphic Discriminator
 */
export interface DiagnosticsSinkProperties {
  name?: string;
  description?: string;
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the DiagnosticsDescription class.
 * @constructor
 * Describes the diagnostics options available
 *
 * @property {array} [sinks] List of supported sinks that can be referenced.
 * @property {boolean} [enabled] Status of whether or not sinks are enabled.
 * @property {array} [defaultSinkRefs] The sinks to be used if diagnostics is
 * enabled. Sink choices can be overridden at the service and code package
 * level.
 */
export interface DiagnosticsDescription {
  sinks?: DiagnosticsSinkProperties[];
  enabled?: boolean;
  defaultSinkRefs?: string[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationResourceDescription class.
 * @constructor
 * Describes a service fabric application resource.
 *
 * @property {string} [description] User readable description of the
 * application.
 * @property {string} [debugParams] Internal use.
 * @property {array} [services] describes the services in the application.
 * @property {string} [healthState] Describes the health state of an
 * application resource. Possible values include: 'Invalid', 'Ok', 'Warning',
 * 'Error', 'Unknown'
 * @property {string} [unhealthyEvaluation] When the application's health state
 * is not 'Ok', this additional details from service fabric Health Manager for
 * the user to know why the application is marked unhealthy.
 * @property {string} [status] Status of the application resource. Possible
 * values include: 'Invalid', 'Ready', 'Upgrading', 'Creating', 'Deleting',
 * 'Failed'
 * @property {string} [statusDetails] Gives additional information about the
 * current status of the application deployment.
 * @property {array} [serviceNames] Names of the services in the application.
 * @property {object} [diagnostics] Describes the diagnostics definition and
 * usage for an application resource.
 * @property {array} [diagnostics.sinks] List of supported sinks that can be
 * referenced.
 * @property {boolean} [diagnostics.enabled] Status of whether or not sinks are
 * enabled.
 * @property {array} [diagnostics.defaultSinkRefs] The sinks to be used if
 * diagnostics is enabled. Sink choices can be overridden at the service and
 * code package level.
 * @property {string} name Application resource name.
 */
export interface ApplicationResourceDescription {
  description?: string;
  debugParams?: string;
  services?: ServiceResourceDescription[];
  readonly healthState?: string;
  readonly unhealthyEvaluation?: string;
  readonly status?: string;
  readonly statusDetails?: string;
  readonly serviceNames?: string[];
  diagnostics?: DiagnosticsDescription;
  name: string;
}

/**
 * @class
 * Initializes a new instance of the PagedServiceResourceDescriptionList class.
 * @constructor
 * The list of service resources in the cluster. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of service resource description.
 */
export interface PagedServiceResourceDescriptionList {
  continuationToken?: string;
  items?: ServiceResourceDescription[];
}

/**
 * @class
 * Initializes a new instance of the ServiceReplicaProperties class.
 * @constructor
 * Describes the properties of a service replica.
 *
 * @property {string} osType The Operating system type required by the code in
 * service. Possible values include: 'Linux', 'Windows'
 * @property {array} codePackages Describes the set of code packages that forms
 * the service. A code package describes the container and the properties for
 * running it. All the code packages are started together on the same host and
 * share the same context (network, process etc.).
 * @property {array} [networkRefs] The names of the private networks that this
 * service needs to be part of.
 * @property {object} [diagnostics] Reference to sinks in
 * DiagnosticsDescription.
 * @property {boolean} [diagnostics.enabled] Status of whether or not sinks are
 * enabled.
 * @property {array} [diagnostics.sinkRefs] List of sinks to be used if
 * enabled. References the list of sinks in DiagnosticsDescription.
 */
export interface ServiceReplicaProperties {
  osType: string;
  codePackages: ContainerCodePackageProperties[];
  networkRefs?: NetworkRef[];
  diagnostics?: DiagnosticsRef;
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceReplicaDescription class.
 * @constructor
 * Describes a replica of a service resource.
 *
 * @property {string} replicaName Name of the replica.
 */
export interface ServiceResourceReplicaDescription extends ServiceReplicaProperties {
  replicaName: string;
}

/**
 * @class
 * Initializes a new instance of the PagedServiceResourceReplicaDescriptionList class.
 * @constructor
 * The list of service resources in the cluster. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in
 * this list.
 *
 * @property {string} [continuationToken] The continuation token parameter is
 * used to obtain next set of results. The continuation token is included in
 * the response of the API when the results from the system do not fit in a
 * single response. When this value is passed to the next API call, the API
 * returns next set of results. If there are no further results, then the
 * continuation token is not included in the response.
 * @property {array} [items] List of service resource description.
 */
export interface PagedServiceResourceReplicaDescriptionList {
  continuationToken?: string;
  items?: ServiceResourceReplicaDescription[];
}

/**
 * @class
 * Initializes a new instance of the VolumeProviderParametersAzureFile class.
 * @constructor
 * This type describes a volume provided by an Azure Files file share.
 *
 * @property {string} accountName Name of the Azure storage account for the
 * File Share.
 * @property {string} [accountKey] Access key of the Azure storage account for
 * the File Share.
 * @property {string} shareName Name of the Azure Files file share that
 * provides storage for the volume.
 */
export interface VolumeProviderParametersAzureFile {
  accountName: string;
  accountKey?: string;
  shareName: string;
}

/**
 * @class
 * Initializes a new instance of the VolumeResourceDescription class.
 * @constructor
 * Describes a service fabric volume resource.
 *
 * @property {string} [description] User readable description of the volume.
 * @property {object} [azureFileParameters] This type describes a volume
 * provided by an Azure Files file share.
 * @property {string} [azureFileParameters.accountName] Name of the Azure
 * storage account for the File Share.
 * @property {string} [azureFileParameters.accountKey] Access key of the Azure
 * storage account for the File Share.
 * @property {string} [azureFileParameters.shareName] Name of the Azure Files
 * file share that provides storage for the volume.
 * @property {string} name Volume resource name.
 */
export interface VolumeResourceDescription {
  description?: string;
  azureFileParameters?: VolumeProviderParametersAzureFile;
  name: string;
}

/**
 * @class
 * Initializes a new instance of the ImageRegistryCredential class.
 * @constructor
 * Image registry credential.
 *
 * @property {string} server Docker image registry server, without protocol
 * such as `http` and `https`.
 * @property {string} username The username for the private registry.
 * @property {string} [password] The password for the private registry.
 */
export interface ImageRegistryCredential {
  server: string;
  username: string;
  password?: string;
}

/**
 * @class
 * Initializes a new instance of the EnvironmentVariable class.
 * @constructor
 * Describes an environment variable for the container.
 *
 * @property {string} [name] The name of the environment variable.
 * @property {string} [value] The value of the environment variable.
 */
export interface EnvironmentVariable {
  name?: string;
  value?: string;
}

/**
 * @class
 * Initializes a new instance of the Setting class.
 * @constructor
 * Describes a setting for the container.
 *
 * @property {string} [name] The name of the setting.
 * @property {string} [value] The value of the setting.
 */
export interface Setting {
  name?: string;
  value?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerLabel class.
 * @constructor
 * Describes a container label.
 *
 * @property {string} name The name of the container label.
 * @property {string} value The value of the container label.
 */
export interface ContainerLabel {
  name: string;
  value: string;
}

/**
 * @class
 * Initializes a new instance of the EndpointProperties class.
 * @constructor
 * Describes a container endpoint.
 *
 * @property {string} name The name of the endpoint.
 * @property {number} [port] Port used by the container.
 */
export interface EndpointProperties {
  name: string;
  port?: number;
}

/**
 * @class
 * Initializes a new instance of the ResourceRequests class.
 * @constructor
 * This type describes the requested resources for a given container. It
 * describes the least amount of resources required for the container. A
 * container can consume more than requested resources up to the specified
 * limits before being restarted. Currently, the requested resources are
 * treated as limits.
 *
 * @property {number} memoryInGB The memory request in GB for this container.
 * @property {number} cpu Requested number of CPU cores. At present, only full
 * cores are supported.
 */
export interface ResourceRequests {
  memoryInGB: number;
  cpu: number;
}

/**
 * @class
 * Initializes a new instance of the ResourceLimits class.
 * @constructor
 * This type describes the resource limits for a given container. It describes
 * the most amount of resources a container is allowed to use before being
 * restarted.
 *
 * @property {number} [memoryInGB] The memory limit in GB.
 * @property {number} [cpu] CPU limits in cores. At present, only full cores
 * are supported.
 */
export interface ResourceLimits {
  memoryInGB?: number;
  cpu?: number;
}

/**
 * @class
 * Initializes a new instance of the ResourceRequirements class.
 * @constructor
 * This type describes the resource requirements for a container or a service.
 *
 * @property {object} requests Describes the requested resources for a given
 * container.
 * @property {number} [requests.memoryInGB] The memory request in GB for this
 * container.
 * @property {number} [requests.cpu] Requested number of CPU cores. At present,
 * only full cores are supported.
 * @property {object} [limits] Describes the maximum limits on the resources
 * for a given container.
 * @property {number} [limits.memoryInGB] The memory limit in GB.
 * @property {number} [limits.cpu] CPU limits in cores. At present, only full
 * cores are supported.
 */
export interface ResourceRequirements {
  requests: ResourceRequests;
  limits?: ResourceLimits;
}

/**
 * @class
 * Initializes a new instance of the ContainerVolume class.
 * @constructor
 * Describes how a volume is attached to a container.
 *
 * @property {string} name Name of the volume.
 * @property {boolean} [readOnly] The flag indicating whether the volume is
 * read only. Default is 'false'.
 * @property {string} destinationPath The path within the container at which
 * the volume should be mounted. Only valid path characters are allowed.
 */
export interface ContainerVolume {
  name: string;
  readOnly?: boolean;
  destinationPath: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerState class.
 * @constructor
 * The container state.
 *
 * @property {string} [state] The state of this container
 * @property {date} [startTime] Date/time when the container state started.
 * @property {string} [exitCode] The container exit code.
 * @property {date} [finishTime] Date/time when the container state finished.
 * @property {string} [detailStatus] Human-readable status of this state.
 */
export interface ContainerState {
  state?: string;
  startTime?: Date;
  exitCode?: string;
  finishTime?: Date;
  detailStatus?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerEvent class.
 * @constructor
 * A container event.
 *
 * @property {string} [name] The name of the container event.
 * @property {number} [count] The count of the event.
 * @property {string} [firstTimestamp] Date/time of the first event.
 * @property {string} [lastTimestamp] Date/time of the last event.
 * @property {string} [message] The event message
 * @property {string} [type] The event type.
 */
export interface ContainerEvent {
  name?: string;
  count?: number;
  firstTimestamp?: string;
  lastTimestamp?: string;
  message?: string;
  type?: string;
}

/**
 * @class
 * Initializes a new instance of the ContainerInstanceView class.
 * @constructor
 * Runtime information of a container instance.
 *
 * @property {number} [restartCount] The number of times the container has been
 * restarted.
 * @property {object} [currentState] Current container instance state.
 * @property {string} [currentState.state] The state of this container
 * @property {date} [currentState.startTime] Date/time when the container state
 * started.
 * @property {string} [currentState.exitCode] The container exit code.
 * @property {date} [currentState.finishTime] Date/time when the container
 * state finished.
 * @property {string} [currentState.detailStatus] Human-readable status of this
 * state.
 * @property {object} [previousState] Previous container instance state.
 * @property {string} [previousState.state] The state of this container
 * @property {date} [previousState.startTime] Date/time when the container
 * state started.
 * @property {string} [previousState.exitCode] The container exit code.
 * @property {date} [previousState.finishTime] Date/time when the container
 * state finished.
 * @property {string} [previousState.detailStatus] Human-readable status of
 * this state.
 * @property {array} [events] The events of this container instance.
 */
export interface ContainerInstanceView {
  restartCount?: number;
  currentState?: ContainerState;
  previousState?: ContainerState;
  events?: ContainerEvent[];
}

/**
 * @class
 * Initializes a new instance of the DiagnosticsRef class.
 * @constructor
 * Reference to sinks in DiagnosticsDescription.
 *
 * @property {boolean} [enabled] Status of whether or not sinks are enabled.
 * @property {array} [sinkRefs] List of sinks to be used if enabled. References
 * the list of sinks in DiagnosticsDescription.
 */
export interface DiagnosticsRef {
  enabled?: boolean;
  sinkRefs?: string[];
}

/**
 * @class
 * Initializes a new instance of the ContainerCodePackageProperties class.
 * @constructor
 * Describes a container and its runtime properties.
 *
 * @property {string} name The name of the code package.
 * @property {string} image The Container image to use.
 * @property {object} [imageRegistryCredential] Image registry credential.
 * @property {string} [imageRegistryCredential.server] Docker image registry
 * server, without protocol such as `http` and `https`.
 * @property {string} [imageRegistryCredential.username] The username for the
 * private registry.
 * @property {string} [imageRegistryCredential.password] The password for the
 * private registry.
 * @property {string} [entrypoint] Override for the default entry point in the
 * container.
 * @property {array} [commands] Command array to execute within the container
 * in exec form.
 * @property {array} [environmentVariables] The environment variables to set in
 * this container
 * @property {array} [settings] The settings to set in this container. The
 * setting file path can be fetched from environment variable
 * "Fabric_SettingPath". The path for Windows container is "C:\\secrets". The
 * path for Linux container is "/var/secrets".
 * @property {array} [labels] The labels to set in this container.
 * @property {array} [endpoints] The endpoints exposed by this container.
 * @property {object} resources This type describes the resource requirements
 * for a container or a service.
 * @property {object} [resources.requests] Describes the requested resources
 * for a given container.
 * @property {number} [resources.requests.memoryInGB] The memory request in GB
 * for this container.
 * @property {number} [resources.requests.cpu] Requested number of CPU cores.
 * At present, only full cores are supported.
 * @property {object} [resources.limits] Describes the maximum limits on the
 * resources for a given container.
 * @property {number} [resources.limits.memoryInGB] The memory limit in GB.
 * @property {number} [resources.limits.cpu] CPU limits in cores. At present,
 * only full cores are supported.
 * @property {array} [volumeRefs] The volumes to be attached to the container.
 * @property {object} [instanceView] Runtime information of a container
 * instance.
 * @property {number} [instanceView.restartCount] The number of times the
 * container has been restarted.
 * @property {object} [instanceView.currentState] Current container instance
 * state.
 * @property {string} [instanceView.currentState.state] The state of this
 * container
 * @property {date} [instanceView.currentState.startTime] Date/time when the
 * container state started.
 * @property {string} [instanceView.currentState.exitCode] The container exit
 * code.
 * @property {date} [instanceView.currentState.finishTime] Date/time when the
 * container state finished.
 * @property {string} [instanceView.currentState.detailStatus] Human-readable
 * status of this state.
 * @property {object} [instanceView.previousState] Previous container instance
 * state.
 * @property {string} [instanceView.previousState.state] The state of this
 * container
 * @property {date} [instanceView.previousState.startTime] Date/time when the
 * container state started.
 * @property {string} [instanceView.previousState.exitCode] The container exit
 * code.
 * @property {date} [instanceView.previousState.finishTime] Date/time when the
 * container state finished.
 * @property {string} [instanceView.previousState.detailStatus] Human-readable
 * status of this state.
 * @property {array} [instanceView.events] The events of this container
 * instance.
 * @property {object} [diagnostics] Reference to sinks in
 * DiagnosticsDescription.
 * @property {boolean} [diagnostics.enabled] Status of whether or not sinks are
 * enabled.
 * @property {array} [diagnostics.sinkRefs] List of sinks to be used if
 * enabled. References the list of sinks in DiagnosticsDescription.
 */
export interface ContainerCodePackageProperties {
  name: string;
  image: string;
  imageRegistryCredential?: ImageRegistryCredential;
  entrypoint?: string;
  commands?: string[];
  environmentVariables?: EnvironmentVariable[];
  settings?: Setting[];
  labels?: ContainerLabel[];
  endpoints?: EndpointProperties[];
  resources: ResourceRequirements;
  volumeRefs?: ContainerVolume[];
  readonly instanceView?: ContainerInstanceView;
  diagnostics?: DiagnosticsRef;
}

/**
 * @class
 * Initializes a new instance of the NetworkRef class.
 * @constructor
 * Describes a network reference in a service.
 *
 * @property {string} [name] Name of the network.
 */
export interface NetworkRef {
  name?: string;
}
