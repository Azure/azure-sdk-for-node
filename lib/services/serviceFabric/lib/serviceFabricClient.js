/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');


/**
 * @summary Get the Service Fabric cluster manifest.
 *
 * Get the Service Fabric cluster manifest. The cluster manifest contains
 * properties of the cluster that include different node types on the cluster,
 * security configurations, fault and upgrade domain topologies etc.
 *
 * These properties are specified as part of the ClusterConfig.JSON file while
 * deploying a stand alone cluster. However, most of the information in the
 * cluster manifest
 * is generated internally by service fabric during cluster deployment in other
 * deployment scenarios (for e.g when using azuer portal).
 *
 * The contents of the cluster manifest are for informational purposes only and
 * users are not expected to take a dependency on the format of the file
 * contents or its interpretation.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterManifest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterManifest(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterManifest';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster.
 *
 * Gets the health of a Service Fabric cluster.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
 * filter the collection of nodes and applications returned based on their
 * aggregated health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
 * node health state objects returned in the result of cluster health query
 * based on their health state. The possible values for this parameter include
 * integer value of one of the
 * following health states. Only nodes that match the filter are returned. All
 * nodes are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of nodes with
 * HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
 * the application health state objects returned in the result of cluster
 * health
 * query based on their health state.
 * The possible values for this parameter include integer value obtained from
 * members or bitwise operations
 * on members of HealthStateFilter enumeration. Only applications that match
 * the filter are returned.
 * All applications are used to evaluate the aggregated health state. If not
 * specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of applications
 * with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {boolean} [options.includeSystemApplicationHealthStatistics]
 * Indicates whether the health statistics should include the fabric:/System
 * application health statistics. False by default.
 * If IncludeSystemApplicationHealthStatistics is set to true, the health
 * statistics include the entities that belong to the fabric:/System
 * application.
 * Otherwise, the query result includes health statistics only for user
 * applications.
 * The health statistics must be included in the query result for this
 * parameter to be applied.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealth(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let nodesHealthStateFilter = (options && options.nodesHealthStateFilter !== undefined) ? options.nodesHealthStateFilter : 0;
  let applicationsHealthStateFilter = (options && options.applicationsHealthStateFilter !== undefined) ? options.applicationsHealthStateFilter : 0;
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let includeSystemApplicationHealthStatistics = (options && options.includeSystemApplicationHealthStatistics !== undefined) ? options.includeSystemApplicationHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined && typeof nodesHealthStateFilter !== 'number') {
      throw new Error('nodesHealthStateFilter must be of type number.');
    }
    if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined && typeof applicationsHealthStateFilter !== 'number') {
      throw new Error('applicationsHealthStateFilter must be of type number.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined && typeof includeSystemApplicationHealthStatistics !== 'boolean') {
      throw new Error('includeSystemApplicationHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined) {
    queryParameters.push('NodesHealthStateFilter=' + encodeURIComponent(nodesHealthStateFilter.toString()));
  }
  if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined) {
    queryParameters.push('ApplicationsHealthStateFilter=' + encodeURIComponent(applicationsHealthStateFilter.toString()));
  }
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined) {
    queryParameters.push('IncludeSystemApplicationHealthStatistics=' + encodeURIComponent(includeSystemApplicationHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using the specified
 * policy.
 *
 * Gets the health of a Service Fabric cluster.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
 * filter the collection of nodes and applications returned based on their
 * aggregated health state.
 * Use ClusterHealthPolicies to override the health policies used to evaluate
 * the health.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
 * node health state objects returned in the result of cluster health query
 * based on their health state. The possible values for this parameter include
 * integer value of one of the
 * following health states. Only nodes that match the filter are returned. All
 * nodes are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of nodes with
 * HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
 * the application health state objects returned in the result of cluster
 * health
 * query based on their health state.
 * The possible values for this parameter include integer value obtained from
 * members or bitwise operations
 * on members of HealthStateFilter enumeration. Only applications that match
 * the filter are returned.
 * All applications are used to evaluate the aggregated health state. If not
 * specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of applications
 * with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {boolean} [options.includeSystemApplicationHealthStatistics]
 * Indicates whether the health statistics should include the fabric:/System
 * application health statistics. False by default.
 * If IncludeSystemApplicationHealthStatistics is set to true, the health
 * statistics include the entities that belong to the fabric:/System
 * application.
 * Otherwise, the query result includes health statistics only for user
 * applications.
 * The health statistics must be included in the query result for this
 * parameter to be applied.
 *
 *
 * @param {object} [options.clusterHealthPolicies] Describes the health
 * policies used to evaluate the cluster health.
 * If not present, the health evaluation uses the cluster health policy defined
 * in the cluster manifest or the default cluster health policy.
 * By default, each application is evaluated using its specific application
 * health policy, defined in the application manifest, or the default health
 * policy, if no policy is defined in manifest.
 * If the application health policy map is specified, and it has an entry for
 * an application, the specified application health policy
 * is used to evaluate the application health.
 *
 *
 * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
 *
 * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy]
 *
 * @param {boolean}
 * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array}
 * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthUsingPolicy(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let nodesHealthStateFilter = (options && options.nodesHealthStateFilter !== undefined) ? options.nodesHealthStateFilter : 0;
  let applicationsHealthStateFilter = (options && options.applicationsHealthStateFilter !== undefined) ? options.applicationsHealthStateFilter : 0;
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let includeSystemApplicationHealthStatistics = (options && options.includeSystemApplicationHealthStatistics !== undefined) ? options.includeSystemApplicationHealthStatistics : false;
  let clusterHealthPolicies = (options && options.clusterHealthPolicies !== undefined) ? options.clusterHealthPolicies : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined && typeof nodesHealthStateFilter !== 'number') {
      throw new Error('nodesHealthStateFilter must be of type number.');
    }
    if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined && typeof applicationsHealthStateFilter !== 'number') {
      throw new Error('applicationsHealthStateFilter must be of type number.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined && typeof includeSystemApplicationHealthStatistics !== 'boolean') {
      throw new Error('includeSystemApplicationHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined) {
    queryParameters.push('NodesHealthStateFilter=' + encodeURIComponent(nodesHealthStateFilter.toString()));
  }
  if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined) {
    queryParameters.push('ApplicationsHealthStateFilter=' + encodeURIComponent(applicationsHealthStateFilter.toString()));
  }
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined) {
    queryParameters.push('IncludeSystemApplicationHealthStatistics=' + encodeURIComponent(includeSystemApplicationHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthPolicies !== null && clusterHealthPolicies !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthPolicies']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthPolicies, 'clusterHealthPolicies');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthPolicies, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using health chunks.
 *
 * Gets the health of a Service Fabric cluster using health chunks. Includes
 * the aggregated health state of the cluster, but none of the cluster
 * entities.
 * To expand the cluster health and get the health state of all or some of the
 * entities, use the POST URI and specify the cluster health chunk query
 * description.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealthChunk} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthChunk(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealthChunk';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealthChunk']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using health chunks.
 *
 * Gets the health of a Service Fabric cluster using health chunks. The health
 * evaluation is done based on the input cluster health chunk query
 * description.
 * The query description allows users to specify health policies for evaluating
 * the cluster and its children.
 * Users can specify very flexible filters to select which cluster entities to
 * return. The selection can be done based on the entities health state and
 * based on the hierarchy.
 * The query can return multi-level children of the entities based on the
 * specified filters. For example, it can return one application with a
 * specified name, and for this application, return
 * only services that are in Error or Warning, and all partitions and replicas
 * for one of these services.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
 * cluster and application health policies used to evaluate the cluster health
 * and the filters to select which cluster entities to be returned.
 * If the cluster health policy is present, it is used to evaluate the cluster
 * events and the cluster nodes. If not present, the health evaluation uses the
 * cluster health policy defined in the cluster manifest or the default cluster
 * health policy.
 * By default, each application is evaluated using its specific application
 * health policy, defined in the application manifest, or the default health
 * policy, if no policy is defined in manifest.
 * If the application health policy map is specified, and it has an entry for
 * an application, the specified application health policy
 * is used to evaluate the application health.
 * Users can specify very flexible filters to select which cluster entities to
 * include in response. The selection can be done based on the entities health
 * state and based on the hierarchy.
 * The query can return multi-level children of the entities based on the
 * specified filters. For example, it can return one application with a
 * specified name, and for this application, return
 * only services that are in Error or Warning, and all partitions and replicas
 * for one of these services.
 *
 *
 * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
 * Defines a list of filters that specify which nodes to be included in the
 * returned cluster health chunk.
 * If no filters are specified, no nodes are returned. All the nodes are used
 * to evaluate the cluster's aggregated health state, regardless of the input
 * filters.
 * The cluster health chunk query may specify multiple node filters.
 * For example, it can specify a filter to return all nodes with health state
 * Error and another filter to always include a node identified by its
 * NodeName.
 *
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
 * list of filters that specify which applications to be included in the
 * returned cluster health chunk.
 * If no filters are specified, no applications are returned. All the
 * applications are used to evaluate the cluster's aggregated health state,
 * regardless of the input filters.
 * The cluster health chunk query may specify multiple application filters.
 * For example, it can specify a filter to return all applications with health
 * state Error and another filter to always include applications of a specified
 * application type.
 *
 *
 * @param {object}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy]
 *
 * @param {boolean}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {object}
 * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealthChunk} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let clusterHealthChunkQueryDescription = (options && options.clusterHealthChunkQueryDescription !== undefined) ? options.clusterHealthChunkQueryDescription : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealthChunk';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthChunkQueryDescription !== null && clusterHealthChunkQueryDescription !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthChunkQueryDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthChunkQueryDescription, 'clusterHealthChunkQueryDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthChunkQueryDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealthChunk']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric cluster.
 *
 * Sends a health report on a Service Fabric cluster. The report must contain
 * the information about the source of the health report and property on which
 * it is reported.
 * The report is sent to a Service Fabric gateway node, which forwards to the
 * health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetClusterHealth and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportClusterHealth(healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/ReportClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of fabric code versions that are provisioned in a
 * Service Fabric cluster.
 *
 * Gets a list of information about fabric code versions that are provisioned
 * in the cluster. The parameter CodeVersion can be used to optionally filter
 * the output to only that particular version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.codeVersion] The product version of Service Fabric.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProvisionedFabricCodeVersionInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let codeVersion = (options && options.codeVersion !== undefined) ? options.codeVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (codeVersion !== null && codeVersion !== undefined && typeof codeVersion.valueOf() !== 'string') {
      throw new Error('codeVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetProvisionedCodeVersions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (codeVersion !== null && codeVersion !== undefined) {
    queryParameters.push('CodeVersion=' + encodeURIComponent(codeVersion));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FabricCodeVersionInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'FabricCodeVersionInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of fabric config versions that are provisioned in a
 * Service Fabric cluster.
 *
 * Gets a list of information about fabric config versions that are provisioned
 * in the cluster. The parameter ConfigVersion can be used to optionally filter
 * the output to only that particular version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.configVersion] The config version of Service
 * Fabric.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProvisionedFabricConfigVersionInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let configVersion = (options && options.configVersion !== undefined) ? options.configVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (configVersion !== null && configVersion !== undefined && typeof configVersion.valueOf() !== 'string') {
      throw new Error('configVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetProvisionedConfigVersions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (configVersion !== null && configVersion !== undefined) {
    queryParameters.push('ConfigVersion=' + encodeURIComponent(configVersion));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FabricConfigVersionInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'FabricConfigVersionInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of the current cluster upgrade.
 *
 * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
 * currently in progress, gets the last state of the previous cluster upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterUpgradeProgressObject} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterUpgradeProgress(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetUpgradeProgress';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterUpgradeProgressObject']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the Service Fabric standalone cluster configuration.
 *
 * Get the Service Fabric standalone cluster configuration. The cluster
 * configuration contains properties of the cluster that include different node
 * types on the cluster,
 * security configurations, fault and upgrade domain topologies etc.
 *
 *
 * @param {string} configurationApiVersion The API version of the Standalone
 * cluster json configuration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterConfiguration} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterConfiguration(configurationApiVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (configurationApiVersion === null || configurationApiVersion === undefined || typeof configurationApiVersion.valueOf() !== 'string') {
      throw new Error('configurationApiVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterConfiguration';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ConfigurationApiVersion=' + encodeURIComponent(configurationApiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterConfiguration']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the cluster configuration upgrade status of a Service Fabric
 * standalone cluster.
 *
 * Get the cluster configuration upgrade status of a Service Fabric standalone
 * cluster.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterConfigurationUpgradeStatusInfo} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterConfigurationUpgradeStatus(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterConfigurationUpgradeStatus';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterConfigurationUpgradeStatusInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Provision the code or configuration packages of a Service Fabric
 * cluster.
 *
 * Validate and provision the code or configuration packages of a Service
 * Fabric cluster.
 *
 * @param {object} provisionFabricDescription Describes the parameters for
 * provisioning a cluster.
 *
 * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
 * package file path.
 *
 * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
 * cluster manifest file path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _provisionCluster(provisionFabricDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (provisionFabricDescription === null || provisionFabricDescription === undefined) {
      throw new Error('provisionFabricDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Provision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (provisionFabricDescription !== null && provisionFabricDescription !== undefined) {
      let requestModelMapper = new client.models['ProvisionFabricDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, provisionFabricDescription, 'provisionFabricDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(provisionFabricDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Unprovision the code or configuration packages of a Service Fabric
 * cluster.
 *
 * Unprovision the code or configuration packages of a Service Fabric cluster.
 *
 * @param {object} unprovisionFabricDescription Describes the parameters for
 * unprovisioning a cluster.
 *
 * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
 * package version.
 *
 * @param {string} [unprovisionFabricDescription.configVersion] The cluster
 * manifest version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _unprovisionCluster(unprovisionFabricDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (unprovisionFabricDescription === null || unprovisionFabricDescription === undefined) {
      throw new Error('unprovisionFabricDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Unprovision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (unprovisionFabricDescription !== null && unprovisionFabricDescription !== undefined) {
      let requestModelMapper = new client.models['UnprovisionFabricDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, unprovisionFabricDescription, 'unprovisionFabricDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(unprovisionFabricDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Rollback the upgrade of a Service Fabric cluster.
 *
 * Rollback the upgrade of a Service Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rollbackClusterUpgrade(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RollbackUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Make the cluster upgrade move on to the next upgrade domain.
 *
 * Make the cluster upgrade move on to the next upgrade domain.
 *
 * @param {object} resumeClusterUpgradeDescription Describes the parameters for
 * resuming a cluster upgrade.
 *
 * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
 * upgrade domain for this cluster upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeClusterUpgrade(resumeClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (resumeClusterUpgradeDescription === null || resumeClusterUpgradeDescription === undefined) {
      throw new Error('resumeClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/MoveToNextUpgradeDomain';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (resumeClusterUpgradeDescription !== null && resumeClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ResumeClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, resumeClusterUpgradeDescription, 'resumeClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(resumeClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start upgrading the code or configuration version of a Service
 * Fabric cluster.
 *
 * Validate the supplied upgrade parameters and start upgrading the code or
 * configuration version of a Service Fabric cluster if the parameters are
 * valid.
 *
 * @param {object} startClusterUpgradeDescription Describes the parameters for
 * starting a cluster upgrade.
 *
 * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
 * code version.
 *
 * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
 * configuration version.
 *
 * @param {string} [startClusterUpgradeDescription.upgradeKind] Possible values
 * include: 'Invalid', 'Rolling'
 *
 * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] Possible
 * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 *
 * @param {number}
 * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
 *
 * @param {boolean} [startClusterUpgradeDescription.forceRestart]
 *
 * @param {object} [startClusterUpgradeDescription.monitoringPolicy]
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.failureAction] Possible
 * values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 *
 * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy]
 *
 * @param {boolean}
 * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array}
 * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {boolean}
 * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
 * enables delta health evaluation rather than absolute health evaluation after
 * completion of each upgrade domain.
 *
 * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
 * The maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the nodes at
 * the beginning of upgrade and the state of the nodes at the time of the
 * health evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 *
 * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
 *
 * @param {array}
 * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startClusterUpgrade(startClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (startClusterUpgradeDescription === null || startClusterUpgradeDescription === undefined) {
      throw new Error('startClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Upgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (startClusterUpgradeDescription !== null && startClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['StartClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, startClusterUpgradeDescription, 'startClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(startClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start upgrading the configuration of a Service Fabric standalone
 * cluster.
 *
 * Validate the supplied configuration upgrade parameters and start upgrading
 * the cluster configuration if the parameters are valid.
 *
 * @param {object} clusterConfigurationUpgradeDescription Parameters for a
 * standalone cluster configuration upgrade.
 *
 * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
 * cluster configuration.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
 * of time between attempts to perform a health checks if the application or
 * cluster is not healthy.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
 * The length of time to wait after completing an upgrade domain before
 * starting the health checks process.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
 * The length of time that the application or cluster must remain healthy.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
 * timeout for the upgrade domain.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
 * timeout.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications during the upgrade.
 * Allowed values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
 * values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
 * maximum allowed percentage of delta health degradation during the upgrade.
 * Allowed values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain delta health degradation
 * during the upgrade. Allowed values are integer values from zero to 100.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (clusterConfigurationUpgradeDescription === null || clusterConfigurationUpgradeDescription === undefined) {
      throw new Error('clusterConfigurationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/StartClusterConfigurationUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterConfigurationUpgradeDescription !== null && clusterConfigurationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ClusterConfigurationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterConfigurationUpgradeDescription, 'clusterConfigurationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterConfigurationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
 *
 * Update the upgrade parameters of a Service Fabric cluster upgrade.
 *
 * @param {object} updateClusterUpgradeDescription Parameters for updating a
 * cluster upgrade.
 *
 * @param {string} [updateClusterUpgradeDescription.upgradeKind] Possible
 * values include: 'Invalid', 'Rolling', 'Rolling_ForceRestart'
 *
 * @param {object} [updateClusterUpgradeDescription.updateDescription]
 *
 * @param {string}
 * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.updateDescription.forceRestart]
 *
 * @param {number}
 * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.failureAction] Possible
 * values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
 *
 * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation]
 *
 * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
 * The maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the nodes at
 * the beginning of upgrade and the state of the nodes at the time of the
 * health evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 *
 * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
 *
 * @param {array}
 * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateClusterUpgrade(updateClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (updateClusterUpgradeDescription === null || updateClusterUpgradeDescription === undefined) {
      throw new Error('updateClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (updateClusterUpgradeDescription !== null && updateClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['UpdateClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, updateClusterUpgradeDescription, 'updateClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(updateClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Azure Active Directory metadata used for secured
 * connection to cluster.
 *
 * Gets the Azure Active Directory metadata used for secured connection to
 * cluster.
 * This API is not supposed to be called separately. It provides information
 * needed to set up an Azure Active Directory secured connection with a Service
 * Fabric cluster.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AadMetadataObject} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAadMetadata(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetAadMetadata';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AadMetadataObject']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of nodes in the Service Fabric cluster.
 *
 * The Nodes endpoint returns information about the nodes in the Service Fabric
 * Cluster. The respons include the name, status, id, health, uptime and other
 * details about the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
 * on the NodeStatus. Only the nodes that are matching the specified filter
 * value will be returned. The filter value can be one of the following.
 *
 * - default - This filter value will match all of the nodes excepts the ones
 * with with status as Unknown or Removed.
 * - all - This filter value will match all of the nodes.
 * - up - This filter value will match nodes that are Up.
 * - down - This filter value will match nodes that are Down.
 * - enabling - This filter value will match nodes that are in the process of
 * being enabled with status as Enabling.
 * - disabling - This filter value will match nodes that are in the process of
 * being disabled with status as Disabling.
 * - disabled - This filter value will match nodes that are Disabled.
 * - unknown - This filter value will match nodes whose status is Unknown. A
 * node would be in Unknown state if Service Fabric does not have authoritative
 * information about that node. This can happen if the system learns about a
 * node at runtime.
 * - removed - This filter value will match nodes whose status is Removed.
 * These are the nodes that are removed from the cluster using the
 * RemoveNodeState API.
 * . Possible values include: 'default', 'all', 'up', 'down', 'enabling',
 * 'disabling', 'disabled', 'unknown', 'removed'
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedNodeInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let nodeStatusFilter = (options && options.nodeStatusFilter !== undefined) ? options.nodeStatusFilter : 'default';
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (nodeStatusFilter !== null && nodeStatusFilter !== undefined && typeof nodeStatusFilter.valueOf() !== 'string') {
      throw new Error('nodeStatusFilter must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (nodeStatusFilter !== null && nodeStatusFilter !== undefined) {
    queryParameters.push('NodeStatusFilter=' + encodeURIComponent(nodeStatusFilter));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedNodeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of nodes in the Service Fabric cluster.
 *
 * Gets the information about a specific node in the Service Fabric Cluster.The
 * respons include the name, status, id, health, uptime and other details about
 * the node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeInfo(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric node.
 *
 * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
 * filter the collection of health events reported on the node based on the
 * health state. If the node that you specify by name does not exist in the
 * health store, this returns an error.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeHealth(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric node, by using the specified
 * health policy.
 *
 * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
 * filter the collection of health events reported on the node based on the
 * health state. Use ClusterHealthPolicy in the POST body to override the
 * health policies used to evaluate the health. If the node that you specify by
 * name does not exist in the health store, this returns an error.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.clusterHealthPolicy] Describes the health policies
 * used to evaluate the health of a cluster or node. If not present, the health
 * evaluation uses the health policy from cluster manifest or the default
 * health policy.
 *
 * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
 * allowed percentage of unhealthy applications before reporting an error. For
 * example, to allow 10% of applications to be unhealthy, this value would be
 * 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeHealthUsingPolicy(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let clusterHealthPolicy = (options && options.clusterHealthPolicy !== undefined) ? options.clusterHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthPolicy !== null && clusterHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthPolicy, 'clusterHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric node.
 *
 * Reports health state of the specified Service Fabric node. The report must
 * contain the information about the source of the health report and property
 * on which it is reported.
 * The report is sent to a Service Fabric gateway node, which forwards to the
 * health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run GetNodeHealth
 * and check that the report appears in the HealthEvents section.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportNodeHealth(nodeName, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the load information of a Service Fabric node.
 *
 * Gets the load information of a Service Fabric node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeLoadInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeLoadInfo(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeLoadInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deactivate a Service Fabric cluster node with the specified
 * deactivation intent.
 *
 * Deactivate a Service Fabric cluster node with the specified deactivation
 * intent. Once the deactivation is in progress, the deactivation intent can be
 * increased, but not decreased (for example, a node which is was deactivated
 * with the Pause intent can be deactivated further with Restart, but not the
 * other way around. Nodes may be reactivated using the Activate a node
 * operation any time after they are deactivated. If the deactivation is not
 * complete this will cancel the deactivation. A node which goes down and comes
 * back up while deactivated will still need to be reactivated before services
 * will be placed on that node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} deactivationIntentDescription Describes the intent or reason
 * for deactivating the node.
 *
 * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
 * the intent or reason for deactivating the node. The possible values are
 * following.
 * - Pause - Indicates that the node should be paused. The value is 1.
 * - Restart - Indicates that the intent is for the node to be restarted after
 * a short period of time. The value is 2.
 * - RemoveData - Indicates the intent is for the node to remove data. The
 * value is 3.
 * . Possible values include: 'Pause', 'Restart', 'RemoveData'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disableNode(nodeName, deactivationIntentDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (deactivationIntentDescription === null || deactivationIntentDescription === undefined) {
      throw new Error('deactivationIntentDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Deactivate';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deactivationIntentDescription !== null && deactivationIntentDescription !== undefined) {
      let requestModelMapper = new client.models['DeactivationIntentDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, deactivationIntentDescription, 'deactivationIntentDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deactivationIntentDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Activate a Service Fabric cluster node which is currently
 * deactivated.
 *
 * Activates a Service Fabric cluster node which is currently deactivated. Once
 * activated, the node will again become a viable target for placing new
 * replicas, and any deactivated replicas remaining on the node will be
 * reactivated.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enableNode(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Activate';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Notifies Service Fabric that the persisted state on a node has been
 * permanently removed or lost.
 *
 * Notifies Service Fabric that the persisted state on a node has been
 * permanently removed or lost.  This implies that it is not possible to
 * recover the persisted state of that node. This generally happens if a hard
 * disk has been wiped clean, or if a hard disk crashes. The node has to be
 * down for this operation to be successful. This operation lets Service Fabric
 * know that the replicas on that node no longer exist, and that Service Fabric
 * should stop waiting for those replicas to come back up. Do not run this
 * cmdlet if the state on the node has not been removed and the node can comes
 * back up with its state intact.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeNodeState(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/RemoveNodeState';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a Service Fabric cluster node.
 *
 * Restarts a Service Fabric cluster node that is already started.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} restartNodeDescription The instance of the node to be
 * restarted and a flag indicating the need to take dump of the fabric process.
 *
 * @param {string} restartNodeDescription.nodeInstanceId The instance id of the
 * target node. If instance id is specified the node is restarted only if it
 * matches with the current instance of the node. A default value of "0" would
 * match any instance id. The instance id can be obtained using get node query.
 *
 * @param {string} [restartNodeDescription.createFabricDump] Specify True to
 * create a dump of the fabric node process. This is case sensitive. Possible
 * values include: 'False', 'True'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartNode(nodeName, restartNodeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (restartNodeDescription === null || restartNodeDescription === undefined) {
      throw new Error('restartNodeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (restartNodeDescription !== null && restartNodeDescription !== undefined) {
      let requestModelMapper = new client.models['RestartNodeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, restartNodeDescription, 'restartNodeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(restartNodeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of application types in the Service Fabric cluster.
 *
 * Returns the information about the application types that are provisioned or
 * in the process of being provisioned in the Service Fabric cluster. Each
 * version of an application type is returned as one application type. The
 * response includes the name, version, status and other details about the
 * application type. This is a paged query, meaning that if not all of the
 * application types fit in a page, one page of results is returned as well as
 * a continuation token which can be used to get the next page. For example, if
 * there are 10 application types but a page only fits the first 3 application
 * types, or if max results is set to 3, then 3 is returned. To access the rest
 * of the results, retrieve subsequent pages by using the returned continuation
 * token in the next query. An empty continuation token is returned if there
 * are no subsequent pages.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
 * on ApplicationTypeDefinitionKind for application type query operations.
 * - Default - Default value. Filter that matches input with any
 * ApplicationTypeDefinitionKind value. The value is 0.
 * - All - Filter that matches input with any ApplicationTypeDefinitionKind
 * value. The value is 65535.
 * - ServiceFabricApplicationPackage - Filter that matches input with
 * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
 * value is 1.
 * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
 * value Compose. The value is 2.
 *
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged queries includes as much
 * results as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationTypeInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationTypeInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationTypeDefinitionKindFilter = (options && options.applicationTypeDefinitionKindFilter !== undefined) ? options.applicationTypeDefinitionKindFilter : 65535;
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeDefinitionKindFilter !== null && applicationTypeDefinitionKindFilter !== undefined && typeof applicationTypeDefinitionKindFilter !== 'number') {
      throw new Error('applicationTypeDefinitionKindFilter must be of type number.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (applicationTypeDefinitionKindFilter !== null && applicationTypeDefinitionKindFilter !== undefined) {
    queryParameters.push('ApplicationTypeDefinitionKindFilter=' + encodeURIComponent(applicationTypeDefinitionKindFilter.toString()));
  }
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationTypeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of application types in the Service Fabric cluster
 * matching exactly the specified name.
 *
 * Returns the information about the application types that are provisioned or
 * in the process of being provisioned in the Service Fabric cluster. These
 * results are of application types whose name match exactly the one specified
 * as the parameter, and which comply with the given query parameters. All
 * versions of the application type matching the application type name are
 * returned, with each version returned as one application type. The response
 * includes the name, version, status and other details about the application
 * type. This is a paged query, meaning that if not all of the application
 * types fit in a page, one page of results is returned as well as a
 * continuation token which can be used to get the next page. For example, if
 * there are 10 application types but a page only fits the first 3 application
 * types, or if max results is set to 3, then 3 is returned. To access the rest
 * of the results, retrieve subsequent pages by using the returned continuation
 * token in the next query. An empty continuation token is returned if there
 * are no subsequent pages.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged queries includes as much
 * results as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationTypeInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationTypeInfoListByName(applicationTypeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationTypeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Provisions or registers a Service Fabric application type with the
 * cluster.
 *
 * Provisions or registers a Service Fabric application type with the cluster.
 * This is required before any new applications can be instantiated.
 *
 * @param {object} applicationTypeImageStorePath The relative path for the
 * application package in the image store specified during the prior copy
 * operation.
 *
 * @param {string} applicationTypeImageStorePath.applicationTypeBuildPath The
 * relative image store path to the application package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _provisionApplicationType(applicationTypeImageStorePath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeImageStorePath === null || applicationTypeImageStorePath === undefined) {
      throw new Error('applicationTypeImageStorePath cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/$/Provision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationTypeImageStorePath !== null && applicationTypeImageStorePath !== undefined) {
      let requestModelMapper = new client.models['ApplicationTypeImageStorePath']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationTypeImageStorePath, 'applicationTypeImageStorePath');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationTypeImageStorePath, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes or unregisters a Service Fabric application type from the
 * cluster.
 *
 * Removes or unregisters a Service Fabric application type from the cluster.
 * This operation can only be performed if all application instance of the
 * application type has been deleted. Once the application type is
 * unregistered, no new application instance can be created for this particular
 * application type.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {object} applicationTypeImageStoreVersion The version of the
 * application type in the image store.
 *
 * @param {string} applicationTypeImageStoreVersion.applicationTypeVersion
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _unprovisionApplicationType(applicationTypeName, applicationTypeImageStoreVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeImageStoreVersion === null || applicationTypeImageStoreVersion === undefined) {
      throw new Error('applicationTypeImageStoreVersion cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/Unprovision';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationTypeImageStoreVersion !== null && applicationTypeImageStoreVersion !== undefined) {
      let requestModelMapper = new client.models['ApplicationTypeImageStoreVersion']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationTypeImageStoreVersion, 'applicationTypeImageStoreVersion');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationTypeImageStoreVersion, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list containing the information about service types that
 * are supported by a provisioned application type in a Service Fabric cluster.
 *
 * Gets the list containing the information about service types that are
 * supported by a provisioned application type in a Service Fabric cluster. The
 * response includes the name of the service type, the name and version of the
 * service manifest the type is defined in, kind (stateless or stateless) of
 * the service type and other information about it.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetServiceTypes';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'ServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the manifest describing a service type.
 *
 * Gets the manifest describing a service type. The response contains the
 * service manifest XML as a string.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {string} serviceManifestName The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceTypeManifest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName === null || serviceManifestName === undefined || typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetServiceManifest';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceTypeManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list containing the information about service types from
 * the applications deployed on a node in a Service Fabric cluster.
 *
 * Gets the list containing the information about service types from the
 * applications deployed on a node in a Service Fabric cluster. The response
 * includes the name of the service type, its registration status, the code
 * package that registered it and activation id of the service package.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of the service
 * manifest to filter the list of deployed service type information. If
 * specified, the response will only contain the information about service
 * types that are defined in this service manifest.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceTypeInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a specified service type of the
 * application deployed on a node in a Service Fabric cluster.
 *
 * Gets the list containing the information about a specific service type from
 * the applications deployed on a node in a Service Fabric cluster. The
 * response includes the name of the service type, its registration status, the
 * code package that registered it and activation id of the service package.
 * Each entry represents one activation of a service type, differentiated by
 * the activation id.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceTypeName Specifies the name of a Service Fabric
 * service type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of the service
 * manifest to filter the list of deployed service type information. If
 * specified, the response will only contain the information about service
 * types that are defined in this service manifest.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceTypeName === null || serviceTypeName === undefined || typeof serviceTypeName.valueOf() !== 'string') {
      throw new Error('serviceTypeName cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{serviceTypeName}', serviceTypeName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric application.
 *
 * Creates a Service Fabric application using the specified description.
 *
 * @param {object} applicationDescription Description for creating an
 * application.
 *
 * @param {string} applicationDescription.name
 *
 * @param {string} applicationDescription.typeName
 *
 * @param {string} applicationDescription.typeVersion
 *
 * @param {array} [applicationDescription.parameterList]
 *
 * @param {object} [applicationDescription.applicationCapacity]
 *
 * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
 * The minimum number of nodes where Service Fabric will reserve capacity for
 * this application. Note that this does not mean that the services of this
 * application will be placed on all of those nodes. If this property is set to
 * zero, no capacity will be reserved. The value of this property cannot be
 * more than the value of the MaximumNodes property.
 *
 * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
 * The maximum number of nodes where Service Fabric will reserve capacity for
 * this application. Note that this does not mean that the services of this
 * application will be placed on all of those nodes. By default, the value of
 * this property is zero and it means that the services can be placed on any
 * node.
 *
 * @param {array}
 * [applicationDescription.applicationCapacity.applicationMetrics]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createApplication(applicationDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationDescription === null || applicationDescription === undefined) {
      throw new Error('applicationDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationDescription !== null && applicationDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationDescription, 'applicationDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric application.
 *
 * Deletes an existing Service Fabric application. An application must be
 * created before it can be deleted. Deleting an application will delete all
 * services that are part of that application. By default Service Fabric will
 * try to close service replicas in a graceful manner and then delete the
 * service. However if service is having issues closing the replica gracefully,
 * the delete operation may take a long time or get stuck. Use the optional
 * ForceRemove flag to skip the graceful close sequence and forcefully delete
 * the application and all of the its services.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteApplication(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/Delete';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets load information about a Service Fabric application.
 *
 * Returns the load information about the application that was created or in
 * the process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * minimum nodes, maximum nodes, the number of nodes the app is occupying
 * currently, and application load metric information about the application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationLoadInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationLoadInfo(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationLoadInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of applications created in the Service Fabric cluster
 * that match filters specified as the parameter.
 *
 * Gets the information about the applications that were created or in the
 * process of being created in the Service Fabric cluster and match filters
 * specified as the parameter. The response includes the name, type, status,
 * parameters and other details about the application. If the applications do
 * not fit in a page, one page of results is returned as well as a continuation
 * token which can be used to get the next page.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
 * ApplicationDefinitionKind for application query operations.
 * - Default - Default value. Filter that matches input with any
 * ApplicationDefinitionKind value. The value is 0.
 * - All - Filter that matches input with any ApplicationDefinitionKind value.
 * The value is 65535.
 * - ServiceFabricApplicationDescription - Filter that matches input with
 * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
 * value is 1.
 * - Compose - Filter that matches input with ApplicationDefinitionKind value
 * Compose. The value is 2.
 *
 *
 * @param {string} [options.applicationTypeName] The application type name used
 * to filter the applications to query for. This value should not contain the
 * application type version.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationDefinitionKindFilter = (options && options.applicationDefinitionKindFilter !== undefined) ? options.applicationDefinitionKindFilter : 65535;
  let applicationTypeName = (options && options.applicationTypeName !== undefined) ? options.applicationTypeName : undefined;
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationDefinitionKindFilter !== null && applicationDefinitionKindFilter !== undefined && typeof applicationDefinitionKindFilter !== 'number') {
      throw new Error('applicationDefinitionKindFilter must be of type number.');
    }
    if (applicationTypeName !== null && applicationTypeName !== undefined && typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (applicationDefinitionKindFilter !== null && applicationDefinitionKindFilter !== undefined) {
    queryParameters.push('ApplicationDefinitionKindFilter=' + encodeURIComponent(applicationDefinitionKindFilter.toString()));
  }
  if (applicationTypeName !== null && applicationTypeName !== undefined) {
    queryParameters.push('ApplicationTypeName=' + encodeURIComponent(applicationTypeName));
  }
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information about a Service Fabric application.
 *
 * Returns the information about the application that was created or in the
 * process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * type, status, parameters and other details about the application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationInfo(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the service fabric application.
 *
 * Returns the heath state of the service fabric application. The response
 * reports either Ok, Error or Warning health state. If the entity is not found
 * in the helath store, it will return Error.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
 * filtering of the deployed applications health state objects returned in the
 * result of application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states. Only deployed applications that match the filter
 * will be returned.\
 * All deployed applications are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these value obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of deployed
 * applications with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
 * services health state objects returned in the result of services health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only services that match the filter are returned. All services are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of services with HealthState value of OK (2) and Warning
 * (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationHealth(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedApplicationsHealthStateFilter = (options && options.deployedApplicationsHealthStateFilter !== undefined) ? options.deployedApplicationsHealthStateFilter : 0;
  let servicesHealthStateFilter = (options && options.servicesHealthStateFilter !== undefined) ? options.servicesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined && typeof deployedApplicationsHealthStateFilter !== 'number') {
      throw new Error('deployedApplicationsHealthStateFilter must be of type number.');
    }
    if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined && typeof servicesHealthStateFilter !== 'number') {
      throw new Error('servicesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined) {
    queryParameters.push('DeployedApplicationsHealthStateFilter=' + encodeURIComponent(deployedApplicationsHealthStateFilter.toString()));
  }
  if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined) {
    queryParameters.push('ServicesHealthStateFilter=' + encodeURIComponent(servicesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric application using the specified
 * policy.
 *
 * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
 * to filter the collection of health events reported on the node based on the
 * health state. Use ClusterHealthPolicies to override the health policies used
 * to evaluate the health.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
 * filtering of the deployed applications health state objects returned in the
 * result of application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states. Only deployed applications that match the filter
 * will be returned.\
 * All deployed applications are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value could be a
 * combination of these value obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of deployed
 * applications with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
 * services health state objects returned in the result of services health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only services that match the filter are returned. All services are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of services with HealthState value of OK (2) and Warning
 * (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationHealthUsingPolicy(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedApplicationsHealthStateFilter = (options && options.deployedApplicationsHealthStateFilter !== undefined) ? options.deployedApplicationsHealthStateFilter : 0;
  let servicesHealthStateFilter = (options && options.servicesHealthStateFilter !== undefined) ? options.servicesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined && typeof deployedApplicationsHealthStateFilter !== 'number') {
      throw new Error('deployedApplicationsHealthStateFilter must be of type number.');
    }
    if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined && typeof servicesHealthStateFilter !== 'number') {
      throw new Error('servicesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined) {
    queryParameters.push('DeployedApplicationsHealthStateFilter=' + encodeURIComponent(deployedApplicationsHealthStateFilter.toString()));
  }
  if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined) {
    queryParameters.push('ServicesHealthStateFilter=' + encodeURIComponent(servicesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric application.
 *
 * Reports health state of the specified Service Fabric application. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Application, which forwards
 * to the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get application
 * health and check that the report appears in the HealthEvents section.
 *
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportApplicationHealth(applicationId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts upgrading an application in the Service Fabric cluster.
 *
 * Validates the supplied application upgrade parameters and starts upgrading
 * the application if the parameters are valid.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} applicationUpgradeDescription Parameters for an application
 * upgrade.
 *
 * @param {string} applicationUpgradeDescription.name
 *
 * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
 *
 * @param {array} applicationUpgradeDescription.parameters
 *
 * @param {string} applicationUpgradeDescription.upgradeKind Possible values
 * include: 'Invalid', 'Rolling'
 *
 * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] Possible
 * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 *
 * @param {number}
 * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
 *
 * @param {boolean} [applicationUpgradeDescription.forceRestart]
 *
 * @param {object} [applicationUpgradeDescription.monitoringPolicy]
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.failureAction] Possible
 * values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 *
 * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
 *
 * @param {boolean}
 * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array}
 * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (applicationUpgradeDescription === null || applicationUpgradeDescription === undefined) {
      throw new Error('applicationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/Upgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationUpgradeDescription !== null && applicationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationUpgradeDescription, 'applicationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest upgrade performed on this application.
 *
 * Returns information about the state of the latest application upgrade along
 * with details to aid debugging application health issues.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationUpgradeProgressInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationUpgrade(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetUpgradeProgress';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationUpgradeProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates an ongoing application upgrade in the Service Fabric
 * cluster.
 *
 * Updates the parameters of an ongoing application upgrade from the ones
 * specified at the time of starting the application upgrade. This may be
 * required to mitigate stuck application upgrades due to incorrect parameters
 * or issues in the application to make progress.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} applicationUpgradeUpdateDescription Parameters for updating
 * an existing application upgrade.
 *
 * @param {string} applicationUpgradeUpdateDescription.name
 *
 * @param {string} applicationUpgradeUpdateDescription.upgradeKind Possible
 * values include: 'Invalid', 'Rolling'
 *
 * @param {object}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy]
 *
 * @param {boolean}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
 *
 * @param {string}
 * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 *
 * @param {boolean}
 * [applicationUpgradeUpdateDescription.updateDescription.forceRestart]
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.failureAction]
 * Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (applicationUpgradeUpdateDescription === null || applicationUpgradeUpdateDescription === undefined) {
      throw new Error('applicationUpgradeUpdateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/UpdateUpgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationUpgradeUpdateDescription !== null && applicationUpgradeUpdateDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationUpgradeUpdateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationUpgradeUpdateDescription, 'applicationUpgradeUpdateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationUpgradeUpdateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resumes upgrading an application in the Service Fabric cluster.
 *
 * Resumes an unmonitored manual Service Fabric application upgrade. Service
 * Fabric upgrades one upgrade domain at a time. For unmonitored manual
 * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
 * to call this API before proceeding to the next upgrade domain.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} resumeApplicationUpgradeDescription Describes the parameters
 * for resuming an application upgrade.
 *
 * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
 * name of the upgrade domain in which to resume the upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (resumeApplicationUpgradeDescription === null || resumeApplicationUpgradeDescription === undefined) {
      throw new Error('resumeApplicationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/MoveToNextUpgradeDomain';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (resumeApplicationUpgradeDescription !== null && resumeApplicationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ResumeApplicationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, resumeApplicationUpgradeDescription, 'resumeApplicationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(resumeApplicationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts rolling back the currently on-going upgrade of an
 * application in the Service Fabric cluster.
 *
 * Starts rolling back the current application upgrade to the previous version.
 * This API can only be used to rollback the current in-progress upgrade that
 * is rolling forward to new version. If the application is not currently being
 * upgraded use StartApplicationUpgrade API to upgrade it to desired version
 * including rolling back to a previous version.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rollbackApplicationUpgrade(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/RollbackUpgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of applications deployed on a Service Fabric node.
 *
 * Gets the list of applications deployed on a Service Fabric node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationInfoList(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedApplicationInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedApplicationInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about an application deployed on a Service
 * Fabric node.
 *
 * Gets the information about an application deployed on a Service Fabric node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationInfo(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of an application deployed on a
 * Service Fabric node.
 *
 * Gets the information about health of an application deployed on a Service
 * Fabric node. Use EventsHealthStateFilter to optionally filter for the
 * collection of HealthEvent objects reported on the deployed application based
 * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
 * filter for DeployedServicePackageHealth children based on health state.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
 * filtering of the deployed service package health state objects returned in
 * the result of deployed application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only deployed service packages that match the filter are returned. All
 * deployed service packages are used to evaluate the aggregated health state
 * of the deployed application.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value can be a
 * combination of these value obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of service
 * packages with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationHealth(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedServicePackagesHealthStateFilter = (options && options.deployedServicePackagesHealthStateFilter !== undefined) ? options.deployedServicePackagesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined && typeof deployedServicePackagesHealthStateFilter !== 'number') {
      throw new Error('deployedServicePackagesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined) {
    queryParameters.push('DeployedServicePackagesHealthStateFilter=' + encodeURIComponent(deployedServicePackagesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of an application deployed on a
 * Service Fabric node. using the specified policy.
 *
 * Gets the information about health of an application deployed on a Service
 * Fabric node using the specified policy. Use EventsHealthStateFilter to
 * optionally filter for the collection of HealthEvent objects reported on the
 * deployed application based on health state. Use
 * DeployedServicePackagesHealthStateFilter to optionally filter for
 * DeployedServicePackageHealth children based on health state. Use
 * ApplicationHealthPolicy to optionally override the health policies used to
 * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
 * the ApplicationHealthPolicy. The rest of the fields are ignored while
 * evaluating the health of the deployed application.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
 * filtering of the deployed service package health state objects returned in
 * the result of deployed application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only deployed service packages that match the filter are returned. All
 * deployed service packages are used to evaluate the aggregated health state
 * of the deployed application.
 * If not specified, all entries are returned.
 * The state values are flag based enumeration, so the value can be a
 * combination of these value obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of service
 * packages with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedServicePackagesHealthStateFilter = (options && options.deployedServicePackagesHealthStateFilter !== undefined) ? options.deployedServicePackagesHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined && typeof deployedServicePackagesHealthStateFilter !== 'number') {
      throw new Error('deployedServicePackagesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined) {
    queryParameters.push('DeployedServicePackagesHealthStateFilter=' + encodeURIComponent(deployedServicePackagesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric application deployed on
 * a Service Fabric node.
 *
 * Reports health state of the application deployed on a Service Fabric node.
 * The report must contain the information about the source of the health
 * report and property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get deployed
 * application health and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the manifest describing an application type.
 *
 * Gets the manifest describing an application type. The response contains the
 * application manifest XML as a string.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationTypeManifest} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationManifest(applicationTypeName, applicationTypeVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationTypeManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about all services belonging to the
 * application specified by the application id.
 *
 * Returns the information about all services belonging to the application
 * specified by the application id.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceTypeName] The service type name used to
 * filter the services to query for.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedServiceInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceInfoList(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceTypeName = (options && options.serviceTypeName !== undefined) ? options.serviceTypeName : undefined;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceTypeName !== null && serviceTypeName !== undefined && typeof serviceTypeName.valueOf() !== 'string') {
      throw new Error('serviceTypeName must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  if (serviceTypeName !== null && serviceTypeName !== undefined) {
    queryParameters.push('ServiceTypeName=' + encodeURIComponent(serviceTypeName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedServiceInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about the specific service belonging to a
 * Service Fabric application.
 *
 * Returns the information about specified service belonging to the specified
 * Service Fabric application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceInfo(applicationId, serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/{serviceId}';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the name of the Service Fabric application for a service.
 *
 * The GetApplicationName endpoint returns the name of the application for the
 * specified service.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationNameInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationNameInfo(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetApplicationName';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationNameInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates the specified service.
 *
 * Creates the specified service.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} serviceDescription The information necessary to create a
 * service.
 *
 * @param {string} [serviceDescription.applicationName]
 *
 * @param {string} serviceDescription.serviceName
 *
 * @param {string} serviceDescription.serviceTypeName
 *
 * @param {array} [serviceDescription.initializationData]
 *
 * @param {object} serviceDescription.partitionDescription
 *
 * @param {string} serviceDescription.partitionDescription.partitionScheme
 * Polymorphic Discriminator
 *
 * @param {string} [serviceDescription.placementConstraints] The placement
 * constraints as a string. Placement constraints are boolean expressions on
 * node properties and allow for restricting a service to particular nodes
 * based on the service requirements. For example, to place a service on nodes
 * where NodeType is blue specify the following: "NodeColor == blue)".
 *
 * @param {array} [serviceDescription.correlationScheme]
 *
 * @param {array} [serviceDescription.serviceLoadMetrics]
 *
 * @param {array} [serviceDescription.servicePlacementPolicies]
 *
 * @param {string} [serviceDescription.defaultMoveCost] Possible values
 * include: 'Zero', 'Low', 'Medium', 'High'
 *
 * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
 * if the DefaultMoveCost property is specified.
 *
 * @param {string} [serviceDescription.servicePackageActivationMode] Possible
 * values include: 'SharedProcess', 'ExclusiveProcess'
 *
 * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
 * service. It requires the DNS system service to be enabled in Service Fabric
 * cluster.
 *
 * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createService(applicationId, serviceDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceDescription === null || serviceDescription === undefined) {
      throw new Error('serviceDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/$/Create';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceDescription !== null && serviceDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceDescription, 'serviceDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric service from the service template defined
 * in the application manifest.
 *
 * Creates a Service Fabric service from the service template defined in the
 * application manifest.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} serviceFromTemplateDescription Describes the service that
 * needs to be created from the template defined in the application manifest.
 *
 * @param {string} serviceFromTemplateDescription.applicationName
 *
 * @param {string} serviceFromTemplateDescription.serviceName
 *
 * @param {string} serviceFromTemplateDescription.serviceTypeName
 *
 * @param {array} [serviceFromTemplateDescription.initializationData]
 *
 * @param {string}
 * [serviceFromTemplateDescription.servicePackageActivationMode] Possible
 * values include: 'SharedProcess', 'ExclusiveProcess'
 *
 * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
 * of the service. It requires the DNS system service to be enabled in Service
 * Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceFromTemplateDescription === null || serviceFromTemplateDescription === undefined) {
      throw new Error('serviceFromTemplateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/$/CreateFromTemplate';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceFromTemplateDescription !== null && serviceFromTemplateDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceFromTemplateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceFromTemplateDescription, 'serviceFromTemplateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceFromTemplateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric service.
 *
 * Deletes an existing Service Fabric service. A service must be created before
 * it can be deleted. By default Service Fabric will try to close service
 * replicas in a graceful manner and then delete the service. However if
 * service is having issues closing the replica gracefully, the delete
 * operation may take a long time or get stuck. Use the optional ForceRemove
 * flag to skip the graceful close sequence and forcefully delete the service.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteService(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/Delete';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the specified service using the given update description.
 *
 * Updates the specified service using the given update description.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} serviceUpdateDescription The information necessary to update
 * a service.
 *
 * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
 * other properties are set. Each of the associated properties corresponds to a
 * flag, specified below, which, if set, indicate that the property is
 * specified.
 * This property can be a combination of those flags obtained using bitwise
 * 'OR' operator.
 * For example, if the provided value is 6 then the flags for
 * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
 *
 * - None - Does not indicate any other properties are set. The value is zero.
 * - TargetReplicaSetSize/InstanceCount - Indicates whether the
 * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
 * property (for Stateless services) is set. The value is 1.
 * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
 * property is set. The value is  2.
 * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
 * set. The value is 4.
 * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
 * property is set. The value is 8.
 * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
 * value is 16.
 * - PlacementConstraints - Indicates the PlacementConstraints property is set.
 * The value is 32.
 * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
 * set. The value is 64.
 * - Correlation - Indicates the CorrelationScheme property is set. The value
 * is 128.
 * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
 * 256.
 * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
 * is 512.
 *
 *
 * @param {string} [serviceUpdateDescription.placementConstraints] The
 * placement constraints as a string. Placement constraints are boolean
 * expressions on node properties and allow for restricting a service to
 * particular nodes based on the service requirements. For example, to place a
 * service on nodes where NodeType is blue specify the following: "NodeColor ==
 * blue)".
 *
 * @param {array} [serviceUpdateDescription.correlationScheme]
 *
 * @param {array} [serviceUpdateDescription.loadMetrics]
 *
 * @param {array} [serviceUpdateDescription.servicePlacementPolicies]
 *
 * @param {string} [serviceUpdateDescription.defaultMoveCost] Possible values
 * include: 'Zero', 'Low', 'Medium', 'High'
 *
 * @param {string} serviceUpdateDescription.serviceKind Polymorphic
 * Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateService(serviceId, serviceUpdateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (serviceUpdateDescription === null || serviceUpdateDescription === undefined) {
      throw new Error('serviceUpdateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/Update';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceUpdateDescription !== null && serviceUpdateDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceUpdateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceUpdateDescription, 'serviceUpdateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceUpdateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the description of an existing Service Fabric service.
 *
 * Gets the description of an existing Service Fabric service. A service must
 * be created before its description can be obtained.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceDescription} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceDescription(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetDescription';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceDescription']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric service.
 *
 * Gets the health information of the specified service.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use PartitionsHealthStateFilter to filter the collection of partitions
 * returned.
 * If you specify a service that does not exist in the health store, this
 * cmdlet returns an error.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
 * the partitions health state objects returned in the result of service health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only partitions that match the filter are returned. All partitions are used
 * to evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of partitions with HealthState value of OK (2) and
 * Warning (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceHealth(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let partitionsHealthStateFilter = (options && options.partitionsHealthStateFilter !== undefined) ? options.partitionsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined && typeof partitionsHealthStateFilter !== 'number') {
      throw new Error('partitionsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined) {
    queryParameters.push('PartitionsHealthStateFilter=' + encodeURIComponent(partitionsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric service, by using
 * the specified health policy.
 *
 * Gets the health information of the specified service.
 * If the application health policy is specified, the health evaluation uses it
 * to get the aggregated health state.
 * If the policy is not specified, the health evaluation uses the application
 * health policy defined in the application manifest, or the default health
 * policy, if no policy is defined in the manifest.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use PartitionsHealthStateFilter to filter the collection of partitions
 * returned.
 * If you specify a service that does not exist in the health store, this
 * cmdlet returns an error.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
 * the partitions health state objects returned in the result of service health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only partitions that match the filter are returned. All partitions are used
 * to evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of partitions with HealthState value of OK (2) and
 * Warning (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceHealthUsingPolicy(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let partitionsHealthStateFilter = (options && options.partitionsHealthStateFilter !== undefined) ? options.partitionsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined && typeof partitionsHealthStateFilter !== 'number') {
      throw new Error('partitionsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined) {
    queryParameters.push('PartitionsHealthStateFilter=' + encodeURIComponent(partitionsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric service.
 *
 * Reports health state of the specified Service Fabric service. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetServiceHealth and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportServiceHealth(serviceId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resolve a Service Fabric partition.
 *
 * Resolve a Service Fabric service partition, to get the endpoints of the
 * service replicas.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.partitionKeyType] Key type for the partition. This
 * parameter is required if the partition scheme for the service is Int64Range
 * or Named. The possible values are following.
 * - None (1) - Indicates that the the PartitionKeyValue parameter is not
 * specified. This is valid for the partitions with partitioning scheme as
 * Singleton. This is the default value. The value is 1.
 * - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an
 * int64 partition key. This is valid for the partitions with partitioning
 * scheme as Int64Range. The value is 2.
 * - Named (3) - Indicates that the the PartitionKeyValue parameter is a name
 * of the partition. This is valid for the partitions with partitioning scheme
 * as Named. The value is 3.
 *
 *
 * @param {string} [options.partitionKeyValue] Partition key. This is required
 * if the partition scheme for the service is Int64Range or Named.
 *
 * @param {string} [options.previousRspVersion] The value in the Version field
 * of the response that was received previously. This is required if the user
 * knows that the result that was got previously is stale.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResolvedServicePartition} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resolveService(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let partitionKeyType = (options && options.partitionKeyType !== undefined) ? options.partitionKeyType : undefined;
  let partitionKeyValue = (options && options.partitionKeyValue !== undefined) ? options.partitionKeyValue : undefined;
  let previousRspVersion = (options && options.previousRspVersion !== undefined) ? options.previousRspVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionKeyType !== null && partitionKeyType !== undefined && typeof partitionKeyType !== 'number') {
      throw new Error('partitionKeyType must be of type number.');
    }
    if (partitionKeyValue !== null && partitionKeyValue !== undefined && typeof partitionKeyValue.valueOf() !== 'string') {
      throw new Error('partitionKeyValue must be of type string.');
    }
    if (previousRspVersion !== null && previousRspVersion !== undefined && typeof previousRspVersion.valueOf() !== 'string') {
      throw new Error('previousRspVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/ResolvePartition';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (partitionKeyType !== null && partitionKeyType !== undefined) {
    queryParameters.push('PartitionKeyType=' + encodeURIComponent(partitionKeyType.toString()));
  }
  if (partitionKeyValue !== null && partitionKeyValue !== undefined) {
    queryParameters.push('PartitionKeyValue=' + partitionKeyValue);
  }
  if (previousRspVersion !== null && previousRspVersion !== undefined) {
    queryParameters.push('PreviousRspVersion=' + previousRspVersion);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResolvedServicePartition']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of partitions of a Service Fabric service.
 *
 * Gets the list of partitions of a Service Fabric service. The response
 * include the partition id, partitioning scheme information, keys supported by
 * the partition, status, health and other details about the partition.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedServicePartitionInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionInfoList(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetPartitions';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedServicePartitionInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a Service Fabric partition.
 *
 * The Partitions endpoint returns information about the specified partition.
 * The response include the partition id, partitioning scheme information, keys
 * supported by the partition, status, health and other details about the
 * partition.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServicePartitionInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionInfo(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServicePartitionInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the name of the Service Fabric service for a partition.
 *
 * The GetServiceName endpoint returns the name of the service for the
 * specified partition.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceNameInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceNameInfo(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetServiceName';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceNameInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric partition.
 *
 * Gets the health information of the specified partition.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
 * objects on the partition.
 * If you specify a partition that does not exist in the health store, this
 * cmdlet returns an error.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.replicasHealthStateFilter] Allows filtering the
 * collection of ReplicaHealthState objects on the partition. The value can be
 * obtained from members or bitwise operations on members of HealthStateFilter.
 * Only replicas that match the filter will be returned. All replicas will be
 * used to evaluate the aggregated health state. If not specified, all entries
 * will be returned.The state values are flag based enumeration, so the value
 * could be a combination of these value obtained using bitwise 'OR' operator.
 * For example, If the provided value is 6 then all of the events with
 * HealthState value of OK (2) and Warning (4) will be returned. The possible
 * values for this parameter include integer value of one of the following
 * health states.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionHealth(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let replicasHealthStateFilter = (options && options.replicasHealthStateFilter !== undefined) ? options.replicasHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined && typeof replicasHealthStateFilter !== 'number') {
      throw new Error('replicasHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined) {
    queryParameters.push('ReplicasHealthStateFilter=' + encodeURIComponent(replicasHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric partition, by using
 * the specified health policy.
 *
 * Gets the health information of the specified partition.
 * If the application health policy is specified, the health evaluation uses it
 * to get the aggregated health state.
 * If the policy is not specified, the health evaluation uses the application
 * health policy defined in the application manifest, or the default health
 * policy, if no policy is defined in the manifest.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the partition based on the health state.
 * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
 * objects on the partition. Use ApplicationHealthPolicy in the POST body to
 * override the health policies used to evaluate the health.
 * If you specify a partition that does not exist in the health store, this
 * cmdlet returns an error.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.replicasHealthStateFilter] Allows filtering the
 * collection of ReplicaHealthState objects on the partition. The value can be
 * obtained from members or bitwise operations on members of HealthStateFilter.
 * Only replicas that match the filter will be returned. All replicas will be
 * used to evaluate the aggregated health state. If not specified, all entries
 * will be returned.The state values are flag based enumeration, so the value
 * could be a combination of these value obtained using bitwise 'OR' operator.
 * For example, If the provided value is 6 then all of the events with
 * HealthState value of OK (2) and Warning (4) will be returned. The possible
 * values for this parameter include integer value of one of the following
 * health states.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionHealthUsingPolicy(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let replicasHealthStateFilter = (options && options.replicasHealthStateFilter !== undefined) ? options.replicasHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined && typeof replicasHealthStateFilter !== 'number') {
      throw new Error('replicasHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined) {
    queryParameters.push('ReplicasHealthStateFilter=' + encodeURIComponent(replicasHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric partition.
 *
 * Reports health state of the specified Service Fabric partition. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Partition, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetPartitionHealth and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportPartitionHealth(partitionId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the load of the specified Service Fabric partition.
 *
 * Returns information about the specified partition.
 * The response includes a list of load information.
 * Each information includes load metric name, value and last reported time in
 * UTC.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionLoadInformation} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionLoadInformation(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionLoadInformation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resets the current load of a Service Fabric partition.
 *
 * Resets the current load of a Service Fabric partition to the default load
 * for the service.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetPartitionLoad(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/ResetLoad';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover a specific partition which is currently stuck in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover a
 * specific partition which is currently stuck in quorum loss. This operation
 * should only be performed if it is known that the replicas that are down
 * cannot be recovered. Incorrect use of this API can cause potential data
 * loss.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverPartition(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/Recover';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover the specified service which is currently stuck in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover
 * the specified service which is currently stuck in quorum loss. This
 * operation should only be performed if it is known that the replicas that are
 * down cannot be recovered. Incorrect use of this API can cause potential data
 * loss.
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverServicePartitions(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/$/{serviceId}/$/GetPartitions/$/Recover';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover the system services which are currently stuck in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover
 * the system services which are currently stuck in quorum loss. This operation
 * should only be performed if it is known that the replicas that are down
 * cannot be recovered. Incorrect use of this API can cause potential data
 * loss.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSystemPartitions(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RecoverSystemPartitions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover any services (including system services) which are currently stuck
 * in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover
 * any services (including system services) which are currently stuck in quorum
 * loss. This operation should only be performed if it is known that the
 * replicas that are down cannot be recovered. Incorrect use of this API can
 * cause potential data loss.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverAllPartitions(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RecoverAllPartitions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new repair task.
 *
 * For clusters that have the Repair Manager Service configured,
 * this API provides a way to create repair tasks that run automatically or
 * manually.
 * For repair tasks that run automatically, an appropriate repair executor
 * must be running for each repair action to run automatically.
 * These are currently only available in specially-configured Azure Cloud
 * Services.
 *
 * To create a manual repair task, provide the set of impacted node names and
 * the
 * expected impact. When the state of the created repair task changes to
 * approved,
 * you can safely perform repair actions on those nodes.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTask Describes the repair task to be created or
 * updated.
 *
 * @param {string} repairTask.taskId The ID of the repair task.
 *
 * @param {string} [repairTask.version] The version of the repair task.
 * When creating a new repair task, the version must be set to zero.  When
 * updating a repair task,
 * the version is used for optimistic concurrency checks.  If the version is
 * set to zero, the update will not check for write conflicts.  If the version
 * is set to a non-zero value, then the
 * update will only succeed if the actual current version of the repair task
 * matches this value.
 *
 *
 * @param {string} [repairTask.description] A description of the purpose of the
 * repair task, or other informational details.
 * May be set when the repair task is created, and is immutable once set.
 *
 *
 * @param {string} repairTask.state The workflow state of the repair task.
 * Valid initial states are Created, Claimed, and Preparing.
 *
 * - Invalid - Indicates that the repair task state is invalid. All Service
 * Fabric enumerations have the invalid value.
 * - Created - Indicates that the repair task has been created.
 * - Claimed - Indicates that the repair task has been claimed by a repair
 * executor.
 * - Preparing - Indicates that the Repair Manager is preparing the system to
 * handle the impact of the repair task, usually by taking resources offline
 * gracefully.
 * - Approved - Indicates that the repair task has been approved by the Repair
 * Manager and is safe to execute.
 * - Executing - Indicates that execution of the repair task is in progress.
 * - Restoring - Indicates that the Repair Manager is restoring the system to
 * its pre-repair state, usually by bringing resources back online.
 * - Completed - Indicates that the repair task has completed, and no further
 * state changes will occur.
 * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
 * 'Approved', 'Executing', 'Restoring', 'Completed'
 *
 * @param {number} [repairTask.flags] A bitwise-OR of the following values,
 * which gives additional details about the status of the repair task.
 * - 1 - Cancellation of the repair has been requested
 * - 2 - Abort of the repair has been requested
 * - 4 - Approval of the repair was forced via client request
 *
 *
 * @param {string} repairTask.action The requested repair action. Must be
 * specified when the repair task is created, and is immutable once set.
 *
 *
 * @param {object} [repairTask.target]
 *
 * @param {string} repairTask.target.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.executor] The name of the repair executor. Must
 * be specified in Claimed and later states, and is immutable once set.
 *
 * @param {string} [repairTask.executorData] A data string that the repair
 * executor can use to store its internal state.
 *
 * @param {object} [repairTask.impact]
 *
 * @param {string} repairTask.impact.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.resultStatus] A value describing the overall
 * result of the repair task execution.
 * Must be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * - Invalid - Indicates that the repair task result is invalid. All Service
 * Fabric enumerations have the invalid value.
 * - Succeeded - Indicates that the repair task completed execution
 * successfully.
 * - Cancelled - Indicates that the repair task was cancelled prior to
 * execution.
 * - Interrupted - Indicates that execution of the repair task was interrupted
 * by a cancellation request after some work had already been performed.
 * - Failed - Indicates that there was a failure during execution of the repair
 * task. Some work may have been performed.
 * - Pending - Indicates that the repair task result is not yet available,
 * because the repair task has not finished executing.
 * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
 * 'Interrupted', 'Failed', 'Pending'
 *
 * @param {number} [repairTask.resultCode] A numeric value providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 *
 * @param {string} [repairTask.resultDetails] A string providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 *
 * @param {object} [repairTask.history]
 *
 * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
 * repair task entered the Created state.
 *
 * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
 * repair task entered the Claimed state.
 *
 * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
 * repair task entered the Preparing state.
 *
 * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
 * repair task entered the Approved state
 *
 * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
 * repair task entered the Executing state
 *
 * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
 * repair task entered the Restoring state
 *
 * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
 * repair task entered the Completed state
 *
 * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Restoring state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Restoring state.
 *
 * @param {string} [repairTask.preparingHealthCheckState] Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 *
 * @param {string} [repairTask.restoringHealthCheckState] Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 *
 * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Preparing state.
 *
 * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Restoring state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createRepairTask(repairTask, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTask === null || repairTask === undefined) {
      throw new Error('repairTask cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/CreateRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTask !== null && repairTask !== undefined) {
      let requestModelMapper = new client.models['RepairTask']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTask, 'repairTask');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTask, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Requests the cancellation of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTaskCancelDescription Describes the repair task to be
 * cancelled.
 *
 * @param {string} repairTaskCancelDescription.taskId The ID of the repair
 * task.
 *
 * @param {string} [repairTaskCancelDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.</para>
 *
 * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
 * repair should be stopped as soon as possible even if it has already started
 * executing. _False_ if the repair should be cancelled only if execution has
 * not yet started.</para>
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _cancelRepairTask(repairTaskCancelDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskCancelDescription === null || repairTaskCancelDescription === undefined) {
      throw new Error('repairTaskCancelDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/CancelRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskCancelDescription !== null && repairTaskCancelDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskCancelDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskCancelDescription, 'repairTaskCancelDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskCancelDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a completed repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTaskDeleteDescription Describes the repair task to be
 * deleted.
 *
 * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
 * repair task to be deleted.
 *
 * @param {string} [repairTaskDeleteDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRepairTask(repairTaskDeleteDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskDeleteDescription === null || repairTaskDeleteDescription === undefined) {
      throw new Error('repairTaskDeleteDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/DeleteRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskDeleteDescription !== null && repairTaskDeleteDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskDeleteDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskDeleteDescription, 'repairTaskDeleteDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskDeleteDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of repair tasks matching the given filters.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.taskIdFilter] The repair task ID prefix to be
 * matched.
 *
 * @param {number} [options.stateFilter] A bitwise-OR of the following values,
 * specifying which task states should be included in the result list.
 * - 1 - Created
 * - 2 - Claimed
 * - 4 - Preparing
 * - 8 - Approved
 * - 16 - Executing
 * - 32 - Restoring
 * - 64 - Completed
 *
 *
 * @param {string} [options.executorFilter] The name of the repair executor
 * whose claimed tasks should be included in the list.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRepairTaskList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let taskIdFilter = (options && options.taskIdFilter !== undefined) ? options.taskIdFilter : undefined;
  let stateFilter = (options && options.stateFilter !== undefined) ? options.stateFilter : undefined;
  let executorFilter = (options && options.executorFilter !== undefined) ? options.executorFilter : undefined;
  let apiVersion = '6.0';
  // Validate
  try {
    if (taskIdFilter !== null && taskIdFilter !== undefined && typeof taskIdFilter.valueOf() !== 'string') {
      throw new Error('taskIdFilter must be of type string.');
    }
    if (stateFilter !== null && stateFilter !== undefined && typeof stateFilter !== 'number') {
      throw new Error('stateFilter must be of type number.');
    }
    if (executorFilter !== null && executorFilter !== undefined && typeof executorFilter.valueOf() !== 'string') {
      throw new Error('executorFilter must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetRepairTaskList';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (taskIdFilter !== null && taskIdFilter !== undefined) {
    queryParameters.push('TaskIdFilter=' + encodeURIComponent(taskIdFilter));
  }
  if (stateFilter !== null && stateFilter !== undefined) {
    queryParameters.push('StateFilter=' + encodeURIComponent(stateFilter.toString()));
  }
  if (executorFilter !== null && executorFilter !== undefined) {
    queryParameters.push('ExecutorFilter=' + encodeURIComponent(executorFilter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RepairTaskElementType',
                  type: {
                    name: 'Composite',
                    className: 'RepairTask'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Forces the approval of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTaskApproveDescription Describes the repair task to be
 * approved.
 *
 * @param {string} repairTaskApproveDescription.taskId The ID of the repair
 * task.
 *
 * @param {string} [repairTaskApproveDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.</para>
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _forceApproveRepairTask(repairTaskApproveDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskApproveDescription === null || repairTaskApproveDescription === undefined) {
      throw new Error('repairTaskApproveDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/ForceApproveRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskApproveDescription !== null && repairTaskApproveDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskApproveDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskApproveDescription, 'repairTaskApproveDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskApproveDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the health policy of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
 * task healthy policy to be updated.
 *
 * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
 * repair task to be updated.
 *
 * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
 * current version number of the repair task. If non-zero, then the request
 * will only succeed if this value matches the actual current value of the
 * repair task. If zero, then no version check is performed.
 *
 * @param {boolean}
 * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
 * boolean indicating if health check is to be performed in the Preparing stage
 * of the repair task. If not specified the existing value should not be
 * altered. Otherwise, specify the desired new value.
 *
 * @param {boolean}
 * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
 * boolean indicating if health check is to be performed in the Restoring stage
 * of the repair task. If not specified the existing value should not be
 * altered. Otherwise, specify the desired new value.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskUpdateHealthPolicyDescription === null || repairTaskUpdateHealthPolicyDescription === undefined) {
      throw new Error('repairTaskUpdateHealthPolicyDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateRepairTaskHealthPolicy';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskUpdateHealthPolicyDescription !== null && repairTaskUpdateHealthPolicyDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskUpdateHealthPolicyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskUpdateHealthPolicyDescription, 'repairTaskUpdateHealthPolicyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskUpdateHealthPolicyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the execution state of a repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {object} repairTask Describes the repair task to be created or
 * updated.
 *
 * @param {string} repairTask.taskId The ID of the repair task.
 *
 * @param {string} [repairTask.version] The version of the repair task.
 * When creating a new repair task, the version must be set to zero.  When
 * updating a repair task,
 * the version is used for optimistic concurrency checks.  If the version is
 * set to zero, the update will not check for write conflicts.  If the version
 * is set to a non-zero value, then the
 * update will only succeed if the actual current version of the repair task
 * matches this value.
 *
 *
 * @param {string} [repairTask.description] A description of the purpose of the
 * repair task, or other informational details.
 * May be set when the repair task is created, and is immutable once set.
 *
 *
 * @param {string} repairTask.state The workflow state of the repair task.
 * Valid initial states are Created, Claimed, and Preparing.
 *
 * - Invalid - Indicates that the repair task state is invalid. All Service
 * Fabric enumerations have the invalid value.
 * - Created - Indicates that the repair task has been created.
 * - Claimed - Indicates that the repair task has been claimed by a repair
 * executor.
 * - Preparing - Indicates that the Repair Manager is preparing the system to
 * handle the impact of the repair task, usually by taking resources offline
 * gracefully.
 * - Approved - Indicates that the repair task has been approved by the Repair
 * Manager and is safe to execute.
 * - Executing - Indicates that execution of the repair task is in progress.
 * - Restoring - Indicates that the Repair Manager is restoring the system to
 * its pre-repair state, usually by bringing resources back online.
 * - Completed - Indicates that the repair task has completed, and no further
 * state changes will occur.
 * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
 * 'Approved', 'Executing', 'Restoring', 'Completed'
 *
 * @param {number} [repairTask.flags] A bitwise-OR of the following values,
 * which gives additional details about the status of the repair task.
 * - 1 - Cancellation of the repair has been requested
 * - 2 - Abort of the repair has been requested
 * - 4 - Approval of the repair was forced via client request
 *
 *
 * @param {string} repairTask.action The requested repair action. Must be
 * specified when the repair task is created, and is immutable once set.
 *
 *
 * @param {object} [repairTask.target]
 *
 * @param {string} repairTask.target.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.executor] The name of the repair executor. Must
 * be specified in Claimed and later states, and is immutable once set.
 *
 * @param {string} [repairTask.executorData] A data string that the repair
 * executor can use to store its internal state.
 *
 * @param {object} [repairTask.impact]
 *
 * @param {string} repairTask.impact.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.resultStatus] A value describing the overall
 * result of the repair task execution.
 * Must be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * - Invalid - Indicates that the repair task result is invalid. All Service
 * Fabric enumerations have the invalid value.
 * - Succeeded - Indicates that the repair task completed execution
 * successfully.
 * - Cancelled - Indicates that the repair task was cancelled prior to
 * execution.
 * - Interrupted - Indicates that execution of the repair task was interrupted
 * by a cancellation request after some work had already been performed.
 * - Failed - Indicates that there was a failure during execution of the repair
 * task. Some work may have been performed.
 * - Pending - Indicates that the repair task result is not yet available,
 * because the repair task has not finished executing.
 * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
 * 'Interrupted', 'Failed', 'Pending'
 *
 * @param {number} [repairTask.resultCode] A numeric value providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 *
 * @param {string} [repairTask.resultDetails] A string providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 *
 * @param {object} [repairTask.history]
 *
 * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
 * repair task entered the Created state.
 *
 * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
 * repair task entered the Claimed state.
 *
 * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
 * repair task entered the Preparing state.
 *
 * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
 * repair task entered the Approved state
 *
 * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
 * repair task entered the Executing state
 *
 * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
 * repair task entered the Restoring state
 *
 * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
 * repair task entered the Completed state
 *
 * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Restoring state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Restoring state.
 *
 * @param {string} [repairTask.preparingHealthCheckState] Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 *
 * @param {string} [repairTask.restoringHealthCheckState] Possible values
 * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 *
 * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Preparing state.
 *
 * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Restoring state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRepairExecutionState(repairTask, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTask === null || repairTask === undefined) {
      throw new Error('repairTask cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateRepairExecutionState';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTask !== null && repairTask !== undefined) {
      let requestModelMapper = new client.models['RepairTask']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTask, 'repairTask');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTask, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about replicas of a Service Fabric service
 * partition.
 *
 * The GetReplicas endpoint returns information about the replicas of the
 * specified partition. The respons include the id, role, status, health, node
 * name, uptime, and other details about the replica.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedReplicaInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaInfoList(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedReplicaInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a replica of a Service Fabric partition.
 *
 * The respons include the id, role, status, health, node name, uptime, and
 * other details about the replica.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaInfo(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric stateful service replica or
 * stateless service instance.
 *
 * Gets the health of a Service Fabric replica.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the replica based on the health state.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaHealth(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric stateful service replica or
 * stateless service instance using the specified policy.
 *
 * Gets the health of a Service Fabric stateful service replica or stateless
 * service instance.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Use ApplicationHealthPolicy to optionally override the health policies used
 * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
 * the ApplicationHealthPolicy. The rest of the fields are ignored while
 * evaluating the health of the replica.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaHealthUsingPolicy(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric replica.
 *
 * Reports health state of the specified Service Fabric replica. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Replica, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetReplicaHealth and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {string} serviceKind The kind of service replica (Stateless or
 * Stateful) for which the health is being reported. Following are the possible
 * values.
 * - Stateless - Does not use Service Fabric to make its state highly available
 * or reliable. The value is 1
 * - Stateful - Uses Service Fabric to make its state or part of its state
 * highly available and reliable. The value is 2.
 * . Possible values include: 'Stateless', 'Stateful'
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportReplicaHealth(partitionId, replicaId, serviceKind, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (serviceKind === null || serviceKind === undefined || typeof serviceKind.valueOf() !== 'string') {
      throw new Error('serviceKind cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ServiceKind=' + encodeURIComponent(serviceKind));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of replicas deployed on a Service Fabric node.
 *
 * Gets the list containing the information about replicas deployed on a
 * Service Fabric node. The information include partition id, replica id,
 * status of the replica, name of the service, name of the service type and
 * other information. Use PartitionId or ServiceManifestName query parameters
 * to return information about the deployed replicas matching the specified
 * values for those parameters.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {uuid} [options.partitionId] The identity of the partition.
 *
 * @param {string} [options.serviceManifestName] The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let partitionId = (options && options.partitionId !== undefined) ? options.partitionId : undefined;
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId !== null && partitionId !== undefined && !(typeof partitionId.valueOf() === 'string' && msRest.isValidUuid(partitionId))) {
      throw new Error('partitionId must be of type string and must be a valid uuid.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (partitionId !== null && partitionId !== undefined) {
    queryParameters.push('PartitionId=' + encodeURIComponent(partitionId.toString()));
  }
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceReplicaInfoElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'ServiceKind',
                      clientName: 'serviceKind'
                    },
                    uberParent: 'DeployedServiceReplicaInfo',
                    className: 'DeployedServiceReplicaInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of replica deployed on a Service Fabric node.
 *
 * Gets the details of the replica deployed on a Service Fabric node. The
 * information include service kind, service name, current service operation,
 * current service operation start date time, partition id, replica/instance
 * id, reported load and other information.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServiceReplicaDetailInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServiceReplicaDetailInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of replica deployed on a Service Fabric node.
 *
 * Gets the details of the replica deployed on a Service Fabric node. The
 * information include service kind, service name, current service operation,
 * current service operation start date time, partition id, replica/instance
 * id, reported load and other information.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServiceReplicaDetailInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServiceReplicaDetailInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a service replica of a persisted service running on a
 * node.
 *
 * Restarts a service replica of a persisted service running on a node. Warning
 * - There are no safety checks performed when this API is used. Incorrect use
 * of this API can lead to availability loss for stateful services.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartReplica(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a service replica running on a node.
 *
 * This API simulates a Service Fabric replica failure by removing a replica
 * from a Service Fabric cluster. The removal closes the replica, transitions
 * the replica to the role None, and then removes all of the state information
 * of the replica from the cluster. This API tests the replica state removal
 * path, and simulates the report fault permanent path through client APIs.
 * Warning - There are no safety checks performed when this API is used.
 * Incorrect use of this API can lead to data loss for stateful services.In
 * addition, the forceRemove flag impacts all other replicas hosted in the same
 * process.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeReplica(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of service packages deployed on a Service Fabric
 * node.
 *
 * Returns the information about the service packages deployed on a Service
 * Fabric node for the given application.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServicePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServicePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of service packages deployed on a Service Fabric node
 * matching exactly the specified name.
 *
 * Returns the information about the service packages deployed on a Service
 * Fabric node for the given application. These results are of service packages
 * whose name match exactly the service package name specified as the
 * parameter.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServicePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServicePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of an service package for a
 * specific application deployed for a Service Fabric node and application.
 *
 * Gets the information about health of service package for a specific
 * application deployed on a Service Fabric node. Use EventsHealthStateFilter
 * to optionally filter for the collection of HealthEvent objects reported on
 * the deployed service package based on health state.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServicePackageHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServicePackageHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of service package for a specific
 * application deployed on a Service Fabric node using the specified policy.
 *
 * Gets the information about health of an service package for a specific
 * application deployed on a Service Fabric node. using the specified policy.
 * Use EventsHealthStateFilter to optionally filter for the collection of
 * HealthEvent objects reported on the deployed service package based on health
 * state. Use ApplicationHealthPolicy to optionally override the health
 * policies used to evaluate the health. This API only uses
 * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
 * the fields are ignored while evaluating the health of the deployed service
 * package.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag based
 * enumeration, so the value could be a combination of these value obtained
 * using bitwise 'OR' operator. For example, If the provided value is 6 then
 * all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServicePackageHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServicePackageHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric deployed service
 * package.
 *
 * Reports health state of the service package of the application deployed on a
 * Service Fabric node. The report must contain the information about the
 * source of the health report and property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get deployed
 * service package health and check that the report appears in the HealthEvents
 * section.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name which identifies
 * the client/watchdog/system component which generated the health information.
 *
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 *
 * @param {string} healthInformation.healthState Possible values include:
 * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field is using ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is remopved from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, is the reporter has issues (eg. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag which indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from Http
 * Gateway to the health store, regardless of the fabric client settings that
 * the Http Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the Http Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the Http Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Downloads packages associated with specified service manifest to
 * image cache on specified node.
 *
 * Downloads packages associated with specified service manifest to image cache
 * on specified node.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} deployServicePackageToNodeDescription Describes information
 * for deploying a service package to a Service Fabric node.
 *
 * @param {string} deployServicePackageToNodeDescription.serviceManifestName
 *
 * @param {string} deployServicePackageToNodeDescription.applicationTypeName
 *
 * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
 *
 * @param {string} deployServicePackageToNodeDescription.nodeName
 *
 * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deployedServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (deployServicePackageToNodeDescription === null || deployServicePackageToNodeDescription === undefined) {
      throw new Error('deployServicePackageToNodeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/DeployServicePackage';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployServicePackageToNodeDescription !== null && deployServicePackageToNodeDescription !== undefined) {
      let requestModelMapper = new client.models['DeployServicePackageToNodeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, deployServicePackageToNodeDescription, 'deployServicePackageToNodeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployServicePackageToNodeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of code packages deployed on a Service Fabric node.
 *
 * Gets the list of code packages deployed on a Service Fabric node for the
 * given application.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {string} [options.codePackageName] The name of code package specified
 * in service manifest registered as part of an application type in a Service
 * Fabric cluster.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedCodePackageInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let codePackageName = (options && options.codePackageName !== undefined) ? options.codePackageName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (codePackageName !== null && codePackageName !== undefined && typeof codePackageName.valueOf() !== 'string') {
      throw new Error('codePackageName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (codePackageName !== null && codePackageName !== undefined) {
    queryParameters.push('CodePackageName=' + encodeURIComponent(codePackageName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedCodePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedCodePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a code package deployed on a Service Fabric node in a
 * cluster.
 *
 * Restarts a code package deployed on a Service Fabric node in a cluster. This
 * aborts the code package process, which will restart all the user service
 * replicas hosted in that process.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character. For example, if the application name is "fabric://myapp/app1",
 * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} restartDeployedCodePackageDescription Describes the deployed
 * code package on Service Fabric node to restart.
 *
 * @param {string} restartDeployedCodePackageDescription.serviceManifestName
 *
 * @param {string}
 * [restartDeployedCodePackageDescription.servicePackageActivationId]
 *
 * @param {string} restartDeployedCodePackageDescription.codePackageName
 *
 * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (restartDeployedCodePackageDescription === null || restartDeployedCodePackageDescription === undefined) {
      throw new Error('restartDeployedCodePackageDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (restartDeployedCodePackageDescription !== null && restartDeployedCodePackageDescription !== undefined) {
      let requestModelMapper = new client.models['RestartDeployedCodePackageDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, restartDeployedCodePackageDescription, 'restartDeployedCodePackageDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(restartDeployedCodePackageDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric compose deployment.
 *
 * Creates a Service Fabric compose deployment.
 *
 * @param {object} createComposeDeploymentDescription Describes the compose
 * deployment that needs to be created.
 *
 * @param {string} createComposeDeploymentDescription.deploymentName
 *
 * @param {string} createComposeDeploymentDescription.composeFileContent The
 * content of the compose file that describes the deployment to create.
 *
 * @param {object} [createComposeDeploymentDescription.registryCredential]
 *
 * @param {string}
 * [createComposeDeploymentDescription.registryCredential.registryUserName] The
 * user name to connect to container registry.
 *
 * @param {string}
 * [createComposeDeploymentDescription.registryCredential.registryPassword] The
 * password for supplied username to connect to container registry.
 *
 * @param {boolean}
 * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
 * Indicates that supplied container registry password is encrypted.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createComposeDeployment(createComposeDeploymentDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (createComposeDeploymentDescription === null || createComposeDeploymentDescription === undefined) {
      throw new Error('createComposeDeploymentDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createComposeDeploymentDescription !== null && createComposeDeploymentDescription !== undefined) {
      let requestModelMapper = new client.models['CreateComposeDeploymentDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, createComposeDeploymentDescription, 'createComposeDeploymentDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createComposeDeploymentDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information about a Service Fabric compose deployment.
 *
 * Returns the status of the compose deployment that was created or in the
 * process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * status and other details about the deployment.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ComposeDeploymentStatusInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentStatus(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ComposeDeploymentStatusInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of compose deployments created in the Service Fabric
 * cluster.
 *
 * Gets the status about the compose deployments that were created or in the
 * process of being created in the Service Fabric cluster. The response
 * includes the name, status and other details about the compose deployments.
 * If the list of deployments do not fit in a page, one page of results is
 * returned as well as a continuation token which can be used to get the next
 * page.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged queries includes as much
 * results as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedComposeDeploymentStatusInfoList} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentStatusList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedComposeDeploymentStatusInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest upgrade performed on this Service
 * Fabric compose deployment.
 *
 * Returns the information about the state of the compose deployment upgrade
 * along with details to aid debugging application health issues.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ComposeDeploymentUpgradeProgressInfo} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentUpgradeProgress(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/GetUpgradeProgress';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ComposeDeploymentUpgradeProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric compose deployment from cluster.
 *
 * Deletes an existing Service Fabric compose deployment.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeComposeDeployment(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/Delete';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts upgrading a compose deployment in the Service Fabric
 * cluster.
 *
 * Validates the supplied upgrade parameters and starts upgrading the
 * deployment if the parameters are valid.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
 * compose deployment.
 *
 * @param {string} composeDeploymentUpgradeDescription.deploymentName
 *
 * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
 * content of the compose file that describes the deployment to create.
 *
 * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
 * The user name to connect to container registry.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
 * The password for supplied username to connect to container registry.
 *
 * @param {boolean}
 * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
 * Indicates that supplied container registry password is encrypted.
 *
 * @param {string} composeDeploymentUpgradeDescription.upgradeKind Possible
 * values include: 'Invalid', 'Rolling'
 *
 * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode]
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
 * 'Monitored'
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
 *
 * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart]
 *
 * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction]
 * Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 *
 * @param {object}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy]
 *
 * @param {boolean}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 *
 * @param {object}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum maximum allowed percentage of unhealthy services. Allowed values
 * are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 *
 * @param {array}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (composeDeploymentUpgradeDescription === null || composeDeploymentUpgradeDescription === undefined) {
      throw new Error('composeDeploymentUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/Upgrade';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (composeDeploymentUpgradeDescription !== null && composeDeploymentUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ComposeDeploymentUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, composeDeploymentUpgradeDescription, 'composeDeploymentUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(composeDeploymentUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts Chaos in the cluster.
 *
 * If Chaos is not already running in the cluster, it starts Chaos with the
 * passed in Chaos parameters.
 * If Chaos is already running when this call is made, the call fails with the
 * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
 * Please refer to the article [Induce controlled Chaos in Service Fabric
 * clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos)
 * for more details.
 *
 *
 * @param {object} chaosParameters Describes all the parameters to configure a
 * Chaos run.
 *
 * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
 * for which Chaos will run before automatically stopping. The maximum allowed
 * value is 4,294,967,295 (System.UInt32.MaxValue).
 *
 *
 * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
 * The maximum amount of time to wait for all cluster entities to become stable
 * and healthy. Chaos executes in iterations and at the start of each iteration
 * it validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event.
 *
 *
 * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
 * the maximum number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults --
 * inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up.
 *
 *
 * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
 * disables the move primary and move secondary faults.
 *
 *
 * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
 * (in seconds) between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up.
 *
 *
 * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
 * Time-separation (in seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate.
 *
 *
 * @param {object} [chaosParameters.clusterHealthPolicy]
 *
 * @param {boolean}
 * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
 * allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 *
 * @param {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 *
 * @param {array}
 * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 *
 * @param {object} [chaosParameters.context]
 *
 * @param {object} [chaosParameters.context.map]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startChaos(chaosParameters, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (chaosParameters === null || chaosParameters === undefined) {
      throw new Error('chaosParameters cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/$/Start';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (chaosParameters !== null && chaosParameters !== undefined) {
      let requestModelMapper = new client.models['ChaosParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, chaosParameters, 'chaosParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(chaosParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops Chaos in the cluster if it is already running, otherwise it
 * does nothing.
 *
 * Stops Chaos from scheduling further faults; but, the in-flight faults are
 * not affected.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopChaos(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/$/Stop';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the next segment of the Chaos report based on the passed-in
 * continuation token or the passed-in time-range.
 *
 * You can either specify the ContinuationToken to get the next segment of the
 * Chaos report or you can specify the time-range
 * through StartTimeUtc and EndTimeUtc, but you cannot specify both the
 * ContinuationToken and the time-range in the same call.
 * When there are more than 100 Chaos events, the Chaos report is returned in
 * segments where a segment contains no more than 100 Chaos events.
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {string} [options.startTimeUtc] The count of ticks representing the
 * start time of the time range for which a Chaos report is to be generated.
 * Please consult [DateTime.Ticks
 * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
 * for details about tick.
 *
 * @param {string} [options.endTimeUtc] The count of ticks representing the end
 * time of the time range for which a Chaos report is to be generated. Please
 * consult [DateTime.Ticks
 * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
 * for details about tick.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ChaosReport} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getChaosReport(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let startTimeUtc = (options && options.startTimeUtc !== undefined) ? options.startTimeUtc : undefined;
  let endTimeUtc = (options && options.endTimeUtc !== undefined) ? options.endTimeUtc : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (startTimeUtc !== null && startTimeUtc !== undefined && typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc must be of type string.');
    }
    if (endTimeUtc !== null && endTimeUtc !== undefined && typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/$/Report';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (startTimeUtc !== null && startTimeUtc !== undefined) {
    queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  }
  if (endTimeUtc !== null && endTimeUtc !== undefined) {
    queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ChaosReport']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Uploads contents of the file to the image store.
 *
 * Uploads contents of the file to the image store. Use this API if the file is
 * small enough to upload again if the connection fails. The file's data needs
 * to be added to the request body. The contents will be uploaded to the
 * specified path. Image store service uses a mark file to indicate the
 * availability of the folder. The mark file is an empty file named "_.dir".
 * The mark file is generated by the image store service when all files in a
 * folder are uploaded. When using File-by-File approach to upload application
 * package in REST, the image store service isn't aware of the file hierarchy
 * of the application package; you need to create a mark file per folder and
 * upload it last, to let the image store service know that the folder is
 * complete.
 *
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _uploadFile(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the image store content information.
 *
 * Returns the information about the image store content at the specified
 * contentPath relative to the root of the image store.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ImageStoreContent} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreContent(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ImageStoreContent']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes existing image store content.
 *
 * Deletes existing image store content being found within the given image
 * store relative path. This can be used to delete uploaded application
 * packages once they are provisioned.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteImageStoreContent(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the content information at the root of the image store.
 *
 * Returns the information about the image store content at the root of the
 * image store.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ImageStoreContent} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreRootContent(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ImageStoreContent']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Copies image store content internally
 *
 * Copies the image store content from the source image store relative path to
 * the destination image store relative path.
 *
 * @param {object} imageStoreCopyDescription Describes the copy description for
 * the image store.
 *
 * @param {string} imageStoreCopyDescription.remoteSource The relative path of
 * source image store content to be copied from.
 *
 * @param {string} imageStoreCopyDescription.remoteDestination The relative
 * path of destination image store content to be copied to.
 *
 * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
 * names to be skipped for copying.
 *
 * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
 * to check mark file during copying. The property is true if checking mark
 * file is required, false otherwise. The mark file is used to check whether
 * the folder is well constructed. If the property is true and mark file does
 * not exist, the copy is skipped.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _copyImageStoreContent(imageStoreCopyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (imageStoreCopyDescription === null || imageStoreCopyDescription === undefined) {
      throw new Error('imageStoreCopyDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/$/Copy';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (imageStoreCopyDescription !== null && imageStoreCopyDescription !== undefined) {
      let requestModelMapper = new client.models['ImageStoreCopyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, imageStoreCopyDescription, 'imageStoreCopyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(imageStoreCopyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Invokes an administrative command on the given Infrastructure
 * Service instance.
 *
 * For clusters that have one or more instances of the Infrastructure Service
 * configured,
 * this API provides a way to send infrastructure-specific commands to a
 * particular
 * instance of the Infrastructure Service.
 *
 * Available commands and their corresponding response formats vary depending
 * upon
 * the infrastructure on which the cluster is running.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {string} command The text of the command to be invoked. The content
 * of the command is infrastructure-specific.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceId] The identity of the infrastructure
 * service. This is  the full name of the infrastructure service without the
 * 'fabric:' URI scheme. This parameter required only for the cluster that have
 * more than one instance of infrastructure service running.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _invokeInfrastructureCommand(command, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceId = (options && options.serviceId !== undefined) ? options.serviceId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (command === null || command === undefined || typeof command.valueOf() !== 'string') {
      throw new Error('command cannot be null or undefined and it must be of type string.');
    }
    if (serviceId !== null && serviceId !== undefined && typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/InvokeInfrastructureCommand';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('Command=' + encodeURIComponent(command));
  if (serviceId !== null && serviceId !== undefined) {
    queryParameters.push('ServiceId=' + encodeURIComponent(serviceId));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Invokes a read-only query on the given infrastructure service
 * instance.
 *
 * For clusters that have one or more instances of the Infrastructure Service
 * configured,
 * this API provides a way to send infrastructure-specific queries to a
 * particular
 * instance of the Infrastructure Service.
 *
 * Available commands and their corresponding response formats vary depending
 * upon
 * the infrastructure on which the cluster is running.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 *
 * @param {string} command The text of the command to be invoked. The content
 * of the command is infrastructure-specific.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceId] The identity of the infrastructure
 * service. This is  the full name of the infrastructure service without the
 * 'fabric:' URI scheme. This parameter required only for the cluster that have
 * more than one instance of infrastructure service running.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _invokeInfrastructureQuery(command, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceId = (options && options.serviceId !== undefined) ? options.serviceId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (command === null || command === undefined || typeof command.valueOf() !== 'string') {
      throw new Error('command cannot be null or undefined and it must be of type string.');
    }
    if (serviceId !== null && serviceId !== undefined && typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/InvokeInfrastructureQuery';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('Command=' + encodeURIComponent(command));
  if (serviceId !== null && serviceId !== undefined) {
    queryParameters.push('ServiceId=' + encodeURIComponent(serviceId));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary This API will induce data loss for the specified partition. It will
 * trigger a call to the OnDataLossAsync API of the partition.
 *
 * This API will induce data loss for the specified partition. It will trigger
 * a call to the OnDataLoss API of the partition.
 * Actual data loss will depend on the specified DataLossMode
 * PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
 * triggered for the partition but actual data loss depends on the presence of
 * in-flight replication.
 * FullDataLoss - All replicas are removed hence all data is lost and
 * OnDataLoss is triggered.
 *
 * This API should only be called with a stateful service as the target.
 *
 * Calling this API with a system service as the target is not advised.
 *
 * Note:  Once this API has been called, it cannot be reversed. Calling
 * CancelOperation will only stop execution and clean up internal system state.
 * It will not restore data if the command has progressed far enough to cause
 * data loss.
 *
 * Call the GetDataLossProgress API with the same OperationId to return
 * information on the operation started with this API.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
 * indicate what type of data loss to induce.
 * - Invalid - Reserved.  Do not pass into API.
 * - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas
 * to go down, triggering an OnDataLoss event in the system for the given
 * partition.
 * - FullDataLoss - FullDataLoss option will drop all the replicas which means
 * that all the data will be lost.
 * . Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (dataLossMode === null || dataLossMode === undefined || typeof dataLossMode.valueOf() !== 'string') {
      throw new Error('dataLossMode cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('DataLossMode=' + encodeURIComponent(dataLossMode));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a partition data loss operation started using
 * the StartDataLoss API.
 *
 * Gets the progress of a data loss operation started with StartDataLoss, using
 * the OperationId.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionDataLossProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDataLossProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionDataLossProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Induces quorum loss for a given stateful service partition.
 *
 * Induces quorum loss for a given stateful service partition.  This API is
 * useful for a temporary quorum loss situation on your service.
 *
 * Call the GetQuorumLossProgress API with the same OperationId to return
 * information on the operation started with this API.
 *
 * This can only be called on stateful persisted (HasPersistedState==true)
 * services.  Do not use this API on stateless services or stateful in-memory
 * only services.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
 * API to indicate what type of quorum loss to induce.
 * - Invalid - Reserved.  Do not pass into API.
 * - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for
 * a partition will be down that will cause a quorum loss.
 * - AllReplicas- Full Quorum loss mode : All replicas for a partition will be
 * down that will cause a quorum loss.
 * . Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
 *
 * @param {number} quorumLossDuration The amount of time for which the
 * partition will be kept in quorum loss.  This must be specified in seconds.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (quorumLossMode === null || quorumLossMode === undefined || typeof quorumLossMode.valueOf() !== 'string') {
      throw new Error('quorumLossMode cannot be null or undefined and it must be of type string.');
    }
    if (quorumLossDuration === null || quorumLossDuration === undefined || typeof quorumLossDuration !== 'number') {
      throw new Error('quorumLossDuration cannot be null or undefined and it must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('QuorumLossMode=' + encodeURIComponent(quorumLossMode));
  queryParameters.push('QuorumLossDuration=' + encodeURIComponent(quorumLossDuration.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a quorum loss operation on a partition started
 * using the StartQuorumLoss API.
 *
 * Gets the progress of a quorum loss operation started with StartQuorumLoss,
 * using the provided OperationId.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionQuorumLossProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQuorumLossProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionQuorumLossProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary This API will restart some or all replicas or instances of the
 * specified partition.
 *
 * This API is useful for testing failover.
 *
 * If used to target a stateless service partition, RestartPartitionMode must
 * be AllReplicasOrInstances.
 *
 * Call the GetPartitionRestartProgress API using the same OperationId to get
 * the progress.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} restartPartitionMode - Invalid - Reserved.  Do not pass into
 * API.
 * - AllReplicasOrInstances - All replicas or instances in the partition are
 * restarted at once.
 * - OnlyActiveSecondaries - Only the secondary replicas are restarted.
 * . Possible values include: 'Invalid', 'AllReplicasOrInstances',
 * 'OnlyActiveSecondaries'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (restartPartitionMode === null || restartPartitionMode === undefined || typeof restartPartitionMode.valueOf() !== 'string') {
      throw new Error('restartPartitionMode cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('RestartPartitionMode=' + encodeURIComponent(restartPartitionMode));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a PartitionRestart operation started using
 * StartPartitionRestart.
 *
 * Gets the progress of a PartitionRestart started with StartPartitionRestart
 * using the provided OperationId.
 *
 *
 * @param {string} serviceId The identity of the service. This is typically the
 * full name of the service without the 'fabric:' URI scheme. Starting from
 * version 6.0, hierarchical names are delimited with the "~" character. For
 * example, if the service name is "fabric://myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionRestartProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionRestartProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionRestartProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts or stops a cluster node.
 *
 * Starts or stops a cluster node.  A cluster node is a process, not the OS
 * instance itself.  To start a node, pass in "Start" for the
 * NodeTransitionType parameter.
 * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
 * API starts the operation - when the API returns the node may not have
 * finished transitioning yet.
 * Call GetNodeTransitionProgress with the same OperationId to get the progress
 * of the operation.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} nodeTransitionType Indicates the type of transition to
 * perform.  NodeTransitionType.Start will start a stopped node.
 * NodeTransitionType.Stop will stop a node that is up.
 * - Invalid - Reserved.  Do not pass into API.
 * - Start - Transition a stopped node to up.
 * - Stop - Transition an up node to stopped.
 * . Possible values include: 'Invalid', 'Start', 'Stop'
 *
 * @param {string} nodeInstanceId The node instance ID of the target node.
 * This can be determined through GetNodeInfo API.
 *
 * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
 * node stopped.  The minimum value is 600, the maximum is 14400.  After this
 * time expires, the node will automatically come back up.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (nodeTransitionType === null || nodeTransitionType === undefined || typeof nodeTransitionType.valueOf() !== 'string') {
      throw new Error('nodeTransitionType cannot be null or undefined and it must be of type string.');
    }
    if (nodeInstanceId === null || nodeInstanceId === undefined || typeof nodeInstanceId.valueOf() !== 'string') {
      throw new Error('nodeInstanceId cannot be null or undefined and it must be of type string.');
    }
    if (stopDurationInSeconds === null || stopDurationInSeconds === undefined || typeof stopDurationInSeconds !== 'number') {
      throw new Error('stopDurationInSeconds cannot be null or undefined and it must be of type number.');
    }
    if (stopDurationInSeconds !== null && stopDurationInSeconds !== undefined) {
      if (stopDurationInSeconds < 0)
      {
        throw new Error('"stopDurationInSeconds" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Nodes/{nodeName}/$/StartTransition/';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('NodeTransitionType=' + encodeURIComponent(nodeTransitionType));
  queryParameters.push('NodeInstanceId=' + encodeURIComponent(nodeInstanceId));
  queryParameters.push('StopDurationInSeconds=' + encodeURIComponent(stopDurationInSeconds.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of an operation started using
 * StartNodeTransition.
 *
 * Gets the progress of an operation started with StartNodeTransition using the
 * provided OperationId.
 *
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeTransitionProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeTransitionProgress(nodeName, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Nodes/{nodeName}/$/GetTransitionProgress';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeTransitionProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user-induced fault operations filtered by provided
 * input.
 *
 * Gets the a list of user-induced fault operations filtered by provided input.
 *
 * @param {number} typeFilter Used to filter on OperationType for user-induced
 * operations.
 * 65535 - select all
 * 1     - select PartitionDataLoss.
 * 2     - select PartitionQuorumLoss.
 * 4     - select PartitionRestart.
 * 8     - select NodeTransition.
 *
 *
 * @param {number} stateFilter Used to filter on OperationState's for
 * user-induced operations.
 * 65535 - select All
 * 1     - select Running
 * 2     - select RollingBack
 * 8     - select Completed
 * 16    - select Faulted
 * 32    - select Cancelled
 * 64    - select ForceCancelled
 *
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFaultOperationList(typeFilter, stateFilter, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (typeFilter === null || typeFilter === undefined || typeof typeFilter !== 'number') {
      throw new Error('typeFilter cannot be null or undefined and it must be of type number.');
    }
    if (stateFilter === null || stateFilter === undefined || typeof stateFilter !== 'number') {
      throw new Error('stateFilter cannot be null or undefined and it must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('TypeFilter=' + encodeURIComponent(typeFilter.toString()));
  queryParameters.push('StateFilter=' + encodeURIComponent(stateFilter.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'OperationStatusElementType',
                  type: {
                    name: 'Composite',
                    className: 'OperationStatus'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Cancels a user-induced fault operation.
 *
 * The following is a list of APIs that start fault operations that may be
 * cancelled using CancelOperation -
 * - StartDataLoss
 * - StartQuorumLoss
 * - StartPartitionRestart
 * - StartNodeTransition
 *
 * If force is false, then the specified user-induced operation will be
 * gracefully stopped and cleaned up.  If force is true, the command will be
 * aborted, and some internal state
 * may be left behind.  Specifying force as true should be used with care.
 * Calling this API with force set to true is not allowed until this API has
 * already
 * been called on the same test command with force set to false first, or
 * unless the test command already has an OperationState of
 * OperationState.RollingBack.
 * Clarification: OperationState.RollingBack means that the system will/is be
 * cleaning up internal system state caused by executing the command.  It will
 * not restore data if the
 * test command was to cause data loss.  For example, if you call StartDataLoss
 * then call this API, the system will only clean up internal state from
 * running the command.
 * It will not restore the target partition's data, if the command progressed
 * far enough to cause data loss.
 *
 * Important note:  if this API is invoked with force==true, internal state may
 * be left behind.
 *
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {boolean} force Indicates whether to gracefully rollback and clean up
 * internal system state modified by executing the user-induced operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This specifies the time duration that the client is
 * willing to wait for the requested operation to complete. The default value
 * for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _cancelOperation(operationId, force, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (force === null || force === undefined || typeof force !== 'boolean') {
      throw new Error('force cannot be null or undefined and it must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/$/Cancel';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('Force=' + encodeURIComponent(force.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a ServiceFabricClient. */
class ServiceFabricClient extends ServiceClient {
  /**
   * Create a ServiceFabricClient.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   */
  constructor(baseUri, options) {

    if (!options) options = {};

    super(null, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'http://localhost:19080';
    }

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    this.models = models;
    this._getClusterManifest = _getClusterManifest;
    this._getClusterHealth = _getClusterHealth;
    this._getClusterHealthUsingPolicy = _getClusterHealthUsingPolicy;
    this._getClusterHealthChunk = _getClusterHealthChunk;
    this._getClusterHealthChunkUsingPolicyAndAdvancedFilters = _getClusterHealthChunkUsingPolicyAndAdvancedFilters;
    this._reportClusterHealth = _reportClusterHealth;
    this._getProvisionedFabricCodeVersionInfoList = _getProvisionedFabricCodeVersionInfoList;
    this._getProvisionedFabricConfigVersionInfoList = _getProvisionedFabricConfigVersionInfoList;
    this._getClusterUpgradeProgress = _getClusterUpgradeProgress;
    this._getClusterConfiguration = _getClusterConfiguration;
    this._getClusterConfigurationUpgradeStatus = _getClusterConfigurationUpgradeStatus;
    this._provisionCluster = _provisionCluster;
    this._unprovisionCluster = _unprovisionCluster;
    this._rollbackClusterUpgrade = _rollbackClusterUpgrade;
    this._resumeClusterUpgrade = _resumeClusterUpgrade;
    this._startClusterUpgrade = _startClusterUpgrade;
    this._startClusterConfigurationUpgrade = _startClusterConfigurationUpgrade;
    this._updateClusterUpgrade = _updateClusterUpgrade;
    this._getAadMetadata = _getAadMetadata;
    this._getNodeInfoList = _getNodeInfoList;
    this._getNodeInfo = _getNodeInfo;
    this._getNodeHealth = _getNodeHealth;
    this._getNodeHealthUsingPolicy = _getNodeHealthUsingPolicy;
    this._reportNodeHealth = _reportNodeHealth;
    this._getNodeLoadInfo = _getNodeLoadInfo;
    this._disableNode = _disableNode;
    this._enableNode = _enableNode;
    this._removeNodeState = _removeNodeState;
    this._restartNode = _restartNode;
    this._getApplicationTypeInfoList = _getApplicationTypeInfoList;
    this._getApplicationTypeInfoListByName = _getApplicationTypeInfoListByName;
    this._provisionApplicationType = _provisionApplicationType;
    this._unprovisionApplicationType = _unprovisionApplicationType;
    this._getServiceTypeInfoList = _getServiceTypeInfoList;
    this._getServiceManifest = _getServiceManifest;
    this._getDeployedServiceTypeInfoList = _getDeployedServiceTypeInfoList;
    this._getDeployedServiceTypeInfoByName = _getDeployedServiceTypeInfoByName;
    this._createApplication = _createApplication;
    this._deleteApplication = _deleteApplication;
    this._getApplicationLoadInfo = _getApplicationLoadInfo;
    this._getApplicationInfoList = _getApplicationInfoList;
    this._getApplicationInfo = _getApplicationInfo;
    this._getApplicationHealth = _getApplicationHealth;
    this._getApplicationHealthUsingPolicy = _getApplicationHealthUsingPolicy;
    this._reportApplicationHealth = _reportApplicationHealth;
    this._startApplicationUpgrade = _startApplicationUpgrade;
    this._getApplicationUpgrade = _getApplicationUpgrade;
    this._updateApplicationUpgrade = _updateApplicationUpgrade;
    this._resumeApplicationUpgrade = _resumeApplicationUpgrade;
    this._rollbackApplicationUpgrade = _rollbackApplicationUpgrade;
    this._getDeployedApplicationInfoList = _getDeployedApplicationInfoList;
    this._getDeployedApplicationInfo = _getDeployedApplicationInfo;
    this._getDeployedApplicationHealth = _getDeployedApplicationHealth;
    this._getDeployedApplicationHealthUsingPolicy = _getDeployedApplicationHealthUsingPolicy;
    this._reportDeployedApplicationHealth = _reportDeployedApplicationHealth;
    this._getApplicationManifest = _getApplicationManifest;
    this._getServiceInfoList = _getServiceInfoList;
    this._getServiceInfo = _getServiceInfo;
    this._getApplicationNameInfo = _getApplicationNameInfo;
    this._createService = _createService;
    this._createServiceFromTemplate = _createServiceFromTemplate;
    this._deleteService = _deleteService;
    this._updateService = _updateService;
    this._getServiceDescription = _getServiceDescription;
    this._getServiceHealth = _getServiceHealth;
    this._getServiceHealthUsingPolicy = _getServiceHealthUsingPolicy;
    this._reportServiceHealth = _reportServiceHealth;
    this._resolveService = _resolveService;
    this._getPartitionInfoList = _getPartitionInfoList;
    this._getPartitionInfo = _getPartitionInfo;
    this._getServiceNameInfo = _getServiceNameInfo;
    this._getPartitionHealth = _getPartitionHealth;
    this._getPartitionHealthUsingPolicy = _getPartitionHealthUsingPolicy;
    this._reportPartitionHealth = _reportPartitionHealth;
    this._getPartitionLoadInformation = _getPartitionLoadInformation;
    this._resetPartitionLoad = _resetPartitionLoad;
    this._recoverPartition = _recoverPartition;
    this._recoverServicePartitions = _recoverServicePartitions;
    this._recoverSystemPartitions = _recoverSystemPartitions;
    this._recoverAllPartitions = _recoverAllPartitions;
    this._createRepairTask = _createRepairTask;
    this._cancelRepairTask = _cancelRepairTask;
    this._deleteRepairTask = _deleteRepairTask;
    this._getRepairTaskList = _getRepairTaskList;
    this._forceApproveRepairTask = _forceApproveRepairTask;
    this._updateRepairTaskHealthPolicy = _updateRepairTaskHealthPolicy;
    this._updateRepairExecutionState = _updateRepairExecutionState;
    this._getReplicaInfoList = _getReplicaInfoList;
    this._getReplicaInfo = _getReplicaInfo;
    this._getReplicaHealth = _getReplicaHealth;
    this._getReplicaHealthUsingPolicy = _getReplicaHealthUsingPolicy;
    this._reportReplicaHealth = _reportReplicaHealth;
    this._getDeployedServiceReplicaInfoList = _getDeployedServiceReplicaInfoList;
    this._getDeployedServiceReplicaDetailInfo = _getDeployedServiceReplicaDetailInfo;
    this._getDeployedServiceReplicaDetailInfoByPartitionId = _getDeployedServiceReplicaDetailInfoByPartitionId;
    this._restartReplica = _restartReplica;
    this._removeReplica = _removeReplica;
    this._getDeployedServicePackageInfoList = _getDeployedServicePackageInfoList;
    this._getDeployedServicePackageInfoListByName = _getDeployedServicePackageInfoListByName;
    this._getDeployedServicePackageHealth = _getDeployedServicePackageHealth;
    this._getDeployedServicePackageHealthUsingPolicy = _getDeployedServicePackageHealthUsingPolicy;
    this._reportDeployedServicePackageHealth = _reportDeployedServicePackageHealth;
    this._deployedServicePackageToNode = _deployedServicePackageToNode;
    this._getDeployedCodePackageInfoList = _getDeployedCodePackageInfoList;
    this._restartDeployedCodePackage = _restartDeployedCodePackage;
    this._createComposeDeployment = _createComposeDeployment;
    this._getComposeDeploymentStatus = _getComposeDeploymentStatus;
    this._getComposeDeploymentStatusList = _getComposeDeploymentStatusList;
    this._getComposeDeploymentUpgradeProgress = _getComposeDeploymentUpgradeProgress;
    this._removeComposeDeployment = _removeComposeDeployment;
    this._startComposeDeploymentUpgrade = _startComposeDeploymentUpgrade;
    this._startChaos = _startChaos;
    this._stopChaos = _stopChaos;
    this._getChaosReport = _getChaosReport;
    this._uploadFile = _uploadFile;
    this._getImageStoreContent = _getImageStoreContent;
    this._deleteImageStoreContent = _deleteImageStoreContent;
    this._getImageStoreRootContent = _getImageStoreRootContent;
    this._copyImageStoreContent = _copyImageStoreContent;
    this._invokeInfrastructureCommand = _invokeInfrastructureCommand;
    this._invokeInfrastructureQuery = _invokeInfrastructureQuery;
    this._startDataLoss = _startDataLoss;
    this._getDataLossProgress = _getDataLossProgress;
    this._startQuorumLoss = _startQuorumLoss;
    this._getQuorumLossProgress = _getQuorumLossProgress;
    this._startPartitionRestart = _startPartitionRestart;
    this._getPartitionRestartProgress = _getPartitionRestartProgress;
    this._startNodeTransition = _startNodeTransition;
    this._getNodeTransitionProgress = _getNodeTransitionProgress;
    this._getFaultOperationList = _getFaultOperationList;
    this._cancelOperation = _cancelOperation;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault and upgrade domain topologies etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (for e.g when using azuer portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterManifestWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterManifest(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault and upgrade domain topologies etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (for e.g when using azuer portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterManifest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterManifest(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterManifest(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterManifest(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Gets the health of a Service Fabric cluster.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealth(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Gets the health of a Service Fabric cluster.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealth(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealth(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealth(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Gets the health of a Service Fabric cluster.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy]
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthUsingPolicyWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthUsingPolicy(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Gets the health of a Service Fabric cluster.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy]
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthUsingPolicy(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthUsingPolicy(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthUsingPolicy(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthChunkWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthChunk(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunk(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthChunk(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthChunk(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportClusterHealthWithHttpOperationResponse(healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportClusterHealth(healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportClusterHealth(healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportClusterHealth(healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportClusterHealth(healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getProvisionedFabricCodeVersionInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProvisionedFabricCodeVersionInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricCodeVersionInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProvisionedFabricCodeVersionInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProvisionedFabricCodeVersionInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getProvisionedFabricConfigVersionInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProvisionedFabricConfigVersionInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricConfigVersionInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProvisionedFabricConfigVersionInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProvisionedFabricConfigVersionInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, gets the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterUpgradeProgressObject>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterUpgradeProgressWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterUpgradeProgress(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, gets the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterUpgradeProgressObject} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterUpgradeProgressObject} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterUpgradeProgress(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterUpgradeProgress(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterUpgradeProgress(options, optionalCallback);
    }
  }

  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * Get the Service Fabric standalone cluster configuration. The cluster
   * configuration contains properties of the cluster that include different node
   * types on the cluster,
   * security configurations, fault and upgrade domain topologies etc.
   *
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfiguration>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterConfigurationWithHttpOperationResponse(configurationApiVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterConfiguration(configurationApiVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * Get the Service Fabric standalone cluster configuration. The cluster
   * configuration contains properties of the cluster that include different node
   * types on the cluster,
   * security configurations, fault and upgrade domain topologies etc.
   *
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterConfiguration} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfiguration} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfiguration(configurationApiVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterConfiguration(configurationApiVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterConfiguration(configurationApiVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status of a Service Fabric standalone
   * cluster.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfigurationUpgradeStatusInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterConfigurationUpgradeStatusWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterConfigurationUpgradeStatus(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status of a Service Fabric standalone
   * cluster.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterConfigurationUpgradeStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfigurationUpgradeStatusInfo} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfigurationUpgradeStatus(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterConfigurationUpgradeStatus(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterConfigurationUpgradeStatus(options, optionalCallback);
    }
  }

  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  provisionClusterWithHttpOperationResponse(provisionFabricDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._provisionCluster(provisionFabricDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionCluster(provisionFabricDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._provisionCluster(provisionFabricDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._provisionCluster(provisionFabricDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Unprovision the code or configuration packages of a Service Fabric cluster.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  unprovisionClusterWithHttpOperationResponse(unprovisionFabricDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._unprovisionCluster(unprovisionFabricDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Unprovision the code or configuration packages of a Service Fabric cluster.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionCluster(unprovisionFabricDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._unprovisionCluster(unprovisionFabricDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._unprovisionCluster(unprovisionFabricDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Rollback the upgrade of a Service Fabric cluster.
   *
   * Rollback the upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rollbackClusterUpgradeWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rollbackClusterUpgrade(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Rollback the upgrade of a Service Fabric cluster.
   *
   * Rollback the upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackClusterUpgrade(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rollbackClusterUpgrade(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rollbackClusterUpgrade(options, optionalCallback);
    }
  }

  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster upgrade move on to the next upgrade domain.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeClusterUpgradeWithHttpOperationResponse(resumeClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster upgrade move on to the next upgrade domain.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeClusterUpgrade(resumeClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] Possible values
   * include: 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] Possible
   * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart]
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startClusterUpgradeWithHttpOperationResponse(startClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startClusterUpgrade(startClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] Possible values
   * include: 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] Possible
   * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart]
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterUpgrade(startClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startClusterUpgrade(startClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startClusterUpgrade(startClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform a health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startClusterConfigurationUpgradeWithHttpOperationResponse(clusterConfigurationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform a health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] Possible
   * values include: 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart]
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation]
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateClusterUpgradeWithHttpOperationResponse(updateClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateClusterUpgrade(updateClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] Possible
   * values include: 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart]
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation]
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateClusterUpgrade(updateClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateClusterUpgrade(updateClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateClusterUpgrade(updateClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AadMetadataObject>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAadMetadataWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAadMetadata(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AadMetadataObject} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AadMetadataObject} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAadMetadata(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAadMetadata(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAadMetadata(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The Nodes endpoint returns information about the nodes in the Service Fabric
   * Cluster. The respons include the name, status, id, health, uptime and other
   * details about the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   *
   * - default - This filter value will match all of the nodes excepts the ones
   * with with status as Unknown or Removed.
   * - all - This filter value will match all of the nodes.
   * - up - This filter value will match nodes that are Up.
   * - down - This filter value will match nodes that are Down.
   * - enabling - This filter value will match nodes that are in the process of
   * being enabled with status as Enabling.
   * - disabling - This filter value will match nodes that are in the process of
   * being disabled with status as Disabling.
   * - disabled - This filter value will match nodes that are Disabled.
   * - unknown - This filter value will match nodes whose status is Unknown. A
   * node would be in Unknown state if Service Fabric does not have authoritative
   * information about that node. This can happen if the system learns about a
   * node at runtime.
   * - removed - This filter value will match nodes whose status is Removed.
   * These are the nodes that are removed from the cluster using the
   * RemoveNodeState API.
   * . Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedNodeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The Nodes endpoint returns information about the nodes in the Service Fabric
   * Cluster. The respons include the name, status, id, health, uptime and other
   * details about the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   *
   * - default - This filter value will match all of the nodes excepts the ones
   * with with status as Unknown or Removed.
   * - all - This filter value will match all of the nodes.
   * - up - This filter value will match nodes that are Up.
   * - down - This filter value will match nodes that are Down.
   * - enabling - This filter value will match nodes that are in the process of
   * being enabled with status as Enabling.
   * - disabling - This filter value will match nodes that are in the process of
   * being disabled with status as Disabling.
   * - disabled - This filter value will match nodes that are Disabled.
   * - unknown - This filter value will match nodes whose status is Unknown. A
   * node would be in Unknown state if Service Fabric does not have authoritative
   * information about that node. This can happen if the system learns about a
   * node at runtime.
   * - removed - This filter value will match nodes whose status is Removed.
   * These are the nodes that are removed from the cluster using the
   * RemoveNodeState API.
   * . Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedNodeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedNodeInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * Gets the information about a specific node in the Service Fabric Cluster.The
   * respons include the name, status, id, health, uptime and other details about
   * the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeInfoWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeInfo(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * Gets the information about a specific node in the Service Fabric Cluster.The
   * respons include the name, status, id, health, uptime and other details about
   * the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfo(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeInfo(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeInfo(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeHealthWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeHealth(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealth(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeHealth(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeHealth(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeHealthUsingPolicyWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeHealthUsingPolicy(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealthUsingPolicy(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeHealthUsingPolicy(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeHealthUsingPolicy(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportNodeHealthWithHttpOperationResponse(nodeName, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportNodeHealth(nodeName, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportNodeHealth(nodeName, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportNodeHealth(nodeName, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportNodeHealth(nodeName, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Gets the load information of a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeLoadInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeLoadInfoWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeLoadInfo(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Gets the load information of a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeLoadInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeLoadInfo(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeLoadInfo(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeLoadInfo(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node which is was deactivated
   * with the Pause intent can be deactivated further with Restart, but not the
   * other way around. Nodes may be reactivated using the Activate a node
   * operation any time after they are deactivated. If the deactivation is not
   * complete this will cancel the deactivation. A node which goes down and comes
   * back up while deactivated will still need to be reactivated before services
   * will be placed on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following.
   * - Pause - Indicates that the node should be paused. The value is 1.
   * - Restart - Indicates that the intent is for the node to be restarted after
   * a short period of time. The value is 2.
   * - RemoveData - Indicates the intent is for the node to remove data. The
   * value is 3.
   * . Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableNodeWithHttpOperationResponse(nodeName, deactivationIntentDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disableNode(nodeName, deactivationIntentDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node which is was deactivated
   * with the Pause intent can be deactivated further with Restart, but not the
   * other way around. Nodes may be reactivated using the Activate a node
   * operation any time after they are deactivated. If the deactivation is not
   * complete this will cancel the deactivation. A node which goes down and comes
   * back up while deactivated will still need to be reactivated before services
   * will be placed on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following.
   * - Pause - Indicates that the node should be paused. The value is 1.
   * - Restart - Indicates that the intent is for the node to be restarted after
   * a short period of time. The value is 2.
   * - RemoveData - Indicates the intent is for the node to remove data. The
   * value is 3.
   * . Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disableNode(nodeName, deactivationIntentDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disableNode(nodeName, deactivationIntentDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disableNode(nodeName, deactivationIntentDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Activate a Service Fabric cluster node which is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node which is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableNodeWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enableNode(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Activate a Service Fabric cluster node which is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node which is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enableNode(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enableNode(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enableNode(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.  This implies that it is not possible to
   * recover the persisted state of that node. This generally happens if a hard
   * disk has been wiped clean, or if a hard disk crashes. The node has to be
   * down for this operation to be successful. This operation lets Service Fabric
   * know that the replicas on that node no longer exist, and that Service Fabric
   * should stop waiting for those replicas to come back up. Do not run this
   * cmdlet if the state on the node has not been removed and the node can comes
   * back up with its state intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeNodeStateWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeNodeState(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.  This implies that it is not possible to
   * recover the persisted state of that node. This generally happens if a hard
   * disk has been wiped clean, or if a hard disk crashes. The node has to be
   * down for this operation to be successful. This operation lets Service Fabric
   * know that the replicas on that node no longer exist, and that Service Fabric
   * should stop waiting for those replicas to come back up. Do not run this
   * cmdlet if the state on the node has not been removed and the node can comes
   * back up with its state intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeNodeState(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeNodeState(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeNodeState(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance id of the
   * target node. If instance id is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance id. The instance id can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartNodeWithHttpOperationResponse(nodeName, restartNodeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartNode(nodeName, restartNodeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance id of the
   * target node. If instance id is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance id. The instance id can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartNode(nodeName, restartNodeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartNode(nodeName, restartNodeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartNode(nodeName, restartNodeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first 3 application
   * types, or if max results is set to 3, then 3 is returned. To access the rest
   * of the results, retrieve subsequent pages by using the returned continuation
   * token in the next query. An empty continuation token is returned if there
   * are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind for application type query operations.
   * - Default - Default value. Filter that matches input with any
   * ApplicationTypeDefinitionKind value. The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationTypeInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationTypeInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first 3 application
   * types, or if max results is set to 3, then 3 is returned. To access the rest
   * of the results, retrieve subsequent pages by using the returned continuation
   * token in the next query. An empty continuation token is returned if there
   * are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind for application type query operations.
   * - Default - Default value. Filter that matches input with any
   * ApplicationTypeDefinitionKind value. The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationTypeInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationTypeInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first 3 application
   * types, or if max results is set to 3, then 3 is returned. To access the rest
   * of the results, retrieve subsequent pages by using the returned continuation
   * token in the next query. An empty continuation token is returned if there
   * are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationTypeInfoListByNameWithHttpOperationResponse(applicationTypeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationTypeInfoListByName(applicationTypeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first 3 application
   * types, or if max results is set to 3, then 3 is returned. To access the rest
   * of the results, retrieve subsequent pages by using the returned continuation
   * token in the next query. An empty continuation token is returned if there
   * are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoListByName(applicationTypeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationTypeInfoListByName(applicationTypeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationTypeInfoListByName(applicationTypeName, options, optionalCallback);
    }
  }

  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster.
   *
   * Provisions or registers a Service Fabric application type with the cluster.
   * This is required before any new applications can be instantiated.
   *
   * @param {object} applicationTypeImageStorePath The relative path for the
   * application package in the image store specified during the prior copy
   * operation.
   *
   * @param {string} applicationTypeImageStorePath.applicationTypeBuildPath The
   * relative image store path to the application package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  provisionApplicationTypeWithHttpOperationResponse(applicationTypeImageStorePath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._provisionApplicationType(applicationTypeImageStorePath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster.
   *
   * Provisions or registers a Service Fabric application type with the cluster.
   * This is required before any new applications can be instantiated.
   *
   * @param {object} applicationTypeImageStorePath The relative path for the
   * application package in the image store specified during the prior copy
   * operation.
   *
   * @param {string} applicationTypeImageStorePath.applicationTypeBuildPath The
   * relative image store path to the application package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionApplicationType(applicationTypeImageStorePath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._provisionApplicationType(applicationTypeImageStorePath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._provisionApplicationType(applicationTypeImageStorePath, options, optionalCallback);
    }
  }

  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * Removes or unregisters a Service Fabric application type from the cluster.
   * This operation can only be performed if all application instance of the
   * application type has been deleted. Once the application type is
   * unregistered, no new application instance can be created for this particular
   * application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} applicationTypeImageStoreVersion The version of the
   * application type in the image store.
   *
   * @param {string} applicationTypeImageStoreVersion.applicationTypeVersion
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  unprovisionApplicationTypeWithHttpOperationResponse(applicationTypeName, applicationTypeImageStoreVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._unprovisionApplicationType(applicationTypeName, applicationTypeImageStoreVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * Removes or unregisters a Service Fabric application type from the cluster.
   * This operation can only be performed if all application instance of the
   * application type has been deleted. Once the application type is
   * unregistered, no new application instance can be created for this particular
   * application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} applicationTypeImageStoreVersion The version of the
   * application type in the image store.
   *
   * @param {string} applicationTypeImageStoreVersion.applicationTypeVersion
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionApplicationType(applicationTypeName, applicationTypeImageStoreVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._unprovisionApplicationType(applicationTypeName, applicationTypeImageStoreVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._unprovisionApplicationType(applicationTypeName, applicationTypeImageStoreVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * response includes the name of the service type, the name and version of the
   * service manifest the type is defined in, kind (stateless or stateless) of
   * the service type and other information about it.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceTypeInfoListWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * response includes the name of the service type, the name and version of the
   * service manifest the type is defined in, kind (stateless or stateless) of
   * the service type and other information about it.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceTypeManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceManifestWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, serviceManifestName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceTypeManifest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation id of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceTypeInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation id of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation id of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation id.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceTypeInfoByNameWithHttpOperationResponse(nodeName, applicationId, serviceTypeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation id of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation id.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name
   *
   * @param {string} applicationDescription.typeName
   *
   * @param {string} applicationDescription.typeVersion
   *
   * @param {array} [applicationDescription.parameterList]
   *
   * @param {object} [applicationDescription.applicationCapacity]
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createApplicationWithHttpOperationResponse(applicationDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createApplication(applicationDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name
   *
   * @param {string} applicationDescription.typeName
   *
   * @param {string} applicationDescription.typeVersion
   *
   * @param {array} [applicationDescription.parameterList]
   *
   * @param {object} [applicationDescription.applicationCapacity]
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createApplication(applicationDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createApplication(applicationDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createApplication(applicationDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * Deletes an existing Service Fabric application. An application must be
   * created before it can be deleted. Deleting an application will delete all
   * services that are part of that application. By default Service Fabric will
   * try to close service replicas in a graceful manner and then delete the
   * service. However if service is having issues closing the replica gracefully,
   * the delete operation may take a long time or get stuck. Use the optional
   * ForceRemove flag to skip the graceful close sequence and forcefully delete
   * the application and all of the its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteApplicationWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteApplication(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * Deletes an existing Service Fabric application. An application must be
   * created before it can be deleted. Deleting an application will delete all
   * services that are part of that application. By default Service Fabric will
   * try to close service replicas in a graceful manner and then delete the
   * service. However if service is having issues closing the replica gracefully,
   * the delete operation may take a long time or get stuck. Use the optional
   * ForceRemove flag to skip the graceful close sequence and forcefully delete
   * the application and all of the its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplication(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteApplication(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteApplication(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the app is occupying
   * currently, and application load metric information about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationLoadInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationLoadInfoWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationLoadInfo(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the app is occupying
   * currently, and application load metric information about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationLoadInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationLoadInfo(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationLoadInfo(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationLoadInfo(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match filters specified as the parameter.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match filters
   * specified as the parameter. The response includes the name, type, status,
   * parameters and other details about the application. If the applications do
   * not fit in a page, one page of results is returned as well as a continuation
   * token which can be used to get the next page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind for application query operations.
   * - Default - Default value. Filter that matches input with any
   * ApplicationDefinitionKind value. The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match filters specified as the parameter.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match filters
   * specified as the parameter. The response includes the name, type, status,
   * parameters and other details about the application. If the applications do
   * not fit in a page, one page of results is returned as well as a continuation
   * token which can be used to get the next page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind for application query operations.
   * - Default - Default value. Filter that matches input with any
   * ApplicationDefinitionKind value. The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationInfoWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationInfo(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfo(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationInfo(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationInfo(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the helath store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.\
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationHealthWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationHealth(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the helath store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.\
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealth(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationHealth(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationHealth(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.\
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationHealthUsingPolicyWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationHealthUsingPolicy(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.\
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value could be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealthUsingPolicy(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationHealthUsingPolicy(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationHealthUsingPolicy(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportApplicationHealthWithHttpOperationResponse(applicationId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportApplicationHealth(applicationId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportApplicationHealth(applicationId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportApplicationHealth(applicationId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportApplicationHealth(applicationId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   *
   * @param {array} applicationUpgradeDescription.parameters
   *
   * @param {string} applicationUpgradeDescription.upgradeKind Possible values
   * include: 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] Possible
   * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart]
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startApplicationUpgradeWithHttpOperationResponse(applicationId, applicationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   *
   * @param {array} applicationUpgradeDescription.parameters
   *
   * @param {string} applicationUpgradeDescription.upgradeKind Possible values
   * include: 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] Possible
   * values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart]
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationUpgradeWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationUpgrade(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationUpgradeProgressInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationUpgrade(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationUpgrade(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationUpgrade(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind Possible
   * values include: 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart]
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction]
   * Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationUpgradeWithHttpOperationResponse(applicationId, applicationUpgradeUpdateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind Possible
   * values include: 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart]
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction]
   * Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeApplicationUpgradeWithHttpOperationResponse(applicationId, resumeApplicationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to rollback the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rollbackApplicationUpgradeWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rollbackApplicationUpgrade(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to rollback the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackApplicationUpgrade(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rollbackApplicationUpgrade(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rollbackApplicationUpgrade(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationInfoListWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationInfoList(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfoList(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationInfoList(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationInfoList(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * Gets the information about an application deployed on a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationInfoWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationInfo(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * Gets the information about an application deployed on a Service Fabric node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfo(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationInfo(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationInfo(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value can be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationHealthWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationHealth(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value can be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealth(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationHealth(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationHealth(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value can be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationHealthUsingPolicyWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag based enumeration, so the value can be a
   * combination of these value obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportDeployedApplicationHealthWithHttpOperationResponse(nodeName, applicationId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the manifest describing an application type.
   *
   * Gets the manifest describing an application type. The response contains the
   * application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationTypeManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationManifestWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the manifest describing an application type.
   *
   * Gets the manifest describing an application type. The response contains the
   * application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationTypeManifest} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationManifest(applicationTypeName, applicationTypeVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application id.
   *
   * Returns the information about all services belonging to the application
   * specified by the application id.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServiceInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceInfoListWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceInfoList(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application id.
   *
   * Returns the information about all services belonging to the application
   * specified by the application id.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedServiceInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServiceInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfoList(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceInfoList(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceInfoList(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about the specific service belonging to a
   * Service Fabric application.
   *
   * Returns the information about specified service belonging to the specified
   * Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceInfoWithHttpOperationResponse(applicationId, serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceInfo(applicationId, serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about the specific service belonging to a
   * Service Fabric application.
   *
   * Returns the information about specified service belonging to the specified
   * Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfo(applicationId, serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceInfo(applicationId, serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceInfo(applicationId, serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * The GetApplicationName endpoint returns the name of the application for the
   * specified service.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationNameInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationNameInfoWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationNameInfo(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * The GetApplicationName endpoint returns the name of the application for the
   * specified service.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationNameInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationNameInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationNameInfo(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationNameInfo(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationNameInfo(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Creates the specified service.
   *
   * Creates the specified service.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName]
   *
   * @param {string} serviceDescription.serviceName
   *
   * @param {string} serviceDescription.serviceTypeName
   *
   * @param {array} [serviceDescription.initializationData]
   *
   * @param {object} serviceDescription.partitionDescription
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme]
   *
   * @param {array} [serviceDescription.serviceLoadMetrics]
   *
   * @param {array} [serviceDescription.servicePlacementPolicies]
   *
   * @param {string} [serviceDescription.defaultMoveCost] Possible values
   * include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createServiceWithHttpOperationResponse(applicationId, serviceDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createService(applicationId, serviceDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates the specified service.
   *
   * Creates the specified service.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName]
   *
   * @param {string} serviceDescription.serviceName
   *
   * @param {string} serviceDescription.serviceTypeName
   *
   * @param {array} [serviceDescription.initializationData]
   *
   * @param {object} serviceDescription.partitionDescription
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme]
   *
   * @param {array} [serviceDescription.serviceLoadMetrics]
   *
   * @param {array} [serviceDescription.servicePlacementPolicies]
   *
   * @param {string} [serviceDescription.defaultMoveCost] Possible values
   * include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createService(applicationId, serviceDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createService(applicationId, serviceDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createService(applicationId, serviceDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric service from the service template defined
   * in the application manifest.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName
   *
   * @param {string} serviceFromTemplateDescription.serviceName
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName
   *
   * @param {array} [serviceFromTemplateDescription.initializationData]
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createServiceFromTemplateWithHttpOperationResponse(applicationId, serviceFromTemplateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric service from the service template defined
   * in the application manifest.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName
   *
   * @param {string} serviceFromTemplateDescription.serviceName
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName
   *
   * @param {array} [serviceFromTemplateDescription.initializationData]
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] Possible
   * values include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * Deletes an existing Service Fabric service. A service must be created before
   * it can be deleted. By default Service Fabric will try to close service
   * replicas in a graceful manner and then delete the service. However if
   * service is having issues closing the replica gracefully, the delete
   * operation may take a long time or get stuck. Use the optional ForceRemove
   * flag to skip the graceful close sequence and forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteServiceWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteService(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * Deletes an existing Service Fabric service. A service must be created before
   * it can be deleted. By default Service Fabric will try to close service
   * replicas in a graceful manner and then delete the service. However if
   * service is having issues closing the replica gracefully, the delete
   * operation may take a long time or get stuck. Use the optional ForceRemove
   * flag to skip the graceful close sequence and forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteService(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteService(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteService(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the specified service using the given update description.
   *
   * Updates the specified service using the given update description.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   *
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme]
   *
   * @param {array} [serviceUpdateDescription.loadMetrics]
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies]
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] Possible values
   * include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateServiceWithHttpOperationResponse(serviceId, serviceUpdateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateService(serviceId, serviceUpdateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the specified service using the given update description.
   *
   * Updates the specified service using the given update description.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   *
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme]
   *
   * @param {array} [serviceUpdateDescription.loadMetrics]
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies]
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] Possible values
   * include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateService(serviceId, serviceUpdateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateService(serviceId, serviceUpdateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateService(serviceId, serviceUpdateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceDescription>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceDescriptionWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceDescription(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceDescription} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceDescription} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceDescription(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceDescription(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceDescription(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceHealthWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceHealth(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealth(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceHealth(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceHealth(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceHealthUsingPolicyWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceHealthUsingPolicy(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealthUsingPolicy(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceHealthUsingPolicy(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceHealthUsingPolicy(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportServiceHealthWithHttpOperationResponse(serviceId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportServiceHealth(serviceId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportServiceHealth(serviceId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportServiceHealth(serviceId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportServiceHealth(serviceId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition, to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the the PartitionKeyValue parameter is a name
   * of the partition. This is valid for the partitions with partitioning scheme
   * as Named. The value is 3.
   *
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was got previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResolvedServicePartition>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resolveServiceWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resolveService(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition, to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the the PartitionKeyValue parameter is a name
   * of the partition. This is valid for the partitions with partitioning scheme
   * as Named. The value is 3.
   *
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was got previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResolvedServicePartition} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResolvedServicePartition} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resolveService(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resolveService(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resolveService(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * Gets the list of partitions of a Service Fabric service. The response
   * include the partition id, partitioning scheme information, keys supported by
   * the partition, status, health and other details about the partition.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServicePartitionInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionInfoListWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionInfoList(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * Gets the list of partitions of a Service Fabric service. The response
   * include the partition id, partitioning scheme information, keys supported by
   * the partition, status, health and other details about the partition.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedServicePartitionInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServicePartitionInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfoList(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionInfoList(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionInfoList(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * The Partitions endpoint returns information about the specified partition.
   * The response include the partition id, partitioning scheme information, keys
   * supported by the partition, status, health and other details about the
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServicePartitionInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionInfoWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionInfo(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * The Partitions endpoint returns information about the specified partition.
   * The response include the partition id, partitioning scheme information, keys
   * supported by the partition, status, health and other details about the
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServicePartitionInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServicePartitionInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfo(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionInfo(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionInfo(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * The GetServiceName endpoint returns the name of the service for the
   * specified partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceNameInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceNameInfoWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceNameInfo(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * The GetServiceName endpoint returns the name of the service for the
   * specified partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceNameInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceNameInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceNameInfo(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceNameInfo(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceNameInfo(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Gets the health information of the specified partition.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag based enumeration, so the value
   * could be a combination of these value obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionHealthWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionHealth(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Gets the health information of the specified partition.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag based enumeration, so the value
   * could be a combination of these value obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealth(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionHealth(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionHealth(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag based enumeration, so the value
   * could be a combination of these value obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionHealthUsingPolicyWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionHealthUsingPolicy(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * cmdlet returns an error.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag based enumeration, so the value
   * could be a combination of these value obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealthUsingPolicy(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionHealthUsingPolicy(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionHealthUsingPolicy(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportPartitionHealthWithHttpOperationResponse(partitionId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportPartitionHealth(partitionId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportPartitionHealth(partitionId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportPartitionHealth(partitionId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportPartitionHealth(partitionId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the load of the specified Service Fabric partition.
   *
   * Returns information about the specified partition.
   * The response includes a list of load information.
   * Each information includes load metric name, value and last reported time in
   * UTC.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionLoadInformation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionLoadInformationWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionLoadInformation(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the load of the specified Service Fabric partition.
   *
   * Returns information about the specified partition.
   * The response includes a list of load information.
   * Each information includes load metric name, value and last reported time in
   * UTC.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionLoadInformation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionLoadInformation} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionLoadInformation(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionLoadInformation(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionLoadInformation(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetPartitionLoadWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetPartitionLoad(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetPartitionLoad(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetPartitionLoad(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetPartitionLoad(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition which is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover a
   * specific partition which is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverPartitionWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverPartition(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition which is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover a
   * specific partition which is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverPartition(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverPartition(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverPartition(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service which is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service which is currently stuck in quorum loss. This
   * operation should only be performed if it is known that the replicas that are
   * down cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverServicePartitionsWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverServicePartitions(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service which is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service which is currently stuck in quorum loss. This
   * operation should only be performed if it is known that the replicas that are
   * down cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverServicePartitions(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverServicePartitions(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverServicePartitions(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services which are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services which are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSystemPartitionsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSystemPartitions(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services which are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services which are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSystemPartitions(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSystemPartitions(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSystemPartitions(options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * any services (including system services) which are currently stuck in quorum
   * loss. This operation should only be performed if it is known that the
   * replicas that are down cannot be recovered. Incorrect use of this API can
   * cause potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverAllPartitionsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverAllPartitions(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * any services (including system services) which are currently stuck in quorum
   * loss. This operation should only be performed if it is known that the
   * replicas that are down cannot be recovered. Incorrect use of this API can
   * cause potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverAllPartitions(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverAllPartitions(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverAllPartitions(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing.
   *
   * - Invalid - Indicates that the repair task state is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Created - Indicates that the repair task has been created.
   * - Claimed - Indicates that the repair task has been claimed by a repair
   * executor.
   * - Preparing - Indicates that the Repair Manager is preparing the system to
   * handle the impact of the repair task, usually by taking resources offline
   * gracefully.
   * - Approved - Indicates that the repair task has been approved by the Repair
   * Manager and is safe to execute.
   * - Executing - Indicates that execution of the repair task is in progress.
   * - Restoring - Indicates that the Repair Manager is restoring the system to
   * its pre-repair state, usually by bringing resources back online.
   * - Completed - Indicates that the repair task has completed, and no further
   * state changes will occur.
   * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
   * 'Approved', 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   *
   * @param {object} [repairTask.target]
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact]
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution.
   * Must be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * - Invalid - Indicates that the repair task result is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Succeeded - Indicates that the repair task completed execution
   * successfully.
   * - Cancelled - Indicates that the repair task was cancelled prior to
   * execution.
   * - Interrupted - Indicates that execution of the repair task was interrupted
   * by a cancellation request after some work had already been performed.
   * - Failed - Indicates that there was a failure during execution of the repair
   * task. Some work may have been performed.
   * - Pending - Indicates that the repair task result is not yet available,
   * because the repair task has not finished executing.
   * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
   * 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {object} [repairTask.history]
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createRepairTaskWithHttpOperationResponse(repairTask, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createRepairTask(repairTask, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing.
   *
   * - Invalid - Indicates that the repair task state is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Created - Indicates that the repair task has been created.
   * - Claimed - Indicates that the repair task has been claimed by a repair
   * executor.
   * - Preparing - Indicates that the Repair Manager is preparing the system to
   * handle the impact of the repair task, usually by taking resources offline
   * gracefully.
   * - Approved - Indicates that the repair task has been approved by the Repair
   * Manager and is safe to execute.
   * - Executing - Indicates that execution of the repair task is in progress.
   * - Restoring - Indicates that the Repair Manager is restoring the system to
   * its pre-repair state, usually by bringing resources back online.
   * - Completed - Indicates that the repair task has completed, and no further
   * state changes will occur.
   * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
   * 'Approved', 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   *
   * @param {object} [repairTask.target]
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact]
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution.
   * Must be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * - Invalid - Indicates that the repair task result is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Succeeded - Indicates that the repair task completed execution
   * successfully.
   * - Cancelled - Indicates that the repair task was cancelled prior to
   * execution.
   * - Interrupted - Indicates that execution of the repair task was interrupted
   * by a cancellation request after some work had already been performed.
   * - Failed - Indicates that there was a failure during execution of the repair
   * task. Some work may have been performed.
   * - Pending - Indicates that the repair task result is not yet available,
   * because the repair task has not finished executing.
   * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
   * 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {object} [repairTask.history]
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createRepairTask(repairTask, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createRepairTask(repairTask, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createRepairTask(repairTask, options, optionalCallback);
    }
  }

  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.</para>
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.</para>
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  cancelRepairTaskWithHttpOperationResponse(repairTaskCancelDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._cancelRepairTask(repairTaskCancelDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.</para>
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.</para>
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelRepairTask(repairTaskCancelDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._cancelRepairTask(repairTaskCancelDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._cancelRepairTask(repairTaskCancelDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRepairTaskWithHttpOperationResponse(repairTaskDeleteDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRepairTask(repairTaskDeleteDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRepairTask(repairTaskDeleteDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRepairTask(repairTaskDeleteDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRepairTask(repairTaskDeleteDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRepairTaskListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRepairTaskList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRepairTaskList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRepairTaskList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRepairTaskList(options, optionalCallback);
    }
  }

  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.</para>
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  forceApproveRepairTaskWithHttpOperationResponse(repairTaskApproveDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._forceApproveRepairTask(repairTaskApproveDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.</para>
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  forceApproveRepairTask(repairTaskApproveDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._forceApproveRepairTask(repairTaskApproveDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._forceApproveRepairTask(repairTaskApproveDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRepairTaskHealthPolicyWithHttpOperationResponse(repairTaskUpdateHealthPolicyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing.
   *
   * - Invalid - Indicates that the repair task state is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Created - Indicates that the repair task has been created.
   * - Claimed - Indicates that the repair task has been claimed by a repair
   * executor.
   * - Preparing - Indicates that the Repair Manager is preparing the system to
   * handle the impact of the repair task, usually by taking resources offline
   * gracefully.
   * - Approved - Indicates that the repair task has been approved by the Repair
   * Manager and is safe to execute.
   * - Executing - Indicates that execution of the repair task is in progress.
   * - Restoring - Indicates that the Repair Manager is restoring the system to
   * its pre-repair state, usually by bringing resources back online.
   * - Completed - Indicates that the repair task has completed, and no further
   * state changes will occur.
   * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
   * 'Approved', 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   *
   * @param {object} [repairTask.target]
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact]
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution.
   * Must be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * - Invalid - Indicates that the repair task result is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Succeeded - Indicates that the repair task completed execution
   * successfully.
   * - Cancelled - Indicates that the repair task was cancelled prior to
   * execution.
   * - Interrupted - Indicates that execution of the repair task was interrupted
   * by a cancellation request after some work had already been performed.
   * - Failed - Indicates that there was a failure during execution of the repair
   * task. Some work may have been performed.
   * - Pending - Indicates that the repair task result is not yet available,
   * because the repair task has not finished executing.
   * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
   * 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {object} [repairTask.history]
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRepairExecutionStateWithHttpOperationResponse(repairTask, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRepairExecutionState(repairTask, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing.
   *
   * - Invalid - Indicates that the repair task state is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Created - Indicates that the repair task has been created.
   * - Claimed - Indicates that the repair task has been claimed by a repair
   * executor.
   * - Preparing - Indicates that the Repair Manager is preparing the system to
   * handle the impact of the repair task, usually by taking resources offline
   * gracefully.
   * - Approved - Indicates that the repair task has been approved by the Repair
   * Manager and is safe to execute.
   * - Executing - Indicates that execution of the repair task is in progress.
   * - Restoring - Indicates that the Repair Manager is restoring the system to
   * its pre-repair state, usually by bringing resources back online.
   * - Completed - Indicates that the repair task has completed, and no further
   * state changes will occur.
   * . Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing',
   * 'Approved', 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   *
   * @param {object} [repairTask.target]
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact]
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution.
   * Must be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * - Invalid - Indicates that the repair task result is invalid. All Service
   * Fabric enumerations have the invalid value.
   * - Succeeded - Indicates that the repair task completed execution
   * successfully.
   * - Cancelled - Indicates that the repair task was cancelled prior to
   * execution.
   * - Interrupted - Indicates that execution of the repair task was interrupted
   * by a cancellation request after some work had already been performed.
   * - Failed - Indicates that there was a failure during execution of the repair
   * task. Some work may have been performed.
   * - Pending - Indicates that the repair task result is not yet available,
   * because the repair task has not finished executing.
   * . Possible values include: 'Invalid', 'Succeeded', 'Cancelled',
   * 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   *
   * @param {object} [repairTask.history]
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] Possible values
   * include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairExecutionState(repairTask, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRepairExecutionState(repairTask, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRepairExecutionState(repairTask, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The respons include the id, role, status, health, node
   * name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedReplicaInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaInfoListWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaInfoList(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The respons include the id, role, status, health, node
   * name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedReplicaInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedReplicaInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfoList(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaInfoList(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaInfoList(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The respons include the id, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaInfoWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaInfo(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The respons include the id, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfo(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaInfo(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaInfo(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaHealthWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaHealth(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealth(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaHealth(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaHealth(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaHealthUsingPolicyWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealthUsingPolicy(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} serviceKind The kind of service replica (Stateless or
   * Stateful) for which the health is being reported. Following are the possible
   * values.
   * - Stateless - Does not use Service Fabric to make its state highly available
   * or reliable. The value is 1
   * - Stateful - Uses Service Fabric to make its state or part of its state
   * highly available and reliable. The value is 2.
   * . Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportReplicaHealthWithHttpOperationResponse(partitionId, replicaId, serviceKind, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportReplicaHealth(partitionId, replicaId, serviceKind, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} serviceKind The kind of service replica (Stateless or
   * Stateful) for which the health is being reported. Following are the possible
   * values.
   * - Stateless - Does not use Service Fabric to make its state highly available
   * or reliable. The value is 1
   * - Stateful - Uses Service Fabric to make its state or part of its state
   * highly available and reliable. The value is 2.
   * . Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportReplicaHealth(partitionId, replicaId, serviceKind, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportReplicaHealth(partitionId, replicaId, serviceKind, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportReplicaHealth(partitionId, replicaId, serviceKind, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition id, replica id,
   * status of the replica, name of the service, name of the service type and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition id, replica id,
   * status of the replica, name of the service, name of the service type and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information include service kind, service name, current service operation,
   * current service operation start date time, partition id, replica/instance
   * id, reported load and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaDetailInfoWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information include service kind, service name, current service operation,
   * current service operation start date time, partition id, replica/instance
   * id, reported load and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information include service kind, service name, current service operation,
   * current service operation start date time, partition id, replica/instance
   * id, reported load and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaDetailInfoByPartitionIdWithHttpOperationResponse(nodeName, partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information include service kind, service name, current service operation,
   * current service operation start date time, partition id, replica/instance
   * id, reported load and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartReplicaWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartReplica(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartReplica(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services.In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeReplicaWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services.In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeReplica(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeReplica(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageInfoListByNameWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of an service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageHealthWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of an service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of an service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageHealthUsingPolicyWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of an service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag based
   * enumeration, so the value could be a combination of these value obtained
   * using bitwise 'OR' operator. For example, If the provided value is 6 then
   * all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportDeployedServicePackageHealthWithHttpOperationResponse(nodeName, applicationId, servicePackageName, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name which identifies
   * the client/watchdog/system component which generated the health information.
   *
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   *
   * @param {string} healthInformation.healthState Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field is using ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is remopved from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag which indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from Http
   * Gateway to the health store, regardless of the fabric client settings that
   * the Http Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the Http Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the Http Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Downloads packages associated with specified service manifest to
   * image cache on specified node.
   *
   * Downloads packages associated with specified service manifest to image cache
   * on specified node.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deployedServicePackageToNodeWithHttpOperationResponse(nodeName, deployServicePackageToNodeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deployedServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Downloads packages associated with specified service manifest to
   * image cache on specified node.
   *
   * Downloads packages associated with specified service manifest to image cache
   * on specified node.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deployedServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deployedServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deployedServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedCodePackageInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedCodePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedCodePackageInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedCodePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedCodePackageInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId]
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartDeployedCodePackageWithHttpOperationResponse(nodeName, applicationId, restartDeployedCodePackageDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character. For example, if the application name is "fabric://myapp/app1",
   * the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId]
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Creates a Service Fabric compose deployment.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createComposeDeploymentWithHttpOperationResponse(createComposeDeploymentDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createComposeDeployment(createComposeDeploymentDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Creates a Service Fabric compose deployment.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createComposeDeployment(createComposeDeploymentDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createComposeDeployment(createComposeDeploymentDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createComposeDeployment(createComposeDeploymentDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentStatusInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentStatusWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentStatus(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ComposeDeploymentStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentStatusInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatus(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentStatus(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentStatus(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedComposeDeploymentStatusInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentStatusListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentStatusList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged queries includes as much
   * results as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedComposeDeploymentStatusInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedComposeDeploymentStatusInfoList} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatusList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentStatusList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentStatusList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentUpgradeProgressWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentUpgradeProgress(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ComposeDeploymentUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentUpgradeProgressInfo} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentUpgradeProgress(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentUpgradeProgress(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentUpgradeProgress(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeComposeDeploymentWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeComposeDeployment(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeComposeDeployment(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeComposeDeployment(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeComposeDeployment(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind Possible
   * values include: 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode]
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart]
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction]
   * Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startComposeDeploymentUpgradeWithHttpOperationResponse(deploymentName, composeDeploymentUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind Possible
   * values include: 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode]
   * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual',
   * 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart]
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction]
   * Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy]
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Please refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults --
   * inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   *
   * @param {object} [chaosParameters.clusterHealthPolicy]
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {object} [chaosParameters.context]
   *
   * @param {object} [chaosParameters.context.map]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startChaosWithHttpOperationResponse(chaosParameters, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startChaos(chaosParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Please refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults --
   * inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   *
   * @param {object} [chaosParameters.clusterHealthPolicy]
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   *
   * @param {object} [chaosParameters.context]
   *
   * @param {object} [chaosParameters.context.map]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startChaos(chaosParameters, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startChaos(chaosParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startChaos(chaosParameters, options, optionalCallback);
    }
  }

  /**
   * @summary Stops Chaos in the cluster if it is already running, otherwise it
   * does nothing.
   *
   * Stops Chaos from scheduling further faults; but, the in-flight faults are
   * not affected.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopChaosWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopChaos(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops Chaos in the cluster if it is already running, otherwise it
   * does nothing.
   *
   * Stops Chaos from scheduling further faults; but, the in-flight faults are
   * not affected.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopChaos(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopChaos(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopChaos(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the next segment of the Chaos report based on the passed-in
   * continuation token or the passed-in time-range.
   *
   * You can either specify the ContinuationToken to get the next segment of the
   * Chaos report or you can specify the time-range
   * through StartTimeUtc and EndTimeUtc, but you cannot specify both the
   * ContinuationToken and the time-range in the same call.
   * When there are more than 100 Chaos events, the Chaos report is returned in
   * segments where a segment contains no more than 100 Chaos events.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The count of ticks representing the
   * start time of the time range for which a Chaos report is to be generated.
   * Please consult [DateTime.Ticks
   * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
   * for details about tick.
   *
   * @param {string} [options.endTimeUtc] The count of ticks representing the end
   * time of the time range for which a Chaos report is to be generated. Please
   * consult [DateTime.Ticks
   * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
   * for details about tick.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ChaosReport>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getChaosReportWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getChaosReport(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the next segment of the Chaos report based on the passed-in
   * continuation token or the passed-in time-range.
   *
   * You can either specify the ContinuationToken to get the next segment of the
   * Chaos report or you can specify the time-range
   * through StartTimeUtc and EndTimeUtc, but you cannot specify both the
   * ContinuationToken and the time-range in the same call.
   * When there are more than 100 Chaos events, the Chaos report is returned in
   * segments where a segment contains no more than 100 Chaos events.
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The count of ticks representing the
   * start time of the time range for which a Chaos report is to be generated.
   * Please consult [DateTime.Ticks
   * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
   * for details about tick.
   *
   * @param {string} [options.endTimeUtc] The count of ticks representing the end
   * time of the time range for which a Chaos report is to be generated. Please
   * consult [DateTime.Ticks
   * Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29)
   * for details about tick.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ChaosReport} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ChaosReport} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaosReport(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getChaosReport(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getChaosReport(options, optionalCallback);
    }
  }

  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  uploadFileWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._uploadFile(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  uploadFile(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._uploadFile(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._uploadFile(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreContentWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreContent(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreContent(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreContent(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreContent(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteImageStoreContentWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteImageStoreContent(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteImageStoreContent(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteImageStoreContent(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteImageStoreContent(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreRootContentWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreRootContent(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreRootContent(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreRootContent(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreRootContent(options, optionalCallback);
    }
  }

  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  copyImageStoreContentWithHttpOperationResponse(imageStoreCopyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._copyImageStoreContent(imageStoreCopyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  copyImageStoreContent(imageStoreCopyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._copyImageStoreContent(imageStoreCopyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._copyImageStoreContent(imageStoreCopyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is  the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that have
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  invokeInfrastructureCommandWithHttpOperationResponse(command, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._invokeInfrastructureCommand(command, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is  the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that have
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureCommand(command, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._invokeInfrastructureCommand(command, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._invokeInfrastructureCommand(command, options, optionalCallback);
    }
  }

  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is  the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that have
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  invokeInfrastructureQueryWithHttpOperationResponse(command, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._invokeInfrastructureQuery(command, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is  the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that have
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureQuery(command, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._invokeInfrastructureQuery(command, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._invokeInfrastructureQuery(command, options, optionalCallback);
    }
  }

  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode
   * PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce.
   * - Invalid - Reserved.  Do not pass into API.
   * - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas
   * to go down, triggering an OnDataLoss event in the system for the given
   * partition.
   * - FullDataLoss - FullDataLoss option will drop all the replicas which means
   * that all the data will be lost.
   * . Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startDataLossWithHttpOperationResponse(serviceId, partitionId, operationId, dataLossMode, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode
   * PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce.
   * - Invalid - Reserved.  Do not pass into API.
   * - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas
   * to go down, triggering an OnDataLoss event in the system for the given
   * partition.
   * - FullDataLoss - FullDataLoss option will drop all the replicas which means
   * that all the data will be lost.
   * . Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionDataLossProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDataLossProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDataLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionDataLossProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionDataLossProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataLossProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDataLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDataLossProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * Induces quorum loss for a given stateful service partition.  This API is
   * useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce.
   * - Invalid - Reserved.  Do not pass into API.
   * - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for
   * a partition will be down that will cause a quorum loss.
   * - AllReplicas- Full Quorum loss mode : All replicas for a partition will be
   * down that will cause a quorum loss.
   * . Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startQuorumLossWithHttpOperationResponse(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * Induces quorum loss for a given stateful service partition.  This API is
   * useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce.
   * - Invalid - Reserved.  Do not pass into API.
   * - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for
   * a partition will be down that will cause a quorum loss.
   * - AllReplicas- Full Quorum loss mode : All replicas for a partition will be
   * down that will cause a quorum loss.
   * . Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionQuorumLossProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQuorumLossProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQuorumLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionQuorumLossProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionQuorumLossProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQuorumLossProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQuorumLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQuorumLossProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode - Invalid - Reserved.  Do not pass into
   * API.
   * - AllReplicasOrInstances - All replicas or instances in the partition are
   * restarted at once.
   * - OnlyActiveSecondaries - Only the secondary replicas are restarted.
   * . Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startPartitionRestartWithHttpOperationResponse(serviceId, partitionId, operationId, restartPartitionMode, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode - Invalid - Reserved.  Do not pass into
   * API.
   * - AllReplicasOrInstances - All replicas or instances in the partition are
   * restarted at once.
   * - OnlyActiveSecondaries - Only the secondary replicas are restarted.
   * . Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionRestartProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionRestartProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   *
   * @param {string} serviceId The identity of the service. This is typically the
   * full name of the service without the 'fabric:' URI scheme. Starting from
   * version 6.0, hierarchical names are delimited with the "~" character. For
   * example, if the service name is "fabric://myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionRestartProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionRestartProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionRestartProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up.
   * - Invalid - Reserved.  Do not pass into API.
   * - Start - Transition a stopped node to up.
   * - Stop - Transition an up node to stopped.
   * . Possible values include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startNodeTransitionWithHttpOperationResponse(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up.
   * - Invalid - Reserved.  Do not pass into API.
   * - Start - Transition a stopped node to up.
   * - Stop - Transition an up node to stopped.
   * . Possible values include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeTransitionProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeTransitionProgressWithHttpOperationResponse(nodeName, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeTransitionProgress(nodeName, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeTransitionProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeTransitionProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeTransitionProgress(nodeName, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeTransitionProgress(nodeName, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeTransitionProgress(nodeName, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the a list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   * 65535 - select all
   * 1     - select PartitionDataLoss.
   * 2     - select PartitionQuorumLoss.
   * 4     - select PartitionRestart.
   * 8     - select NodeTransition.
   *
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   * 65535 - select All
   * 1     - select Running
   * 2     - select RollingBack
   * 8     - select Completed
   * 16    - select Faulted
   * 32    - select Cancelled
   * 64    - select ForceCancelled
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFaultOperationListWithHttpOperationResponse(typeFilter, stateFilter, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFaultOperationList(typeFilter, stateFilter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the a list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   * 65535 - select all
   * 1     - select PartitionDataLoss.
   * 2     - select PartitionQuorumLoss.
   * 4     - select PartitionRestart.
   * 8     - select NodeTransition.
   *
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   * 65535 - select All
   * 1     - select Running
   * 2     - select RollingBack
   * 8     - select Completed
   * 16    - select Faulted
   * 32    - select Cancelled
   * 64    - select ForceCancelled
   *
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFaultOperationList(typeFilter, stateFilter, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFaultOperationList(typeFilter, stateFilter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFaultOperationList(typeFilter, stateFilter, options, optionalCallback);
    }
  }

  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following is a list of APIs that start fault operations that may be
   * cancelled using CancelOperation -
   * - StartDataLoss
   * - StartQuorumLoss
   * - StartPartitionRestart
   * - StartNodeTransition
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will/is be
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully rollback and clean up
   * internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  cancelOperationWithHttpOperationResponse(operationId, force, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._cancelOperation(operationId, force, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following is a list of APIs that start fault operations that may be
   * cancelled using CancelOperation -
   * - StartDataLoss
   * - StartQuorumLoss
   * - StartPartitionRestart
   * - StartNodeTransition
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will/is be
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully rollback and clean up
   * internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This specifies the time duration that the client is
   * willing to wait for the requested operation to complete. The default value
   * for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelOperation(operationId, force, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._cancelOperation(operationId, force, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._cancelOperation(operationId, force, options, optionalCallback);
    }
  }

}

module.exports = ServiceFabricClient;
