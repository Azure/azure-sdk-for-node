/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');
const operations = require('./operations');


/**
 * @summary Get the Service Fabric cluster manifest.
 *
 * Get the Service Fabric cluster manifest. The cluster manifest contains
 * properties of the cluster that include different node types on the cluster,
 * security configurations, fault, and upgrade domain topologies, etc.
 *
 * These properties are specified as part of the ClusterConfig.JSON file while
 * deploying a stand-alone cluster. However, most of the information in the
 * cluster manifest
 * is generated internally by service fabric during cluster deployment in other
 * deployment scenarios (e.g. when using Azure portal).
 *
 * The contents of the cluster manifest are for informational purposes only and
 * users are not expected to take a dependency on the format of the file
 * contents or its interpretation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterManifest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterManifest(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterManifest';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster.
 *
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
 * filter the collection of nodes and applications returned based on their
 * aggregated health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
 * node health state objects returned in the result of cluster health query
 * based on their health state. The possible values for this parameter include
 * integer value of one of the
 * following health states. Only nodes that match the filter are returned. All
 * nodes are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of nodes with
 * HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
 * the application health state objects returned in the result of cluster
 * health
 * query based on their health state.
 * The possible values for this parameter include integer value obtained from
 * members or bitwise operations
 * on members of HealthStateFilter enumeration. Only applications that match
 * the filter are returned.
 * All applications are used to evaluate the aggregated health state. If not
 * specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of applications
 * with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {boolean} [options.includeSystemApplicationHealthStatistics]
 * Indicates whether the health statistics should include the fabric:/System
 * application health statistics. False by default.
 * If IncludeSystemApplicationHealthStatistics is set to true, the health
 * statistics include the entities that belong to the fabric:/System
 * application.
 * Otherwise, the query result includes health statistics only for user
 * applications.
 * The health statistics must be included in the query result for this
 * parameter to be applied.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealth(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let nodesHealthStateFilter = (options && options.nodesHealthStateFilter !== undefined) ? options.nodesHealthStateFilter : 0;
  let applicationsHealthStateFilter = (options && options.applicationsHealthStateFilter !== undefined) ? options.applicationsHealthStateFilter : 0;
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let includeSystemApplicationHealthStatistics = (options && options.includeSystemApplicationHealthStatistics !== undefined) ? options.includeSystemApplicationHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined && typeof nodesHealthStateFilter !== 'number') {
      throw new Error('nodesHealthStateFilter must be of type number.');
    }
    if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined && typeof applicationsHealthStateFilter !== 'number') {
      throw new Error('applicationsHealthStateFilter must be of type number.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined && typeof includeSystemApplicationHealthStatistics !== 'boolean') {
      throw new Error('includeSystemApplicationHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined) {
    queryParameters.push('NodesHealthStateFilter=' + encodeURIComponent(nodesHealthStateFilter.toString()));
  }
  if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined) {
    queryParameters.push('ApplicationsHealthStateFilter=' + encodeURIComponent(applicationsHealthStateFilter.toString()));
  }
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined) {
    queryParameters.push('IncludeSystemApplicationHealthStatistics=' + encodeURIComponent(includeSystemApplicationHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using the specified
 * policy.
 *
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
 * filter the collection of nodes and applications returned based on their
 * aggregated health state.
 * Use ClusterHealthPolicies to override the health policies used to evaluate
 * the health.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
 * node health state objects returned in the result of cluster health query
 * based on their health state. The possible values for this parameter include
 * integer value of one of the
 * following health states. Only nodes that match the filter are returned. All
 * nodes are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of nodes with
 * HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
 * the application health state objects returned in the result of cluster
 * health
 * query based on their health state.
 * The possible values for this parameter include integer value obtained from
 * members or bitwise operations
 * on members of HealthStateFilter enumeration. Only applications that match
 * the filter are returned.
 * All applications are used to evaluate the aggregated health state. If not
 * specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of applications
 * with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {boolean} [options.includeSystemApplicationHealthStatistics]
 * Indicates whether the health statistics should include the fabric:/System
 * application health statistics. False by default.
 * If IncludeSystemApplicationHealthStatistics is set to true, the health
 * statistics include the entities that belong to the fabric:/System
 * application.
 * Otherwise, the query result includes health statistics only for user
 * applications.
 * The health statistics must be included in the query result for this
 * parameter to be applied.
 *
 * @param {object} [options.clusterHealthPolicies] Describes the health
 * policies used to evaluate the cluster health.
 * If not present, the health evaluation uses the cluster health policy defined
 * in the cluster manifest or the default cluster health policy.
 * By default, each application is evaluated using its specific application
 * health policy, defined in the application manifest, or the default health
 * policy, if no policy is defined in manifest.
 * If the application health policy map is specified, and it has an entry for
 * an application, the specified application health policy
 * is used to evaluate the application health.
 *
 * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
 * Defines a map that contains specific application health policies for
 * different applications.
 * Each entry specifies as key the application name and as value an
 * ApplicationHealthPolicy used to evaluate the application health.
 * If an application is not specified in the map, the application health
 * evaluation uses the ApplicationHealthPolicy found in its application
 * manifest or the default application health policy (if no health policy is
 * defined in the manifest).
 * The map is empty by default.
 *
 * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy] Defines
 * a health policy used to evaluate the health of the cluster or of a cluster
 * node.
 *
 * @param {boolean}
 * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array}
 * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthUsingPolicy(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let nodesHealthStateFilter = (options && options.nodesHealthStateFilter !== undefined) ? options.nodesHealthStateFilter : 0;
  let applicationsHealthStateFilter = (options && options.applicationsHealthStateFilter !== undefined) ? options.applicationsHealthStateFilter : 0;
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let includeSystemApplicationHealthStatistics = (options && options.includeSystemApplicationHealthStatistics !== undefined) ? options.includeSystemApplicationHealthStatistics : false;
  let clusterHealthPolicies = (options && options.clusterHealthPolicies !== undefined) ? options.clusterHealthPolicies : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined && typeof nodesHealthStateFilter !== 'number') {
      throw new Error('nodesHealthStateFilter must be of type number.');
    }
    if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined && typeof applicationsHealthStateFilter !== 'number') {
      throw new Error('applicationsHealthStateFilter must be of type number.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined && typeof includeSystemApplicationHealthStatistics !== 'boolean') {
      throw new Error('includeSystemApplicationHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (nodesHealthStateFilter !== null && nodesHealthStateFilter !== undefined) {
    queryParameters.push('NodesHealthStateFilter=' + encodeURIComponent(nodesHealthStateFilter.toString()));
  }
  if (applicationsHealthStateFilter !== null && applicationsHealthStateFilter !== undefined) {
    queryParameters.push('ApplicationsHealthStateFilter=' + encodeURIComponent(applicationsHealthStateFilter.toString()));
  }
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (includeSystemApplicationHealthStatistics !== null && includeSystemApplicationHealthStatistics !== undefined) {
    queryParameters.push('IncludeSystemApplicationHealthStatistics=' + encodeURIComponent(includeSystemApplicationHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthPolicies !== null && clusterHealthPolicies !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthPolicies']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthPolicies, 'clusterHealthPolicies');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthPolicies, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using health chunks.
 *
 * Gets the health of a Service Fabric cluster using health chunks. Includes
 * the aggregated health state of the cluster, but none of the cluster
 * entities.
 * To expand the cluster health and get the health state of all or some of the
 * entities, use the POST URI and specify the cluster health chunk query
 * description.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealthChunk} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthChunk(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealthChunk';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealthChunk']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric cluster using health chunks.
 *
 * Gets the health of a Service Fabric cluster using health chunks. The health
 * evaluation is done based on the input cluster health chunk query
 * description.
 * The query description allows users to specify health policies for evaluating
 * the cluster and its children.
 * Users can specify very flexible filters to select which cluster entities to
 * return. The selection can be done based on the entities health state and
 * based on the hierarchy.
 * The query can return multi-level children of the entities based on the
 * specified filters. For example, it can return one application with a
 * specified name, and for this application, return
 * only services that are in Error or Warning, and all partitions and replicas
 * for one of these services.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
 * cluster and application health policies used to evaluate the cluster health
 * and the filters to select which cluster entities to be returned.
 * If the cluster health policy is present, it is used to evaluate the cluster
 * events and the cluster nodes. If not present, the health evaluation uses the
 * cluster health policy defined in the cluster manifest or the default cluster
 * health policy.
 * By default, each application is evaluated using its specific application
 * health policy, defined in the application manifest, or the default health
 * policy, if no policy is defined in manifest.
 * If the application health policy map is specified, and it has an entry for
 * an application, the specified application health policy
 * is used to evaluate the application health.
 * Users can specify very flexible filters to select which cluster entities to
 * include in response. The selection can be done based on the entities health
 * state and based on the hierarchy.
 * The query can return multi-level children of the entities based on the
 * specified filters. For example, it can return one application with a
 * specified name, and for this application, return
 * only services that are in Error or Warning, and all partitions and replicas
 * for one of these services.
 *
 * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
 * Defines a list of filters that specify which nodes to be included in the
 * returned cluster health chunk.
 * If no filters are specified, no nodes are returned. All the nodes are used
 * to evaluate the cluster's aggregated health state, regardless of the input
 * filters.
 * The cluster health chunk query may specify multiple node filters.
 * For example, it can specify a filter to return all nodes with health state
 * Error and another filter to always include a node identified by its
 * NodeName.
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
 * list of filters that specify which applications to be included in the
 * returned cluster health chunk.
 * If no filters are specified, no applications are returned. All the
 * applications are used to evaluate the cluster's aggregated health state,
 * regardless of the input filters.
 * The cluster health chunk query may specify multiple application filters.
 * For example, it can specify a filter to return all applications with health
 * state Error and another filter to always include applications of a specified
 * application type.
 *
 * @param {object}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy] Defines a
 * health policy used to evaluate the health of the cluster or of a cluster
 * node.
 *
 * @param {boolean}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {object}
 * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 * @param {array}
 * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterHealthChunk} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let clusterHealthChunkQueryDescription = (options && options.clusterHealthChunkQueryDescription !== undefined) ? options.clusterHealthChunkQueryDescription : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterHealthChunk';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthChunkQueryDescription !== null && clusterHealthChunkQueryDescription !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthChunkQueryDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthChunkQueryDescription, 'clusterHealthChunkQueryDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthChunkQueryDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterHealthChunk']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric cluster.
 *
 * Sends a health report on a Service Fabric cluster. The report must contain
 * the information about the source of the health report and property on which
 * it is reported.
 * The report is sent to a Service Fabric gateway node, which forwards to the
 * health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetClusterHealth and check that the report appears in the HealthEvents
 * section.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportClusterHealth(healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/ReportClusterHealth';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of fabric code versions that are provisioned in a
 * Service Fabric cluster.
 *
 * Gets a list of information about fabric code versions that are provisioned
 * in the cluster. The parameter CodeVersion can be used to optionally filter
 * the output to only that particular version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.codeVersion] The product version of Service Fabric.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProvisionedFabricCodeVersionInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let codeVersion = (options && options.codeVersion !== undefined) ? options.codeVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (codeVersion !== null && codeVersion !== undefined && typeof codeVersion.valueOf() !== 'string') {
      throw new Error('codeVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetProvisionedCodeVersions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (codeVersion !== null && codeVersion !== undefined) {
    queryParameters.push('CodeVersion=' + encodeURIComponent(codeVersion));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FabricCodeVersionInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'FabricCodeVersionInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of fabric config versions that are provisioned in a
 * Service Fabric cluster.
 *
 * Gets a list of information about fabric config versions that are provisioned
 * in the cluster. The parameter ConfigVersion can be used to optionally filter
 * the output to only that particular version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.configVersion] The config version of Service
 * Fabric.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProvisionedFabricConfigVersionInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let configVersion = (options && options.configVersion !== undefined) ? options.configVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (configVersion !== null && configVersion !== undefined && typeof configVersion.valueOf() !== 'string') {
      throw new Error('configVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetProvisionedConfigVersions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (configVersion !== null && configVersion !== undefined) {
    queryParameters.push('ConfigVersion=' + encodeURIComponent(configVersion));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FabricConfigVersionInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'FabricConfigVersionInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of the current cluster upgrade.
 *
 * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
 * currently in progress, get the last state of the previous cluster upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterUpgradeProgressObject} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterUpgradeProgress(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetUpgradeProgress';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterUpgradeProgressObject']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the Service Fabric standalone cluster configuration.
 *
 * The cluster configuration contains properties of the cluster that include
 * different node types on the cluster,
 * security configurations, fault, and upgrade domain topologies, etc.
 *
 * @param {string} configurationApiVersion The API version of the Standalone
 * cluster json configuration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterConfiguration} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterConfiguration(configurationApiVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (configurationApiVersion === null || configurationApiVersion === undefined || typeof configurationApiVersion.valueOf() !== 'string') {
      throw new Error('configurationApiVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterConfiguration';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ConfigurationApiVersion=' + encodeURIComponent(configurationApiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterConfiguration']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the cluster configuration upgrade status of a Service Fabric
 * standalone cluster.
 *
 * Get the cluster configuration upgrade status details of a Service Fabric
 * standalone cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterConfigurationUpgradeStatusInfo} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterConfigurationUpgradeStatus(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterConfigurationUpgradeStatus';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterConfigurationUpgradeStatusInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the service state of Service Fabric Upgrade Orchestration
 * Service.
 *
 * Get the service state of Service Fabric Upgrade Orchestration Service. This
 * API is internally used for support purposes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UpgradeOrchestrationServiceState} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUpgradeOrchestrationServiceState(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetUpgradeOrchestrationServiceState';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UpgradeOrchestrationServiceState']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Update the service state of Service Fabric Upgrade Orchestration
 * Service.
 *
 * Update the service state of Service Fabric Upgrade Orchestration Service.
 * This API is internally used for support purposes.
 *
 * @param {object} upgradeOrchestrationServiceState Service state of Service
 * Fabric Upgrade Orchestration Service.
 *
 * @param {string} [upgradeOrchestrationServiceState.serviceState] The state of
 * Service Fabric Upgrade Orchestration Service.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UpgradeOrchestrationServiceStateSummary} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (upgradeOrchestrationServiceState === null || upgradeOrchestrationServiceState === undefined) {
      throw new Error('upgradeOrchestrationServiceState cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/SetUpgradeOrchestrationServiceState';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (upgradeOrchestrationServiceState !== null && upgradeOrchestrationServiceState !== undefined) {
      let requestModelMapper = new client.models['UpgradeOrchestrationServiceState']().mapper();
      requestModel = client.serialize(requestModelMapper, upgradeOrchestrationServiceState, 'upgradeOrchestrationServiceState');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(upgradeOrchestrationServiceState, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UpgradeOrchestrationServiceStateSummary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Provision the code or configuration packages of a Service Fabric
 * cluster.
 *
 * Validate and provision the code or configuration packages of a Service
 * Fabric cluster.
 *
 * @param {object} provisionFabricDescription Describes the parameters for
 * provisioning a cluster.
 *
 * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
 * package file path.
 *
 * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
 * cluster manifest file path.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _provisionCluster(provisionFabricDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (provisionFabricDescription === null || provisionFabricDescription === undefined) {
      throw new Error('provisionFabricDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Provision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (provisionFabricDescription !== null && provisionFabricDescription !== undefined) {
      let requestModelMapper = new client.models['ProvisionFabricDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, provisionFabricDescription, 'provisionFabricDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(provisionFabricDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Unprovision the code or configuration packages of a Service Fabric
 * cluster.
 *
 * It is supported to unprovision code and configuration separately.
 *
 * @param {object} unprovisionFabricDescription Describes the parameters for
 * unprovisioning a cluster.
 *
 * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
 * package version.
 *
 * @param {string} [unprovisionFabricDescription.configVersion] The cluster
 * manifest version.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _unprovisionCluster(unprovisionFabricDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (unprovisionFabricDescription === null || unprovisionFabricDescription === undefined) {
      throw new Error('unprovisionFabricDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Unprovision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (unprovisionFabricDescription !== null && unprovisionFabricDescription !== undefined) {
      let requestModelMapper = new client.models['UnprovisionFabricDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, unprovisionFabricDescription, 'unprovisionFabricDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(unprovisionFabricDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Roll back the upgrade of a Service Fabric cluster.
 *
 * Roll back the code or configuration upgrade of a Service Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rollbackClusterUpgrade(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RollbackUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Make the cluster upgrade move on to the next upgrade domain.
 *
 * Make the cluster code or configuration upgrade move on to the next upgrade
 * domain if appropriate.
 *
 * @param {object} resumeClusterUpgradeDescription Describes the parameters for
 * resuming a cluster upgrade.
 *
 * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
 * upgrade domain for this cluster upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeClusterUpgrade(resumeClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (resumeClusterUpgradeDescription === null || resumeClusterUpgradeDescription === undefined) {
      throw new Error('resumeClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/MoveToNextUpgradeDomain';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (resumeClusterUpgradeDescription !== null && resumeClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ResumeClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, resumeClusterUpgradeDescription, 'resumeClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(resumeClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start upgrading the code or configuration version of a Service
 * Fabric cluster.
 *
 * Validate the supplied upgrade parameters and start upgrading the code or
 * configuration version of a Service Fabric cluster if the parameters are
 * valid.
 *
 * @param {object} startClusterUpgradeDescription Describes the parameters for
 * starting a cluster upgrade.
 *
 * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
 * code version.
 *
 * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
 * configuration version.
 *
 * @param {string} [startClusterUpgradeDescription.upgradeKind] The kind of
 * upgrade out of the following possible values. Possible values include:
 * 'Invalid', 'Rolling'
 *
 * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] The mode
 * used to monitor health during a rolling upgrade. The values are
 * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
 * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 *
 * @param {number}
 * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
 * maximum amount of time to block processing of an upgrade domain and prevent
 * loss of availability when there are unexpected issues. When this timeout
 * expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 *
 * @param {boolean} [startClusterUpgradeDescription.forceRestart] If true, then
 * processes are forcefully restarted during upgrade even when the code version
 * has not changed (the upgrade only changes configuration or data).
 *
 * @param {object} [startClusterUpgradeDescription.monitoringPolicy] Describes
 * the parameters for monitoring an upgrade in Monitored mode.
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 * The amount of time the overall upgrade has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {string}
 * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy] Defines
 * a health policy used to evaluate the health of the cluster or of a cluster
 * node.
 *
 * @param {boolean}
 * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array}
 * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {boolean}
 * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
 * enables delta health evaluation rather than absolute health evaluation after
 * completion of each upgrade domain.
 *
 * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
 * Defines a health policy used to evaluate the health of the cluster during a
 * cluster upgrade.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
 * The maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the nodes at
 * the beginning of upgrade and the state of the nodes at the time of the
 * health evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 *
 * @param {number}
 * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 *
 * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 * @param {array}
 * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startClusterUpgrade(startClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (startClusterUpgradeDescription === null || startClusterUpgradeDescription === undefined) {
      throw new Error('startClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/Upgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (startClusterUpgradeDescription !== null && startClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['StartClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, startClusterUpgradeDescription, 'startClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(startClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start upgrading the configuration of a Service Fabric standalone
 * cluster.
 *
 * Validate the supplied configuration upgrade parameters and start upgrading
 * the cluster configuration if the parameters are valid.
 *
 * @param {object} clusterConfigurationUpgradeDescription Parameters for a
 * standalone cluster configuration upgrade.
 *
 * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
 * cluster configuration as a JSON string. For example, [this
 * file](https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json)
 * contains JSON describing the [nodes and other properties of the
 * cluster](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest).
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
 * of time between attempts to perform health checks if the application or
 * cluster is not healthy.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
 * The length of time to wait after completing an upgrade domain before
 * starting the health checks process.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
 * The length of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
 * timeout for the upgrade domain.
 *
 * @param {moment.duration}
 * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
 * timeout.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications during the upgrade.
 * Allowed values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
 * values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
 * maximum allowed percentage of delta health degradation during the upgrade.
 * Allowed values are integer values from zero to 100.
 *
 * @param {number}
 * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain delta health degradation
 * during the upgrade. Allowed values are integer values from zero to 100.
 *
 * @param {object}
 * [clusterConfigurationUpgradeDescription.applicationHealthPolicies] Defines
 * the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 * @param {array}
 * [clusterConfigurationUpgradeDescription.applicationHealthPolicies.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (clusterConfigurationUpgradeDescription === null || clusterConfigurationUpgradeDescription === undefined) {
      throw new Error('clusterConfigurationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/StartClusterConfigurationUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterConfigurationUpgradeDescription !== null && clusterConfigurationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ClusterConfigurationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterConfigurationUpgradeDescription, 'clusterConfigurationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterConfigurationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
 *
 * Update the upgrade parameters used during a Service Fabric cluster upgrade.
 *
 * @param {object} updateClusterUpgradeDescription Parameters for updating a
 * cluster upgrade.
 *
 * @param {string} [updateClusterUpgradeDescription.upgradeKind] The type of
 * upgrade out of the following possible values. Possible values include:
 * 'Invalid', 'Rolling', 'Rolling_ForceRestart'
 *
 * @param {object} [updateClusterUpgradeDescription.updateDescription]
 * Describes the parameters for updating a rolling upgrade of application or
 * cluster.
 *
 * @param {string}
 * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode The
 * mode used to monitor health during a rolling upgrade. The values are
 * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
 * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.updateDescription.forceRestart] If true,
 * then processes are forcefully restarted during upgrade even when the code
 * version has not changed (the upgrade only changes configuration or data).
 *
 * @param {number}
 * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
 * The maximum amount of time to block processing of an upgrade domain and
 * prevent loss of availability when there are unexpected issues. When this
 * timeout expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
 * The amount of time the overall upgrade has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {string}
 * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
 * Defines a health policy used to evaluate the health of the cluster or of a
 * cluster node.
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
 * The maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array}
 * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {boolean}
 * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
 * enables delta health evaluation rather than absolute health evaluation after
 * completion of each upgrade domain.
 *
 * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
 * Defines a health policy used to evaluate the health of the cluster during a
 * cluster upgrade.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
 * The maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades. The delta is measured between the state of the nodes at
 * the beginning of upgrade and the state of the nodes at the time of the
 * health evaluation. The check is performed after every upgrade domain upgrade
 * completion to make sure the global state of the cluster is within tolerated
 * limits. The default value is 10%.
 *
 * @param {number}
 * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades. The delta is measured between the state of
 * the upgrade domain nodes at the beginning of upgrade and the state of the
 * upgrade domain nodes at the time of the health evaluation. The check is
 * performed after every upgrade domain upgrade completion for all completed
 * upgrade domains to make sure the state of the upgrade domains is within
 * tolerated limits. The default value is 15%.
 *
 * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 *
 * @param {array}
 * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
 * The wrapper that contains the map with application health policies used to
 * evaluate specific applications in the cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateClusterUpgrade(updateClusterUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (updateClusterUpgradeDescription === null || updateClusterUpgradeDescription === undefined) {
      throw new Error('updateClusterUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateUpgrade';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (updateClusterUpgradeDescription !== null && updateClusterUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['UpdateClusterUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, updateClusterUpgradeDescription, 'updateClusterUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(updateClusterUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Azure Active Directory metadata used for secured
 * connection to cluster.
 *
 * Gets the Azure Active Directory metadata used for secured connection to
 * cluster.
 * This API is not supposed to be called separately. It provides information
 * needed to set up an Azure Active Directory secured connection with a Service
 * Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AadMetadataObject} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAadMetadata(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetAadMetadata';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AadMetadataObject']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the current Service Fabric cluster version.
 *
 * If a cluster upgrade is happening, then this API will return the lowest
 * (older) version of the current and target cluster runtime versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ClusterVersion} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterVersion(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetClusterVersion';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ClusterVersion']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of nodes in the Service Fabric cluster.
 *
 * The response includes the name, status, ID, health, uptime, and other
 * details about the nodes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
 * on the NodeStatus. Only the nodes that are matching the specified filter
 * value will be returned. The filter value can be one of the following.
 * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
 * 'disabling', 'disabled', 'unknown', 'removed'
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedNodeInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let nodeStatusFilter = (options && options.nodeStatusFilter !== undefined) ? options.nodeStatusFilter : 'default';
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.3';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (nodeStatusFilter !== null && nodeStatusFilter !== undefined && typeof nodeStatusFilter.valueOf() !== 'string') {
      throw new Error('nodeStatusFilter must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (nodeStatusFilter !== null && nodeStatusFilter !== undefined) {
    queryParameters.push('NodeStatusFilter=' + encodeURIComponent(nodeStatusFilter));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedNodeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a specific node in the Service Fabric
 * cluster.
 *
 * The response includes the name, status, ID, health, uptime, and other
 * details about the node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeInfo(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric node.
 *
 * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
 * filter the collection of health events reported on the node based on the
 * health state. If the node that you specify by name does not exist in the
 * health store, this returns an error.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeHealth(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric node, by using the specified
 * health policy.
 *
 * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
 * filter the collection of health events reported on the node based on the
 * health state. Use ClusterHealthPolicy in the POST body to override the
 * health policies used to evaluate the health. If the node that you specify by
 * name does not exist in the health store, this returns an error.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.clusterHealthPolicy] Describes the health policies
 * used to evaluate the health of a cluster or node. If not present, the health
 * evaluation uses the health policy from cluster manifest or the default
 * health policy.
 *
 * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
 * maximum allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
 * allowed percentage of unhealthy applications before reporting an error. For
 * example, to allow 10% of applications to be unhealthy, this value would be
 * 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
 * Defines a map with max percentage unhealthy applications for specific
 * application types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeHealthUsingPolicy(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let clusterHealthPolicy = (options && options.clusterHealthPolicy !== undefined) ? options.clusterHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (clusterHealthPolicy !== null && clusterHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ClusterHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, clusterHealthPolicy, 'clusterHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(clusterHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric node.
 *
 * Reports health state of the specified Service Fabric node. The report must
 * contain the information about the source of the health report and property
 * on which it is reported.
 * The report is sent to a Service Fabric gateway node, which forwards to the
 * health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run GetNodeHealth
 * and check that the report appears in the HealthEvents section.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportNodeHealth(nodeName, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the load information of a Service Fabric node.
 *
 * Retrieves the load information of a Service Fabric node for all the metrics
 * that have load or capacity defined.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeLoadInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeLoadInfo(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeLoadInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deactivate a Service Fabric cluster node with the specified
 * deactivation intent.
 *
 * Deactivate a Service Fabric cluster node with the specified deactivation
 * intent. Once the deactivation is in progress, the deactivation intent can be
 * increased, but not decreased (for example, a node that is deactivated with
 * the Pause intent can be deactivated further with Restart, but not the other
 * way around. Nodes may be reactivated using the Activate a node operation any
 * time after they are deactivated. If the deactivation is not complete, this
 * will cancel the deactivation. A node that goes down and comes back up while
 * deactivated will still need to be reactivated before services will be placed
 * on that node.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} deactivationIntentDescription Describes the intent or reason
 * for deactivating the node.
 *
 * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
 * the intent or reason for deactivating the node. The possible values are
 * following. Possible values include: 'Pause', 'Restart', 'RemoveData'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disableNode(nodeName, deactivationIntentDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (deactivationIntentDescription === null || deactivationIntentDescription === undefined) {
      throw new Error('deactivationIntentDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Deactivate';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deactivationIntentDescription !== null && deactivationIntentDescription !== undefined) {
      let requestModelMapper = new client.models['DeactivationIntentDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, deactivationIntentDescription, 'deactivationIntentDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deactivationIntentDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Activate a Service Fabric cluster node that is currently
 * deactivated.
 *
 * Activates a Service Fabric cluster node that is currently deactivated. Once
 * activated, the node will again become a viable target for placing new
 * replicas, and any deactivated replicas remaining on the node will be
 * reactivated.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enableNode(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Activate';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Notifies Service Fabric that the persisted state on a node has been
 * permanently removed or lost.
 *
 * This implies that it is not possible to recover the persisted state of that
 * node. This generally happens if a hard disk has been wiped clean, or if a
 * hard disk crashes. The node has to be down for this operation to be
 * successful. This operation lets Service Fabric know that the replicas on
 * that node no longer exist, and that Service Fabric should stop waiting for
 * those replicas to come back up. Do not run this cmdlet if the state on the
 * node has not been removed and the node can come back up with its state
 * intact.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeNodeState(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/RemoveNodeState';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a Service Fabric cluster node.
 *
 * Restarts a Service Fabric cluster node that is already started.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} restartNodeDescription The instance of the node to be
 * restarted and a flag indicating the need to take dump of the fabric process.
 *
 * @param {string} restartNodeDescription.nodeInstanceId The instance ID of the
 * target node. If instance ID is specified the node is restarted only if it
 * matches with the current instance of the node. A default value of "0" would
 * match any instance ID. The instance ID can be obtained using get node query.
 *
 * @param {string} [restartNodeDescription.createFabricDump] Specify True to
 * create a dump of the fabric node process. This is case-sensitive. Possible
 * values include: 'False', 'True'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartNode(nodeName, restartNodeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (restartNodeDescription === null || restartNodeDescription === undefined) {
      throw new Error('restartNodeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (restartNodeDescription !== null && restartNodeDescription !== undefined) {
      let requestModelMapper = new client.models['RestartNodeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, restartNodeDescription, 'restartNodeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(restartNodeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of application types in the Service Fabric cluster.
 *
 * Returns the information about the application types that are provisioned or
 * in the process of being provisioned in the Service Fabric cluster. Each
 * version of an application type is returned as one application type. The
 * response includes the name, version, status, and other details about the
 * application type. This is a paged query, meaning that if not all of the
 * application types fit in a page, one page of results is returned as well as
 * a continuation token, which can be used to get the next page. For example,
 * if there are 10 application types but a page only fits the first three
 * application types, or if max results is set to 3, then three is returned. To
 * access the rest of the results, retrieve subsequent pages by using the
 * returned continuation token in the next query. An empty continuation token
 * is returned if there are no subsequent pages.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
 * on ApplicationTypeDefinitionKind which is the mechanism used to define a
 * Service Fabric application type.
 * - Default - Default value, which performs the same function as selecting
 * "All". The value is 0.
 * - All - Filter that matches input with any ApplicationTypeDefinitionKind
 * value. The value is 65535.
 * - ServiceFabricApplicationPackage - Filter that matches input with
 * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
 * value is 1.
 * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
 * value Compose. The value is 2.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationTypeInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationTypeInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationTypeDefinitionKindFilter = (options && options.applicationTypeDefinitionKindFilter !== undefined) ? options.applicationTypeDefinitionKindFilter : 0;
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeDefinitionKindFilter !== null && applicationTypeDefinitionKindFilter !== undefined && typeof applicationTypeDefinitionKindFilter !== 'number') {
      throw new Error('applicationTypeDefinitionKindFilter must be of type number.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (applicationTypeDefinitionKindFilter !== null && applicationTypeDefinitionKindFilter !== undefined) {
    queryParameters.push('ApplicationTypeDefinitionKindFilter=' + encodeURIComponent(applicationTypeDefinitionKindFilter.toString()));
  }
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationTypeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of application types in the Service Fabric cluster
 * matching exactly the specified name.
 *
 * Returns the information about the application types that are provisioned or
 * in the process of being provisioned in the Service Fabric cluster. These
 * results are of application types whose name match exactly the one specified
 * as the parameter, and which comply with the given query parameters. All
 * versions of the application type matching the application type name are
 * returned, with each version returned as one application type. The response
 * includes the name, version, status, and other details about the application
 * type. This is a paged query, meaning that if not all of the application
 * types fit in a page, one page of results is returned as well as a
 * continuation token, which can be used to get the next page. For example, if
 * there are 10 application types but a page only fits the first three
 * application types, or if max results is set to 3, then three is returned. To
 * access the rest of the results, retrieve subsequent pages by using the
 * returned continuation token in the next query. An empty continuation token
 * is returned if there are no subsequent pages.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.applicationTypeVersion] The version of the
 * application type.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationTypeInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationTypeInfoListByName(applicationTypeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationTypeVersion = (options && options.applicationTypeVersion !== undefined) ? options.applicationTypeVersion : undefined;
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion !== null && applicationTypeVersion !== undefined && typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (applicationTypeVersion !== null && applicationTypeVersion !== undefined) {
    queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  }
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationTypeInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Provisions or registers a Service Fabric application type with the
 * cluster using the '.sfpkg' package in the external store or using the
 * application package in the image store.
 *
 * Provisions a Service Fabric application type with the cluster. The provision
 * is required before any new applications can be instantiated.
 * The provision operation can be performed either on the application package
 * specified by the relativePathInImageStore, or by using the URI of the
 * external '.sfpkg'.
 *
 * @param {object} provisionApplicationTypeDescriptionBaseRequiredBodyParam The
 * base type of provision application type description which supports either
 * image store-based provision or external store-based provision.
 *
 * @param {boolean}
 * provisionApplicationTypeDescriptionBaseRequiredBodyParam.async Indicates
 * whether or not provisioning should occur asynchronously. When set to true,
 * the provision operation returns when the request is accepted by the system,
 * and the provision operation continues without any timeout limit. The default
 * value is false. For large application packages, we recommend setting the
 * value to true.
 *
 * @param {string}
 * provisionApplicationTypeDescriptionBaseRequiredBodyParam.kind Polymorphic
 * Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (provisionApplicationTypeDescriptionBaseRequiredBodyParam === null || provisionApplicationTypeDescriptionBaseRequiredBodyParam === undefined) {
      throw new Error('provisionApplicationTypeDescriptionBaseRequiredBodyParam cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/$/Provision';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (provisionApplicationTypeDescriptionBaseRequiredBodyParam !== null && provisionApplicationTypeDescriptionBaseRequiredBodyParam !== undefined) {
      let requestModelMapper = new client.models['ProvisionApplicationTypeDescriptionBase']().mapper();
      requestModel = client.serialize(requestModelMapper, provisionApplicationTypeDescriptionBaseRequiredBodyParam, 'provisionApplicationTypeDescriptionBaseRequiredBodyParam');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(provisionApplicationTypeDescriptionBaseRequiredBodyParam, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes or unregisters a Service Fabric application type from the
 * cluster.
 *
 * This operation can only be performed if all application instances of the
 * application type have been deleted. Once the application type is
 * unregistered, no new application instances can be created for this
 * particular application type.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {object} unprovisionApplicationTypeDescriptionInfo The relative path
 * for the application package in the image store specified during the prior
 * copy operation.
 *
 * @param {string}
 * unprovisionApplicationTypeDescriptionInfo.applicationTypeVersion The version
 * of the application type as defined in the application manifest.
 *
 * @param {boolean} [unprovisionApplicationTypeDescriptionInfo.async] The flag
 * indicating whether or not unprovision should occur asynchronously. When set
 * to true, the unprovision operation returns when the request is accepted by
 * the system, and the unprovision operation continues without any timeout
 * limit. The default value is false. However, we recommend setting it to true
 * for large application packages that were provisioned.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _unprovisionApplicationType(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (unprovisionApplicationTypeDescriptionInfo === null || unprovisionApplicationTypeDescriptionInfo === undefined) {
      throw new Error('unprovisionApplicationTypeDescriptionInfo cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/Unprovision';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (unprovisionApplicationTypeDescriptionInfo !== null && unprovisionApplicationTypeDescriptionInfo !== undefined) {
      let requestModelMapper = new client.models['UnprovisionApplicationTypeDescriptionInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, unprovisionApplicationTypeDescriptionInfo, 'unprovisionApplicationTypeDescriptionInfo');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(unprovisionApplicationTypeDescriptionInfo, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list containing the information about service types that
 * are supported by a provisioned application type in a Service Fabric cluster.
 *
 * Gets the list containing the information about service types that are
 * supported by a provisioned application type in a Service Fabric cluster. The
 * provided application type must exist. Otherwise, a 404 status is returned.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetServiceTypes';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'ServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a specific service type that is
 * supported by a provisioned application type in a Service Fabric cluster.
 *
 * Gets the information about a specific service type that is supported by a
 * provisioned application type in a Service Fabric cluster. The provided
 * application type must exist. Otherwise, a 404 status is returned. A 204
 * response is returned if the specified service type is not found in the
 * cluster.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {string} serviceTypeName Specifies the name of a Service Fabric
 * service type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceTypeInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceTypeInfoByName(applicationTypeName, applicationTypeVersion, serviceTypeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (serviceTypeName === null || serviceTypeName === undefined || typeof serviceTypeName.valueOf() !== 'string') {
      throw new Error('serviceTypeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetServiceTypes/{serviceTypeName}';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  requestUrl = requestUrl.replace('{serviceTypeName}', serviceTypeName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceTypeInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the manifest describing a service type.
 *
 * Gets the manifest describing a service type. The response contains the
 * service manifest XML as a string.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {string} serviceManifestName The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceTypeManifest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName === null || serviceManifestName === undefined || typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetServiceManifest';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceTypeManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list containing the information about service types from
 * the applications deployed on a node in a Service Fabric cluster.
 *
 * Gets the list containing the information about service types from the
 * applications deployed on a node in a Service Fabric cluster. The response
 * includes the name of the service type, its registration status, the code
 * package that registered it and activation ID of the service package.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of the service
 * manifest to filter the list of deployed service type information. If
 * specified, the response will only contain the information about service
 * types that are defined in this service manifest.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceTypeInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a specified service type of the
 * application deployed on a node in a Service Fabric cluster.
 *
 * Gets the list containing the information about a specific service type from
 * the applications deployed on a node in a Service Fabric cluster. The
 * response includes the name of the service type, its registration status, the
 * code package that registered it and activation ID of the service package.
 * Each entry represents one activation of a service type, differentiated by
 * the activation ID.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceTypeName Specifies the name of a Service Fabric
 * service type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of the service
 * manifest to filter the list of deployed service type information. If
 * specified, the response will only contain the information about service
 * types that are defined in this service manifest.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceTypeName === null || serviceTypeName === undefined || typeof serviceTypeName.valueOf() !== 'string') {
      throw new Error('serviceTypeName cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{serviceTypeName}', serviceTypeName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceTypeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServiceTypeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric application.
 *
 * Creates a Service Fabric application using the specified description.
 *
 * @param {object} applicationDescription Description for creating an
 * application.
 *
 * @param {string} applicationDescription.name The name of the application,
 * including the 'fabric:' URI scheme.
 *
 * @param {string} applicationDescription.typeName The application type name as
 * defined in the application manifest.
 *
 * @param {string} applicationDescription.typeVersion The version of the
 * application type as defined in the application manifest.
 *
 * @param {array} [applicationDescription.parameterList] List of application
 * parameters with overridden values from their default values specified in the
 * application manifest.
 *
 * @param {object} [applicationDescription.applicationCapacity] Describes
 * capacity information for services of this application. This description can
 * be used for describing the following.
 * - Reserving the capacity for the services on the nodes
 * - Limiting the total number of nodes that services of this application can
 * run on
 * - Limiting the custom capacity metrics to limit the total consumption of
 * this metric by the services of this application
 *
 * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
 * The minimum number of nodes where Service Fabric will reserve capacity for
 * this application. Note that this does not mean that the services of this
 * application will be placed on all of those nodes. If this property is set to
 * zero, no capacity will be reserved. The value of this property cannot be
 * more than the value of the MaximumNodes property.
 *
 * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
 * The maximum number of nodes where Service Fabric will reserve capacity for
 * this application. Note that this does not mean that the services of this
 * application will be placed on all of those nodes. By default, the value of
 * this property is zero and it means that the services can be placed on any
 * node.
 *
 * @param {array}
 * [applicationDescription.applicationCapacity.applicationMetrics] List of
 * application capacity metric description.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createApplication(applicationDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationDescription === null || applicationDescription === undefined) {
      throw new Error('applicationDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationDescription !== null && applicationDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationDescription, 'applicationDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric application.
 *
 * An application must be created before it can be deleted. Deleting an
 * application will delete all services that are part of that application. By
 * default, Service Fabric will try to close service replicas in a graceful
 * manner and then delete the service. However, if a service is having issues
 * closing the replica gracefully, the delete operation may take a long time or
 * get stuck. Use the optional ForceRemove flag to skip the graceful close
 * sequence and forcefully delete the application and all of its services.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteApplication(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/Delete';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets load information about a Service Fabric application.
 *
 * Returns the load information about the application that was created or in
 * the process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * minimum nodes, maximum nodes, the number of nodes the application is
 * occupying currently, and application load metric information about the
 * application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationLoadInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationLoadInfo(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationLoadInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of applications created in the Service Fabric cluster
 * that match the specified filters.
 *
 * Gets the information about the applications that were created or in the
 * process of being created in the Service Fabric cluster and match the
 * specified filters. The response includes the name, type, status, parameters,
 * and other details about the application. If the applications do not fit in a
 * page, one page of results is returned as well as a continuation token, which
 * can be used to get the next page. Filters ApplicationTypeName and
 * ApplicationDefinitionKindFilter cannot be specified at the same time.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
 * ApplicationDefinitionKind, which is the mechanism used to define a Service
 * Fabric application.
 * - Default - Default value, which performs the same function as selecting
 * "All". The value is 0.
 * - All - Filter that matches input with any ApplicationDefinitionKind value.
 * The value is 65535.
 * - ServiceFabricApplicationDescription - Filter that matches input with
 * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
 * value is 1.
 * - Compose - Filter that matches input with ApplicationDefinitionKind value
 * Compose. The value is 2.
 *
 * @param {string} [options.applicationTypeName] The application type name used
 * to filter the applications to query for. This value should not contain the
 * application type version.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedApplicationInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationInfoList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let applicationDefinitionKindFilter = (options && options.applicationDefinitionKindFilter !== undefined) ? options.applicationDefinitionKindFilter : 0;
  let applicationTypeName = (options && options.applicationTypeName !== undefined) ? options.applicationTypeName : undefined;
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.1';
  // Validate
  try {
    if (applicationDefinitionKindFilter !== null && applicationDefinitionKindFilter !== undefined && typeof applicationDefinitionKindFilter !== 'number') {
      throw new Error('applicationDefinitionKindFilter must be of type number.');
    }
    if (applicationTypeName !== null && applicationTypeName !== undefined && typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (applicationDefinitionKindFilter !== null && applicationDefinitionKindFilter !== undefined) {
    queryParameters.push('ApplicationDefinitionKindFilter=' + encodeURIComponent(applicationDefinitionKindFilter.toString()));
  }
  if (applicationTypeName !== null && applicationTypeName !== undefined) {
    queryParameters.push('ApplicationTypeName=' + encodeURIComponent(applicationTypeName));
  }
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedApplicationInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information about a Service Fabric application.
 *
 * Returns the information about the application that was created or in the
 * process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * type, status, parameters, and other details about the application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.excludeApplicationParameters] The flag that
 * specifies whether application parameters will be excluded from the result.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationInfo(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let excludeApplicationParameters = (options && options.excludeApplicationParameters !== undefined) ? options.excludeApplicationParameters : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined && typeof excludeApplicationParameters !== 'boolean') {
      throw new Error('excludeApplicationParameters must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (excludeApplicationParameters !== null && excludeApplicationParameters !== undefined) {
    queryParameters.push('ExcludeApplicationParameters=' + encodeURIComponent(excludeApplicationParameters.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the service fabric application.
 *
 * Returns the heath state of the service fabric application. The response
 * reports either Ok, Error or Warning health state. If the entity is not found
 * in the health store, it will return Error.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
 * filtering of the deployed applications health state objects returned in the
 * result of application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states. Only deployed applications that match the filter
 * will be returned.
 * All deployed applications are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values, obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of deployed
 * applications with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
 * services health state objects returned in the result of services health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only services that match the filter are returned. All services are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values,
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of services with HealthState value of OK (2) and Warning
 * (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationHealth(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedApplicationsHealthStateFilter = (options && options.deployedApplicationsHealthStateFilter !== undefined) ? options.deployedApplicationsHealthStateFilter : 0;
  let servicesHealthStateFilter = (options && options.servicesHealthStateFilter !== undefined) ? options.servicesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined && typeof deployedApplicationsHealthStateFilter !== 'number') {
      throw new Error('deployedApplicationsHealthStateFilter must be of type number.');
    }
    if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined && typeof servicesHealthStateFilter !== 'number') {
      throw new Error('servicesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined) {
    queryParameters.push('DeployedApplicationsHealthStateFilter=' + encodeURIComponent(deployedApplicationsHealthStateFilter.toString()));
  }
  if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined) {
    queryParameters.push('ServicesHealthStateFilter=' + encodeURIComponent(servicesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric application using the specified
 * policy.
 *
 * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
 * to filter the collection of health events reported on the node based on the
 * health state. Use ClusterHealthPolicies to override the health policies used
 * to evaluate the health.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
 * filtering of the deployed applications health state objects returned in the
 * result of application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states. Only deployed applications that match the filter
 * will be returned.
 * All deployed applications are used to evaluate the aggregated health state.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value could be a
 * combination of these values, obtained using bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of deployed
 * applications with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
 * services health state objects returned in the result of services health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only services that match the filter are returned. All services are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values,
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of services with HealthState value of OK (2) and Warning
 * (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationHealthUsingPolicy(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedApplicationsHealthStateFilter = (options && options.deployedApplicationsHealthStateFilter !== undefined) ? options.deployedApplicationsHealthStateFilter : 0;
  let servicesHealthStateFilter = (options && options.servicesHealthStateFilter !== undefined) ? options.servicesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined && typeof deployedApplicationsHealthStateFilter !== 'number') {
      throw new Error('deployedApplicationsHealthStateFilter must be of type number.');
    }
    if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined && typeof servicesHealthStateFilter !== 'number') {
      throw new Error('servicesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedApplicationsHealthStateFilter !== null && deployedApplicationsHealthStateFilter !== undefined) {
    queryParameters.push('DeployedApplicationsHealthStateFilter=' + encodeURIComponent(deployedApplicationsHealthStateFilter.toString()));
  }
  if (servicesHealthStateFilter !== null && servicesHealthStateFilter !== undefined) {
    queryParameters.push('ServicesHealthStateFilter=' + encodeURIComponent(servicesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric application.
 *
 * Reports health state of the specified Service Fabric application. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Application, which forwards
 * to the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get application
 * health and check that the report appears in the HealthEvents section.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportApplicationHealth(applicationId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts upgrading an application in the Service Fabric cluster.
 *
 * Validates the supplied application upgrade parameters and starts upgrading
 * the application if the parameters are valid.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} applicationUpgradeDescription Parameters for an application
 * upgrade.
 *
 * @param {string} applicationUpgradeDescription.name The name of the target
 * application, including the 'fabric:' URI scheme.
 *
 * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
 * The target application type version (found in the application manifest) for
 * the application upgrade.
 *
 * @param {array} applicationUpgradeDescription.parameters List of application
 * parameters with overridden values from their default values specified in the
 * application manifest.
 *
 * @param {string} applicationUpgradeDescription.upgradeKind The kind of
 * upgrade out of the following possible values. Possible values include:
 * 'Invalid', 'Rolling'
 *
 * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] The mode
 * used to monitor health during a rolling upgrade. The values are
 * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
 * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 *
 * @param {number}
 * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
 * maximum amount of time to block processing of an upgrade domain and prevent
 * loss of availability when there are unexpected issues. When this timeout
 * expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 *
 * @param {boolean} [applicationUpgradeDescription.forceRestart] If true, then
 * processes are forcefully restarted during upgrade even when the code version
 * has not changed (the upgrade only changes configuration or data).
 *
 * @param {object} [applicationUpgradeDescription.monitoringPolicy] Describes
 * the parameters for monitoring an upgrade in Monitored mode.
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 * The amount of time the overall upgrade has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {string}
 * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
 * Defines a health policy used to evaluate the health of an application or one
 * of its children entities.
 *
 * @param {boolean}
 * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array}
 * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (applicationUpgradeDescription === null || applicationUpgradeDescription === undefined) {
      throw new Error('applicationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/Upgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationUpgradeDescription !== null && applicationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationUpgradeDescription, 'applicationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest upgrade performed on this application.
 *
 * Returns information about the state of the latest application upgrade along
 * with details to aid debugging application health issues.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationUpgradeProgressInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationUpgrade(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetUpgradeProgress';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationUpgradeProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates an ongoing application upgrade in the Service Fabric
 * cluster.
 *
 * Updates the parameters of an ongoing application upgrade from the ones
 * specified at the time of starting the application upgrade. This may be
 * required to mitigate stuck application upgrades due to incorrect parameters
 * or issues in the application to make progress.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} applicationUpgradeUpdateDescription Parameters for updating
 * an existing application upgrade.
 *
 * @param {string} applicationUpgradeUpdateDescription.name The name of the
 * application, including the 'fabric:' URI scheme.
 *
 * @param {string} applicationUpgradeUpdateDescription.upgradeKind The kind of
 * upgrade out of the following possible values. Possible values include:
 * 'Invalid', 'Rolling'
 *
 * @param {object}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy] Defines a
 * health policy used to evaluate the health of an application or one of its
 * children entities.
 *
 * @param {boolean}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array}
 * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
 * Describes the parameters for updating a rolling upgrade of application or
 * cluster.
 *
 * @param {string}
 * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode The
 * mode used to monitor health during a rolling upgrade. The values are
 * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
 * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 *
 * @param {boolean}
 * [applicationUpgradeUpdateDescription.updateDescription.forceRestart] If
 * true, then processes are forcefully restarted during upgrade even when the
 * code version has not changed (the upgrade only changes configuration or
 * data).
 *
 * @param {number}
 * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
 * The maximum amount of time to block processing of an upgrade domain and
 * prevent loss of availability when there are unexpected issues. When this
 * timeout expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
 * The amount of time the overall upgrade has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {string}
 * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (applicationUpgradeUpdateDescription === null || applicationUpgradeUpdateDescription === undefined) {
      throw new Error('applicationUpgradeUpdateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/UpdateUpgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationUpgradeUpdateDescription !== null && applicationUpgradeUpdateDescription !== undefined) {
      let requestModelMapper = new client.models['ApplicationUpgradeUpdateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationUpgradeUpdateDescription, 'applicationUpgradeUpdateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationUpgradeUpdateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resumes upgrading an application in the Service Fabric cluster.
 *
 * Resumes an unmonitored manual Service Fabric application upgrade. Service
 * Fabric upgrades one upgrade domain at a time. For unmonitored manual
 * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
 * to call this API before proceeding to the next upgrade domain.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} resumeApplicationUpgradeDescription Describes the parameters
 * for resuming an application upgrade.
 *
 * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
 * name of the upgrade domain in which to resume the upgrade.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (resumeApplicationUpgradeDescription === null || resumeApplicationUpgradeDescription === undefined) {
      throw new Error('resumeApplicationUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/MoveToNextUpgradeDomain';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (resumeApplicationUpgradeDescription !== null && resumeApplicationUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ResumeApplicationUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, resumeApplicationUpgradeDescription, 'resumeApplicationUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(resumeApplicationUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts rolling back the currently on-going upgrade of an
 * application in the Service Fabric cluster.
 *
 * Starts rolling back the current application upgrade to the previous version.
 * This API can only be used to roll back the current in-progress upgrade that
 * is rolling forward to new version. If the application is not currently being
 * upgraded use StartApplicationUpgrade API to upgrade it to desired version,
 * including rolling back to a previous version.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _rollbackApplicationUpgrade(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/RollbackUpgrade';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of applications deployed on a Service Fabric node.
 *
 * Gets the list of applications deployed on a Service Fabric node. The results
 * do not include information about deployed system applications unless
 * explicitly queried for by ID. Results encompass deployed applications in
 * active, activating, and downloading states. This query requires that the
 * node name corresponds to a node on the cluster. The query fails if the
 * provided node name does not point to any active Service Fabric nodes on the
 * cluster.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {boolean} [options.includeHealthState] Include the health state of an
 * entity.
 * If this parameter is false or not specified, then the health state returned
 * is "Unknown".
 * When set to true, the query goes in parallel to the node and the health
 * system service before the results are merged.
 * As a result, the query is more expensive and may take a longer time.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedDeployedApplicationInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationInfoList(nodeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let includeHealthState = (options && options.includeHealthState !== undefined) ? options.includeHealthState : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let apiVersion = '6.1';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (includeHealthState !== null && includeHealthState !== undefined && typeof includeHealthState !== 'boolean') {
      throw new Error('includeHealthState must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (includeHealthState !== null && includeHealthState !== undefined) {
    queryParameters.push('IncludeHealthState=' + encodeURIComponent(includeHealthState.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedDeployedApplicationInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about an application deployed on a Service
 * Fabric node.
 *
 * This query returns system application information if the application ID
 * provided is for system application. Results encompass deployed applications
 * in active, activating, and downloading states. This query requires that the
 * node name corresponds to a node on the cluster. The query fails if the
 * provided node name does not point to any active Service Fabric nodes on the
 * cluster.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {boolean} [options.includeHealthState] Include the health state of an
 * entity.
 * If this parameter is false or not specified, then the health state returned
 * is "Unknown".
 * When set to true, the query goes in parallel to the node and the health
 * system service before the results are merged.
 * As a result, the query is more expensive and may take a longer time.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationInfo(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let includeHealthState = (options && options.includeHealthState !== undefined) ? options.includeHealthState : false;
  let apiVersion = '6.1';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (includeHealthState !== null && includeHealthState !== undefined && typeof includeHealthState !== 'boolean') {
      throw new Error('includeHealthState must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (includeHealthState !== null && includeHealthState !== undefined) {
    queryParameters.push('IncludeHealthState=' + encodeURIComponent(includeHealthState.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of an application deployed on a
 * Service Fabric node.
 *
 * Gets the information about health of an application deployed on a Service
 * Fabric node. Use EventsHealthStateFilter to optionally filter for the
 * collection of HealthEvent objects reported on the deployed application based
 * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
 * filter for DeployedServicePackageHealth children based on health state.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
 * filtering of the deployed service package health state objects returned in
 * the result of deployed application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only deployed service packages that match the filter are returned. All
 * deployed service packages are used to evaluate the aggregated health state
 * of the deployed application.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value can be a
 * combination of these values, obtained using the bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of service
 * packages with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationHealth(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedServicePackagesHealthStateFilter = (options && options.deployedServicePackagesHealthStateFilter !== undefined) ? options.deployedServicePackagesHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined && typeof deployedServicePackagesHealthStateFilter !== 'number') {
      throw new Error('deployedServicePackagesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined) {
    queryParameters.push('DeployedServicePackagesHealthStateFilter=' + encodeURIComponent(deployedServicePackagesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of an application deployed on a
 * Service Fabric node. using the specified policy.
 *
 * Gets the information about health of an application deployed on a Service
 * Fabric node using the specified policy. Use EventsHealthStateFilter to
 * optionally filter for the collection of HealthEvent objects reported on the
 * deployed application based on health state. Use
 * DeployedServicePackagesHealthStateFilter to optionally filter for
 * DeployedServicePackageHealth children based on health state. Use
 * ApplicationHealthPolicy to optionally override the health policies used to
 * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
 * the ApplicationHealthPolicy. The rest of the fields are ignored while
 * evaluating the health of the deployed application.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
 * filtering of the deployed service package health state objects returned in
 * the result of deployed application health query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only deployed service packages that match the filter are returned. All
 * deployed service packages are used to evaluate the aggregated health state
 * of the deployed application.
 * If not specified, all entries are returned.
 * The state values are flag-based enumeration, so the value can be a
 * combination of these values, obtained using the bitwise 'OR' operator.
 * For example, if the provided value is 6 then health state of service
 * packages with HealthState value of OK (2) and Warning (4) are returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedApplicationHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let deployedServicePackagesHealthStateFilter = (options && options.deployedServicePackagesHealthStateFilter !== undefined) ? options.deployedServicePackagesHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined && typeof deployedServicePackagesHealthStateFilter !== 'number') {
      throw new Error('deployedServicePackagesHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (deployedServicePackagesHealthStateFilter !== null && deployedServicePackagesHealthStateFilter !== undefined) {
    queryParameters.push('DeployedServicePackagesHealthStateFilter=' + encodeURIComponent(deployedServicePackagesHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedApplicationHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric application deployed on
 * a Service Fabric node.
 *
 * Reports health state of the application deployed on a Service Fabric node.
 * The report must contain the information about the source of the health
 * report and property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get deployed
 * application health and check that the report appears in the HealthEvents
 * section.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the manifest describing an application type.
 *
 * The response contains the application manifest XML as a string.
 *
 * @param {string} applicationTypeName The name of the application type.
 *
 * @param {string} applicationTypeVersion The version of the application type.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationTypeManifest} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationManifest(applicationTypeName, applicationTypeVersion, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationTypeName === null || applicationTypeName === undefined || typeof applicationTypeName.valueOf() !== 'string') {
      throw new Error('applicationTypeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationTypeVersion === null || applicationTypeVersion === undefined || typeof applicationTypeVersion.valueOf() !== 'string') {
      throw new Error('applicationTypeVersion cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest';
  requestUrl = requestUrl.replace('{applicationTypeName}', encodeURIComponent(applicationTypeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ApplicationTypeVersion=' + encodeURIComponent(applicationTypeVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationTypeManifest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about all services belonging to the
 * application specified by the application ID.
 *
 * Returns the information about all services belonging to the application
 * specified by the application ID.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceTypeName] The service type name used to
 * filter the services to query for.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedServiceInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceInfoList(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceTypeName = (options && options.serviceTypeName !== undefined) ? options.serviceTypeName : undefined;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceTypeName !== null && serviceTypeName !== undefined && typeof serviceTypeName.valueOf() !== 'string') {
      throw new Error('serviceTypeName must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  if (serviceTypeName !== null && serviceTypeName !== undefined) {
    queryParameters.push('ServiceTypeName=' + encodeURIComponent(serviceTypeName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedServiceInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about the specific service belonging to the
 * Service Fabric application.
 *
 * Returns the information about the specified service belonging to the
 * specified Service Fabric application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceInfo(applicationId, serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/{serviceId}';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the name of the Service Fabric application for a service.
 *
 * Gets the name of the application for the specified service. A 404
 * FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the
 * provided service ID does not exist.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ApplicationNameInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationNameInfo(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetApplicationName';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApplicationNameInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates the specified Service Fabric service.
 *
 * This api allows creating a new Service Fabric stateless or stateful service
 * under a specified Service Fabric application. The description for creating
 * the service includes partitioning information and optional properties for
 * placement and load balancing. Some of the properties can later be modified
 * using `UpdateService` API.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} serviceDescription The information necessary to create a
 * service.
 *
 * @param {string} [serviceDescription.applicationName] The name of the
 * application, including the 'fabric:' URI scheme.
 *
 * @param {string} serviceDescription.serviceName The full name of the service
 * with 'fabric:' URI scheme.
 *
 * @param {string} serviceDescription.serviceTypeName Name of the service type
 * as specified in the service manifest.
 *
 * @param {array} [serviceDescription.initializationData] The initialization
 * data as an array of bytes. Initialization data is passed to service
 * instances or replicas when they are created.
 *
 * @param {object} serviceDescription.partitionDescription The partition
 * description as an object.
 *
 * @param {string} serviceDescription.partitionDescription.partitionScheme
 * Polymorphic Discriminator
 *
 * @param {string} [serviceDescription.placementConstraints] The placement
 * constraints as a string. Placement constraints are boolean expressions on
 * node properties and allow for restricting a service to particular nodes
 * based on the service requirements. For example, to place a service on nodes
 * where NodeType is blue specify the following: "NodeColor == blue)".
 *
 * @param {array} [serviceDescription.correlationScheme] The correlation
 * scheme.
 *
 * @param {array} [serviceDescription.serviceLoadMetrics] The service load
 * metrics.
 *
 * @param {array} [serviceDescription.servicePlacementPolicies] The service
 * placement policies.
 *
 * @param {string} [serviceDescription.defaultMoveCost] The move cost for the
 * service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
 *
 * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
 * if the DefaultMoveCost property is specified.
 *
 * @param {string} [serviceDescription.servicePackageActivationMode] The
 * activation mode of service package to be used for a service. Possible values
 * include: 'SharedProcess', 'ExclusiveProcess'
 *
 * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
 * service. It requires the DNS system service to be enabled in Service Fabric
 * cluster.
 *
 * @param {array} [serviceDescription.scalingPolicies] Scaling policies for
 * this service.
 *
 * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createService(applicationId, serviceDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceDescription === null || serviceDescription === undefined) {
      throw new Error('serviceDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/$/Create';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceDescription !== null && serviceDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceDescription, 'serviceDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric service from the service template.
 *
 * Creates a Service Fabric service from the service template defined in the
 * application manifest. A service template contains the properties that will
 * be same for the service instance of the same type. The API allows overriding
 * the properties that are usually different for different services of the same
 * service type.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} serviceFromTemplateDescription Describes the service that
 * needs to be created from the template defined in the application manifest.
 *
 * @param {string} serviceFromTemplateDescription.applicationName The name of
 * the application, including the 'fabric:' URI scheme.
 *
 * @param {string} serviceFromTemplateDescription.serviceName The full name of
 * the service with 'fabric:' URI scheme.
 *
 * @param {string} serviceFromTemplateDescription.serviceTypeName Name of the
 * service type as specified in the service manifest.
 *
 * @param {array} [serviceFromTemplateDescription.initializationData] The
 * initialization data for the newly created service instance.
 *
 * @param {string}
 * [serviceFromTemplateDescription.servicePackageActivationMode] The activation
 * mode of service package to be used for a service. Possible values include:
 * 'SharedProcess', 'ExclusiveProcess'
 *
 * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
 * of the service. It requires the DNS system service to be enabled in Service
 * Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceFromTemplateDescription === null || serviceFromTemplateDescription === undefined) {
      throw new Error('serviceFromTemplateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetServices/$/CreateFromTemplate';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceFromTemplateDescription !== null && serviceFromTemplateDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceFromTemplateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceFromTemplateDescription, 'serviceFromTemplateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceFromTemplateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric service.
 *
 * A service must be created before it can be deleted. By default, Service
 * Fabric will try to close service replicas in a graceful manner and then
 * delete the service. However, if the service is having issues closing the
 * replica gracefully, the delete operation may take a long time or get stuck.
 * Use the optional ForceRemove flag to skip the graceful close sequence and
 * forcefully delete the service.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteService(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/Delete';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a Service Fabric service using the specified update
 * description.
 *
 * This API allows updating properties of a running Service Fabric service. The
 * set of properties that can be updated are a subset of the properties that
 * were specified at the time of creating the service. The current set of
 * properties can be obtained using `GetServiceDescription` API. Note that
 * updating the properties of a running service is different than upgrading
 * your application using `StartApplicationUpgrade` API. The upgrade is a long
 * running background operation that involves moving the application from one
 * version to another, one upgrade domain at a time, whereas update applies the
 * new properties immediately to the service.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} serviceUpdateDescription The information necessary to update
 * a service.
 *
 * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
 * other properties are set. Each of the associated properties corresponds to a
 * flag, specified below, which, if set, indicate that the property is
 * specified.
 * This property can be a combination of those flags obtained using bitwise
 * 'OR' operator.
 * For example, if the provided value is 6 then the flags for
 * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
 *
 * - None - Does not indicate any other properties are set. The value is zero.
 * - TargetReplicaSetSize/InstanceCount - Indicates whether the
 * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
 * property (for Stateless services) is set. The value is 1.
 * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
 * property is set. The value is  2.
 * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
 * set. The value is 4.
 * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
 * property is set. The value is 8.
 * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
 * value is 16.
 * - PlacementConstraints - Indicates the PlacementConstraints property is set.
 * The value is 32.
 * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
 * set. The value is 64.
 * - Correlation - Indicates the CorrelationScheme property is set. The value
 * is 128.
 * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
 * 256.
 * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
 * is 512.
 * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
 * is 1024.
 *
 * @param {string} [serviceUpdateDescription.placementConstraints] The
 * placement constraints as a string. Placement constraints are boolean
 * expressions on node properties and allow for restricting a service to
 * particular nodes based on the service requirements. For example, to place a
 * service on nodes where NodeType is blue specify the following: "NodeColor ==
 * blue)".
 *
 * @param {array} [serviceUpdateDescription.correlationScheme] The correlation
 * scheme.
 *
 * @param {array} [serviceUpdateDescription.loadMetrics] The service load
 * metrics.
 *
 * @param {array} [serviceUpdateDescription.servicePlacementPolicies] The
 * service placement policies.
 *
 * @param {string} [serviceUpdateDescription.defaultMoveCost] The move cost for
 * the service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
 *
 * @param {array} [serviceUpdateDescription.scalingPolicies] Scaling policies
 * for this service.
 *
 * @param {string} serviceUpdateDescription.serviceKind Polymorphic
 * Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateService(serviceId, serviceUpdateDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (serviceUpdateDescription === null || serviceUpdateDescription === undefined) {
      throw new Error('serviceUpdateDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/Update';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (serviceUpdateDescription !== null && serviceUpdateDescription !== undefined) {
      let requestModelMapper = new client.models['ServiceUpdateDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, serviceUpdateDescription, 'serviceUpdateDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(serviceUpdateDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the description of an existing Service Fabric service.
 *
 * Gets the description of an existing Service Fabric service. A service must
 * be created before its description can be obtained.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceDescription} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceDescription(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetDescription';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceDescription']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric service.
 *
 * Gets the health information of the specified service.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use PartitionsHealthStateFilter to filter the collection of partitions
 * returned.
 * If you specify a service that does not exist in the health store, this
 * request returns an error.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
 * the partitions health state objects returned in the result of service health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only partitions that match the filter are returned. All partitions are used
 * to evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of partitions with HealthState value of OK (2) and
 * Warning (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceHealth(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let partitionsHealthStateFilter = (options && options.partitionsHealthStateFilter !== undefined) ? options.partitionsHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined && typeof partitionsHealthStateFilter !== 'number') {
      throw new Error('partitionsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined) {
    queryParameters.push('PartitionsHealthStateFilter=' + encodeURIComponent(partitionsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric service, by using
 * the specified health policy.
 *
 * Gets the health information of the specified service.
 * If the application health policy is specified, the health evaluation uses it
 * to get the aggregated health state.
 * If the policy is not specified, the health evaluation uses the application
 * health policy defined in the application manifest, or the default health
 * policy, if no policy is defined in the manifest.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use PartitionsHealthStateFilter to filter the collection of partitions
 * returned.
 * If you specify a service that does not exist in the health store, this
 * request returns an error.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
 * the partitions health state objects returned in the result of service health
 * query based on their health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only partitions that match the filter are returned. All partitions are used
 * to evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these value
 * obtained using bitwise 'OR' operator. For example, if the provided value is
 * 6 then health state of partitions with HealthState value of OK (2) and
 * Warning (4) will be returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceHealthUsingPolicy(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let partitionsHealthStateFilter = (options && options.partitionsHealthStateFilter !== undefined) ? options.partitionsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined && typeof partitionsHealthStateFilter !== 'number') {
      throw new Error('partitionsHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (partitionsHealthStateFilter !== null && partitionsHealthStateFilter !== undefined) {
    queryParameters.push('PartitionsHealthStateFilter=' + encodeURIComponent(partitionsHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric service.
 *
 * Reports health state of the specified Service Fabric service. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetServiceHealth and check that the report appears in the HealthEvents
 * section.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportServiceHealth(serviceId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resolve a Service Fabric partition.
 *
 * Resolve a Service Fabric service partition to get the endpoints of the
 * service replicas.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.partitionKeyType] Key type for the partition. This
 * parameter is required if the partition scheme for the service is Int64Range
 * or Named. The possible values are following.
 * - None (1) - Indicates that the PartitionKeyValue parameter is not
 * specified. This is valid for the partitions with partitioning scheme as
 * Singleton. This is the default value. The value is 1.
 * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
 * int64 partition key. This is valid for the partitions with partitioning
 * scheme as Int64Range. The value is 2.
 * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
 * the partition. This is valid for the partitions with partitioning scheme as
 * Named. The value is 3.
 *
 * @param {string} [options.partitionKeyValue] Partition key. This is required
 * if the partition scheme for the service is Int64Range or Named.
 * This is not the partition ID, but rather, either the integer key value, or
 * the name of the partition ID.
 * For example, if your service is using ranged partitions from 0 to 10, then
 * they PartitionKeyValue would be an
 * integer in that range. Query service description to see the range or name.
 *
 * @param {string} [options.previousRspVersion] The value in the Version field
 * of the response that was received previously. This is required if the user
 * knows that the result that was gotten previously is stale.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResolvedServicePartition} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resolveService(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let partitionKeyType = (options && options.partitionKeyType !== undefined) ? options.partitionKeyType : undefined;
  let partitionKeyValue = (options && options.partitionKeyValue !== undefined) ? options.partitionKeyValue : undefined;
  let previousRspVersion = (options && options.previousRspVersion !== undefined) ? options.previousRspVersion : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionKeyType !== null && partitionKeyType !== undefined && typeof partitionKeyType !== 'number') {
      throw new Error('partitionKeyType must be of type number.');
    }
    if (partitionKeyValue !== null && partitionKeyValue !== undefined && typeof partitionKeyValue.valueOf() !== 'string') {
      throw new Error('partitionKeyValue must be of type string.');
    }
    if (previousRspVersion !== null && previousRspVersion !== undefined && typeof previousRspVersion.valueOf() !== 'string') {
      throw new Error('previousRspVersion must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/ResolvePartition';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (partitionKeyType !== null && partitionKeyType !== undefined) {
    queryParameters.push('PartitionKeyType=' + encodeURIComponent(partitionKeyType.toString()));
  }
  if (partitionKeyValue !== null && partitionKeyValue !== undefined) {
    queryParameters.push('PartitionKeyValue=' + partitionKeyValue);
  }
  if (previousRspVersion !== null && previousRspVersion !== undefined) {
    queryParameters.push('PreviousRspVersion=' + previousRspVersion);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResolvedServicePartition']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of partitions of a Service Fabric service.
 *
 * The response includes the partition ID, partitioning scheme information,
 * keys supported by the partition, status, health, and other details about the
 * partition.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedServicePartitionInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionInfoList(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetPartitions';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedServicePartitionInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a Service Fabric partition.
 *
 * Gets the information about the specified partition. The response includes
 * the partition ID, partitioning scheme information, keys supported by the
 * partition, status, health, and other details about the partition.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServicePartitionInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionInfo(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServicePartitionInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the name of the Service Fabric service for a partition.
 *
 * Gets name of the service for the specified partition. A 404 error is
 * returned if the partition ID does not exist in the cluster.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ServiceNameInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceNameInfo(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetServiceName';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ServiceNameInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric partition.
 *
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the service based on the health state.
 * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
 * objects on the partition.
 * If you specify a partition that does not exist in the health store, this
 * request returns an error.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.replicasHealthStateFilter] Allows filtering the
 * collection of ReplicaHealthState objects on the partition. The value can be
 * obtained from members or bitwise operations on members of HealthStateFilter.
 * Only replicas that match the filter will be returned. All replicas will be
 * used to evaluate the aggregated health state. If not specified, all entries
 * will be returned.The state values are flag-based enumeration, so the value
 * could be a combination of these values obtained using bitwise 'OR' operator.
 * For example, If the provided value is 6 then all of the events with
 * HealthState value of OK (2) and Warning (4) will be returned. The possible
 * values for this parameter include integer value of one of the following
 * health states.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionHealth(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let replicasHealthStateFilter = (options && options.replicasHealthStateFilter !== undefined) ? options.replicasHealthStateFilter : 0;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined && typeof replicasHealthStateFilter !== 'number') {
      throw new Error('replicasHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined) {
    queryParameters.push('ReplicasHealthStateFilter=' + encodeURIComponent(replicasHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of the specified Service Fabric partition, by using
 * the specified health policy.
 *
 * Gets the health information of the specified partition.
 * If the application health policy is specified, the health evaluation uses it
 * to get the aggregated health state.
 * If the policy is not specified, the health evaluation uses the application
 * health policy defined in the application manifest, or the default health
 * policy, if no policy is defined in the manifest.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the partition based on the health state.
 * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
 * objects on the partition. Use ApplicationHealthPolicy in the POST body to
 * override the health policies used to evaluate the health.
 * If you specify a partition that does not exist in the health store, this
 * request returns an error.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.replicasHealthStateFilter] Allows filtering the
 * collection of ReplicaHealthState objects on the partition. The value can be
 * obtained from members or bitwise operations on members of HealthStateFilter.
 * Only replicas that match the filter will be returned. All replicas will be
 * used to evaluate the aggregated health state. If not specified, all entries
 * will be returned.The state values are flag-based enumeration, so the value
 * could be a combination of these values obtained using bitwise 'OR' operator.
 * For example, If the provided value is 6 then all of the events with
 * HealthState value of OK (2) and Warning (4) will be returned. The possible
 * values for this parameter include integer value of one of the following
 * health states.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
 * health statistics should be returned as part of the query result. False by
 * default.
 * The statistics show the number of children entities in health state Ok,
 * Warning, and Error.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionHealthUsingPolicy(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let replicasHealthStateFilter = (options && options.replicasHealthStateFilter !== undefined) ? options.replicasHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let excludeHealthStatistics = (options && options.excludeHealthStatistics !== undefined) ? options.excludeHealthStatistics : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined && typeof replicasHealthStateFilter !== 'number') {
      throw new Error('replicasHealthStateFilter must be of type number.');
    }
    if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined && typeof excludeHealthStatistics !== 'boolean') {
      throw new Error('excludeHealthStatistics must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (replicasHealthStateFilter !== null && replicasHealthStateFilter !== undefined) {
    queryParameters.push('ReplicasHealthStateFilter=' + encodeURIComponent(replicasHealthStateFilter.toString()));
  }
  if (excludeHealthStatistics !== null && excludeHealthStatistics !== undefined) {
    queryParameters.push('ExcludeHealthStatistics=' + encodeURIComponent(excludeHealthStatistics.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric partition.
 *
 * Reports health state of the specified Service Fabric partition. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Partition, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetPartitionHealth and check that the report appears in the HealthEvents
 * section.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportPartitionHealth(partitionId, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the load information of the specified Service Fabric
 * partition.
 *
 * Returns information about the load of a specified partition.
 * The response includes a list of load reports for a Service Fabric partition.
 * Each report includes the load metric name, value, and last reported time in
 * UTC.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionLoadInformation} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionLoadInformation(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetLoadInformation';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionLoadInformation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resets the current load of a Service Fabric partition.
 *
 * Resets the current load of a Service Fabric partition to the default load
 * for the service.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetPartitionLoad(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/ResetLoad';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover a specific partition that is currently stuck in quorum loss.
 *
 * This operation should only be performed if it is known that the replicas
 * that are down cannot be recovered. Incorrect use of this API can cause
 * potential data loss.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverPartition(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/Recover';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover the specified service that is currently stuck in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover
 * the specified service that is currently stuck in quorum loss. This operation
 * should only be performed if it is known that the replicas that are down
 * cannot be recovered. Incorrect use of this API can cause potential data
 * loss.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverServicePartitions(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/$/{serviceId}/$/GetPartitions/$/Recover';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover the system services that are currently stuck in quorum loss.
 *
 * Indicates to the Service Fabric cluster that it should attempt to recover
 * the system services that are currently stuck in quorum loss. This operation
 * should only be performed if it is known that the replicas that are down
 * cannot be recovered. Incorrect use of this API can cause potential data
 * loss.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSystemPartitions(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RecoverSystemPartitions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Indicates to the Service Fabric cluster that it should attempt to
 * recover any services (including system services) which are currently stuck
 * in quorum loss.
 *
 * This operation should only be performed if it is known that the replicas
 * that are down cannot be recovered. Incorrect use of this API can cause
 * potential data loss.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverAllPartitions(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/RecoverAllPartitions';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new repair task.
 *
 * For clusters that have the Repair Manager Service configured,
 * this API provides a way to create repair tasks that run automatically or
 * manually.
 * For repair tasks that run automatically, an appropriate repair executor
 * must be running for each repair action to run automatically.
 * These are currently only available in specially-configured Azure Cloud
 * Services.
 *
 * To create a manual repair task, provide the set of impacted node names and
 * the
 * expected impact. When the state of the created repair task changes to
 * approved,
 * you can safely perform repair actions on those nodes.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTask Describes the repair task to be created or
 * updated.
 *
 * @param {string} repairTask.taskId The ID of the repair task.
 *
 * @param {string} [repairTask.version] The version of the repair task.
 * When creating a new repair task, the version must be set to zero.  When
 * updating a repair task,
 * the version is used for optimistic concurrency checks.  If the version is
 * set to zero, the update will not check for write conflicts.  If the version
 * is set to a non-zero value, then the
 * update will only succeed if the actual current version of the repair task
 * matches this value.
 *
 * @param {string} [repairTask.description] A description of the purpose of the
 * repair task, or other informational details.
 * May be set when the repair task is created, and is immutable once set.
 *
 * @param {string} repairTask.state The workflow state of the repair task.
 * Valid initial states are Created, Claimed, and Preparing. Possible values
 * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
 * 'Executing', 'Restoring', 'Completed'
 *
 * @param {number} [repairTask.flags] A bitwise-OR of the following values,
 * which gives additional details about the status of the repair task.
 * - 1 - Cancellation of the repair has been requested
 * - 2 - Abort of the repair has been requested
 * - 4 - Approval of the repair was forced via client request
 *
 * @param {string} repairTask.action The requested repair action. Must be
 * specified when the repair task is created, and is immutable once set.
 *
 * @param {object} [repairTask.target] The target object determines what
 * actions the system will take to prepare for the impact of the repair, prior
 * to approving execution of the repair.
 * May be set when the repair task is created, and is immutable once set.
 *
 * @param {string} repairTask.target.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.executor] The name of the repair executor. Must
 * be specified in Claimed and later states, and is immutable once set.
 *
 * @param {string} [repairTask.executorData] A data string that the repair
 * executor can use to store its internal state.
 *
 * @param {object} [repairTask.impact] The impact object determines what
 * actions the system will take to prepare for the impact of the repair, prior
 * to approving execution of the repair.
 * Impact must be specified by the repair executor when transitioning to the
 * Preparing state, and is immutable once set.
 *
 * @param {string} repairTask.impact.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.resultStatus] A value describing the overall
 * result of the repair task execution. Must be specified in the Restoring and
 * later states, and is immutable once set. Possible values include: 'Invalid',
 * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
 *
 * @param {number} [repairTask.resultCode] A numeric value providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * @param {string} [repairTask.resultDetails] A string providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * @param {object} [repairTask.history] An object that contains timestamps of
 * the repair task's state transitions.
 * These timestamps are updated by the system, and cannot be directly modified.
 *
 * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
 * repair task entered the Created state.
 *
 * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
 * repair task entered the Claimed state.
 *
 * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
 * repair task entered the Preparing state.
 *
 * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
 * repair task entered the Approved state
 *
 * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
 * repair task entered the Executing state
 *
 * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
 * repair task entered the Restoring state
 *
 * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
 * repair task entered the Completed state
 *
 * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Restoring state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Restoring state.
 *
 * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
 * the health check when the repair task is in the Preparing state. Possible
 * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
 * 'TimedOut'
 *
 * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
 * the health check when the repair task is in the Restoring state. Possible
 * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
 * 'TimedOut'
 *
 * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Preparing state.
 *
 * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Restoring state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createRepairTask(repairTask, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTask === null || repairTask === undefined) {
      throw new Error('repairTask cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/CreateRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTask !== null && repairTask !== undefined) {
      let requestModelMapper = new client.models['RepairTask']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTask, 'repairTask');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTask, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Requests the cancellation of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTaskCancelDescription Describes the repair task to be
 * cancelled.
 *
 * @param {string} repairTaskCancelDescription.taskId The ID of the repair
 * task.
 *
 * @param {string} [repairTaskCancelDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.
 *
 * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
 * repair should be stopped as soon as possible even if it has already started
 * executing. _False_ if the repair should be cancelled only if execution has
 * not yet started.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _cancelRepairTask(repairTaskCancelDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskCancelDescription === null || repairTaskCancelDescription === undefined) {
      throw new Error('repairTaskCancelDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/CancelRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskCancelDescription !== null && repairTaskCancelDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskCancelDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskCancelDescription, 'repairTaskCancelDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskCancelDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a completed repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTaskDeleteDescription Describes the repair task to be
 * deleted.
 *
 * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
 * repair task to be deleted.
 *
 * @param {string} [repairTaskDeleteDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRepairTask(repairTaskDeleteDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskDeleteDescription === null || repairTaskDeleteDescription === undefined) {
      throw new Error('repairTaskDeleteDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/DeleteRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskDeleteDescription !== null && repairTaskDeleteDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskDeleteDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskDeleteDescription, 'repairTaskDeleteDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskDeleteDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of repair tasks matching the given filters.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.taskIdFilter] The repair task ID prefix to be
 * matched.
 *
 * @param {number} [options.stateFilter] A bitwise-OR of the following values,
 * specifying which task states should be included in the result list.
 *
 * - 1 - Created
 * - 2 - Claimed
 * - 4 - Preparing
 * - 8 - Approved
 * - 16 - Executing
 * - 32 - Restoring
 * - 64 - Completed
 *
 * @param {string} [options.executorFilter] The name of the repair executor
 * whose claimed tasks should be included in the list.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRepairTaskList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let taskIdFilter = (options && options.taskIdFilter !== undefined) ? options.taskIdFilter : undefined;
  let stateFilter = (options && options.stateFilter !== undefined) ? options.stateFilter : undefined;
  let executorFilter = (options && options.executorFilter !== undefined) ? options.executorFilter : undefined;
  let apiVersion = '6.0';
  // Validate
  try {
    if (taskIdFilter !== null && taskIdFilter !== undefined && typeof taskIdFilter.valueOf() !== 'string') {
      throw new Error('taskIdFilter must be of type string.');
    }
    if (stateFilter !== null && stateFilter !== undefined && typeof stateFilter !== 'number') {
      throw new Error('stateFilter must be of type number.');
    }
    if (executorFilter !== null && executorFilter !== undefined && typeof executorFilter.valueOf() !== 'string') {
      throw new Error('executorFilter must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/GetRepairTaskList';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (taskIdFilter !== null && taskIdFilter !== undefined) {
    queryParameters.push('TaskIdFilter=' + encodeURIComponent(taskIdFilter));
  }
  if (stateFilter !== null && stateFilter !== undefined) {
    queryParameters.push('StateFilter=' + encodeURIComponent(stateFilter.toString()));
  }
  if (executorFilter !== null && executorFilter !== undefined) {
    queryParameters.push('ExecutorFilter=' + encodeURIComponent(executorFilter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RepairTaskElementType',
                  type: {
                    name: 'Composite',
                    className: 'RepairTask'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Forces the approval of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTaskApproveDescription Describes the repair task to be
 * approved.
 *
 * @param {string} repairTaskApproveDescription.taskId The ID of the repair
 * task.
 *
 * @param {string} [repairTaskApproveDescription.version] The current version
 * number of the repair task. If non-zero, then the request will only succeed
 * if this value matches the actual current version of the repair task. If
 * zero, then no version check is performed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _forceApproveRepairTask(repairTaskApproveDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskApproveDescription === null || repairTaskApproveDescription === undefined) {
      throw new Error('repairTaskApproveDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/ForceApproveRepairTask';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskApproveDescription !== null && repairTaskApproveDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskApproveDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskApproveDescription, 'repairTaskApproveDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskApproveDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the health policy of the given repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
 * task healthy policy to be updated.
 *
 * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
 * repair task to be updated.
 *
 * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
 * current version number of the repair task. If non-zero, then the request
 * will only succeed if this value matches the actual current value of the
 * repair task. If zero, then no version check is performed.
 *
 * @param {boolean}
 * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
 * boolean indicating if health check is to be performed in the Preparing stage
 * of the repair task. If not specified the existing value should not be
 * altered. Otherwise, specify the desired new value.
 *
 * @param {boolean}
 * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
 * boolean indicating if health check is to be performed in the Restoring stage
 * of the repair task. If not specified the existing value should not be
 * altered. Otherwise, specify the desired new value.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTaskUpdateHealthPolicyDescription === null || repairTaskUpdateHealthPolicyDescription === undefined) {
      throw new Error('repairTaskUpdateHealthPolicyDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateRepairTaskHealthPolicy';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTaskUpdateHealthPolicyDescription !== null && repairTaskUpdateHealthPolicyDescription !== undefined) {
      let requestModelMapper = new client.models['RepairTaskUpdateHealthPolicyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTaskUpdateHealthPolicyDescription, 'repairTaskUpdateHealthPolicyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTaskUpdateHealthPolicyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the execution state of a repair task.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {object} repairTask Describes the repair task to be created or
 * updated.
 *
 * @param {string} repairTask.taskId The ID of the repair task.
 *
 * @param {string} [repairTask.version] The version of the repair task.
 * When creating a new repair task, the version must be set to zero.  When
 * updating a repair task,
 * the version is used for optimistic concurrency checks.  If the version is
 * set to zero, the update will not check for write conflicts.  If the version
 * is set to a non-zero value, then the
 * update will only succeed if the actual current version of the repair task
 * matches this value.
 *
 * @param {string} [repairTask.description] A description of the purpose of the
 * repair task, or other informational details.
 * May be set when the repair task is created, and is immutable once set.
 *
 * @param {string} repairTask.state The workflow state of the repair task.
 * Valid initial states are Created, Claimed, and Preparing. Possible values
 * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
 * 'Executing', 'Restoring', 'Completed'
 *
 * @param {number} [repairTask.flags] A bitwise-OR of the following values,
 * which gives additional details about the status of the repair task.
 * - 1 - Cancellation of the repair has been requested
 * - 2 - Abort of the repair has been requested
 * - 4 - Approval of the repair was forced via client request
 *
 * @param {string} repairTask.action The requested repair action. Must be
 * specified when the repair task is created, and is immutable once set.
 *
 * @param {object} [repairTask.target] The target object determines what
 * actions the system will take to prepare for the impact of the repair, prior
 * to approving execution of the repair.
 * May be set when the repair task is created, and is immutable once set.
 *
 * @param {string} repairTask.target.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.executor] The name of the repair executor. Must
 * be specified in Claimed and later states, and is immutable once set.
 *
 * @param {string} [repairTask.executorData] A data string that the repair
 * executor can use to store its internal state.
 *
 * @param {object} [repairTask.impact] The impact object determines what
 * actions the system will take to prepare for the impact of the repair, prior
 * to approving execution of the repair.
 * Impact must be specified by the repair executor when transitioning to the
 * Preparing state, and is immutable once set.
 *
 * @param {string} repairTask.impact.kind Polymorphic Discriminator
 *
 * @param {string} [repairTask.resultStatus] A value describing the overall
 * result of the repair task execution. Must be specified in the Restoring and
 * later states, and is immutable once set. Possible values include: 'Invalid',
 * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
 *
 * @param {number} [repairTask.resultCode] A numeric value providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * @param {string} [repairTask.resultDetails] A string providing additional
 * details about the result of the repair task execution.
 * May be specified in the Restoring and later states, and is immutable once
 * set.
 *
 * @param {object} [repairTask.history] An object that contains timestamps of
 * the repair task's state transitions.
 * These timestamps are updated by the system, and cannot be directly modified.
 *
 * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
 * repair task entered the Created state.
 *
 * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
 * repair task entered the Claimed state.
 *
 * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
 * repair task entered the Preparing state.
 *
 * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
 * repair task entered the Approved state
 *
 * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
 * repair task entered the Executing state
 *
 * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
 * repair task entered the Restoring state
 *
 * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
 * repair task entered the Completed state
 *
 * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Preparing state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
 * time when the repair task started the health check in the Restoring state.
 *
 * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
 * time when the repair task completed the health check in the Restoring state.
 *
 * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
 * the health check when the repair task is in the Preparing state. Possible
 * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
 * 'TimedOut'
 *
 * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
 * the health check when the repair task is in the Restoring state. Possible
 * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
 * 'TimedOut'
 *
 * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Preparing state.
 *
 * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
 * determine if health checks will be performed when the repair task enters the
 * Restoring state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RepairTaskUpdateInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRepairExecutionState(repairTask, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '6.0';
  // Validate
  try {
    if (repairTask === null || repairTask === undefined) {
      throw new Error('repairTask cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/UpdateRepairExecutionState';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (repairTask !== null && repairTask !== undefined) {
      let requestModelMapper = new client.models['RepairTask']().mapper();
      requestModel = client.serialize(requestModelMapper, repairTask, 'repairTask');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(repairTask, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RepairTaskUpdateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about replicas of a Service Fabric service
 * partition.
 *
 * The GetReplicas endpoint returns information about the replicas of the
 * specified partition. The response includes the ID, role, status, health,
 * node name, uptime, and other details about the replica.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedReplicaInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaInfoList(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedReplicaInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about a replica of a Service Fabric partition.
 *
 * The response includes the ID, role, status, health, node name, uptime, and
 * other details about the replica.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaInfo(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric stateful service replica or
 * stateless service instance.
 *
 * Gets the health of a Service Fabric replica.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the replica based on the health state.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaHealth(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the health of a Service Fabric stateful service replica or
 * stateless service instance using the specified policy.
 *
 * Gets the health of a Service Fabric stateful service replica or stateless
 * service instance.
 * Use EventsHealthStateFilter to filter the collection of health events
 * reported on the cluster based on the health state.
 * Use ApplicationHealthPolicy to optionally override the health policies used
 * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
 * the ApplicationHealthPolicy. The rest of the fields are ignored while
 * evaluating the health of the replica.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ReplicaHealth} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReplicaHealthUsingPolicy(partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ReplicaHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric replica.
 *
 * Reports health state of the specified Service Fabric replica. The report
 * must contain the information about the source of the health report and
 * property on which it is reported.
 * The report is sent to a Service Fabric gateway Replica, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, run
 * GetReplicaHealth and check that the report appears in the HealthEvents
 * section.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {string} replicaHealthReportServiceKind The kind of service replica
 * (Stateless or Stateful) for which the health is being reported. Following
 * are the possible values. Possible values include: 'Stateless', 'Stateful'
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportReplicaHealth(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (replicaHealthReportServiceKind === null || replicaHealthReportServiceKind === undefined || typeof replicaHealthReportServiceKind.valueOf() !== 'string') {
      throw new Error('replicaHealthReportServiceKind cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ReplicaHealthReportServiceKind=' + encodeURIComponent(replicaHealthReportServiceKind));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of replicas deployed on a Service Fabric node.
 *
 * Gets the list containing the information about replicas deployed on a
 * Service Fabric node. The information include partition ID, replica ID,
 * status of the replica, name of the service, name of the service type, and
 * other information. Use PartitionId or ServiceManifestName query parameters
 * to return information about the deployed replicas matching the specified
 * values for those parameters.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {uuid} [options.partitionId] The identity of the partition.
 *
 * @param {string} [options.serviceManifestName] The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let partitionId = (options && options.partitionId !== undefined) ? options.partitionId : undefined;
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId !== null && partitionId !== undefined && !(typeof partitionId.valueOf() === 'string' && msRest.isValidUuid(partitionId))) {
      throw new Error('partitionId must be of type string and must be a valid uuid.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (partitionId !== null && partitionId !== undefined) {
    queryParameters.push('PartitionId=' + encodeURIComponent(partitionId.toString()));
  }
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServiceReplicaInfoElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'ServiceKind',
                      clientName: 'serviceKind'
                    },
                    uberParent: 'DeployedServiceReplicaInfo',
                    className: 'DeployedServiceReplicaInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of replica deployed on a Service Fabric node.
 *
 * Gets the details of the replica deployed on a Service Fabric node. The
 * information includes service kind, service name, current service operation,
 * current service operation start date time, partition ID, replica/instance
 * ID, reported load, and other information.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServiceReplicaDetailInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServiceReplicaDetailInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of replica deployed on a Service Fabric node.
 *
 * Gets the details of the replica deployed on a Service Fabric node. The
 * information includes service kind, service name, current service operation,
 * current service operation start date time, partition ID, replica/instance
 * ID, reported load, and other information.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServiceReplicaDetailInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServiceReplicaDetailInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a service replica of a persisted service running on a
 * node.
 *
 * Restarts a service replica of a persisted service running on a node. Warning
 * - There are no safety checks performed when this API is used. Incorrect use
 * of this API can lead to availability loss for stateful services.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartReplica(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a service replica running on a node.
 *
 * This API simulates a Service Fabric replica failure by removing a replica
 * from a Service Fabric cluster. The removal closes the replica, transitions
 * the replica to the role None, and then removes all of the state information
 * of the replica from the cluster. This API tests the replica state removal
 * path, and simulates the report fault permanent path through client APIs.
 * Warning - There are no safety checks performed when this API is used.
 * Incorrect use of this API can lead to data loss for stateful services. In
 * addition, the forceRemove flag impacts all other replicas hosted in the same
 * process.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceRemove] Remove a Service Fabric application
 * or service forcefully without going through the graceful shutdown sequence.
 * This parameter can be used to forcefully delete an application or service
 * for which delete is timing out due to issues in the service code that
 * prevents graceful close of replicas.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeReplica(nodeName, partitionId, replicaId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceRemove = (options && options.forceRemove !== undefined) ? options.forceRemove : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (forceRemove !== null && forceRemove !== undefined && typeof forceRemove !== 'boolean') {
      throw new Error('forceRemove must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (forceRemove !== null && forceRemove !== undefined) {
    queryParameters.push('ForceRemove=' + encodeURIComponent(forceRemove.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of service packages deployed on a Service Fabric
 * node.
 *
 * Returns the information about the service packages deployed on a Service
 * Fabric node for the given application.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServicePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServicePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of service packages deployed on a Service Fabric node
 * matching exactly the specified name.
 *
 * Returns the information about the service packages deployed on a Service
 * Fabric node for the given application. These results are of service packages
 * whose name match exactly the service package name specified as the
 * parameter.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedServicePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedServicePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of a service package for a
 * specific application deployed for a Service Fabric node and application.
 *
 * Gets the information about health of a service package for a specific
 * application deployed on a Service Fabric node. Use EventsHealthStateFilter
 * to optionally filter for the collection of HealthEvent objects reported on
 * the deployed service package based on health state.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServicePackageHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServicePackageHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the information about health of service package for a specific
 * application deployed on a Service Fabric node using the specified policy.
 *
 * Gets the information about health of a service package for a specific
 * application deployed on a Service Fabric node. using the specified policy.
 * Use EventsHealthStateFilter to optionally filter for the collection of
 * HealthEvent objects reported on the deployed service package based on health
 * state. Use ApplicationHealthPolicy to optionally override the health
 * policies used to evaluate the health. This API only uses
 * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
 * the fields are ignored while evaluating the health of the deployed service
 * package.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.eventsHealthStateFilter] Allows filtering the
 * collection of HealthEvent objects returned based on health state.
 * The possible values for this parameter include integer value of one of the
 * following health states.
 * Only events that match the filter are returned. All events are used to
 * evaluate the aggregated health state.
 * If not specified, all entries are returned. The state values are flag-based
 * enumeration, so the value could be a combination of these values, obtained
 * using the bitwise 'OR' operator. For example, If the provided value is 6
 * then all of the events with HealthState value of OK (2) and Warning (4) are
 * returned.
 *
 * - Default - Default value. Matches any HealthState. The value is zero.
 * - None - Filter that doesn't match any HealthState value. Used in order to
 * return no results on a given collection of states. The value is 1.
 * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
 * - Warning - Filter that matches input with HealthState value Warning. The
 * value is 4.
 * - Error - Filter that matches input with HealthState value Error. The value
 * is 8.
 * - All - Filter that matches input with any HealthState value. The value is
 * 65535.
 *
 * @param {object} [options.applicationHealthPolicy] Describes the health
 * policies used to evaluate the health of an application or one of its
 * children.
 * If not present, the health evaluation uses the health policy from
 * application manifest or the default health policy.
 *
 * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
 * policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeployedServicePackageHealth} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let eventsHealthStateFilter = (options && options.eventsHealthStateFilter !== undefined) ? options.eventsHealthStateFilter : 0;
  let applicationHealthPolicy = (options && options.applicationHealthPolicy !== undefined) ? options.applicationHealthPolicy : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined && typeof eventsHealthStateFilter !== 'number') {
      throw new Error('eventsHealthStateFilter must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (eventsHealthStateFilter !== null && eventsHealthStateFilter !== undefined) {
    queryParameters.push('EventsHealthStateFilter=' + encodeURIComponent(eventsHealthStateFilter.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (applicationHealthPolicy !== null && applicationHealthPolicy !== undefined) {
      let requestModelMapper = new client.models['ApplicationHealthPolicy']().mapper();
      requestModel = client.serialize(requestModelMapper, applicationHealthPolicy, 'applicationHealthPolicy');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(applicationHealthPolicy, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeployedServicePackageHealth']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sends a health report on the Service Fabric deployed service
 * package.
 *
 * Reports health state of the service package of the application deployed on a
 * Service Fabric node. The report must contain the information about the
 * source of the health report and property on which it is reported.
 * The report is sent to a Service Fabric gateway Service, which forwards to
 * the health store.
 * The report may be accepted by the gateway, but rejected by the health store
 * after extra validation.
 * For example, the health store may reject the report because of an invalid
 * parameter, like a stale sequence number.
 * To see whether the report was applied in the health store, get deployed
 * service package health and check that the report appears in the HealthEvents
 * section.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} servicePackageName The name of the service package.
 *
 * @param {object} healthInformation Describes the health information for the
 * health report. This information needs to be present in all of the health
 * reports sent to the health manager.
 *
 * @param {string} healthInformation.sourceId The source name that identifies
 * the client/watchdog/system component that generated the health information.
 *
 * @param {string} healthInformation.property The property of the health
 * information. An entity can have health reports for different properties.
 * The property is a string and not a fixed enumeration to allow the reporter
 * flexibility to categorize the state condition that triggers the report.
 * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
 * of the available disk on a node,
 * so it can report "AvailableDisk" property on that node.
 * The same reporter can monitor the node connectivity, so it can report a
 * property "Connectivity" on the same node.
 * In the health store, these reports are treated as separate health events for
 * the specified node.
 *
 * Together with the SourceId, the property uniquely identifies the health
 * information.
 *
 * @param {string} healthInformation.healthState The health state of a Service
 * Fabric entity such as Cluster, Node, Application, Service, Partition,
 * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
 * 'Unknown'
 *
 * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
 * duration for which this health report is valid. This field uses ISO8601
 * format for specifying the duration.
 * When clients report periodically, they should send reports with higher
 * frequency than time to live.
 * If clients report on transition, they can set the time to live to infinite.
 * When time to live expires, the health event that contains the health
 * information
 * is either removed from health store, if RemoveWhenExpired is true, or
 * evaluated at error, if RemoveWhenExpired false.
 *
 * If not specified, time to live defaults to infinite value.
 *
 * @param {string} [healthInformation.description] The description of the
 * health information. It represents free text used to add human readable
 * information about the report.
 * The maximum string length for the description is 4096 characters.
 * If the provided string is longer, it will be automatically truncated.
 * When truncated, the last characters of the description contain a marker
 * "[Truncated]", and total string size is 4096 characters.
 * The presence of the marker indicates to users that truncation occurred.
 * Note that when truncated, the description has less than 4096 characters from
 * the original string.
 *
 * @param {string} [healthInformation.sequenceNumber] The sequence number for
 * this health report as a numeric string.
 * The report sequence number is used by the health store to detect stale
 * reports.
 * If not specified, a sequence number is auto-generated by the health client
 * when a report is added.
 *
 * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
 * whether the report is removed from health store when it expires.
 * If set to true, the report is removed from the health store after it
 * expires.
 * If set to false, the report is treated as an error when expired. The value
 * of this property is false by default.
 * When clients report periodically, they should set RemoveWhenExpired false
 * (default).
 * This way, if the reporter has issues (e.g. deadlock) and can't report, the
 * entity is evaluated at error when the health report expires.
 * This flags the entity as being in Error health state.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.immediate] A flag that indicates whether the
 * report should be sent immediately.
 * A health report is sent to a Service Fabric gateway Application, which
 * forwards to the health store.
 * If Immediate is set to true, the report is sent immediately from HTTP
 * Gateway to the health store, regardless of the fabric client settings that
 * the HTTP Gateway Application is using.
 * This is useful for critical reports that should be sent as soon as possible.
 * Depending on timing and other conditions, sending the report may still fail,
 * for example if the HTTP Gateway is closed or the message doesn't reach the
 * Gateway.
 * If Immediate is set to false, the report is sent based on the health client
 * settings from the HTTP Gateway. Therefore, it will be batched according to
 * the HealthReportSendInterval configuration.
 * This is the recommended setting because it allows the health client to
 * optimize health reporting messages to health store as well as health report
 * processing.
 * By default, reports are not sent immediately.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let immediate = (options && options.immediate !== undefined) ? options.immediate : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (servicePackageName === null || servicePackageName === undefined || typeof servicePackageName.valueOf() !== 'string') {
      throw new Error('servicePackageName cannot be null or undefined and it must be of type string.');
    }
    if (healthInformation === null || healthInformation === undefined) {
      throw new Error('healthInformation cannot be null or undefined.');
    }
    if (immediate !== null && immediate !== undefined && typeof immediate !== 'boolean') {
      throw new Error('immediate must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  requestUrl = requestUrl.replace('{servicePackageName}', servicePackageName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (immediate !== null && immediate !== undefined) {
    queryParameters.push('Immediate=' + encodeURIComponent(immediate.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (healthInformation !== null && healthInformation !== undefined) {
      let requestModelMapper = new client.models['HealthInformation']().mapper();
      requestModel = client.serialize(requestModelMapper, healthInformation, 'healthInformation');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(healthInformation, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Downloads all of the code packages associated with specified
 * service manifest on the specified node.
 *
 * This API provides a way to download code packages including the container
 * images on a specific node outside of the normal application deployment and
 * upgrade path. This is useful for the large code packages and container
 * images to be present on the node before the actual application deployment
 * and upgrade, thus significantly reducing the total time required for the
 * deployment or upgrade.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {object} deployServicePackageToNodeDescription Describes information
 * for deploying a service package to a Service Fabric node.
 *
 * @param {string} deployServicePackageToNodeDescription.serviceManifestName
 * The name of service manifest whose packages need to be downloaded.
 *
 * @param {string} deployServicePackageToNodeDescription.applicationTypeName
 * The application type name as defined in the application manifest.
 *
 * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
 * The version of the application type as defined in the application manifest.
 *
 * @param {string} deployServicePackageToNodeDescription.nodeName The name of a
 * Service Fabric node.
 *
 * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
 * List of package sharing policy information.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deployServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (deployServicePackageToNodeDescription === null || deployServicePackageToNodeDescription === undefined) {
      throw new Error('deployServicePackageToNodeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/DeployServicePackage';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployServicePackageToNodeDescription !== null && deployServicePackageToNodeDescription !== undefined) {
      let requestModelMapper = new client.models['DeployServicePackageToNodeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, deployServicePackageToNodeDescription, 'deployServicePackageToNodeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployServicePackageToNodeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of code packages deployed on a Service Fabric node.
 *
 * Gets the list of code packages deployed on a Service Fabric node for the
 * given application.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceManifestName] The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {string} [options.codePackageName] The name of code package specified
 * in service manifest registered as part of an application type in a Service
 * Fabric cluster.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployedCodePackageInfoList(nodeName, applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceManifestName = (options && options.serviceManifestName !== undefined) ? options.serviceManifestName : undefined;
  let codePackageName = (options && options.codePackageName !== undefined) ? options.codePackageName : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName !== null && serviceManifestName !== undefined && typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName must be of type string.');
    }
    if (codePackageName !== null && codePackageName !== undefined && typeof codePackageName.valueOf() !== 'string') {
      throw new Error('codePackageName must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (serviceManifestName !== null && serviceManifestName !== undefined) {
    queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  }
  if (codePackageName !== null && codePackageName !== undefined) {
    queryParameters.push('CodePackageName=' + encodeURIComponent(codePackageName));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DeployedCodePackageInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DeployedCodePackageInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts a code package deployed on a Service Fabric node in a
 * cluster.
 *
 * Restarts a code package deployed on a Service Fabric node in a cluster. This
 * aborts the code package process, which will restart all the user service
 * replicas hosted in that process.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} restartDeployedCodePackageDescription Describes the deployed
 * code package on Service Fabric node to restart.
 *
 * @param {string} restartDeployedCodePackageDescription.serviceManifestName
 * The name of service manifest that specified this code package.
 *
 * @param {string}
 * [restartDeployedCodePackageDescription.servicePackageActivationId] The
 * ActivationId of a deployed service package. If ServicePackageActivationMode
 * specified at the time of creating the service
 * is 'SharedProcess' (or if it is not specified, in which case it defaults to
 * 'SharedProcess'), then value of ServicePackageActivationId
 * is always an empty string.
 *
 * @param {string} restartDeployedCodePackageDescription.codePackageName The
 * name of the code package defined in the service manifest.
 *
 * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
 * The instance ID for currently running entry point. For a code package setup
 * entry point (if specified) runs first and after it finishes main entry point
 * is started.
 * Each time entry point executable is run, its instance ID will change. If 0
 * is passed in as the code package instance ID, the API will restart the code
 * package with whatever instance ID it is currently running.
 * If an instance ID other than 0 is passed in, the API will restart the code
 * package only if the current Instance ID matches the passed in instance ID.
 * Note, passing in the exact instance ID (not 0) in the API is safer, because
 * if ensures at most one restart of the code package.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (restartDeployedCodePackageDescription === null || restartDeployedCodePackageDescription === undefined) {
      throw new Error('restartDeployedCodePackageDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (restartDeployedCodePackageDescription !== null && restartDeployedCodePackageDescription !== undefined) {
      let requestModelMapper = new client.models['RestartDeployedCodePackageDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, restartDeployedCodePackageDescription, 'restartDeployedCodePackageDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(restartDeployedCodePackageDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the container logs for container deployed on a Service Fabric
 * node.
 *
 * Gets the container logs for container deployed on a Service Fabric node for
 * the given code package.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceManifestName The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {string} codePackageName The name of code package specified in
 * service manifest registered as part of an application type in a Service
 * Fabric cluster.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.tail] Number of lines to show from the end of the
 * logs. Default is 100. 'all' to show the complete logs.
 *
 * @param {boolean} [options.previous] Specifies whether to get container logs
 * from exited/dead containers of the code package instance.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ContainerLogs} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getContainerLogsDeployedOnNode(nodeName, applicationId, serviceManifestName, codePackageName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let tail = (options && options.tail !== undefined) ? options.tail : undefined;
  let previous = (options && options.previous !== undefined) ? options.previous : false;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName === null || serviceManifestName === undefined || typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName cannot be null or undefined and it must be of type string.');
    }
    if (codePackageName === null || codePackageName === undefined || typeof codePackageName.valueOf() !== 'string') {
      throw new Error('codePackageName cannot be null or undefined and it must be of type string.');
    }
    if (tail !== null && tail !== undefined && typeof tail.valueOf() !== 'string') {
      throw new Error('tail must be of type string.');
    }
    if (previous !== null && previous !== undefined && typeof previous !== 'boolean') {
      throw new Error('previous must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/ContainerLogs';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  queryParameters.push('CodePackageName=' + encodeURIComponent(codePackageName));
  if (tail !== null && tail !== undefined) {
    queryParameters.push('Tail=' + encodeURIComponent(tail));
  }
  if (previous !== null && previous !== undefined) {
    queryParameters.push('Previous=' + encodeURIComponent(previous.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ContainerLogs']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Invoke container API on a container deployed on a Service Fabric
 * node.
 *
 * Invoke container API on a container deployed on a Service Fabric node for
 * the given code package.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} serviceManifestName The name of a service manifest
 * registered as part of an application type in a Service Fabric cluster.
 *
 * @param {string} codePackageName The name of code package specified in
 * service manifest registered as part of an application type in a Service
 * Fabric cluster.
 *
 * @param {string} codePackageInstanceId ID that uniquely identifies a code
 * package instance deployed on a service fabric node.
 *
 * @param {object} containerApiRequestBody Parameters for making container API
 * call
 *
 * @param {string} [containerApiRequestBody.httpVerb] HTTP verb of container
 * REST API, defaults to "GET"
 *
 * @param {string} containerApiRequestBody.uriPath URI path of container REST
 * API
 *
 * @param {string} [containerApiRequestBody.contentType] Content type of
 * container REST API request, defaults to "application/json"
 *
 * @param {string} [containerApiRequestBody.body] HTTP request body of
 * container REST API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ContainerApiResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _invokeContainerApi(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (serviceManifestName === null || serviceManifestName === undefined || typeof serviceManifestName.valueOf() !== 'string') {
      throw new Error('serviceManifestName cannot be null or undefined and it must be of type string.');
    }
    if (codePackageName === null || codePackageName === undefined || typeof codePackageName.valueOf() !== 'string') {
      throw new Error('codePackageName cannot be null or undefined and it must be of type string.');
    }
    if (codePackageInstanceId === null || codePackageInstanceId === undefined || typeof codePackageInstanceId.valueOf() !== 'string') {
      throw new Error('codePackageInstanceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (containerApiRequestBody === null || containerApiRequestBody === undefined) {
      throw new Error('containerApiRequestBody cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/ContainerApi';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('ServiceManifestName=' + encodeURIComponent(serviceManifestName));
  queryParameters.push('CodePackageName=' + encodeURIComponent(codePackageName));
  queryParameters.push('CodePackageInstanceId=' + encodeURIComponent(codePackageInstanceId));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (containerApiRequestBody !== null && containerApiRequestBody !== undefined) {
      let requestModelMapper = new client.models['ContainerApiRequestBody']().mapper();
      requestModel = client.serialize(requestModelMapper, containerApiRequestBody, 'containerApiRequestBody');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(containerApiRequestBody, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ContainerApiResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric compose deployment.
 *
 * Compose is a file format that describes multi-container applications. This
 * API allows deploying container based applications defined in compose format
 * in a Service Fabric cluster. Once the deployment is created, its status can
 * be tracked via the `GetComposeDeploymentStatus` API.
 *
 * @param {object} createComposeDeploymentDescription Describes the compose
 * deployment that needs to be created.
 *
 * @param {string} createComposeDeploymentDescription.deploymentName The name
 * of the deployment.
 *
 * @param {string} createComposeDeploymentDescription.composeFileContent The
 * content of the compose file that describes the deployment to create.
 *
 * @param {object} [createComposeDeploymentDescription.registryCredential]
 * Credential information to connect to container registry.
 *
 * @param {string}
 * [createComposeDeploymentDescription.registryCredential.registryUserName] The
 * user name to connect to container registry.
 *
 * @param {string}
 * [createComposeDeploymentDescription.registryCredential.registryPassword] The
 * password for supplied username to connect to container registry.
 *
 * @param {boolean}
 * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
 * Indicates that supplied container registry password is encrypted.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createComposeDeployment(createComposeDeploymentDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (createComposeDeploymentDescription === null || createComposeDeploymentDescription === undefined) {
      throw new Error('createComposeDeploymentDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createComposeDeploymentDescription !== null && createComposeDeploymentDescription !== undefined) {
      let requestModelMapper = new client.models['CreateComposeDeploymentDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, createComposeDeploymentDescription, 'createComposeDeploymentDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createComposeDeploymentDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information about a Service Fabric compose deployment.
 *
 * Returns the status of the compose deployment that was created or in the
 * process of being created in the Service Fabric cluster and whose name
 * matches the one specified as the parameter. The response includes the name,
 * status, and other details about the deployment.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ComposeDeploymentStatusInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentStatus(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ComposeDeploymentStatusInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of compose deployments created in the Service Fabric
 * cluster.
 *
 * Gets the status about the compose deployments that were created or in the
 * process of being created in the Service Fabric cluster. The response
 * includes the name, status, and other details about the compose deployments.
 * If the list of deployments do not fit in a page, one page of results is
 * returned as well as a continuation token, which can be used to get the next
 * page.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedComposeDeploymentStatusInfoList} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentStatusList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedComposeDeploymentStatusInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest upgrade performed on this Service
 * Fabric compose deployment.
 *
 * Returns the information about the state of the compose deployment upgrade
 * along with details to aid debugging application health issues.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ComposeDeploymentUpgradeProgressInfo} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getComposeDeploymentUpgradeProgress(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/GetUpgradeProgress';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ComposeDeploymentUpgradeProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes an existing Service Fabric compose deployment from cluster.
 *
 * Deletes an existing Service Fabric compose deployment.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _removeComposeDeployment(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/Delete';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts upgrading a compose deployment in the Service Fabric
 * cluster.
 *
 * Validates the supplied upgrade parameters and starts upgrading the
 * deployment if the parameters are valid.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
 * compose deployment.
 *
 * @param {string} composeDeploymentUpgradeDescription.deploymentName The name
 * of the deployment.
 *
 * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
 * content of the compose file that describes the deployment to create.
 *
 * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
 * Credential information to connect to container registry.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
 * The user name to connect to container registry.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
 * The password for supplied username to connect to container registry.
 *
 * @param {boolean}
 * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
 * Indicates that supplied container registry password is encrypted.
 *
 * @param {string} composeDeploymentUpgradeDescription.upgradeKind The kind of
 * upgrade out of the following possible values. Possible values include:
 * 'Invalid', 'Rolling'
 *
 * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode] The
 * mode used to monitor health during a rolling upgrade. The values are
 * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
 * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
 * The maximum amount of time to block processing of an upgrade domain and
 * prevent loss of availability when there are unexpected issues. When this
 * timeout expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
 * 32-bit integer).
 *
 * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart] If true,
 * then processes are forcefully restarted during upgrade even when the code
 * version has not changed (the upgrade only changes configuration or data).
 *
 * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
 * Describes the parameters for monitoring an upgrade in Monitored mode.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction] The
 * compensating action to perform when a Monitored upgrade encounters
 * monitoring policy or health policy violations.
 * Invalid indicates the failure action is invalid. Rollback specifies that the
 * upgrade will start rolling back automatically.
 * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
 * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
 * The amount of time the overall upgrade has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {string}
 * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
 * The amount of time each upgrade domain has to complete before FailureAction
 * is executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 *
 * @param {object}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy] Defines a
 * health policy used to evaluate the health of an application or one of its
 * children entities.
 *
 * @param {boolean}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
 * Indicates whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * @param {object}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
 * The maximum allowed percentage of unhealthy partitions per service. Allowed
 * values are Byte values from zero to 100
 *
 * The percentage represents the maximum tolerated percentage of partitions
 * that can be unhealthy before the service is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * partition, the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy partitions
 * over the total number of partitions in the service.
 * The computation rounds up to tolerate one failure on small numbers of
 * partitions. Default percentage is zero.
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
 * The maximum allowed percentage of unhealthy replicas per partition. Allowed
 * values are Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of replicas that
 * can be unhealthy before the partition is considered in error.
 * If the percentage is respected but there is at least one unhealthy replica,
 * the health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy replicas
 * over the total number of replicas in the partition.
 * The computation rounds up to tolerate one failure on small numbers of
 * replicas. Default percentage is zero.
 *
 * @param {number}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum allowed percentage of unhealthy services. Allowed values are
 * Byte values from zero to 100.
 *
 * The percentage represents the maximum tolerated percentage of services that
 * can be unhealthy before the application is considered in error.
 * If the percentage is respected but there is at least one unhealthy service,
 * the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy services of the
 * specific service type over the total number of services of the specific
 * service type.
 * The computation rounds up to tolerate one failure on small numbers of
 * services. Default percentage is zero.
 *
 * @param {array}
 * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
 * The map with service type health policy per service type name. The map is
 * empty by default.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (composeDeploymentUpgradeDescription === null || composeDeploymentUpgradeDescription === undefined) {
      throw new Error('composeDeploymentUpgradeDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/Upgrade';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (composeDeploymentUpgradeDescription !== null && composeDeploymentUpgradeDescription !== undefined) {
      let requestModelMapper = new client.models['ComposeDeploymentUpgradeDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, composeDeploymentUpgradeDescription, 'composeDeploymentUpgradeDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(composeDeploymentUpgradeDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts rolling back a compose deployment upgrade in the Service
 * Fabric cluster.
 *
 * Rollback a service fabric compose deployment upgrade.
 *
 * @param {string} deploymentName The identity of the deployment.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startRollbackComposeDeploymentUpgrade(deploymentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4-preview';
  // Validate
  try {
    if (deploymentName === null || deploymentName === undefined || typeof deploymentName.valueOf() !== 'string') {
      throw new Error('deploymentName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ComposeDeployments/{deploymentName}/$/RollbackUpgrade';
  requestUrl = requestUrl.replace('{deploymentName}', deploymentName);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the status of Chaos.
 *
 * Get the status of Chaos indicating whether or not Chaos is running, the
 * Chaos parameters used for running Chaos and the status of the Chaos
 * Schedule.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Chaos} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getChaos(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Chaos']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts Chaos in the cluster.
 *
 * If Chaos is not already running in the cluster, it starts Chaos with the
 * passed in Chaos parameters.
 * If Chaos is already running when this call is made, the call fails with the
 * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
 * Refer to the article [Induce controlled Chaos in Service Fabric
 * clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos)
 * for more details.
 *
 * @param {object} chaosParameters Describes all the parameters to configure a
 * Chaos run.
 *
 * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
 * for which Chaos will run before automatically stopping. The maximum allowed
 * value is 4,294,967,295 (System.UInt32.MaxValue).
 *
 * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
 * The maximum amount of time to wait for all cluster entities to become stable
 * and healthy. Chaos executes in iterations and at the start of each iteration
 * it validates the health of cluster entities.
 * During validation if a cluster entity is not stable and healthy within
 * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
 * event.
 *
 * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
 * the maximum number of concurrent faults induced per iteration.
 * Chaos executes in iterations and two consecutive iterations are separated by
 * a validation phase.
 * The higher the concurrency, the more aggressive the injection of faults,
 * leading to inducing more complex series of states to uncover bugs.
 * The recommendation is to start with a value of 2 or 3 and to exercise
 * caution while moving up.
 *
 * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
 * disables the move primary and move secondary faults.
 *
 * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
 * (in seconds) between consecutive faults within a single iteration.
 * The larger the value, the lower the overlapping between faults and the
 * simpler the sequence of state transitions that the cluster goes through.
 * The recommendation is to start with a value between 1 and 5 and exercise
 * caution while moving up.
 *
 * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
 * Time-separation (in seconds) between two consecutive iterations of Chaos.
 * The larger the value, the lower the fault injection rate.
 *
 * @param {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
 * health policy is used to validate health of the cluster in between Chaos
 * iterations. If the cluster health is in error or if an unexpected exception
 * happens during fault execution--to provide the cluster with some time to
 * recuperate--Chaos will wait for 30 minutes before the next health-check.
 *
 * @param {boolean}
 * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 *
 * @param {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
 * allowed percentage of unhealthy nodes before reporting an error. For
 * example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 *
 * @param {number}
 * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 *
 * @param {array}
 * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
 * a map with max percentage unhealthy applications for specific application
 * types.
 * Each entry specifies as key the application type name and as value an
 * integer that represents the MaxPercentUnhealthyApplications percentage used
 * to evaluate the applications of the specified application type.
 *
 * The application type health policy map can be used during cluster health
 * evaluation to describe special application types.
 * The application types included in the map are evaluated against the
 * percentage specified in the map, and not with the global
 * MaxPercentUnhealthyApplications defined in the cluster health policy.
 * The applications of application types specified in the map are not counted
 * against the global pool of applications.
 * For example, if some applications of a type are critical, the cluster
 * administrator can add an entry to the map for that application type
 * and assign it a value of 0% (that is, do not tolerate any failures).
 * All other applications can be evaluated with MaxPercentUnhealthyApplications
 * set to 20% to tolerate some failures out of the thousands of application
 * instances.
 * The application type health policy map is used only if the cluster manifest
 * enables application type health evaluation using the configuration entry for
 * HealthManager/EnableApplicationTypeHealthEvaluation.
 *
 * @param {object} [chaosParameters.context] Describes a map, which is a
 * collection of (string, string) type key-value pairs. The map can be used to
 * record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key
 * or value) can be at most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the
 * context about the specific run.
 *
 * @param {object} [chaosParameters.context.map] Describes a map that contains
 * a collection of ChaosContextMapItem's.
 *
 * @param {object} [chaosParameters.chaosTargetFilter] List of cluster entities
 * to target for Chaos faults.
 * This filter can be used to target Chaos faults only to certain node types or
 * only to certain application instances. If ChaosTargetFilter is not used,
 * Chaos faults all cluster entities.
 * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
 * ChaosTargetFilter specification.
 *
 * @param {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList] A
 * list of node types to include in Chaos faults.
 * All types of faults (restart node, restart code package, remove replica,
 * restart replica, move primary, and move secondary) are enabled for the nodes
 * of these node types.
 * If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList,
 * then node level faults (like NodeRestart) will never be enabled for the
 * nodes of
 * NodeTypeX, but code package and replica faults can still be enabled for
 * NodeTypeX if an application in the ApplicationInclusionList.
 * happens to reside on a node of NodeTypeX.
 * At most 100 node type names can be included in this list, to increase this
 * number, a config upgrade is required for
 * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
 *
 * @param {array} [chaosParameters.chaosTargetFilter.applicationInclusionList]
 * A list of application URIs to include in Chaos faults.
 * All replicas belonging to services of these applications are amenable to
 * replica faults (restart replica, remove replica, move primary, and move
 * secondary) by Chaos.
 * Chaos may restart a code package only if the code package hosts replicas of
 * these applications only.
 * If an application does not appear in this list, it can still be faulted in
 * some Chaos iteration if the application ends up on a node of a node type
 * that is included in NodeTypeInclusionList.
 * However, if applicationX is tied to nodeTypeY through placement constraints
 * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
 * absent from NodeTypeInclusionList, then applicationX will never be faulted.
 * At most 1000 application names can be included in this list, to increase
 * this number, a config upgrade is required for
 * MaxNumberOfApplicationsInChaosEntityFilter configuration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startChaos(chaosParameters, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (chaosParameters === null || chaosParameters === undefined) {
      throw new Error('chaosParameters cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/$/Start';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (chaosParameters !== null && chaosParameters !== undefined) {
      let requestModelMapper = new client.models['ChaosParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, chaosParameters, 'chaosParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(chaosParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops Chaos if it is running in the cluster and put the Chaos
 * Schedule in a stopped state.
 *
 * Stops Chaos from executing new faults. In-flight faults will continue to
 * execute until they are complete. The current Chaos Schedule is put into a
 * stopped state.
 * Once a schedule is stopped, it will stay in the stopped state and not be
 * used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set
 * in order to resume scheduling.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopChaos(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/$/Stop';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the next segment of the Chaos events based on the continuation
 * token or the time range.
 *
 * To get the next segment of the Chaos events, you can specify the
 * ContinuationToken. To get the start of a new segment of Chaos events, you
 * can specify the time range
 * through StartTimeUtc and EndTimeUtc. You cannot specify both the
 * ContinuationToken and the time range in the same call.
 * When there are more than 100 Chaos events, the Chaos events are returned in
 * multiple segments where a segment contains no more than 100 Chaos events and
 * to get the next segment you make a call to this API with the continuation
 * token.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {string} [options.startTimeUtc] The Windows file time representing
 * the start time of the time range for which a Chaos report is to be
 * generated. Consult [DateTime.ToFileTimeUtc
 * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
 * for details.
 *
 * @param {string} [options.endTimeUtc] The Windows file time representing the
 * end time of the time range for which a Chaos report is to be generated.
 * Consult [DateTime.ToFileTimeUtc
 * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
 * for details.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ChaosEventsSegment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getChaosEvents(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let startTimeUtc = (options && options.startTimeUtc !== undefined) ? options.startTimeUtc : undefined;
  let endTimeUtc = (options && options.endTimeUtc !== undefined) ? options.endTimeUtc : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (startTimeUtc !== null && startTimeUtc !== undefined && typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc must be of type string.');
    }
    if (endTimeUtc !== null && endTimeUtc !== undefined && typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (startTimeUtc !== null && startTimeUtc !== undefined) {
    queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  }
  if (endTimeUtc !== null && endTimeUtc !== undefined) {
    queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ChaosEventsSegment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the Chaos Schedule defining when and how to run Chaos.
 *
 * Gets the version of the Chaos Schedule in use and the Chaos Schedule that
 * defines when and how to run Chaos.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ChaosScheduleDescription} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getChaosSchedule(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/Schedule';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ChaosScheduleDescription']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Set the schedule used by Chaos.
 *
 * Chaos will automatically schedule runs based on the Chaos Schedule.
 * The Chaos Schedule will be updated if the provided version matches the
 * version on the server.
 * When updating the Chaos Schedule, the version on the server is incremented
 * by 1.
 * The version on the server will wrap back to 0 after reaching a large number.
 * If Chaos is running when this call is made, the call will fail.
 *
 * @param {object} chaosSchedule Describes the schedule used by Chaos.
 *
 * @param {number} [chaosSchedule.version] The version number of the Schedule.
 *
 * @param {object} [chaosSchedule.schedule] Defines the schedule used by Chaos.
 *
 * @param {date} [chaosSchedule.schedule.startDate] The date and time Chaos
 * will start using this schedule.
 *
 * @param {date} [chaosSchedule.schedule.expiryDate] The date and time Chaos
 * will continue to use this schedule until.
 *
 * @param {array} [chaosSchedule.schedule.chaosParametersDictionary] A mapping
 * of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
 *
 * @param {array} [chaosSchedule.schedule.jobs] A list of all Chaos Schedule
 * Jobs that will be automated by the schedule.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _postChaosSchedule(chaosSchedule, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (chaosSchedule === null || chaosSchedule === undefined) {
      throw new Error('chaosSchedule cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Tools/Chaos/Schedule';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (chaosSchedule !== null && chaosSchedule !== undefined) {
      let requestModelMapper = new client.models['ChaosScheduleDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, chaosSchedule, 'chaosSchedule');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(chaosSchedule, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Uploads contents of the file to the image store.
 *
 * Uploads contents of the file to the image store. Use this API if the file is
 * small enough to upload again if the connection fails. The file's data needs
 * to be added to the request body. The contents will be uploaded to the
 * specified path. Image store service uses a mark file to indicate the
 * availability of the folder. The mark file is an empty file named "_.dir".
 * The mark file is generated by the image store service when all files in a
 * folder are uploaded. When using File-by-File approach to upload application
 * package in REST, the image store service isn't aware of the file hierarchy
 * of the application package; you need to create a mark file per folder and
 * upload it last, to let the image store service know that the folder is
 * complete.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _uploadFile(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the image store content information.
 *
 * Returns the information about the image store content at the specified
 * contentPath. The contentPath is relative to the root of the image store.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ImageStoreContent} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreContent(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.2';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ImageStoreContent']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes existing image store content.
 *
 * Deletes existing image store content being found within the given image
 * store relative path. This command can be used to delete uploaded application
 * packages once they are provisioned.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteImageStoreContent(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the content information at the root of the image store.
 *
 * Returns the information about the image store content at the root of the
 * image store.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ImageStoreContent} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreRootContent(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ImageStoreContent']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Copies image store content internally
 *
 * Copies the image store content from the source image store relative path to
 * the destination image store relative path.
 *
 * @param {object} imageStoreCopyDescription Describes the copy description for
 * the image store.
 *
 * @param {string} imageStoreCopyDescription.remoteSource The relative path of
 * source image store content to be copied from.
 *
 * @param {string} imageStoreCopyDescription.remoteDestination The relative
 * path of destination image store content to be copied to.
 *
 * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
 * names to be skipped for copying.
 *
 * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
 * to check mark file during copying. The property is true if checking mark
 * file is required, false otherwise. The mark file is used to check whether
 * the folder is well constructed. If the property is true and mark file does
 * not exist, the copy is skipped.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _copyImageStoreContent(imageStoreCopyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (imageStoreCopyDescription === null || imageStoreCopyDescription === undefined) {
      throw new Error('imageStoreCopyDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/$/Copy';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (imageStoreCopyDescription !== null && imageStoreCopyDescription !== undefined) {
      let requestModelMapper = new client.models['ImageStoreCopyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, imageStoreCopyDescription, 'imageStoreCopyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(imageStoreCopyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Cancels an image store upload session.
 *
 * The DELETE request will cause the existing upload session to expire and
 * remove any previously uploaded file chunks.
 *
 * @param {uuid} sessionId A GUID generated by the user for a file uploading.
 * It identifies an image store upload session which keeps track of all file
 * chunks until it is committed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteImageStoreUploadSession(sessionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (sessionId === null || sessionId === undefined || typeof sessionId.valueOf() !== 'string' || !msRest.isValidUuid(sessionId)) {
      throw new Error('sessionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/$/DeleteUploadSession';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('session-id=' + encodeURIComponent(sessionId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Commit an image store upload session.
 *
 * When all file chunks have been uploaded, the upload session needs to be
 * committed explicitly to complete the upload. Image store preserves the
 * upload session until the expiration time, which is 30 minutes after the last
 * chunk received.
 *
 * @param {uuid} sessionId A GUID generated by the user for a file uploading.
 * It identifies an image store upload session which keeps track of all file
 * chunks until it is committed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _commitImageStoreUploadSession(sessionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (sessionId === null || sessionId === undefined || typeof sessionId.valueOf() !== 'string' || !msRest.isValidUuid(sessionId)) {
      throw new Error('sessionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/$/CommitUploadSession';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('session-id=' + encodeURIComponent(sessionId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the image store upload session by ID.
 *
 * Gets the image store upload session identified by the given ID. User can
 * query the upload session at any time during uploading.
 *
 * @param {uuid} sessionId A GUID generated by the user for a file uploading.
 * It identifies an image store upload session which keeps track of all file
 * chunks until it is committed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UploadSession} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreUploadSessionById(sessionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (sessionId === null || sessionId === undefined || typeof sessionId.valueOf() !== 'string' || !msRest.isValidUuid(sessionId)) {
      throw new Error('sessionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/$/GetUploadSession';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('session-id=' + encodeURIComponent(sessionId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UploadSession']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the image store upload session by relative path.
 *
 * Gets the image store upload session associated with the given image store
 * relative path. User can query the upload session at any time during
 * uploading.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UploadSession} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getImageStoreUploadSessionByPath(contentPath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}/$/GetUploadSession';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UploadSession']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Uploads a file chunk to the image store relative path.
 *
 * Uploads a file chunk to the image store with the specified upload session ID
 * and image store relative path. This API allows user to resume the file
 * upload operation. user doesn't have to restart the file upload from scratch
 * whenever there is a network interruption. Use this option if the file size
 * is large.
 *
 * To perform a resumable file upload, user need to break the file into
 * multiple chunks and upload these chunks to the image store one-by-one.
 * Chunks don't have to be uploaded in order. If the file represented by the
 * image store relative path already exists, it will be overwritten when the
 * upload session commits.
 *
 * @param {string} contentPath Relative path to file or folder in the image
 * store from its root.
 *
 * @param {uuid} sessionId A GUID generated by the user for a file uploading.
 * It identifies an image store upload session which keeps track of all file
 * chunks until it is committed.
 *
 * @param {string} contentRange When uploading file chunks to the image store,
 * the Content-Range header field need to be configured and sent with a
 * request. The format should looks like "bytes
 * {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example,
 * Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300
 * through 5,000 and the total file length is 20,000 bytes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _uploadFileChunk(contentPath, sessionId, contentRange, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (contentPath === null || contentPath === undefined || typeof contentPath.valueOf() !== 'string') {
      throw new Error('contentPath cannot be null or undefined and it must be of type string.');
    }
    if (sessionId === null || sessionId === undefined || typeof sessionId.valueOf() !== 'string' || !msRest.isValidUuid(sessionId)) {
      throw new Error('sessionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (contentRange === null || contentRange === undefined || typeof contentRange.valueOf() !== 'string') {
      throw new Error('contentRange cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'ImageStore/{contentPath}/$/UploadChunk';
  requestUrl = requestUrl.replace('{contentPath}', encodeURIComponent(contentPath));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('session-id=' + encodeURIComponent(sessionId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (contentRange !== undefined && contentRange !== null) {
    httpRequest.headers['Content-Range'] = contentRange;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Invokes an administrative command on the given Infrastructure
 * Service instance.
 *
 * For clusters that have one or more instances of the Infrastructure Service
 * configured,
 * this API provides a way to send infrastructure-specific commands to a
 * particular
 * instance of the Infrastructure Service.
 *
 * Available commands and their corresponding response formats vary depending
 * upon
 * the infrastructure on which the cluster is running.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {string} command The text of the command to be invoked. The content
 * of the command is infrastructure-specific.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceId] The identity of the infrastructure
 * service. This is the full name of the infrastructure service without the
 * 'fabric:' URI scheme. This parameter required only for the cluster that has
 * more than one instance of infrastructure service running.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _invokeInfrastructureCommand(command, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceId = (options && options.serviceId !== undefined) ? options.serviceId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (command === null || command === undefined || typeof command.valueOf() !== 'string') {
      throw new Error('command cannot be null or undefined and it must be of type string.');
    }
    if (serviceId !== null && serviceId !== undefined && typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/InvokeInfrastructureCommand';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('Command=' + encodeURIComponent(command));
  if (serviceId !== null && serviceId !== undefined) {
    queryParameters.push('ServiceId=' + encodeURIComponent(serviceId));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Invokes a read-only query on the given infrastructure service
 * instance.
 *
 * For clusters that have one or more instances of the Infrastructure Service
 * configured,
 * this API provides a way to send infrastructure-specific queries to a
 * particular
 * instance of the Infrastructure Service.
 *
 * Available commands and their corresponding response formats vary depending
 * upon
 * the infrastructure on which the cluster is running.
 *
 * This API supports the Service Fabric platform; it is not meant to be used
 * directly from your code.
 *
 * @param {string} command The text of the command to be invoked. The content
 * of the command is infrastructure-specific.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.serviceId] The identity of the infrastructure
 * service. This is the full name of the infrastructure service without the
 * 'fabric:' URI scheme. This parameter required only for the cluster that has
 * more than one instance of infrastructure service running.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _invokeInfrastructureQuery(command, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let serviceId = (options && options.serviceId !== undefined) ? options.serviceId : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (command === null || command === undefined || typeof command.valueOf() !== 'string') {
      throw new Error('command cannot be null or undefined and it must be of type string.');
    }
    if (serviceId !== null && serviceId !== undefined && typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '$/InvokeInfrastructureQuery';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('Command=' + encodeURIComponent(command));
  if (serviceId !== null && serviceId !== undefined) {
    queryParameters.push('ServiceId=' + encodeURIComponent(serviceId));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary This API will induce data loss for the specified partition. It will
 * trigger a call to the OnDataLossAsync API of the partition.
 *
 * This API will induce data loss for the specified partition. It will trigger
 * a call to the OnDataLoss API of the partition.
 * Actual data loss will depend on the specified DataLossMode.
 *
 * - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
 * triggered for the partition but actual data loss depends on the presence of
 * in-flight replication.
 * - FullDataLoss - All replicas are removed hence all data is lost and
 * OnDataLoss is triggered.
 *
 * This API should only be called with a stateful service as the target.
 *
 * Calling this API with a system service as the target is not advised.
 *
 * Note:  Once this API has been called, it cannot be reversed. Calling
 * CancelOperation will only stop execution and clean up internal system state.
 * It will not restore data if the command has progressed far enough to cause
 * data loss.
 *
 * Call the GetDataLossProgress API with the same OperationId to return
 * information on the operation started with this API.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
 * indicate what type of data loss to induce. Possible values include:
 * 'Invalid', 'PartialDataLoss', 'FullDataLoss'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (dataLossMode === null || dataLossMode === undefined || typeof dataLossMode.valueOf() !== 'string') {
      throw new Error('dataLossMode cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('DataLossMode=' + encodeURIComponent(dataLossMode));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a partition data loss operation started using
 * the StartDataLoss API.
 *
 * Gets the progress of a data loss operation started with StartDataLoss, using
 * the OperationId.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionDataLossProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDataLossProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionDataLossProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Induces quorum loss for a given stateful service partition.
 *
 * This API is useful for a temporary quorum loss situation on your service.
 *
 * Call the GetQuorumLossProgress API with the same OperationId to return
 * information on the operation started with this API.
 *
 * This can only be called on stateful persisted (HasPersistedState==true)
 * services.  Do not use this API on stateless services or stateful in-memory
 * only services.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
 * API to indicate what type of quorum loss to induce. Possible values include:
 * 'Invalid', 'QuorumReplicas', 'AllReplicas'
 *
 * @param {number} quorumLossDuration The amount of time for which the
 * partition will be kept in quorum loss.  This must be specified in seconds.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (quorumLossMode === null || quorumLossMode === undefined || typeof quorumLossMode.valueOf() !== 'string') {
      throw new Error('quorumLossMode cannot be null or undefined and it must be of type string.');
    }
    if (quorumLossDuration === null || quorumLossDuration === undefined || typeof quorumLossDuration !== 'number') {
      throw new Error('quorumLossDuration cannot be null or undefined and it must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('QuorumLossMode=' + encodeURIComponent(quorumLossMode));
  queryParameters.push('QuorumLossDuration=' + encodeURIComponent(quorumLossDuration.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a quorum loss operation on a partition started
 * using the StartQuorumLoss API.
 *
 * Gets the progress of a quorum loss operation started with StartQuorumLoss,
 * using the provided OperationId.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionQuorumLossProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getQuorumLossProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionQuorumLossProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary This API will restart some or all replicas or instances of the
 * specified partition.
 *
 * This API is useful for testing failover.
 *
 * If used to target a stateless service partition, RestartPartitionMode must
 * be AllReplicasOrInstances.
 *
 * Call the GetPartitionRestartProgress API using the same OperationId to get
 * the progress.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} restartPartitionMode Describe which partitions to restart.
 * Possible values include: 'Invalid', 'AllReplicasOrInstances',
 * 'OnlyActiveSecondaries'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (restartPartitionMode === null || restartPartitionMode === undefined || typeof restartPartitionMode.valueOf() !== 'string') {
      throw new Error('restartPartitionMode cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('RestartPartitionMode=' + encodeURIComponent(restartPartitionMode));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of a PartitionRestart operation started using
 * StartPartitionRestart.
 *
 * Gets the progress of a PartitionRestart started with StartPartitionRestart
 * using the provided OperationId.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionRestartProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionRestartProgress(serviceId, partitionId, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionRestartProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts or stops a cluster node.
 *
 * Starts or stops a cluster node.  A cluster node is a process, not the OS
 * instance itself.  To start a node, pass in "Start" for the
 * NodeTransitionType parameter.
 * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
 * API starts the operation - when the API returns the node may not have
 * finished transitioning yet.
 * Call GetNodeTransitionProgress with the same OperationId to get the progress
 * of the operation.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {string} nodeTransitionType Indicates the type of transition to
 * perform.  NodeTransitionType.Start will start a stopped node.
 * NodeTransitionType.Stop will stop a node that is up. Possible values
 * include: 'Invalid', 'Start', 'Stop'
 *
 * @param {string} nodeInstanceId The node instance ID of the target node.
 * This can be determined through GetNodeInfo API.
 *
 * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
 * node stopped.  The minimum value is 600, the maximum is 14400.  After this
 * time expires, the node will automatically come back up.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (nodeTransitionType === null || nodeTransitionType === undefined || typeof nodeTransitionType.valueOf() !== 'string') {
      throw new Error('nodeTransitionType cannot be null or undefined and it must be of type string.');
    }
    if (nodeInstanceId === null || nodeInstanceId === undefined || typeof nodeInstanceId.valueOf() !== 'string') {
      throw new Error('nodeInstanceId cannot be null or undefined and it must be of type string.');
    }
    if (stopDurationInSeconds === null || stopDurationInSeconds === undefined || typeof stopDurationInSeconds !== 'number') {
      throw new Error('stopDurationInSeconds cannot be null or undefined and it must be of type number.');
    }
    if (stopDurationInSeconds !== null && stopDurationInSeconds !== undefined) {
      if (stopDurationInSeconds < 0)
      {
        throw new Error('"stopDurationInSeconds" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Nodes/{nodeName}/$/StartTransition/';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('NodeTransitionType=' + encodeURIComponent(nodeTransitionType));
  queryParameters.push('NodeInstanceId=' + encodeURIComponent(nodeInstanceId));
  queryParameters.push('StopDurationInSeconds=' + encodeURIComponent(stopDurationInSeconds.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the progress of an operation started using
 * StartNodeTransition.
 *
 * Gets the progress of an operation started with StartNodeTransition using the
 * provided OperationId.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NodeTransitionProgress} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeTransitionProgress(nodeName, operationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/Nodes/{nodeName}/$/GetTransitionProgress';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NodeTransitionProgress']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of user-induced fault operations filtered by provided
 * input.
 *
 * Gets the list of user-induced fault operations filtered by provided input.
 *
 * @param {number} typeFilter Used to filter on OperationType for user-induced
 * operations.
 *
 * - 65535 - select all
 * - 1 - select PartitionDataLoss.
 * - 2 - select PartitionQuorumLoss.
 * - 4 - select PartitionRestart.
 * - 8 - select NodeTransition.
 *
 * @param {number} stateFilter Used to filter on OperationState's for
 * user-induced operations.
 *
 * - 65535 - select All
 * - 1 - select Running
 * - 2 - select RollingBack
 * - 8 - select Completed
 * - 16 - select Faulted
 * - 32 - select Cancelled
 * - 64 - select ForceCancelled
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFaultOperationList(typeFilter, stateFilter, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (typeFilter === null || typeFilter === undefined || typeof typeFilter !== 'number') {
      throw new Error('typeFilter cannot be null or undefined and it must be of type number.');
    }
    if (stateFilter === null || stateFilter === undefined || typeof stateFilter !== 'number') {
      throw new Error('stateFilter cannot be null or undefined and it must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('TypeFilter=' + encodeURIComponent(typeFilter.toString()));
  queryParameters.push('StateFilter=' + encodeURIComponent(stateFilter.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'OperationStatusElementType',
                  type: {
                    name: 'Composite',
                    className: 'OperationStatus'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Cancels a user-induced fault operation.
 *
 * The following APIs start fault operations that may be cancelled by using
 * CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart,
 * StartNodeTransition.
 *
 * If force is false, then the specified user-induced operation will be
 * gracefully stopped and cleaned up.  If force is true, the command will be
 * aborted, and some internal state
 * may be left behind.  Specifying force as true should be used with care.
 * Calling this API with force set to true is not allowed until this API has
 * already
 * been called on the same test command with force set to false first, or
 * unless the test command already has an OperationState of
 * OperationState.RollingBack.
 * Clarification: OperationState.RollingBack means that the system will be/is
 * cleaning up internal system state caused by executing the command.  It will
 * not restore data if the
 * test command was to cause data loss.  For example, if you call StartDataLoss
 * then call this API, the system will only clean up internal state from
 * running the command.
 * It will not restore the target partition's data, if the command progressed
 * far enough to cause data loss.
 *
 * Important note:  if this API is invoked with force==true, internal state may
 * be left behind.
 *
 * @param {uuid} operationId A GUID that identifies a call of this API.  This
 * is passed into the corresponding GetProgress API
 *
 * @param {boolean} force Indicates whether to gracefully roll back and clean
 * up internal system state modified by executing the user-induced operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _cancelOperation(operationId, force, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (operationId === null || operationId === undefined || typeof operationId.valueOf() !== 'string' || !msRest.isValidUuid(operationId)) {
      throw new Error('operationId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (force === null || force === undefined || typeof force !== 'boolean') {
      throw new Error('force cannot be null or undefined and it must be of type boolean.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Faults/$/Cancel';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('OperationId=' + encodeURIComponent(operationId.toString()));
  queryParameters.push('Force=' + encodeURIComponent(force.toString()));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a backup policy.
 *
 * Creates a backup policy which can be associated later with a Service Fabric
 * application, service or a partition for periodic backup.
 *
 * @param {object} backupPolicyDescription Describes the backup policy.
 *
 * @param {string} backupPolicyDescription.name The unique name identifying
 * this backup policy.
 *
 * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
 * whether to trigger restore automatically using the latest available backup
 * in case the partition experiences a data loss event.
 *
 * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
 * maximum number of incremental backups to be taken between two full backups.
 * This is just the upper limit. A full backup may be taken before specified
 * number of incremental backups are completed in one of the following
 * conditions
 * - The replica has never taken a full backup since it has become primary,
 * - Some of the log records since the last backup has been truncated, or
 * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
 *
 * @param {object} backupPolicyDescription.schedule Describes the backup
 * schedule parameters.
 *
 * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
 * Discriminator
 *
 * @param {object} backupPolicyDescription.storage Describes the details of
 * backup storage where to store the periodic backups.
 *
 * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
 * for this backup storage.
 *
 * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
 * Discriminator
 *
 * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
 * policy to retain backups in storage.
 *
 * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
 * Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createBackupPolicy(backupPolicyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (backupPolicyDescription === null || backupPolicyDescription === undefined) {
      throw new Error('backupPolicyDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (backupPolicyDescription !== null && backupPolicyDescription !== undefined) {
      let requestModelMapper = new client.models['BackupPolicyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, backupPolicyDescription, 'backupPolicyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(backupPolicyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the backup policy.
 *
 * Deletes an existing backup policy. A backup policy must be created before it
 * can be deleted. A currently active backup policy, associated with any
 * Service Fabric application, service or partition, cannot be deleted without
 * first deleting the mapping.
 *
 * @param {string} backupPolicyName The name of the backup policy.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupPolicy(backupPolicyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (backupPolicyName === null || backupPolicyName === undefined || typeof backupPolicyName.valueOf() !== 'string') {
      throw new Error('backupPolicyName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies/{backupPolicyName}/$/Delete';
  requestUrl = requestUrl.replace('{backupPolicyName}', encodeURIComponent(backupPolicyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all the backup policies configured.
 *
 * Get a list of all the backup policies configured.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupPolicyDescriptionList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupPolicyList(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupPolicyDescriptionList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a particular backup policy by name.
 *
 * Gets a particular backup policy identified by {backupPolicyName}
 *
 * @param {string} backupPolicyName The name of the backup policy.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupPolicyDescription} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupPolicyByName(backupPolicyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (backupPolicyName === null || backupPolicyName === undefined || typeof backupPolicyName.valueOf() !== 'string') {
      throw new Error('backupPolicyName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies/{backupPolicyName}';
  requestUrl = requestUrl.replace('{backupPolicyName}', encodeURIComponent(backupPolicyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupPolicyDescription']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of backup entities that are associated with this
 * policy.
 *
 * Returns a list of Service Fabric application, service or partition which are
 * associated with this backup policy.
 *
 * @param {string} backupPolicyName The name of the backup policy.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupEntityList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllEntitiesBackedUpByPolicy(backupPolicyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (backupPolicyName === null || backupPolicyName === undefined || typeof backupPolicyName.valueOf() !== 'string') {
      throw new Error('backupPolicyName cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies/{backupPolicyName}/$/GetBackupEnabledEntities';
  requestUrl = requestUrl.replace('{backupPolicyName}', encodeURIComponent(backupPolicyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupEntityList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the backup policy.
 *
 * Updates the backup policy identified by {backupPolicyName}
 *
 * @param {object} backupPolicyDescription Describes the backup policy.
 *
 * @param {string} backupPolicyDescription.name The unique name identifying
 * this backup policy.
 *
 * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
 * whether to trigger restore automatically using the latest available backup
 * in case the partition experiences a data loss event.
 *
 * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
 * maximum number of incremental backups to be taken between two full backups.
 * This is just the upper limit. A full backup may be taken before specified
 * number of incremental backups are completed in one of the following
 * conditions
 * - The replica has never taken a full backup since it has become primary,
 * - Some of the log records since the last backup has been truncated, or
 * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
 *
 * @param {object} backupPolicyDescription.schedule Describes the backup
 * schedule parameters.
 *
 * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
 * Discriminator
 *
 * @param {object} backupPolicyDescription.storage Describes the details of
 * backup storage where to store the periodic backups.
 *
 * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
 * for this backup storage.
 *
 * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
 * Discriminator
 *
 * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
 * policy to retain backups in storage.
 *
 * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
 * Polymorphic Discriminator
 *
 * @param {string} backupPolicyName The name of the backup policy.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateBackupPolicy(backupPolicyDescription, backupPolicyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (backupPolicyDescription === null || backupPolicyDescription === undefined) {
      throw new Error('backupPolicyDescription cannot be null or undefined.');
    }
    if (backupPolicyName === null || backupPolicyName === undefined || typeof backupPolicyName.valueOf() !== 'string') {
      throw new Error('backupPolicyName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/BackupPolicies/{backupPolicyName}/$/Update';
  requestUrl = requestUrl.replace('{backupPolicyName}', encodeURIComponent(backupPolicyName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (backupPolicyDescription !== null && backupPolicyDescription !== undefined) {
      let requestModelMapper = new client.models['BackupPolicyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, backupPolicyDescription, 'backupPolicyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(backupPolicyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enables periodic backup of stateful partitions under this Service
 * Fabric application.
 *
 * Enables periodic backup of stateful partitions which are part of this
 * Service Fabric application. Each partition is backed up individually as per
 * the specified backup policy description.
 * Note only C# based Reliable Actor and Reliable Stateful services are
 * currently supported for periodic backup.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} enableBackupDescription Specifies the parameters for
 * enabling backup.
 *
 * @param {string} enableBackupDescription.backupPolicyName Name of the backup
 * policy to be used for enabling periodic backups.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enableApplicationBackup(applicationId, enableBackupDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (enableBackupDescription === null || enableBackupDescription === undefined) {
      throw new Error('enableBackupDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/EnableBackup';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (enableBackupDescription !== null && enableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['EnableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, enableBackupDescription, 'enableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(enableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Disables periodic backup of Service Fabric application.
 *
 * Disables periodic backup of Service Fabric application which was previously
 * enabled.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.disableBackupDescription] Specifies the parameters
 * to disable backup for any backup entity.
 *
 * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
 * to delete backups. It can be set to true for deleting all the backups which
 * were created for the backup entity that is getting disabled for backup.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disableApplicationBackup(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let disableBackupDescription = (options && options.disableBackupDescription !== undefined) ? options.disableBackupDescription : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/DisableBackup';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (disableBackupDescription !== null && disableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['DisableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, disableBackupDescription, 'disableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(disableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Service Fabric application backup configuration
 * information.
 *
 * Gets the Service Fabric backup configuration information for the application
 * and the services and partitions under this application.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupConfigurationInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationBackupConfigurationInfo(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetBackupConfigurationInfo';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupConfigurationInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of backups available for every partition in this
 * application.
 *
 * Returns a list of backups available for every partition in this Service
 * Fabric application. The server enumerates all the backups available at the
 * backup location configured in the backup policy. It also allows filtering of
 * the result based on start and end datetime or just fetching the latest
 * available backup for every partition.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {boolean} [options.latest] Specifies whether to get only the most
 * recent backup available for a partition for the specified time range.
 *
 * @param {date} [options.startDateTimeFilter] Specify the start date time from
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, all backups from the beginning are enumerated.
 *
 * @param {date} [options.endDateTimeFilter] Specify the end date time till
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, enumeration is done till the most recent backup.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationBackupList(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let latest = (options && options.latest !== undefined) ? options.latest : false;
  let startDateTimeFilter = (options && options.startDateTimeFilter !== undefined) ? options.startDateTimeFilter : undefined;
  let endDateTimeFilter = (options && options.endDateTimeFilter !== undefined) ? options.endDateTimeFilter : undefined;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (latest !== null && latest !== undefined && typeof latest !== 'boolean') {
      throw new Error('latest must be of type boolean.');
    }
    if (startDateTimeFilter && !(startDateTimeFilter instanceof Date ||
        (typeof startDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(startDateTimeFilter))))) {
          throw new Error('startDateTimeFilter must be of type date.');
        }
    if (endDateTimeFilter && !(endDateTimeFilter instanceof Date ||
        (typeof endDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(endDateTimeFilter))))) {
          throw new Error('endDateTimeFilter must be of type date.');
        }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/GetBackups';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (latest !== null && latest !== undefined) {
    queryParameters.push('Latest=' + encodeURIComponent(latest.toString()));
  }
  if (startDateTimeFilter !== null && startDateTimeFilter !== undefined) {
    queryParameters.push('StartDateTimeFilter=' + encodeURIComponent(client.serializeObject(startDateTimeFilter)));
  }
  if (endDateTimeFilter !== null && endDateTimeFilter !== undefined) {
    queryParameters.push('EndDateTimeFilter=' + encodeURIComponent(client.serializeObject(endDateTimeFilter)));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Suspends periodic backup for the specified Service Fabric
 * application.
 *
 * The application which is configured to take periodic backups, is suspended
 * for taking further backups till it is resumed again. This operation applies
 * to the entire application's hierarchy. It means all the services and
 * partitions under this application are now suspended for backup.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _suspendApplicationBackup(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/SuspendBackup';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resumes periodic backup of a Service Fabric application which was
 * previously suspended.
 *
 * The previously suspended Service Fabric application resumes taking periodic
 * backup as per the backup policy currently configured for the same.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeApplicationBackup(applicationId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Applications/{applicationId}/$/ResumeBackup';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enables periodic backup of stateful partitions under this Service
 * Fabric service.
 *
 * Enables periodic backup of stateful partitions which are part of this
 * Service Fabric service. Each partition is backed up individually as per the
 * specified backup policy description. In case the application, which the
 * service is part of, is already enabled for backup then this operation would
 * override the policy being used to take the periodic backup for this service
 * and its partitions (unless explicitly overridden at the partition level).
 * Note only C# based Reliable Actor and Reliable Stateful services are
 * currently supported for periodic backup.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} enableBackupDescription Specifies the parameters for
 * enabling backup.
 *
 * @param {string} enableBackupDescription.backupPolicyName Name of the backup
 * policy to be used for enabling periodic backups.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enableServiceBackup(serviceId, enableBackupDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (enableBackupDescription === null || enableBackupDescription === undefined) {
      throw new Error('enableBackupDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/EnableBackup';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (enableBackupDescription !== null && enableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['EnableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, enableBackupDescription, 'enableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(enableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Disables periodic backup of Service Fabric service which was
 * previously enabled.
 *
 * Disables periodic backup of Service Fabric service which was previously
 * enabled. Backup must be explicitly enabled before it can be disabled.
 * In case the backup is enabled for the Service Fabric application, which this
 * service is part of, this service would continue to be periodically backed up
 * as per the policy mapped at the application level.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.disableBackupDescription] Specifies the parameters
 * to disable backup for any backup entity.
 *
 * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
 * to delete backups. It can be set to true for deleting all the backups which
 * were created for the backup entity that is getting disabled for backup.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disableServiceBackup(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let disableBackupDescription = (options && options.disableBackupDescription !== undefined) ? options.disableBackupDescription : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/DisableBackup';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (disableBackupDescription !== null && disableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['DisableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, disableBackupDescription, 'disableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(disableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Service Fabric service backup configuration information.
 *
 * Gets the Service Fabric backup configuration information for the service and
 * the partitions under this service.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupConfigurationInfoList} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceBackupConfigurationInfo(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetBackupConfigurationInfo';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupConfigurationInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of backups available for every partition in this
 * service.
 *
 * Returns a list of backups available for every partition in this Service
 * Fabric service. The server enumerates all the backups available in the
 * backup store configured in the backup policy. It also allows filtering of
 * the result based on start and end datetime or just fetching the latest
 * available backup for every partition.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {boolean} [options.latest] Specifies whether to get only the most
 * recent backup available for a partition for the specified time range.
 *
 * @param {date} [options.startDateTimeFilter] Specify the start date time from
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, all backups from the beginning are enumerated.
 *
 * @param {date} [options.endDateTimeFilter] Specify the end date time till
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, enumeration is done till the most recent backup.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceBackupList(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let latest = (options && options.latest !== undefined) ? options.latest : false;
  let startDateTimeFilter = (options && options.startDateTimeFilter !== undefined) ? options.startDateTimeFilter : undefined;
  let endDateTimeFilter = (options && options.endDateTimeFilter !== undefined) ? options.endDateTimeFilter : undefined;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (latest !== null && latest !== undefined && typeof latest !== 'boolean') {
      throw new Error('latest must be of type boolean.');
    }
    if (startDateTimeFilter && !(startDateTimeFilter instanceof Date ||
        (typeof startDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(startDateTimeFilter))))) {
          throw new Error('startDateTimeFilter must be of type date.');
        }
    if (endDateTimeFilter && !(endDateTimeFilter instanceof Date ||
        (typeof endDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(endDateTimeFilter))))) {
          throw new Error('endDateTimeFilter must be of type date.');
        }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/GetBackups';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (latest !== null && latest !== undefined) {
    queryParameters.push('Latest=' + encodeURIComponent(latest.toString()));
  }
  if (startDateTimeFilter !== null && startDateTimeFilter !== undefined) {
    queryParameters.push('StartDateTimeFilter=' + encodeURIComponent(client.serializeObject(startDateTimeFilter)));
  }
  if (endDateTimeFilter !== null && endDateTimeFilter !== undefined) {
    queryParameters.push('EndDateTimeFilter=' + encodeURIComponent(client.serializeObject(endDateTimeFilter)));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Suspends periodic backup for the specified Service Fabric service.
 *
 * The service which is configured to take periodic backups, is suspended for
 * taking further backups till it is resumed again. This operation applies to
 * the entire service's hierarchy. It means all the partitions under this
 * service are now suspended for backup.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _suspendServiceBackup(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/SuspendBackup';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resumes periodic backup of a Service Fabric service which was
 * previously suspended.
 *
 * The previously suspended Service Fabric service resumes taking periodic
 * backup as per the backup policy currently configured for the same.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumeServiceBackup(serviceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Services/{serviceId}/$/ResumeBackup';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enables periodic backup of the stateful persisted partition.
 *
 * Enables periodic backup of stateful persisted partition. Each partition is
 * backed up as per the specified backup policy description. In case the
 * application or service, which is partition is part of, is already enabled
 * for backup then this operation would override the policy being used to take
 * the periodic backup of this partition.
 * Note only C# based Reliable Actor and Reliable Stateful services are
 * currently supported for periodic backup.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} enableBackupDescription Specifies the parameters for
 * enabling backup.
 *
 * @param {string} enableBackupDescription.backupPolicyName Name of the backup
 * policy to be used for enabling periodic backups.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _enablePartitionBackup(partitionId, enableBackupDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (enableBackupDescription === null || enableBackupDescription === undefined) {
      throw new Error('enableBackupDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/EnableBackup';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (enableBackupDescription !== null && enableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['EnableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, enableBackupDescription, 'enableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(enableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Disables periodic backup of Service Fabric partition which was
 * previously enabled.
 *
 * Disables periodic backup of partition which was previously enabled. Backup
 * must be explicitly enabled before it can be disabled.
 * In case the backup is enabled for the Service Fabric application or service,
 * which this partition is part of, this partition would continue to be
 * periodically backed up as per the policy mapped at the higher level entity.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.disableBackupDescription] Specifies the parameters
 * to disable backup for any backup entity.
 *
 * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
 * to delete backups. It can be set to true for deleting all the backups which
 * were created for the backup entity that is getting disabled for backup.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _disablePartitionBackup(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let disableBackupDescription = (options && options.disableBackupDescription !== undefined) ? options.disableBackupDescription : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/DisableBackup';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (disableBackupDescription !== null && disableBackupDescription !== undefined) {
      let requestModelMapper = new client.models['DisableBackupDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, disableBackupDescription, 'disableBackupDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(disableBackupDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the partition backup configuration information
 *
 * Gets the Service Fabric Backup configuration information for the specified
 * partition.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PartitionBackupConfigurationInfo} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionBackupConfigurationInfo(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetBackupConfigurationInfo';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PartitionBackupConfigurationInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of backups available for the specified partition.
 *
 * Returns a list of backups available for the specified partition. The server
 * enumerates all the backups available in the backup store configured in the
 * backup policy. It also allows filtering of the result based on start and end
 * datetime or just fetching the latest available backup for the partition.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {boolean} [options.latest] Specifies whether to get only the most
 * recent backup available for a partition for the specified time range.
 *
 * @param {date} [options.startDateTimeFilter] Specify the start date time from
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, all backups from the beginning are enumerated.
 *
 * @param {date} [options.endDateTimeFilter] Specify the end date time till
 * which to enumerate backups, in datetime format. The date time must be
 * specified in ISO8601 format. This is an optional parameter. If not
 * specified, enumeration is done till the most recent backup.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionBackupList(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let latest = (options && options.latest !== undefined) ? options.latest : false;
  let startDateTimeFilter = (options && options.startDateTimeFilter !== undefined) ? options.startDateTimeFilter : undefined;
  let endDateTimeFilter = (options && options.endDateTimeFilter !== undefined) ? options.endDateTimeFilter : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (latest !== null && latest !== undefined && typeof latest !== 'boolean') {
      throw new Error('latest must be of type boolean.');
    }
    if (startDateTimeFilter && !(startDateTimeFilter instanceof Date ||
        (typeof startDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(startDateTimeFilter))))) {
          throw new Error('startDateTimeFilter must be of type date.');
        }
    if (endDateTimeFilter && !(endDateTimeFilter instanceof Date ||
        (typeof endDateTimeFilter.valueOf() === 'string' && !isNaN(Date.parse(endDateTimeFilter))))) {
          throw new Error('endDateTimeFilter must be of type date.');
        }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetBackups';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (latest !== null && latest !== undefined) {
    queryParameters.push('Latest=' + encodeURIComponent(latest.toString()));
  }
  if (startDateTimeFilter !== null && startDateTimeFilter !== undefined) {
    queryParameters.push('StartDateTimeFilter=' + encodeURIComponent(client.serializeObject(startDateTimeFilter)));
  }
  if (endDateTimeFilter !== null && endDateTimeFilter !== undefined) {
    queryParameters.push('EndDateTimeFilter=' + encodeURIComponent(client.serializeObject(endDateTimeFilter)));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Suspends periodic backup for the specified partition.
 *
 * The partition which is configured to take periodic backups, is suspended for
 * taking further backups till it is resumed again.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _suspendPartitionBackup(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/SuspendBackup';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Resumes periodic backup of partition which was previously
 * suspended.
 *
 * The previously suspended partition resumes taking periodic backup as per the
 * backup policy currently configured for the same.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resumePartitionBackup(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/ResumeBackup';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Triggers backup of the partition's state.
 *
 * Creates a backup of the stateful persisted partition's state. In case the
 * partition is already being periodically backed up, then by default the new
 * backup is created at the same backup storage. One can also override the same
 * by specifying the backup storage details as part of the request body. Once
 * the backup is initiated, its progress can be tracked using the
 * GetBackupProgress operation.
 * In case, the operation times out, specify a greater backup timeout value in
 * the query parameter.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.backupPartitionDescription] Describes the
 * parameters to backup the partition now. If not present, backup operation
 * uses default parameters from the backup policy current associated with this
 * partition.
 *
 * @param {object} [options.backupPartitionDescription.backupStorage] Specifies
 * the details of the backup storage where to save the backup.
 *
 * @param {string}
 * [options.backupPartitionDescription.backupStorage.friendlyName] Friendly
 * name for this backup storage.
 *
 * @param {string} options.backupPartitionDescription.backupStorage.storageKind
 * Polymorphic Discriminator
 *
 * @param {number} [options.backupTimeout] Specifies the maximum amount of
 * time, in minutes, to wait for the backup operation to complete. Post that,
 * the operation completes with timeout error. However, in certain corner cases
 * it could be that though the operation returns back timeout, the backup
 * actually goes through. In case of timeout error, its recommended to invoke
 * this operation again with a greater timeout value. The default value for the
 * same is 10 minutes.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backupPartition(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let backupPartitionDescription = (options && options.backupPartitionDescription !== undefined) ? options.backupPartitionDescription : undefined;
  let backupTimeout = (options && options.backupTimeout !== undefined) ? options.backupTimeout : 10;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (backupTimeout !== null && backupTimeout !== undefined && typeof backupTimeout !== 'number') {
      throw new Error('backupTimeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/Backup';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  if (backupTimeout !== null && backupTimeout !== undefined) {
    queryParameters.push('BackupTimeout=' + encodeURIComponent(backupTimeout.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (backupPartitionDescription !== null && backupPartitionDescription !== undefined) {
      let requestModelMapper = new client.models['BackupPartitionDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, backupPartitionDescription, 'backupPartitionDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(backupPartitionDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest backup triggered for this partition.
 *
 * Returns information about the state of the latest backup along with details
 * or failure reason in case of completion.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupProgressInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionBackupProgress(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetBackupProgress';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Triggers restore of the state of the partition using the specified
 * restore partition description.
 *
 * Restores the state of a of the stateful persisted partition using the
 * specified backup point. In case the partition is already being periodically
 * backed up, then by default the backup point is looked for in the storage
 * specified in backup policy. One can also override the same by specifying the
 * backup storage details as part of the restore partition description in body.
 * Once the restore is initiated, its progress can be tracked using the
 * GetRestoreProgress operation.
 * In case, the operation times out, specify a greater restore timeout value in
 * the query parameter.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} restorePartitionDescription Describes the parameters to
 * restore the partition.
 *
 * @param {uuid} restorePartitionDescription.backupId Unique backup ID.
 *
 * @param {string} restorePartitionDescription.backupLocation Location of the
 * backup relative to the backup storage specified/ configured.
 *
 * @param {object} [restorePartitionDescription.backupStorage] Location of the
 * backup from where the partition will be restored.
 *
 * @param {string} [restorePartitionDescription.backupStorage.friendlyName]
 * Friendly name for this backup storage.
 *
 * @param {string} restorePartitionDescription.backupStorage.storageKind
 * Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.restoreTimeout] Specifies the maximum amount of
 * time to wait, in minutes, for the restore operation to complete. Post that,
 * the operation returns back with timeout error. However, in certain corner
 * cases it could be that the restore operation goes through even though it
 * completes with timeout. In case of timeout error, its recommended to invoke
 * this operation again with a greater timeout value. the default value for the
 * same is 10 minutes.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restorePartition(partitionId, restorePartitionDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let restoreTimeout = (options && options.restoreTimeout !== undefined) ? options.restoreTimeout : 10;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (restorePartitionDescription === null || restorePartitionDescription === undefined) {
      throw new Error('restorePartitionDescription cannot be null or undefined.');
    }
    if (restoreTimeout !== null && restoreTimeout !== undefined && typeof restoreTimeout !== 'number') {
      throw new Error('restoreTimeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/Restore';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  if (restoreTimeout !== null && restoreTimeout !== undefined) {
    queryParameters.push('RestoreTimeout=' + encodeURIComponent(restoreTimeout.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (restorePartitionDescription !== null && restorePartitionDescription !== undefined) {
      let requestModelMapper = new client.models['RestorePartitionDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, restorePartitionDescription, 'restorePartitionDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(restorePartitionDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets details for the latest restore operation triggered for this
 * partition.
 *
 * Returns information about the state of the latest restore operation along
 * with details or failure reason in case of completion.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreProgressInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionRestoreProgress(partitionId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Partitions/{partitionId}/$/GetRestoreProgress';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreProgressInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the list of backups available for the specified backed up
 * entity at the specified backup location.
 *
 * Gets the list of backups available for the specified backed up entity
 * (Application, Service or Partition) at the specified backup location
 * (FileShare or Azure Blob Storage).
 *
 * @param {object} getBackupByStorageQueryDescription Describes the filters and
 * backup storage details to be used for enumerating backups.
 *
 * @param {date} [getBackupByStorageQueryDescription.startDateTimeFilter]
 * Specifies the start date time in ISO8601 from which to enumerate backups. If
 * not specified, backups are enumerated from the beginning.
 *
 * @param {date} [getBackupByStorageQueryDescription.endDateTimeFilter]
 * Specifies the end date time in ISO8601 till which to enumerate backups. If
 * not specified, backups are enumerated till the end.
 *
 * @param {boolean} [getBackupByStorageQueryDescription.latest] If specified as
 * true, gets the most recent backup (within the specified time range) for
 * every partition under the specified backup entity.
 *
 * @param {object} getBackupByStorageQueryDescription.storage Describes the
 * parameters for the backup storage from where to enumerate backups. This is
 * optional and by default backups are enumerated from the backup storage where
 * this backup entity is currently being backed up (as specified in backup
 * policy). This parameter is useful to be able to enumerate backups from
 * another cluster where you may intend to restore.
 *
 * @param {string} [getBackupByStorageQueryDescription.storage.friendlyName]
 * Friendly name for this backup storage.
 *
 * @param {string} getBackupByStorageQueryDescription.storage.storageKind
 * Polymorphic Discriminator
 *
 * @param {object} getBackupByStorageQueryDescription.backupEntity Indicates
 * the entity for which to enumerate backups.
 *
 * @param {string} getBackupByStorageQueryDescription.backupEntity.entityKind
 * Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.maxResults] The maximum number of results to be
 * returned as part of the paged queries. This parameter defines the upper
 * bound on the number of results returned. The results returned can be less
 * than the specified maximum results if they do not fit in the message as per
 * the max message size restrictions defined in the configuration. If this
 * parameter is zero or not specified, the paged query includes as many results
 * as possible that fit in the return message.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedBackupInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupsFromBackupLocation(getBackupByStorageQueryDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let maxResults = (options && options.maxResults !== undefined) ? options.maxResults : 0;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (maxResults !== null && maxResults !== undefined && typeof maxResults !== 'number') {
      throw new Error('maxResults must be of type number.');
    }
    if (maxResults !== null && maxResults !== undefined) {
      if (maxResults < 0)
      {
        throw new Error('"maxResults" should satisfy the constraint - "InclusiveMinimum": 0');
      }
    }
    if (getBackupByStorageQueryDescription === null || getBackupByStorageQueryDescription === undefined) {
      throw new Error('getBackupByStorageQueryDescription cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'BackupRestore/$/GetBackups';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (maxResults !== null && maxResults !== undefined) {
    queryParameters.push('MaxResults=' + encodeURIComponent(maxResults.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (getBackupByStorageQueryDescription !== null && getBackupByStorageQueryDescription !== undefined) {
      let requestModelMapper = new client.models['GetBackupByStorageQueryDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, getBackupByStorageQueryDescription, 'getBackupByStorageQueryDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(getBackupByStorageQueryDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedBackupInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a Service Fabric name.
 *
 * Creates the specified Service Fabric name.
 *
 * @param {object} nameDescription Describes the Service Fabric name to be
 * created.
 *
 * @param {string} nameDescription.name The Service Fabric name, including the
 * 'fabric:' URI scheme.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createName(nameDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameDescription === null || nameDescription === undefined) {
      throw new Error('nameDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/$/Create';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (nameDescription !== null && nameDescription !== undefined) {
      let requestModelMapper = new client.models['NameDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, nameDescription, 'nameDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(nameDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns whether the Service Fabric name exists.
 *
 * Returns whether the specified Service Fabric name exists.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNameExistsInfo(nameId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a Service Fabric name.
 *
 * Deletes the specified Service Fabric name. A name must be created before it
 * can be deleted. Deleting a name with child properties will fail.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteName(nameId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Enumerates all the Service Fabric names under a given name.
 *
 * Enumerates all the Service Fabric names under a given name. If the subnames
 * do not fit in a page, one page of results is returned as well as a
 * continuation token, which can be used to get the next page. Querying a name
 * that doesn't exist will fail.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.recursive] Allows specifying that the search
 * performed should be recursive.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedSubNameInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSubNameInfoList(nameId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let recursive = (options && options.recursive !== undefined) ? options.recursive : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
      throw new Error('recursive must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetSubNames';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (recursive !== null && recursive !== undefined) {
    queryParameters.push('Recursive=' + encodeURIComponent(recursive.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedSubNameInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets information on all Service Fabric properties under a given
 * name.
 *
 * A Service Fabric name can have one or more named properties that store
 * custom information. This operation gets the information about these
 * properties in a paged list. The information includes name, value, and
 * metadata about each of the properties.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeValues] Allows specifying whether to
 * include the values of the properties returned. True if values should be
 * returned with the metadata; False to return only property metadata.
 *
 * @param {string} [options.continuationToken] The continuation token parameter
 * is used to obtain next set of results. A continuation token with a non-empty
 * value is included in the response of the API when the results from the
 * system do not fit in a single response. When this value is passed to the
 * next API call, the API returns next set of results. If there are no further
 * results, then the continuation token does not contain a value. The value of
 * this parameter should not be URL encoded.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PagedPropertyInfoList} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPropertyInfoList(nameId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeValues = (options && options.includeValues !== undefined) ? options.includeValues : false;
  let continuationToken = (options && options.continuationToken !== undefined) ? options.continuationToken : undefined;
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (includeValues !== null && includeValues !== undefined && typeof includeValues !== 'boolean') {
      throw new Error('includeValues must be of type boolean.');
    }
    if (continuationToken !== null && continuationToken !== undefined && typeof continuationToken.valueOf() !== 'string') {
      throw new Error('continuationToken must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetProperties';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (includeValues !== null && includeValues !== undefined) {
    queryParameters.push('IncludeValues=' + encodeURIComponent(includeValues.toString()));
  }
  if (continuationToken !== null && continuationToken !== undefined) {
    queryParameters.push('ContinuationToken=' + continuationToken);
  }
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PagedPropertyInfoList']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates or updates a Service Fabric property.
 *
 * Creates or updates the specified Service Fabric property under a given name.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} propertyDescription Describes the Service Fabric property to
 * be created.
 *
 * @param {string} propertyDescription.propertyName The name of the Service
 * Fabric property.
 *
 * @param {string} [propertyDescription.customTypeId] The property's custom
 * type ID. Using this property, the user is able to tag the type of the value
 * of the property.
 *
 * @param {object} propertyDescription.value Describes a Service Fabric
 * property value.
 *
 * @param {string} propertyDescription.value.kind Polymorphic Discriminator
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _putProperty(nameId, propertyDescription, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (propertyDescription === null || propertyDescription === undefined) {
      throw new Error('propertyDescription cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetProperty';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (propertyDescription !== null && propertyDescription !== undefined) {
      let requestModelMapper = new client.models['PropertyDescription']().mapper();
      requestModel = client.serialize(requestModelMapper, propertyDescription, 'propertyDescription');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(propertyDescription, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the specified Service Fabric property.
 *
 * Gets the specified Service Fabric property under a given name. This will
 * always return both value and metadata.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {string} propertyName Specifies the name of the property to get.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PropertyInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPropertyInfo(nameId, propertyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (propertyName === null || propertyName === undefined || typeof propertyName.valueOf() !== 'string') {
      throw new Error('propertyName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetProperty';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('PropertyName=' + encodeURIComponent(propertyName));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PropertyInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the specified Service Fabric property.
 *
 * Deletes the specified Service Fabric property under a given name. A property
 * must be created before it can be deleted.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {string} propertyName Specifies the name of the property to get.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteProperty(nameId, propertyName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (propertyName === null || propertyName === undefined || typeof propertyName.valueOf() !== 'string') {
      throw new Error('propertyName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetProperty';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  queryParameters.push('PropertyName=' + encodeURIComponent(propertyName));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Submits a property batch.
 *
 * Submits a batch of property operations. Either all or none of the operations
 * will be committed.
 *
 * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
 * scheme.
 *
 * @param {object} propertyBatchDescriptionList Describes the property batch
 * operations to be submitted.
 *
 * @param {array} [propertyBatchDescriptionList.operations] A list of the
 * property batch operations to be executed.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PropertyBatchInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _submitPropertyBatch(nameId, propertyBatchDescriptionList, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.0';
  // Validate
  try {
    if (nameId === null || nameId === undefined || typeof nameId.valueOf() !== 'string') {
      throw new Error('nameId cannot be null or undefined and it must be of type string.');
    }
    if (propertyBatchDescriptionList === null || propertyBatchDescriptionList === undefined) {
      throw new Error('propertyBatchDescriptionList cannot be null or undefined.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'Names/{nameId}/$/GetProperties/$/SubmitBatch';
  requestUrl = requestUrl.replace('{nameId}', nameId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (propertyBatchDescriptionList !== null && propertyBatchDescriptionList !== undefined) {
      let requestModelMapper = new client.models['PropertyBatchDescriptionList']().mapper();
      requestModel = client.serialize(requestModelMapper, propertyBatchDescriptionList, 'propertyBatchDescriptionList');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(propertyBatchDescriptionList, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 409) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SuccessfulPropertyBatchInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 409) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FailedPropertyBatchInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Cluster-related events.
 *
 * The response is list of ClusterEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getClusterEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Cluster/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ClusterEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ClusterEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Containers-related events.
 *
 * The response is list of ContainerInstanceEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getContainersEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.2-preview';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Containers/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ContainerInstanceEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ContainerInstanceEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a Node-related events.
 *
 * The response is list of NodeEvent objects.
 *
 * @param {string} nodeName The name of the node.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodeEventList(nodeName, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (nodeName === null || nodeName === undefined || typeof nodeName.valueOf() !== 'string') {
      throw new Error('nodeName cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Nodes/{nodeName}/$/Events';
  requestUrl = requestUrl.replace('{nodeName}', encodeURIComponent(nodeName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'NodeEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'NodeEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Nodes-related Events.
 *
 * The response is list of NodeEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getNodesEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Nodes/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'NodeEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'NodeEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an Application-related events.
 *
 * The response is list of ApplicationEvent objects.
 *
 * @param {string} applicationId The identity of the application. This is
 * typically the full name of the application without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the application name is "fabric:/myapp/app1", the
 * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
 * previous versions.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationEventList(applicationId, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
      throw new Error('applicationId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Applications/{applicationId}/$/Events';
  requestUrl = requestUrl.replace('{applicationId}', applicationId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ApplicationEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ApplicationEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Applications-related events.
 *
 * The response is list of ApplicationEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getApplicationsEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Applications/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ApplicationEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ApplicationEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a Service-related events.
 *
 * The response is list of ServiceEvent objects.
 *
 * @param {string} serviceId The identity of the service. This ID is typically
 * the full name of the service without the 'fabric:' URI scheme.
 * Starting from version 6.0, hierarchical names are delimited with the "~"
 * character.
 * For example, if the service name is "fabric:/myapp/app1/svc1", the service
 * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
 * previous versions.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServiceEventList(serviceId, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (serviceId === null || serviceId === undefined || typeof serviceId.valueOf() !== 'string') {
      throw new Error('serviceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Services/{serviceId}/$/Events';
  requestUrl = requestUrl.replace('{serviceId}', serviceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ServiceEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ServiceEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Services-related events.
 *
 * The response is list of ServiceEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getServicesEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Services/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ServiceEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ServiceEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a Partition-related events.
 *
 * The response is list of PartitionEvent objects.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionEventList(partitionId, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Partitions/{partitionId}/$/Events';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'PartitionEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'PartitionEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Partitions-related events.
 *
 * The response is list of PartitionEvent objects.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionsEventList(startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Partitions/Events';
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'PartitionEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'PartitionEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a Partition Replica-related events.
 *
 * The response is list of ReplicaEvent objects.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} replicaId The identifier of the replica.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionReplicaEventList(partitionId, replicaId, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (replicaId === null || replicaId === undefined || typeof replicaId.valueOf() !== 'string') {
      throw new Error('replicaId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Partitions/{partitionId}/$/Replicas/{replicaId}/$/Events';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  requestUrl = requestUrl.replace('{replicaId}', replicaId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ReplicaEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ReplicaEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all Replicas-related events for a Partition.
 *
 * The response is list of ReplicaEvent objects.
 *
 * @param {uuid} partitionId The identity of the partition.
 *
 * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
 * yyyy-MM-ddTHH:mm:ssZ.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {string} [options.eventsTypesFilter] This is a comma separated string
 * specifying the types of FabricEvents that should only be included in the
 * response.
 *
 * @param {boolean} [options.excludeAnalysisEvents] This param disables the
 * retrieval of AnalysisEvents if true is passed.
 *
 * @param {boolean} [options.skipCorrelationLookup] This param disables the
 * search of CorrelatedEvents information if true is passed. otherwise the
 * CorrelationEvents get processed and HasCorrelatedEvents field in every
 * FabricEvent gets populated.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPartitionReplicasEventList(partitionId, startTimeUtc, endTimeUtc, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let eventsTypesFilter = (options && options.eventsTypesFilter !== undefined) ? options.eventsTypesFilter : undefined;
  let excludeAnalysisEvents = (options && options.excludeAnalysisEvents !== undefined) ? options.excludeAnalysisEvents : undefined;
  let skipCorrelationLookup = (options && options.skipCorrelationLookup !== undefined) ? options.skipCorrelationLookup : undefined;
  let apiVersion = '6.4';
  // Validate
  try {
    if (partitionId === null || partitionId === undefined || typeof partitionId.valueOf() !== 'string' || !msRest.isValidUuid(partitionId)) {
      throw new Error('partitionId cannot be null or undefined and it must be of type string and must be a valid uuid.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
    if (startTimeUtc === null || startTimeUtc === undefined || typeof startTimeUtc.valueOf() !== 'string') {
      throw new Error('startTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (endTimeUtc === null || endTimeUtc === undefined || typeof endTimeUtc.valueOf() !== 'string') {
      throw new Error('endTimeUtc cannot be null or undefined and it must be of type string.');
    }
    if (eventsTypesFilter !== null && eventsTypesFilter !== undefined && typeof eventsTypesFilter.valueOf() !== 'string') {
      throw new Error('eventsTypesFilter must be of type string.');
    }
    if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined && typeof excludeAnalysisEvents !== 'boolean') {
      throw new Error('excludeAnalysisEvents must be of type boolean.');
    }
    if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined && typeof skipCorrelationLookup !== 'boolean') {
      throw new Error('skipCorrelationLookup must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/Partitions/{partitionId}/$/Replicas/Events';
  requestUrl = requestUrl.replace('{partitionId}', partitionId.toString());
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  queryParameters.push('StartTimeUtc=' + encodeURIComponent(startTimeUtc));
  queryParameters.push('EndTimeUtc=' + encodeURIComponent(endTimeUtc));
  if (eventsTypesFilter !== null && eventsTypesFilter !== undefined) {
    queryParameters.push('EventsTypesFilter=' + encodeURIComponent(eventsTypesFilter));
  }
  if (excludeAnalysisEvents !== null && excludeAnalysisEvents !== undefined) {
    queryParameters.push('ExcludeAnalysisEvents=' + encodeURIComponent(excludeAnalysisEvents.toString()));
  }
  if (skipCorrelationLookup !== null && skipCorrelationLookup !== undefined) {
    queryParameters.push('SkipCorrelationLookup=' + encodeURIComponent(skipCorrelationLookup.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ReplicaEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'ReplicaEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all correlated events for a given event.
 *
 * The response is list of FabricEvents.
 *
 * @param {string} eventInstanceId The EventInstanceId.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.timeout] The server timeout for performing the
 * operation in seconds. This timeout specifies the time duration that the
 * client is willing to wait for the requested operation to complete. The
 * default value for this parameter is 60 seconds.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCorrelatedEventList(eventInstanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let timeout = (options && options.timeout !== undefined) ? options.timeout : 60;
  let apiVersion = '6.4';
  // Validate
  try {
    if (eventInstanceId === null || eventInstanceId === undefined || typeof eventInstanceId.valueOf() !== 'string') {
      throw new Error('eventInstanceId cannot be null or undefined and it must be of type string.');
    }
    if (timeout !== null && timeout !== undefined && typeof timeout !== 'number') {
      throw new Error('timeout must be of type number.');
    }
    if (timeout !== null && timeout !== undefined) {
      if (timeout > 4294967295)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMaximum": 4294967295');
      }
      if (timeout < 1)
      {
        throw new Error('"timeout" should satisfy the constraint - "InclusiveMinimum": 1');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'EventsStore/CorrelatedEvents/{eventInstanceId}/$/Events';
  requestUrl = requestUrl.replace('{eventInstanceId}', encodeURIComponent(eventInstanceId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (timeout !== null && timeout !== undefined) {
    queryParameters.push('timeout=' + encodeURIComponent(timeout.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['FabricError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FabricEventElementType',
                  type: {
                    name: 'Composite',
                    polymorphicDiscriminator: {
                      serializedName: 'Kind',
                      clientName: 'kind'
                    },
                    uberParent: 'FabricEvent',
                    className: 'FabricEvent'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a ServiceFabricClient. */
class ServiceFabricClient extends ServiceClient {
  /**
   * Create a ServiceFabricClient.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   */
  constructor(baseUri, options) {

    if (!options) options = {};

    super(null, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'http://localhost:19080';
    }

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    this.meshSecret = new operations.MeshSecret(this);
    this.meshSecretValue = new operations.MeshSecretValue(this);
    this.meshVolume = new operations.MeshVolume(this);
    this.meshNetwork = new operations.MeshNetwork(this);
    this.meshApplication = new operations.MeshApplication(this);
    this.meshService = new operations.MeshService(this);
    this.meshCodePackage = new operations.MeshCodePackage(this);
    this.meshServiceReplica = new operations.MeshServiceReplica(this);
    this.meshGateway = new operations.MeshGateway(this);
    this.models = models;
    this._getClusterManifest = _getClusterManifest;
    this._getClusterHealth = _getClusterHealth;
    this._getClusterHealthUsingPolicy = _getClusterHealthUsingPolicy;
    this._getClusterHealthChunk = _getClusterHealthChunk;
    this._getClusterHealthChunkUsingPolicyAndAdvancedFilters = _getClusterHealthChunkUsingPolicyAndAdvancedFilters;
    this._reportClusterHealth = _reportClusterHealth;
    this._getProvisionedFabricCodeVersionInfoList = _getProvisionedFabricCodeVersionInfoList;
    this._getProvisionedFabricConfigVersionInfoList = _getProvisionedFabricConfigVersionInfoList;
    this._getClusterUpgradeProgress = _getClusterUpgradeProgress;
    this._getClusterConfiguration = _getClusterConfiguration;
    this._getClusterConfigurationUpgradeStatus = _getClusterConfigurationUpgradeStatus;
    this._getUpgradeOrchestrationServiceState = _getUpgradeOrchestrationServiceState;
    this._setUpgradeOrchestrationServiceState = _setUpgradeOrchestrationServiceState;
    this._provisionCluster = _provisionCluster;
    this._unprovisionCluster = _unprovisionCluster;
    this._rollbackClusterUpgrade = _rollbackClusterUpgrade;
    this._resumeClusterUpgrade = _resumeClusterUpgrade;
    this._startClusterUpgrade = _startClusterUpgrade;
    this._startClusterConfigurationUpgrade = _startClusterConfigurationUpgrade;
    this._updateClusterUpgrade = _updateClusterUpgrade;
    this._getAadMetadata = _getAadMetadata;
    this._getClusterVersion = _getClusterVersion;
    this._getNodeInfoList = _getNodeInfoList;
    this._getNodeInfo = _getNodeInfo;
    this._getNodeHealth = _getNodeHealth;
    this._getNodeHealthUsingPolicy = _getNodeHealthUsingPolicy;
    this._reportNodeHealth = _reportNodeHealth;
    this._getNodeLoadInfo = _getNodeLoadInfo;
    this._disableNode = _disableNode;
    this._enableNode = _enableNode;
    this._removeNodeState = _removeNodeState;
    this._restartNode = _restartNode;
    this._getApplicationTypeInfoList = _getApplicationTypeInfoList;
    this._getApplicationTypeInfoListByName = _getApplicationTypeInfoListByName;
    this._provisionApplicationType = _provisionApplicationType;
    this._unprovisionApplicationType = _unprovisionApplicationType;
    this._getServiceTypeInfoList = _getServiceTypeInfoList;
    this._getServiceTypeInfoByName = _getServiceTypeInfoByName;
    this._getServiceManifest = _getServiceManifest;
    this._getDeployedServiceTypeInfoList = _getDeployedServiceTypeInfoList;
    this._getDeployedServiceTypeInfoByName = _getDeployedServiceTypeInfoByName;
    this._createApplication = _createApplication;
    this._deleteApplication = _deleteApplication;
    this._getApplicationLoadInfo = _getApplicationLoadInfo;
    this._getApplicationInfoList = _getApplicationInfoList;
    this._getApplicationInfo = _getApplicationInfo;
    this._getApplicationHealth = _getApplicationHealth;
    this._getApplicationHealthUsingPolicy = _getApplicationHealthUsingPolicy;
    this._reportApplicationHealth = _reportApplicationHealth;
    this._startApplicationUpgrade = _startApplicationUpgrade;
    this._getApplicationUpgrade = _getApplicationUpgrade;
    this._updateApplicationUpgrade = _updateApplicationUpgrade;
    this._resumeApplicationUpgrade = _resumeApplicationUpgrade;
    this._rollbackApplicationUpgrade = _rollbackApplicationUpgrade;
    this._getDeployedApplicationInfoList = _getDeployedApplicationInfoList;
    this._getDeployedApplicationInfo = _getDeployedApplicationInfo;
    this._getDeployedApplicationHealth = _getDeployedApplicationHealth;
    this._getDeployedApplicationHealthUsingPolicy = _getDeployedApplicationHealthUsingPolicy;
    this._reportDeployedApplicationHealth = _reportDeployedApplicationHealth;
    this._getApplicationManifest = _getApplicationManifest;
    this._getServiceInfoList = _getServiceInfoList;
    this._getServiceInfo = _getServiceInfo;
    this._getApplicationNameInfo = _getApplicationNameInfo;
    this._createService = _createService;
    this._createServiceFromTemplate = _createServiceFromTemplate;
    this._deleteService = _deleteService;
    this._updateService = _updateService;
    this._getServiceDescription = _getServiceDescription;
    this._getServiceHealth = _getServiceHealth;
    this._getServiceHealthUsingPolicy = _getServiceHealthUsingPolicy;
    this._reportServiceHealth = _reportServiceHealth;
    this._resolveService = _resolveService;
    this._getPartitionInfoList = _getPartitionInfoList;
    this._getPartitionInfo = _getPartitionInfo;
    this._getServiceNameInfo = _getServiceNameInfo;
    this._getPartitionHealth = _getPartitionHealth;
    this._getPartitionHealthUsingPolicy = _getPartitionHealthUsingPolicy;
    this._reportPartitionHealth = _reportPartitionHealth;
    this._getPartitionLoadInformation = _getPartitionLoadInformation;
    this._resetPartitionLoad = _resetPartitionLoad;
    this._recoverPartition = _recoverPartition;
    this._recoverServicePartitions = _recoverServicePartitions;
    this._recoverSystemPartitions = _recoverSystemPartitions;
    this._recoverAllPartitions = _recoverAllPartitions;
    this._createRepairTask = _createRepairTask;
    this._cancelRepairTask = _cancelRepairTask;
    this._deleteRepairTask = _deleteRepairTask;
    this._getRepairTaskList = _getRepairTaskList;
    this._forceApproveRepairTask = _forceApproveRepairTask;
    this._updateRepairTaskHealthPolicy = _updateRepairTaskHealthPolicy;
    this._updateRepairExecutionState = _updateRepairExecutionState;
    this._getReplicaInfoList = _getReplicaInfoList;
    this._getReplicaInfo = _getReplicaInfo;
    this._getReplicaHealth = _getReplicaHealth;
    this._getReplicaHealthUsingPolicy = _getReplicaHealthUsingPolicy;
    this._reportReplicaHealth = _reportReplicaHealth;
    this._getDeployedServiceReplicaInfoList = _getDeployedServiceReplicaInfoList;
    this._getDeployedServiceReplicaDetailInfo = _getDeployedServiceReplicaDetailInfo;
    this._getDeployedServiceReplicaDetailInfoByPartitionId = _getDeployedServiceReplicaDetailInfoByPartitionId;
    this._restartReplica = _restartReplica;
    this._removeReplica = _removeReplica;
    this._getDeployedServicePackageInfoList = _getDeployedServicePackageInfoList;
    this._getDeployedServicePackageInfoListByName = _getDeployedServicePackageInfoListByName;
    this._getDeployedServicePackageHealth = _getDeployedServicePackageHealth;
    this._getDeployedServicePackageHealthUsingPolicy = _getDeployedServicePackageHealthUsingPolicy;
    this._reportDeployedServicePackageHealth = _reportDeployedServicePackageHealth;
    this._deployServicePackageToNode = _deployServicePackageToNode;
    this._getDeployedCodePackageInfoList = _getDeployedCodePackageInfoList;
    this._restartDeployedCodePackage = _restartDeployedCodePackage;
    this._getContainerLogsDeployedOnNode = _getContainerLogsDeployedOnNode;
    this._invokeContainerApi = _invokeContainerApi;
    this._createComposeDeployment = _createComposeDeployment;
    this._getComposeDeploymentStatus = _getComposeDeploymentStatus;
    this._getComposeDeploymentStatusList = _getComposeDeploymentStatusList;
    this._getComposeDeploymentUpgradeProgress = _getComposeDeploymentUpgradeProgress;
    this._removeComposeDeployment = _removeComposeDeployment;
    this._startComposeDeploymentUpgrade = _startComposeDeploymentUpgrade;
    this._startRollbackComposeDeploymentUpgrade = _startRollbackComposeDeploymentUpgrade;
    this._getChaos = _getChaos;
    this._startChaos = _startChaos;
    this._stopChaos = _stopChaos;
    this._getChaosEvents = _getChaosEvents;
    this._getChaosSchedule = _getChaosSchedule;
    this._postChaosSchedule = _postChaosSchedule;
    this._uploadFile = _uploadFile;
    this._getImageStoreContent = _getImageStoreContent;
    this._deleteImageStoreContent = _deleteImageStoreContent;
    this._getImageStoreRootContent = _getImageStoreRootContent;
    this._copyImageStoreContent = _copyImageStoreContent;
    this._deleteImageStoreUploadSession = _deleteImageStoreUploadSession;
    this._commitImageStoreUploadSession = _commitImageStoreUploadSession;
    this._getImageStoreUploadSessionById = _getImageStoreUploadSessionById;
    this._getImageStoreUploadSessionByPath = _getImageStoreUploadSessionByPath;
    this._uploadFileChunk = _uploadFileChunk;
    this._invokeInfrastructureCommand = _invokeInfrastructureCommand;
    this._invokeInfrastructureQuery = _invokeInfrastructureQuery;
    this._startDataLoss = _startDataLoss;
    this._getDataLossProgress = _getDataLossProgress;
    this._startQuorumLoss = _startQuorumLoss;
    this._getQuorumLossProgress = _getQuorumLossProgress;
    this._startPartitionRestart = _startPartitionRestart;
    this._getPartitionRestartProgress = _getPartitionRestartProgress;
    this._startNodeTransition = _startNodeTransition;
    this._getNodeTransitionProgress = _getNodeTransitionProgress;
    this._getFaultOperationList = _getFaultOperationList;
    this._cancelOperation = _cancelOperation;
    this._createBackupPolicy = _createBackupPolicy;
    this._deleteBackupPolicy = _deleteBackupPolicy;
    this._getBackupPolicyList = _getBackupPolicyList;
    this._getBackupPolicyByName = _getBackupPolicyByName;
    this._getAllEntitiesBackedUpByPolicy = _getAllEntitiesBackedUpByPolicy;
    this._updateBackupPolicy = _updateBackupPolicy;
    this._enableApplicationBackup = _enableApplicationBackup;
    this._disableApplicationBackup = _disableApplicationBackup;
    this._getApplicationBackupConfigurationInfo = _getApplicationBackupConfigurationInfo;
    this._getApplicationBackupList = _getApplicationBackupList;
    this._suspendApplicationBackup = _suspendApplicationBackup;
    this._resumeApplicationBackup = _resumeApplicationBackup;
    this._enableServiceBackup = _enableServiceBackup;
    this._disableServiceBackup = _disableServiceBackup;
    this._getServiceBackupConfigurationInfo = _getServiceBackupConfigurationInfo;
    this._getServiceBackupList = _getServiceBackupList;
    this._suspendServiceBackup = _suspendServiceBackup;
    this._resumeServiceBackup = _resumeServiceBackup;
    this._enablePartitionBackup = _enablePartitionBackup;
    this._disablePartitionBackup = _disablePartitionBackup;
    this._getPartitionBackupConfigurationInfo = _getPartitionBackupConfigurationInfo;
    this._getPartitionBackupList = _getPartitionBackupList;
    this._suspendPartitionBackup = _suspendPartitionBackup;
    this._resumePartitionBackup = _resumePartitionBackup;
    this._backupPartition = _backupPartition;
    this._getPartitionBackupProgress = _getPartitionBackupProgress;
    this._restorePartition = _restorePartition;
    this._getPartitionRestoreProgress = _getPartitionRestoreProgress;
    this._getBackupsFromBackupLocation = _getBackupsFromBackupLocation;
    this._createName = _createName;
    this._getNameExistsInfo = _getNameExistsInfo;
    this._deleteName = _deleteName;
    this._getSubNameInfoList = _getSubNameInfoList;
    this._getPropertyInfoList = _getPropertyInfoList;
    this._putProperty = _putProperty;
    this._getPropertyInfo = _getPropertyInfo;
    this._deleteProperty = _deleteProperty;
    this._submitPropertyBatch = _submitPropertyBatch;
    this._getClusterEventList = _getClusterEventList;
    this._getContainersEventList = _getContainersEventList;
    this._getNodeEventList = _getNodeEventList;
    this._getNodesEventList = _getNodesEventList;
    this._getApplicationEventList = _getApplicationEventList;
    this._getApplicationsEventList = _getApplicationsEventList;
    this._getServiceEventList = _getServiceEventList;
    this._getServicesEventList = _getServicesEventList;
    this._getPartitionEventList = _getPartitionEventList;
    this._getPartitionsEventList = _getPartitionsEventList;
    this._getPartitionReplicaEventList = _getPartitionReplicaEventList;
    this._getPartitionReplicasEventList = _getPartitionReplicasEventList;
    this._getCorrelatedEventList = _getCorrelatedEventList;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand-alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (e.g. when using Azure portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterManifestWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterManifest(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand-alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (e.g. when using Azure portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterManifest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterManifest(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterManifest(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterManifest(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealth(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealth(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealth(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealth(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthUsingPolicyWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthUsingPolicy(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthUsingPolicy(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthUsingPolicy(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthUsingPolicy(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthChunkWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthChunk(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunk(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthChunk(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthChunk(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy] Defines a
   * health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy] Defines a
   * health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterHealthChunkUsingPolicyAndAdvancedFilters(options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportClusterHealthWithHttpOperationResponse(healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportClusterHealth(healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportClusterHealth(healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportClusterHealth(healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportClusterHealth(healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getProvisionedFabricCodeVersionInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProvisionedFabricCodeVersionInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricCodeVersionInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProvisionedFabricCodeVersionInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProvisionedFabricCodeVersionInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getProvisionedFabricConfigVersionInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProvisionedFabricConfigVersionInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricConfigVersionInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProvisionedFabricConfigVersionInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProvisionedFabricConfigVersionInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, get the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterUpgradeProgressObject>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterUpgradeProgressWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterUpgradeProgress(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, get the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterUpgradeProgressObject} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterUpgradeProgressObject} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterUpgradeProgress(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterUpgradeProgress(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterUpgradeProgress(options, optionalCallback);
    }
  }

  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * The cluster configuration contains properties of the cluster that include
   * different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfiguration>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterConfigurationWithHttpOperationResponse(configurationApiVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterConfiguration(configurationApiVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * The cluster configuration contains properties of the cluster that include
   * different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterConfiguration} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfiguration} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfiguration(configurationApiVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterConfiguration(configurationApiVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterConfiguration(configurationApiVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status details of a Service Fabric
   * standalone cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfigurationUpgradeStatusInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterConfigurationUpgradeStatusWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterConfigurationUpgradeStatus(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status details of a Service Fabric
   * standalone cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterConfigurationUpgradeStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfigurationUpgradeStatusInfo} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfigurationUpgradeStatus(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterConfigurationUpgradeStatus(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterConfigurationUpgradeStatus(options, optionalCallback);
    }
  }

  /**
   * @summary Get the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Get the service state of Service Fabric Upgrade Orchestration Service. This
   * API is internally used for support purposes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UpgradeOrchestrationServiceState>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUpgradeOrchestrationServiceStateWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUpgradeOrchestrationServiceState(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Get the service state of Service Fabric Upgrade Orchestration Service. This
   * API is internally used for support purposes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UpgradeOrchestrationServiceState} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UpgradeOrchestrationServiceState} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUpgradeOrchestrationServiceState(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUpgradeOrchestrationServiceState(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUpgradeOrchestrationServiceState(options, optionalCallback);
    }
  }

  /**
   * @summary Update the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Update the service state of Service Fabric Upgrade Orchestration Service.
   * This API is internally used for support purposes.
   *
   * @param {object} upgradeOrchestrationServiceState Service state of Service
   * Fabric Upgrade Orchestration Service.
   *
   * @param {string} [upgradeOrchestrationServiceState.serviceState] The state of
   * Service Fabric Upgrade Orchestration Service.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UpgradeOrchestrationServiceStateSummary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  setUpgradeOrchestrationServiceStateWithHttpOperationResponse(upgradeOrchestrationServiceState, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Update the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Update the service state of Service Fabric Upgrade Orchestration Service.
   * This API is internally used for support purposes.
   *
   * @param {object} upgradeOrchestrationServiceState Service state of Service
   * Fabric Upgrade Orchestration Service.
   *
   * @param {string} [upgradeOrchestrationServiceState.serviceState] The state of
   * Service Fabric Upgrade Orchestration Service.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UpgradeOrchestrationServiceStateSummary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UpgradeOrchestrationServiceStateSummary} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState, options, optionalCallback);
    }
  }

  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  provisionClusterWithHttpOperationResponse(provisionFabricDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._provisionCluster(provisionFabricDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionCluster(provisionFabricDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._provisionCluster(provisionFabricDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._provisionCluster(provisionFabricDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * It is supported to unprovision code and configuration separately.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  unprovisionClusterWithHttpOperationResponse(unprovisionFabricDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._unprovisionCluster(unprovisionFabricDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * It is supported to unprovision code and configuration separately.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionCluster(unprovisionFabricDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._unprovisionCluster(unprovisionFabricDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._unprovisionCluster(unprovisionFabricDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Roll back the upgrade of a Service Fabric cluster.
   *
   * Roll back the code or configuration upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rollbackClusterUpgradeWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rollbackClusterUpgrade(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Roll back the upgrade of a Service Fabric cluster.
   *
   * Roll back the code or configuration upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackClusterUpgrade(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rollbackClusterUpgrade(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rollbackClusterUpgrade(options, optionalCallback);
    }
  }

  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster code or configuration upgrade move on to the next upgrade
   * domain if appropriate.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeClusterUpgradeWithHttpOperationResponse(resumeClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster code or configuration upgrade move on to the next upgrade
   * domain if appropriate.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeClusterUpgrade(resumeClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeClusterUpgrade(resumeClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startClusterUpgradeWithHttpOperationResponse(startClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startClusterUpgrade(startClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterUpgrade(startClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startClusterUpgrade(startClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startClusterUpgrade(startClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration as a JSON string. For example, [this
   * file](https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json)
   * contains JSON describing the [nodes and other properties of the
   * cluster](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest).
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startClusterConfigurationUpgradeWithHttpOperationResponse(clusterConfigurationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration as a JSON string. For example, [this
   * file](https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json)
   * contains JSON describing the [nodes and other properties of the
   * cluster](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest).
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters used during a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] The type of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster or of a
   * cluster node.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateClusterUpgradeWithHttpOperationResponse(updateClusterUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateClusterUpgrade(updateClusterUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters used during a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] The type of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster or of a
   * cluster node.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateClusterUpgrade(updateClusterUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateClusterUpgrade(updateClusterUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateClusterUpgrade(updateClusterUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AadMetadataObject>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAadMetadataWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAadMetadata(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AadMetadataObject} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AadMetadataObject} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAadMetadata(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAadMetadata(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAadMetadata(options, optionalCallback);
    }
  }

  /**
   * @summary Get the current Service Fabric cluster version.
   *
   * If a cluster upgrade is happening, then this API will return the lowest
   * (older) version of the current and target cluster runtime versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterVersion>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterVersionWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterVersion(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the current Service Fabric cluster version.
   *
   * If a cluster upgrade is happening, then this API will return the lowest
   * (older) version of the current and target cluster runtime versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ClusterVersion} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterVersion} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterVersion(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterVersion(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterVersion(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the nodes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedNodeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the nodes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedNodeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedNodeInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a specific node in the Service Fabric
   * cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeInfoWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeInfo(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a specific node in the Service Fabric
   * cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfo(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeInfo(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeInfo(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeHealthWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeHealth(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealth(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeHealth(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeHealth(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeHealthUsingPolicyWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeHealthUsingPolicy(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealthUsingPolicy(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeHealthUsingPolicy(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeHealthUsingPolicy(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportNodeHealthWithHttpOperationResponse(nodeName, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportNodeHealth(nodeName, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportNodeHealth(nodeName, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportNodeHealth(nodeName, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportNodeHealth(nodeName, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Retrieves the load information of a Service Fabric node for all the metrics
   * that have load or capacity defined.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeLoadInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeLoadInfoWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeLoadInfo(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Retrieves the load information of a Service Fabric node for all the metrics
   * that have load or capacity defined.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeLoadInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeLoadInfo(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeLoadInfo(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeLoadInfo(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node that is deactivated with
   * the Pause intent can be deactivated further with Restart, but not the other
   * way around. Nodes may be reactivated using the Activate a node operation any
   * time after they are deactivated. If the deactivation is not complete, this
   * will cancel the deactivation. A node that goes down and comes back up while
   * deactivated will still need to be reactivated before services will be placed
   * on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following. Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableNodeWithHttpOperationResponse(nodeName, deactivationIntentDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disableNode(nodeName, deactivationIntentDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node that is deactivated with
   * the Pause intent can be deactivated further with Restart, but not the other
   * way around. Nodes may be reactivated using the Activate a node operation any
   * time after they are deactivated. If the deactivation is not complete, this
   * will cancel the deactivation. A node that goes down and comes back up while
   * deactivated will still need to be reactivated before services will be placed
   * on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following. Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disableNode(nodeName, deactivationIntentDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disableNode(nodeName, deactivationIntentDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disableNode(nodeName, deactivationIntentDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Activate a Service Fabric cluster node that is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node that is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableNodeWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enableNode(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Activate a Service Fabric cluster node that is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node that is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enableNode(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enableNode(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enableNode(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * This implies that it is not possible to recover the persisted state of that
   * node. This generally happens if a hard disk has been wiped clean, or if a
   * hard disk crashes. The node has to be down for this operation to be
   * successful. This operation lets Service Fabric know that the replicas on
   * that node no longer exist, and that Service Fabric should stop waiting for
   * those replicas to come back up. Do not run this cmdlet if the state on the
   * node has not been removed and the node can come back up with its state
   * intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeNodeStateWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeNodeState(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * This implies that it is not possible to recover the persisted state of that
   * node. This generally happens if a hard disk has been wiped clean, or if a
   * hard disk crashes. The node has to be down for this operation to be
   * successful. This operation lets Service Fabric know that the replicas on
   * that node no longer exist, and that Service Fabric should stop waiting for
   * those replicas to come back up. Do not run this cmdlet if the state on the
   * node has not been removed and the node can come back up with its state
   * intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeNodeState(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeNodeState(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeNodeState(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance ID of the
   * target node. If instance ID is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance ID. The instance ID can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case-sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartNodeWithHttpOperationResponse(nodeName, restartNodeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartNode(nodeName, restartNodeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance ID of the
   * target node. If instance ID is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance ID. The instance ID can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case-sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartNode(nodeName, restartNodeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartNode(nodeName, restartNodeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartNode(nodeName, restartNodeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status, and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token, which can be used to get the next page. For example,
   * if there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationTypeInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationTypeInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status, and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token, which can be used to get the next page. For example,
   * if there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationTypeInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationTypeInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status, and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.applicationTypeVersion] The version of the
   * application type.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationTypeInfoListByNameWithHttpOperationResponse(applicationTypeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationTypeInfoListByName(applicationTypeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status, and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.applicationTypeVersion] The version of the
   * application type.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoListByName(applicationTypeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationTypeInfoListByName(applicationTypeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationTypeInfoListByName(applicationTypeName, options, optionalCallback);
    }
  }

  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster using the '.sfpkg' package in the external store or using the
   * application package in the image store.
   *
   * Provisions a Service Fabric application type with the cluster. The provision
   * is required before any new applications can be instantiated.
   * The provision operation can be performed either on the application package
   * specified by the relativePathInImageStore, or by using the URI of the
   * external '.sfpkg'.
   *
   * @param {object} provisionApplicationTypeDescriptionBaseRequiredBodyParam The
   * base type of provision application type description which supports either
   * image store-based provision or external store-based provision.
   *
   * @param {boolean}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.async Indicates
   * whether or not provisioning should occur asynchronously. When set to true,
   * the provision operation returns when the request is accepted by the system,
   * and the provision operation continues without any timeout limit. The default
   * value is false. For large application packages, we recommend setting the
   * value to true.
   *
   * @param {string}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.kind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  provisionApplicationTypeWithHttpOperationResponse(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster using the '.sfpkg' package in the external store or using the
   * application package in the image store.
   *
   * Provisions a Service Fabric application type with the cluster. The provision
   * is required before any new applications can be instantiated.
   * The provision operation can be performed either on the application package
   * specified by the relativePathInImageStore, or by using the URI of the
   * external '.sfpkg'.
   *
   * @param {object} provisionApplicationTypeDescriptionBaseRequiredBodyParam The
   * base type of provision application type description which supports either
   * image store-based provision or external store-based provision.
   *
   * @param {boolean}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.async Indicates
   * whether or not provisioning should occur asynchronously. When set to true,
   * the provision operation returns when the request is accepted by the system,
   * and the provision operation continues without any timeout limit. The default
   * value is false. For large application packages, we recommend setting the
   * value to true.
   *
   * @param {string}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.kind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam, options, optionalCallback);
    }
  }

  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * This operation can only be performed if all application instances of the
   * application type have been deleted. Once the application type is
   * unregistered, no new application instances can be created for this
   * particular application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} unprovisionApplicationTypeDescriptionInfo The relative path
   * for the application package in the image store specified during the prior
   * copy operation.
   *
   * @param {string}
   * unprovisionApplicationTypeDescriptionInfo.applicationTypeVersion The version
   * of the application type as defined in the application manifest.
   *
   * @param {boolean} [unprovisionApplicationTypeDescriptionInfo.async] The flag
   * indicating whether or not unprovision should occur asynchronously. When set
   * to true, the unprovision operation returns when the request is accepted by
   * the system, and the unprovision operation continues without any timeout
   * limit. The default value is false. However, we recommend setting it to true
   * for large application packages that were provisioned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  unprovisionApplicationTypeWithHttpOperationResponse(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._unprovisionApplicationType(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * This operation can only be performed if all application instances of the
   * application type have been deleted. Once the application type is
   * unregistered, no new application instances can be created for this
   * particular application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} unprovisionApplicationTypeDescriptionInfo The relative path
   * for the application package in the image store specified during the prior
   * copy operation.
   *
   * @param {string}
   * unprovisionApplicationTypeDescriptionInfo.applicationTypeVersion The version
   * of the application type as defined in the application manifest.
   *
   * @param {boolean} [unprovisionApplicationTypeDescriptionInfo.async] The flag
   * indicating whether or not unprovision should occur asynchronously. When set
   * to true, the unprovision operation returns when the request is accepted by
   * the system, and the unprovision operation continues without any timeout
   * limit. The default value is false. However, we recommend setting it to true
   * for large application packages that were provisioned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionApplicationType(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._unprovisionApplicationType(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._unprovisionApplicationType(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * provided application type must exist. Otherwise, a 404 status is returned.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceTypeInfoListWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * provided application type must exist. Otherwise, a 404 status is returned.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceTypeInfoList(applicationTypeName, applicationTypeVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a specific service type that is
   * supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the information about a specific service type that is supported by a
   * provisioned application type in a Service Fabric cluster. The provided
   * application type must exist. Otherwise, a 404 status is returned. A 204
   * response is returned if the specified service type is not found in the
   * cluster.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceTypeInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceTypeInfoByNameWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, serviceTypeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceTypeInfoByName(applicationTypeName, applicationTypeVersion, serviceTypeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a specific service type that is
   * supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the information about a specific service type that is supported by a
   * provisioned application type in a Service Fabric cluster. The provided
   * application type must exist. Otherwise, a 404 status is returned. A 204
   * response is returned if the specified service type is not found in the
   * cluster.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceTypeInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceTypeInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceTypeInfoByName(applicationTypeName, applicationTypeVersion, serviceTypeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceTypeInfoByName(applicationTypeName, applicationTypeVersion, serviceTypeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceTypeInfoByName(applicationTypeName, applicationTypeVersion, serviceTypeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceTypeManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceManifestWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, serviceManifestName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceTypeManifest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceManifest(applicationTypeName, applicationTypeVersion, serviceManifestName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation ID of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceTypeInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation ID of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceTypeInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation ID of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation ID.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceTypeInfoByNameWithHttpOperationResponse(nodeName, applicationId, serviceTypeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation ID of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation ID.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name The name of the application,
   * including the 'fabric:' URI scheme.
   *
   * @param {string} applicationDescription.typeName The application type name as
   * defined in the application manifest.
   *
   * @param {string} applicationDescription.typeVersion The version of the
   * application type as defined in the application manifest.
   *
   * @param {array} [applicationDescription.parameterList] List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {object} [applicationDescription.applicationCapacity] Describes
   * capacity information for services of this application. This description can
   * be used for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can
   * run on
   * - Limiting the custom capacity metrics to limit the total consumption of
   * this metric by the services of this application
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics] List of
   * application capacity metric description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createApplicationWithHttpOperationResponse(applicationDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createApplication(applicationDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name The name of the application,
   * including the 'fabric:' URI scheme.
   *
   * @param {string} applicationDescription.typeName The application type name as
   * defined in the application manifest.
   *
   * @param {string} applicationDescription.typeVersion The version of the
   * application type as defined in the application manifest.
   *
   * @param {array} [applicationDescription.parameterList] List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {object} [applicationDescription.applicationCapacity] Describes
   * capacity information for services of this application. This description can
   * be used for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can
   * run on
   * - Limiting the custom capacity metrics to limit the total consumption of
   * this metric by the services of this application
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics] List of
   * application capacity metric description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createApplication(applicationDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createApplication(applicationDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createApplication(applicationDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * An application must be created before it can be deleted. Deleting an
   * application will delete all services that are part of that application. By
   * default, Service Fabric will try to close service replicas in a graceful
   * manner and then delete the service. However, if a service is having issues
   * closing the replica gracefully, the delete operation may take a long time or
   * get stuck. Use the optional ForceRemove flag to skip the graceful close
   * sequence and forcefully delete the application and all of its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteApplicationWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteApplication(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * An application must be created before it can be deleted. Deleting an
   * application will delete all services that are part of that application. By
   * default, Service Fabric will try to close service replicas in a graceful
   * manner and then delete the service. However, if a service is having issues
   * closing the replica gracefully, the delete operation may take a long time or
   * get stuck. Use the optional ForceRemove flag to skip the graceful close
   * sequence and forcefully delete the application and all of its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplication(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteApplication(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteApplication(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the application is
   * occupying currently, and application load metric information about the
   * application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationLoadInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationLoadInfoWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationLoadInfo(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the application is
   * occupying currently, and application load metric information about the
   * application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationLoadInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationLoadInfo(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationLoadInfo(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationLoadInfo(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match the specified filters.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match the
   * specified filters. The response includes the name, type, status, parameters,
   * and other details about the application. If the applications do not fit in a
   * page, one page of results is returned as well as a continuation token, which
   * can be used to get the next page. Filters ApplicationTypeName and
   * ApplicationDefinitionKindFilter cannot be specified at the same time.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationInfoListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationInfoList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match the specified filters.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match the
   * specified filters. The response includes the name, type, status, parameters,
   * and other details about the application. If the applications do not fit in a
   * page, one page of results is returned as well as a continuation token, which
   * can be used to get the next page. Filters ApplicationTypeName and
   * ApplicationDefinitionKindFilter cannot be specified at the same time.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedApplicationInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfoList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationInfoList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationInfoList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters, and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationInfoWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationInfo(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters, and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfo(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationInfo(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationInfo(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the health store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationHealthWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationHealth(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the health store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealth(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationHealth(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationHealth(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationHealthUsingPolicyWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationHealthUsingPolicy(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealthUsingPolicy(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationHealthUsingPolicy(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationHealthUsingPolicy(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportApplicationHealthWithHttpOperationResponse(applicationId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportApplicationHealth(applicationId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportApplicationHealth(applicationId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportApplicationHealth(applicationId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportApplicationHealth(applicationId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name The name of the target
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   * The target application type version (found in the application manifest) for
   * the application upgrade.
   *
   * @param {array} applicationUpgradeDescription.parameters List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {string} applicationUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   * Defines a health policy used to evaluate the health of an application or one
   * of its children entities.
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startApplicationUpgradeWithHttpOperationResponse(applicationId, applicationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name The name of the target
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   * The target application type version (found in the application manifest) for
   * the application upgrade.
   *
   * @param {array} applicationUpgradeDescription.parameters List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {string} applicationUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   * Defines a health policy used to evaluate the health of an application or one
   * of its children entities.
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startApplicationUpgrade(applicationId, applicationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationUpgradeWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationUpgrade(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationUpgradeProgressInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationUpgrade(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationUpgrade(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationUpgrade(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart] If
   * true, then processes are forcefully restarted during upgrade even when the
   * code version has not changed (the upgrade only changes configuration or
   * data).
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationUpgradeWithHttpOperationResponse(applicationId, applicationUpgradeUpdateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart] If
   * true, then processes are forcefully restarted during upgrade even when the
   * code version has not changed (the upgrade only changes configuration or
   * data).
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationUpgrade(applicationId, applicationUpgradeUpdateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeApplicationUpgradeWithHttpOperationResponse(applicationId, resumeApplicationUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeApplicationUpgrade(applicationId, resumeApplicationUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to roll back the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version,
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  rollbackApplicationUpgradeWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._rollbackApplicationUpgrade(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to roll back the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version,
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackApplicationUpgrade(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._rollbackApplicationUpgrade(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._rollbackApplicationUpgrade(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node. The results
   * do not include information about deployed system applications unless
   * explicitly queried for by ID. Results encompass deployed applications in
   * active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedDeployedApplicationInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationInfoListWithHttpOperationResponse(nodeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationInfoList(nodeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node. The results
   * do not include information about deployed system applications unless
   * explicitly queried for by ID. Results encompass deployed applications in
   * active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedDeployedApplicationInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedDeployedApplicationInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfoList(nodeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationInfoList(nodeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationInfoList(nodeName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * This query returns system application information if the application ID
   * provided is for system application. Results encompass deployed applications
   * in active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationInfoWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationInfo(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * This query returns system application information if the application ID
   * provided is for system application. Results encompass deployed applications
   * in active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfo(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationInfo(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationInfo(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationHealthWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationHealth(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealth(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationHealth(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationHealth(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedApplicationHealthUsingPolicyWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportDeployedApplicationHealthWithHttpOperationResponse(nodeName, applicationId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportDeployedApplicationHealth(nodeName, applicationId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the manifest describing an application type.
   *
   * The response contains the application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationTypeManifest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationManifestWithHttpOperationResponse(applicationTypeName, applicationTypeVersion, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the manifest describing an application type.
   *
   * The response contains the application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationTypeManifest} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationManifest(applicationTypeName, applicationTypeVersion, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationManifest(applicationTypeName, applicationTypeVersion, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application ID.
   *
   * Returns the information about all services belonging to the application
   * specified by the application ID.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServiceInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceInfoListWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceInfoList(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application ID.
   *
   * Returns the information about all services belonging to the application
   * specified by the application ID.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedServiceInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServiceInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfoList(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceInfoList(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceInfoList(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about the specific service belonging to the
   * Service Fabric application.
   *
   * Returns the information about the specified service belonging to the
   * specified Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceInfoWithHttpOperationResponse(applicationId, serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceInfo(applicationId, serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about the specific service belonging to the
   * Service Fabric application.
   *
   * Returns the information about the specified service belonging to the
   * specified Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfo(applicationId, serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceInfo(applicationId, serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceInfo(applicationId, serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * Gets the name of the application for the specified service. A 404
   * FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the
   * provided service ID does not exist.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationNameInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationNameInfoWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationNameInfo(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * Gets the name of the application for the specified service. A 404
   * FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the
   * provided service ID does not exist.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ApplicationNameInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationNameInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationNameInfo(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationNameInfo(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationNameInfo(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Creates the specified Service Fabric service.
   *
   * This api allows creating a new Service Fabric stateless or stateful service
   * under a specified Service Fabric application. The description for creating
   * the service includes partitioning information and optional properties for
   * placement and load balancing. Some of the properties can later be modified
   * using `UpdateService` API.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName] The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceName The full name of the service
   * with 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceTypeName Name of the service type
   * as specified in the service manifest.
   *
   * @param {array} [serviceDescription.initializationData] The initialization
   * data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   *
   * @param {object} serviceDescription.partitionDescription The partition
   * description as an object.
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceDescription.serviceLoadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceDescription.servicePlacementPolicies] The service
   * placement policies.
   *
   * @param {string} [serviceDescription.defaultMoveCost] The move cost for the
   * service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible values
   * include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {array} [serviceDescription.scalingPolicies] Scaling policies for
   * this service.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createServiceWithHttpOperationResponse(applicationId, serviceDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createService(applicationId, serviceDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates the specified Service Fabric service.
   *
   * This api allows creating a new Service Fabric stateless or stateful service
   * under a specified Service Fabric application. The description for creating
   * the service includes partitioning information and optional properties for
   * placement and load balancing. Some of the properties can later be modified
   * using `UpdateService` API.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName] The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceName The full name of the service
   * with 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceTypeName Name of the service type
   * as specified in the service manifest.
   *
   * @param {array} [serviceDescription.initializationData] The initialization
   * data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   *
   * @param {object} serviceDescription.partitionDescription The partition
   * description as an object.
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceDescription.serviceLoadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceDescription.servicePlacementPolicies] The service
   * placement policies.
   *
   * @param {string} [serviceDescription.defaultMoveCost] The move cost for the
   * service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible values
   * include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {array} [serviceDescription.scalingPolicies] Scaling policies for
   * this service.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createService(applicationId, serviceDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createService(applicationId, serviceDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createService(applicationId, serviceDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric service from the service template.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest. A service template contains the properties that will
   * be same for the service instance of the same type. The API allows overriding
   * the properties that are usually different for different services of the same
   * service type.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName The name of
   * the application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceName The full name of
   * the service with 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName Name of the
   * service type as specified in the service manifest.
   *
   * @param {array} [serviceFromTemplateDescription.initializationData] The
   * initialization data for the newly created service instance.
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] The activation
   * mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createServiceFromTemplateWithHttpOperationResponse(applicationId, serviceFromTemplateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric service from the service template.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest. A service template contains the properties that will
   * be same for the service instance of the same type. The API allows overriding
   * the properties that are usually different for different services of the same
   * service type.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName The name of
   * the application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceName The full name of
   * the service with 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName Name of the
   * service type as specified in the service manifest.
   *
   * @param {array} [serviceFromTemplateDescription.initializationData] The
   * initialization data for the newly created service instance.
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] The activation
   * mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createServiceFromTemplate(applicationId, serviceFromTemplateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * A service must be created before it can be deleted. By default, Service
   * Fabric will try to close service replicas in a graceful manner and then
   * delete the service. However, if the service is having issues closing the
   * replica gracefully, the delete operation may take a long time or get stuck.
   * Use the optional ForceRemove flag to skip the graceful close sequence and
   * forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteServiceWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteService(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * A service must be created before it can be deleted. By default, Service
   * Fabric will try to close service replicas in a graceful manner and then
   * delete the service. However, if the service is having issues closing the
   * replica gracefully, the delete operation may take a long time or get stuck.
   * Use the optional ForceRemove flag to skip the graceful close sequence and
   * forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteService(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteService(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteService(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a Service Fabric service using the specified update
   * description.
   *
   * This API allows updating properties of a running Service Fabric service. The
   * set of properties that can be updated are a subset of the properties that
   * were specified at the time of creating the service. The current set of
   * properties can be obtained using `GetServiceDescription` API. Note that
   * updating the properties of a running service is different than upgrading
   * your application using `StartApplicationUpgrade` API. The upgrade is a long
   * running background operation that involves moving the application from one
   * version to another, one upgrade domain at a time, whereas update applies the
   * new properties immediately to the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceUpdateDescription.loadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies] The
   * service placement policies.
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] The move cost for
   * the service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {array} [serviceUpdateDescription.scalingPolicies] Scaling policies
   * for this service.
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateServiceWithHttpOperationResponse(serviceId, serviceUpdateDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateService(serviceId, serviceUpdateDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a Service Fabric service using the specified update
   * description.
   *
   * This API allows updating properties of a running Service Fabric service. The
   * set of properties that can be updated are a subset of the properties that
   * were specified at the time of creating the service. The current set of
   * properties can be obtained using `GetServiceDescription` API. Note that
   * updating the properties of a running service is different than upgrading
   * your application using `StartApplicationUpgrade` API. The upgrade is a long
   * running background operation that involves moving the application from one
   * version to another, one upgrade domain at a time, whereas update applies the
   * new properties immediately to the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceUpdateDescription.loadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies] The
   * service placement policies.
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] The move cost for
   * the service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {array} [serviceUpdateDescription.scalingPolicies] Scaling policies
   * for this service.
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateService(serviceId, serviceUpdateDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateService(serviceId, serviceUpdateDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateService(serviceId, serviceUpdateDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceDescription>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceDescriptionWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceDescription(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceDescription} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceDescription} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceDescription(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceDescription(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceDescription(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceHealthWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceHealth(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealth(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceHealth(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceHealth(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceHealthUsingPolicyWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceHealthUsingPolicy(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealthUsingPolicy(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceHealthUsingPolicy(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceHealthUsingPolicy(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportServiceHealthWithHttpOperationResponse(serviceId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportServiceHealth(serviceId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportServiceHealth(serviceId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportServiceHealth(serviceId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportServiceHealth(serviceId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
   * the partition. This is valid for the partitions with partitioning scheme as
   * Named. The value is 3.
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   * This is not the partition ID, but rather, either the integer key value, or
   * the name of the partition ID.
   * For example, if your service is using ranged partitions from 0 to 10, then
   * they PartitionKeyValue would be an
   * integer in that range. Query service description to see the range or name.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was gotten previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResolvedServicePartition>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resolveServiceWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resolveService(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
   * the partition. This is valid for the partitions with partitioning scheme as
   * Named. The value is 3.
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   * This is not the partition ID, but rather, either the integer key value, or
   * the name of the partition ID.
   * For example, if your service is using ranged partitions from 0 to 10, then
   * they PartitionKeyValue would be an
   * integer in that range. Query service description to see the range or name.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was gotten previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResolvedServicePartition} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResolvedServicePartition} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resolveService(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resolveService(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resolveService(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * The response includes the partition ID, partitioning scheme information,
   * keys supported by the partition, status, health, and other details about the
   * partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServicePartitionInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionInfoListWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionInfoList(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * The response includes the partition ID, partitioning scheme information,
   * keys supported by the partition, status, health, and other details about the
   * partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedServicePartitionInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServicePartitionInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfoList(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionInfoList(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionInfoList(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * Gets the information about the specified partition. The response includes
   * the partition ID, partitioning scheme information, keys supported by the
   * partition, status, health, and other details about the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServicePartitionInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionInfoWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionInfo(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * Gets the information about the specified partition. The response includes
   * the partition ID, partitioning scheme information, keys supported by the
   * partition, status, health, and other details about the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServicePartitionInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServicePartitionInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfo(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionInfo(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionInfo(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * Gets name of the service for the specified partition. A 404 error is
   * returned if the partition ID does not exist in the cluster.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceNameInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceNameInfoWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceNameInfo(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * Gets name of the service for the specified partition. A 404 error is
   * returned if the partition ID does not exist in the cluster.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ServiceNameInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceNameInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceNameInfo(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceNameInfo(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceNameInfo(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionHealthWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionHealth(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealth(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionHealth(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionHealth(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionHealthUsingPolicyWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionHealthUsingPolicy(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealthUsingPolicy(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionHealthUsingPolicy(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionHealthUsingPolicy(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportPartitionHealthWithHttpOperationResponse(partitionId, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportPartitionHealth(partitionId, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportPartitionHealth(partitionId, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportPartitionHealth(partitionId, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportPartitionHealth(partitionId, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the load information of the specified Service Fabric
   * partition.
   *
   * Returns information about the load of a specified partition.
   * The response includes a list of load reports for a Service Fabric partition.
   * Each report includes the load metric name, value, and last reported time in
   * UTC.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionLoadInformation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionLoadInformationWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionLoadInformation(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the load information of the specified Service Fabric
   * partition.
   *
   * Returns information about the load of a specified partition.
   * The response includes a list of load reports for a Service Fabric partition.
   * Each report includes the load metric name, value, and last reported time in
   * UTC.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionLoadInformation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionLoadInformation} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionLoadInformation(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionLoadInformation(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionLoadInformation(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetPartitionLoadWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetPartitionLoad(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetPartitionLoad(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetPartitionLoad(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetPartitionLoad(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition that is currently stuck in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverPartitionWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverPartition(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition that is currently stuck in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverPartition(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverPartition(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverPartition(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service that is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service that is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverServicePartitionsWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverServicePartitions(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service that is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service that is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverServicePartitions(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverServicePartitions(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverServicePartitions(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services that are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services that are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSystemPartitionsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSystemPartitions(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services that are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services that are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSystemPartitions(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSystemPartitions(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSystemPartitions(options, optionalCallback);
    }
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverAllPartitionsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverAllPartitions(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverAllPartitions(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverAllPartitions(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverAllPartitions(options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createRepairTaskWithHttpOperationResponse(repairTask, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createRepairTask(repairTask, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createRepairTask(repairTask, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createRepairTask(repairTask, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createRepairTask(repairTask, options, optionalCallback);
    }
  }

  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  cancelRepairTaskWithHttpOperationResponse(repairTaskCancelDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._cancelRepairTask(repairTaskCancelDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelRepairTask(repairTaskCancelDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._cancelRepairTask(repairTaskCancelDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._cancelRepairTask(repairTaskCancelDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRepairTaskWithHttpOperationResponse(repairTaskDeleteDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRepairTask(repairTaskDeleteDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRepairTask(repairTaskDeleteDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRepairTask(repairTaskDeleteDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRepairTask(repairTaskDeleteDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRepairTaskListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRepairTaskList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRepairTaskList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRepairTaskList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRepairTaskList(options, optionalCallback);
    }
  }

  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  forceApproveRepairTaskWithHttpOperationResponse(repairTaskApproveDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._forceApproveRepairTask(repairTaskApproveDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  forceApproveRepairTask(repairTaskApproveDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._forceApproveRepairTask(repairTaskApproveDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._forceApproveRepairTask(repairTaskApproveDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRepairTaskHealthPolicyWithHttpOperationResponse(repairTaskUpdateHealthPolicyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRepairExecutionStateWithHttpOperationResponse(repairTask, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRepairExecutionState(repairTask, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairExecutionState(repairTask, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRepairExecutionState(repairTask, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRepairExecutionState(repairTask, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The response includes the ID, role, status, health,
   * node name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedReplicaInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaInfoListWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaInfoList(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The response includes the ID, role, status, health,
   * node name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedReplicaInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedReplicaInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfoList(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaInfoList(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaInfoList(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The response includes the ID, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaInfoWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaInfo(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The response includes the ID, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfo(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaInfo(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaInfo(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaHealthWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaHealth(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealth(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaHealth(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaHealth(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReplicaHealthUsingPolicyWithHttpOperationResponse(partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealthUsingPolicy(partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReplicaHealthUsingPolicy(partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} replicaHealthReportServiceKind The kind of service replica
   * (Stateless or Stateful) for which the health is being reported. Following
   * are the possible values. Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportReplicaHealthWithHttpOperationResponse(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportReplicaHealth(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} replicaHealthReportServiceKind The kind of service replica
   * (Stateless or Stateful) for which the health is being reported. Following
   * are the possible values. Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportReplicaHealth(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportReplicaHealth(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportReplicaHealth(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition ID, replica ID,
   * status of the replica, name of the service, name of the service type, and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition ID, replica ID,
   * status of the replica, name of the service, name of the service type, and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaDetailInfoWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServiceReplicaDetailInfoByPartitionIdWithHttpOperationResponse(nodeName, partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartReplicaWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartReplica(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartReplica(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services. In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeReplicaWithHttpOperationResponse(nodeName, partitionId, replicaId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services. In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeReplica(nodeName, partitionId, replicaId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeReplica(nodeName, partitionId, replicaId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeReplica(nodeName, partitionId, replicaId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageInfoListByNameWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of a service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageHealthWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of a service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedServicePackageHealthUsingPolicyWithHttpOperationResponse(nodeName, applicationId, servicePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reportDeployedServicePackageHealthWithHttpOperationResponse(nodeName, applicationId, servicePackageName, healthInformation, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, healthInformation, options, optionalCallback);
    }
  }

  /**
   * @summary Downloads all of the code packages associated with specified
   * service manifest on the specified node.
   *
   * This API provides a way to download code packages including the container
   * images on a specific node outside of the normal application deployment and
   * upgrade path. This is useful for the large code packages and container
   * images to be present on the node before the actual application deployment
   * and upgrade, thus significantly reducing the total time required for the
   * deployment or upgrade.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   * The name of service manifest whose packages need to be downloaded.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   * The application type name as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   * The version of the application type as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName The name of a
   * Service Fabric node.
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   * List of package sharing policy information.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deployServicePackageToNodeWithHttpOperationResponse(nodeName, deployServicePackageToNodeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deployServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Downloads all of the code packages associated with specified
   * service manifest on the specified node.
   *
   * This API provides a way to download code packages including the container
   * images on a specific node outside of the normal application deployment and
   * upgrade path. This is useful for the large code packages and container
   * images to be present on the node before the actual application deployment
   * and upgrade, thus significantly reducing the total time required for the
   * deployment or upgrade.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   * The name of service manifest whose packages need to be downloaded.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   * The application type name as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   * The version of the application type as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName The name of a
   * Service Fabric node.
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   * List of package sharing policy information.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deployServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deployServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deployServicePackageToNode(nodeName, deployServicePackageToNodeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeployedCodePackageInfoListWithHttpOperationResponse(nodeName, applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployedCodePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedCodePackageInfoList(nodeName, applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployedCodePackageInfoList(nodeName, applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployedCodePackageInfoList(nodeName, applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   * The name of service manifest that specified this code package.
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId] The
   * ActivationId of a deployed service package. If ServicePackageActivationMode
   * specified at the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to
   * 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName The
   * name of the code package defined in the service manifest.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   * The instance ID for currently running entry point. For a code package setup
   * entry point (if specified) runs first and after it finishes main entry point
   * is started.
   * Each time entry point executable is run, its instance ID will change. If 0
   * is passed in as the code package instance ID, the API will restart the code
   * package with whatever instance ID it is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code
   * package only if the current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer, because
   * if ensures at most one restart of the code package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartDeployedCodePackageWithHttpOperationResponse(nodeName, applicationId, restartDeployedCodePackageDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   * The name of service manifest that specified this code package.
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId] The
   * ActivationId of a deployed service package. If ServicePackageActivationMode
   * specified at the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to
   * 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName The
   * name of the code package defined in the service manifest.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   * The instance ID for currently running entry point. For a code package setup
   * entry point (if specified) runs first and after it finishes main entry point
   * is started.
   * Each time entry point executable is run, its instance ID will change. If 0
   * is passed in as the code package instance ID, the API will restart the code
   * package with whatever instance ID it is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code
   * package only if the current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer, because
   * if ensures at most one restart of the code package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartDeployedCodePackage(nodeName, applicationId, restartDeployedCodePackageDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the container logs for container deployed on a Service Fabric
   * node.
   *
   * Gets the container logs for container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.tail] Number of lines to show from the end of the
   * logs. Default is 100. 'all' to show the complete logs.
   *
   * @param {boolean} [options.previous] Specifies whether to get container logs
   * from exited/dead containers of the code package instance.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ContainerLogs>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getContainerLogsDeployedOnNodeWithHttpOperationResponse(nodeName, applicationId, serviceManifestName, codePackageName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getContainerLogsDeployedOnNode(nodeName, applicationId, serviceManifestName, codePackageName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the container logs for container deployed on a Service Fabric
   * node.
   *
   * Gets the container logs for container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.tail] Number of lines to show from the end of the
   * logs. Default is 100. 'all' to show the complete logs.
   *
   * @param {boolean} [options.previous] Specifies whether to get container logs
   * from exited/dead containers of the code package instance.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ContainerLogs} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ContainerLogs} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getContainerLogsDeployedOnNode(nodeName, applicationId, serviceManifestName, codePackageName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getContainerLogsDeployedOnNode(nodeName, applicationId, serviceManifestName, codePackageName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getContainerLogsDeployedOnNode(nodeName, applicationId, serviceManifestName, codePackageName, options, optionalCallback);
    }
  }

  /**
   * @summary Invoke container API on a container deployed on a Service Fabric
   * node.
   *
   * Invoke container API on a container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {string} codePackageInstanceId ID that uniquely identifies a code
   * package instance deployed on a service fabric node.
   *
   * @param {object} containerApiRequestBody Parameters for making container API
   * call
   *
   * @param {string} [containerApiRequestBody.httpVerb] HTTP verb of container
   * REST API, defaults to "GET"
   *
   * @param {string} containerApiRequestBody.uriPath URI path of container REST
   * API
   *
   * @param {string} [containerApiRequestBody.contentType] Content type of
   * container REST API request, defaults to "application/json"
   *
   * @param {string} [containerApiRequestBody.body] HTTP request body of
   * container REST API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ContainerApiResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  invokeContainerApiWithHttpOperationResponse(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._invokeContainerApi(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Invoke container API on a container deployed on a Service Fabric
   * node.
   *
   * Invoke container API on a container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {string} codePackageInstanceId ID that uniquely identifies a code
   * package instance deployed on a service fabric node.
   *
   * @param {object} containerApiRequestBody Parameters for making container API
   * call
   *
   * @param {string} [containerApiRequestBody.httpVerb] HTTP verb of container
   * REST API, defaults to "GET"
   *
   * @param {string} containerApiRequestBody.uriPath URI path of container REST
   * API
   *
   * @param {string} [containerApiRequestBody.contentType] Content type of
   * container REST API request, defaults to "application/json"
   *
   * @param {string} [containerApiRequestBody.body] HTTP request body of
   * container REST API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ContainerApiResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ContainerApiResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeContainerApi(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._invokeContainerApi(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._invokeContainerApi(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Compose is a file format that describes multi-container applications. This
   * API allows deploying container based applications defined in compose format
   * in a Service Fabric cluster. Once the deployment is created, its status can
   * be tracked via the `GetComposeDeploymentStatus` API.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createComposeDeploymentWithHttpOperationResponse(createComposeDeploymentDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createComposeDeployment(createComposeDeploymentDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Compose is a file format that describes multi-container applications. This
   * API allows deploying container based applications defined in compose format
   * in a Service Fabric cluster. Once the deployment is created, its status can
   * be tracked via the `GetComposeDeploymentStatus` API.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createComposeDeployment(createComposeDeploymentDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createComposeDeployment(createComposeDeploymentDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createComposeDeployment(createComposeDeploymentDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status, and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentStatusInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentStatusWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentStatus(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status, and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ComposeDeploymentStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentStatusInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatus(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentStatus(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentStatus(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status, and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token, which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedComposeDeploymentStatusInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentStatusListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentStatusList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status, and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token, which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedComposeDeploymentStatusInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedComposeDeploymentStatusInfoList} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatusList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentStatusList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentStatusList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getComposeDeploymentUpgradeProgressWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getComposeDeploymentUpgradeProgress(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ComposeDeploymentUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentUpgradeProgressInfo} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentUpgradeProgress(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getComposeDeploymentUpgradeProgress(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getComposeDeploymentUpgradeProgress(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  removeComposeDeploymentWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._removeComposeDeployment(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  removeComposeDeployment(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._removeComposeDeployment(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._removeComposeDeployment(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode] The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startComposeDeploymentUpgradeWithHttpOperationResponse(deploymentName, composeDeploymentUpgradeDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode] The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum allowed percentage of unhealthy services. Allowed values are
   * Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startComposeDeploymentUpgrade(deploymentName, composeDeploymentUpgradeDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Starts rolling back a compose deployment upgrade in the Service
   * Fabric cluster.
   *
   * Rollback a service fabric compose deployment upgrade.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startRollbackComposeDeploymentUpgradeWithHttpOperationResponse(deploymentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startRollbackComposeDeploymentUpgrade(deploymentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts rolling back a compose deployment upgrade in the Service
   * Fabric cluster.
   *
   * Rollback a service fabric compose deployment upgrade.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startRollbackComposeDeploymentUpgrade(deploymentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startRollbackComposeDeploymentUpgrade(deploymentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startRollbackComposeDeploymentUpgrade(deploymentName, options, optionalCallback);
    }
  }

  /**
   * @summary Get the status of Chaos.
   *
   * Get the status of Chaos indicating whether or not Chaos is running, the
   * Chaos parameters used for running Chaos and the status of the Chaos
   * Schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Chaos>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getChaosWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getChaos(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the status of Chaos.
   *
   * Get the status of Chaos indicating whether or not Chaos is running, the
   * Chaos parameters used for running Chaos and the status of the Chaos
   * Schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Chaos} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Chaos} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaos(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getChaos(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getChaos(options, optionalCallback);
    }
  }

  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   * @param {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
   * health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected exception
   * happens during fault execution--to provide the cluster with some time to
   * recuperate--Chaos will wait for 30 minutes before the next health-check.
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
   * a map with max percentage unhealthy applications for specific application
   * types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object} [chaosParameters.context] Describes a map, which is a
   * collection of (string, string) type key-value pairs. The map can be used to
   * record information about
   * the Chaos run. There cannot be more than 100 such pairs and each string (key
   * or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   *
   * @param {object} [chaosParameters.context.map] Describes a map that contains
   * a collection of ChaosContextMapItem's.
   *
   * @param {object} [chaosParameters.chaosTargetFilter] List of cluster entities
   * to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types or
   * only to certain application instances. If ChaosTargetFilter is not used,
   * Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList] A
   * list of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the nodes
   * of these node types.
   * If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList,
   * then node level faults (like NodeRestart) will never be enabled for the
   * nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.applicationInclusionList]
   * A list of application URIs to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas of
   * these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement constraints
   * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
   * absent from NodeTypeInclusionList, then applicationX will never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startChaosWithHttpOperationResponse(chaosParameters, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startChaos(chaosParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   * @param {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
   * health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected exception
   * happens during fault execution--to provide the cluster with some time to
   * recuperate--Chaos will wait for 30 minutes before the next health-check.
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
   * a map with max percentage unhealthy applications for specific application
   * types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object} [chaosParameters.context] Describes a map, which is a
   * collection of (string, string) type key-value pairs. The map can be used to
   * record information about
   * the Chaos run. There cannot be more than 100 such pairs and each string (key
   * or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   *
   * @param {object} [chaosParameters.context.map] Describes a map that contains
   * a collection of ChaosContextMapItem's.
   *
   * @param {object} [chaosParameters.chaosTargetFilter] List of cluster entities
   * to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types or
   * only to certain application instances. If ChaosTargetFilter is not used,
   * Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList] A
   * list of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the nodes
   * of these node types.
   * If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList,
   * then node level faults (like NodeRestart) will never be enabled for the
   * nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.applicationInclusionList]
   * A list of application URIs to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas of
   * these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement constraints
   * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
   * absent from NodeTypeInclusionList, then applicationX will never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startChaos(chaosParameters, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startChaos(chaosParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startChaos(chaosParameters, options, optionalCallback);
    }
  }

  /**
   * @summary Stops Chaos if it is running in the cluster and put the Chaos
   * Schedule in a stopped state.
   *
   * Stops Chaos from executing new faults. In-flight faults will continue to
   * execute until they are complete. The current Chaos Schedule is put into a
   * stopped state.
   * Once a schedule is stopped, it will stay in the stopped state and not be
   * used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set
   * in order to resume scheduling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopChaosWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopChaos(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops Chaos if it is running in the cluster and put the Chaos
   * Schedule in a stopped state.
   *
   * Stops Chaos from executing new faults. In-flight faults will continue to
   * execute until they are complete. The current Chaos Schedule is put into a
   * stopped state.
   * Once a schedule is stopped, it will stay in the stopped state and not be
   * used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set
   * in order to resume scheduling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopChaos(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopChaos(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopChaos(options, optionalCallback);
    }
  }

  /**
   * @summary Gets the next segment of the Chaos events based on the continuation
   * token or the time range.
   *
   * To get the next segment of the Chaos events, you can specify the
   * ContinuationToken. To get the start of a new segment of Chaos events, you
   * can specify the time range
   * through StartTimeUtc and EndTimeUtc. You cannot specify both the
   * ContinuationToken and the time range in the same call.
   * When there are more than 100 Chaos events, the Chaos events are returned in
   * multiple segments where a segment contains no more than 100 Chaos events and
   * to get the next segment you make a call to this API with the continuation
   * token.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The Windows file time representing
   * the start time of the time range for which a Chaos report is to be
   * generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {string} [options.endTimeUtc] The Windows file time representing the
   * end time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ChaosEventsSegment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getChaosEventsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getChaosEvents(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the next segment of the Chaos events based on the continuation
   * token or the time range.
   *
   * To get the next segment of the Chaos events, you can specify the
   * ContinuationToken. To get the start of a new segment of Chaos events, you
   * can specify the time range
   * through StartTimeUtc and EndTimeUtc. You cannot specify both the
   * ContinuationToken and the time range in the same call.
   * When there are more than 100 Chaos events, the Chaos events are returned in
   * multiple segments where a segment contains no more than 100 Chaos events and
   * to get the next segment you make a call to this API with the continuation
   * token.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The Windows file time representing
   * the start time of the time range for which a Chaos report is to be
   * generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {string} [options.endTimeUtc] The Windows file time representing the
   * end time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ChaosEventsSegment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ChaosEventsSegment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaosEvents(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getChaosEvents(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getChaosEvents(options, optionalCallback);
    }
  }

  /**
   * @summary Get the Chaos Schedule defining when and how to run Chaos.
   *
   * Gets the version of the Chaos Schedule in use and the Chaos Schedule that
   * defines when and how to run Chaos.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ChaosScheduleDescription>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getChaosScheduleWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getChaosSchedule(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the Chaos Schedule defining when and how to run Chaos.
   *
   * Gets the version of the Chaos Schedule in use and the Chaos Schedule that
   * defines when and how to run Chaos.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ChaosScheduleDescription} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ChaosScheduleDescription} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaosSchedule(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getChaosSchedule(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getChaosSchedule(options, optionalCallback);
    }
  }

  /**
   * @summary Set the schedule used by Chaos.
   *
   * Chaos will automatically schedule runs based on the Chaos Schedule.
   * The Chaos Schedule will be updated if the provided version matches the
   * version on the server.
   * When updating the Chaos Schedule, the version on the server is incremented
   * by 1.
   * The version on the server will wrap back to 0 after reaching a large number.
   * If Chaos is running when this call is made, the call will fail.
   *
   * @param {object} chaosSchedule Describes the schedule used by Chaos.
   *
   * @param {number} [chaosSchedule.version] The version number of the Schedule.
   *
   * @param {object} [chaosSchedule.schedule] Defines the schedule used by Chaos.
   *
   * @param {date} [chaosSchedule.schedule.startDate] The date and time Chaos
   * will start using this schedule.
   *
   * @param {date} [chaosSchedule.schedule.expiryDate] The date and time Chaos
   * will continue to use this schedule until.
   *
   * @param {array} [chaosSchedule.schedule.chaosParametersDictionary] A mapping
   * of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
   *
   * @param {array} [chaosSchedule.schedule.jobs] A list of all Chaos Schedule
   * Jobs that will be automated by the schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  postChaosScheduleWithHttpOperationResponse(chaosSchedule, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._postChaosSchedule(chaosSchedule, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Set the schedule used by Chaos.
   *
   * Chaos will automatically schedule runs based on the Chaos Schedule.
   * The Chaos Schedule will be updated if the provided version matches the
   * version on the server.
   * When updating the Chaos Schedule, the version on the server is incremented
   * by 1.
   * The version on the server will wrap back to 0 after reaching a large number.
   * If Chaos is running when this call is made, the call will fail.
   *
   * @param {object} chaosSchedule Describes the schedule used by Chaos.
   *
   * @param {number} [chaosSchedule.version] The version number of the Schedule.
   *
   * @param {object} [chaosSchedule.schedule] Defines the schedule used by Chaos.
   *
   * @param {date} [chaosSchedule.schedule.startDate] The date and time Chaos
   * will start using this schedule.
   *
   * @param {date} [chaosSchedule.schedule.expiryDate] The date and time Chaos
   * will continue to use this schedule until.
   *
   * @param {array} [chaosSchedule.schedule.chaosParametersDictionary] A mapping
   * of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
   *
   * @param {array} [chaosSchedule.schedule.jobs] A list of all Chaos Schedule
   * Jobs that will be automated by the schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  postChaosSchedule(chaosSchedule, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._postChaosSchedule(chaosSchedule, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._postChaosSchedule(chaosSchedule, options, optionalCallback);
    }
  }

  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  uploadFileWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._uploadFile(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  uploadFile(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._uploadFile(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._uploadFile(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath. The contentPath is relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreContentWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreContent(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath. The contentPath is relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreContent(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreContent(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreContent(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This command can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteImageStoreContentWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteImageStoreContent(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This command can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteImageStoreContent(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteImageStoreContent(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteImageStoreContent(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreRootContentWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreRootContent(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreRootContent(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreRootContent(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreRootContent(options, optionalCallback);
    }
  }

  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  copyImageStoreContentWithHttpOperationResponse(imageStoreCopyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._copyImageStoreContent(imageStoreCopyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  copyImageStoreContent(imageStoreCopyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._copyImageStoreContent(imageStoreCopyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._copyImageStoreContent(imageStoreCopyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Cancels an image store upload session.
   *
   * The DELETE request will cause the existing upload session to expire and
   * remove any previously uploaded file chunks.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteImageStoreUploadSessionWithHttpOperationResponse(sessionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteImageStoreUploadSession(sessionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Cancels an image store upload session.
   *
   * The DELETE request will cause the existing upload session to expire and
   * remove any previously uploaded file chunks.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteImageStoreUploadSession(sessionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteImageStoreUploadSession(sessionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteImageStoreUploadSession(sessionId, options, optionalCallback);
    }
  }

  /**
   * @summary Commit an image store upload session.
   *
   * When all file chunks have been uploaded, the upload session needs to be
   * committed explicitly to complete the upload. Image store preserves the
   * upload session until the expiration time, which is 30 minutes after the last
   * chunk received.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  commitImageStoreUploadSessionWithHttpOperationResponse(sessionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._commitImageStoreUploadSession(sessionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Commit an image store upload session.
   *
   * When all file chunks have been uploaded, the upload session needs to be
   * committed explicitly to complete the upload. Image store preserves the
   * upload session until the expiration time, which is 30 minutes after the last
   * chunk received.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  commitImageStoreUploadSession(sessionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._commitImageStoreUploadSession(sessionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._commitImageStoreUploadSession(sessionId, options, optionalCallback);
    }
  }

  /**
   * @summary Get the image store upload session by ID.
   *
   * Gets the image store upload session identified by the given ID. User can
   * query the upload session at any time during uploading.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UploadSession>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreUploadSessionByIdWithHttpOperationResponse(sessionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreUploadSessionById(sessionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the image store upload session by ID.
   *
   * Gets the image store upload session identified by the given ID. User can
   * query the upload session at any time during uploading.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UploadSession} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UploadSession} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreUploadSessionById(sessionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreUploadSessionById(sessionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreUploadSessionById(sessionId, options, optionalCallback);
    }
  }

  /**
   * @summary Get the image store upload session by relative path.
   *
   * Gets the image store upload session associated with the given image store
   * relative path. User can query the upload session at any time during
   * uploading.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UploadSession>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getImageStoreUploadSessionByPathWithHttpOperationResponse(contentPath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getImageStoreUploadSessionByPath(contentPath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the image store upload session by relative path.
   *
   * Gets the image store upload session associated with the given image store
   * relative path. User can query the upload session at any time during
   * uploading.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UploadSession} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UploadSession} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreUploadSessionByPath(contentPath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getImageStoreUploadSessionByPath(contentPath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getImageStoreUploadSessionByPath(contentPath, options, optionalCallback);
    }
  }

  /**
   * @summary Uploads a file chunk to the image store relative path.
   *
   * Uploads a file chunk to the image store with the specified upload session ID
   * and image store relative path. This API allows user to resume the file
   * upload operation. user doesn't have to restart the file upload from scratch
   * whenever there is a network interruption. Use this option if the file size
   * is large.
   *
   * To perform a resumable file upload, user need to break the file into
   * multiple chunks and upload these chunks to the image store one-by-one.
   * Chunks don't have to be uploaded in order. If the file represented by the
   * image store relative path already exists, it will be overwritten when the
   * upload session commits.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {string} contentRange When uploading file chunks to the image store,
   * the Content-Range header field need to be configured and sent with a
   * request. The format should looks like "bytes
   * {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example,
   * Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300
   * through 5,000 and the total file length is 20,000 bytes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  uploadFileChunkWithHttpOperationResponse(contentPath, sessionId, contentRange, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._uploadFileChunk(contentPath, sessionId, contentRange, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Uploads a file chunk to the image store relative path.
   *
   * Uploads a file chunk to the image store with the specified upload session ID
   * and image store relative path. This API allows user to resume the file
   * upload operation. user doesn't have to restart the file upload from scratch
   * whenever there is a network interruption. Use this option if the file size
   * is large.
   *
   * To perform a resumable file upload, user need to break the file into
   * multiple chunks and upload these chunks to the image store one-by-one.
   * Chunks don't have to be uploaded in order. If the file represented by the
   * image store relative path already exists, it will be overwritten when the
   * upload session commits.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {string} contentRange When uploading file chunks to the image store,
   * the Content-Range header field need to be configured and sent with a
   * request. The format should looks like "bytes
   * {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example,
   * Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300
   * through 5,000 and the total file length is 20,000 bytes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  uploadFileChunk(contentPath, sessionId, contentRange, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._uploadFileChunk(contentPath, sessionId, contentRange, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._uploadFileChunk(contentPath, sessionId, contentRange, options, optionalCallback);
    }
  }

  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  invokeInfrastructureCommandWithHttpOperationResponse(command, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._invokeInfrastructureCommand(command, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureCommand(command, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._invokeInfrastructureCommand(command, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._invokeInfrastructureCommand(command, options, optionalCallback);
    }
  }

  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  invokeInfrastructureQueryWithHttpOperationResponse(command, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._invokeInfrastructureQuery(command, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureQuery(command, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._invokeInfrastructureQuery(command, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._invokeInfrastructureQuery(command, options, optionalCallback);
    }
  }

  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode.
   *
   * - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * - FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce. Possible values include:
   * 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startDataLossWithHttpOperationResponse(serviceId, partitionId, operationId, dataLossMode, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode.
   *
   * - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * - FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce. Possible values include:
   * 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startDataLoss(serviceId, partitionId, operationId, dataLossMode, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionDataLossProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDataLossProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDataLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionDataLossProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionDataLossProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataLossProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDataLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDataLossProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * This API is useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce. Possible values include:
   * 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startQuorumLossWithHttpOperationResponse(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * This API is useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce. Possible values include:
   * 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startQuorumLoss(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionQuorumLossProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getQuorumLossProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getQuorumLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionQuorumLossProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionQuorumLossProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getQuorumLossProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getQuorumLossProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getQuorumLossProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode Describe which partitions to restart.
   * Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startPartitionRestartWithHttpOperationResponse(serviceId, partitionId, operationId, restartPartitionMode, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode Describe which partitions to restart.
   * Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startPartitionRestart(serviceId, partitionId, operationId, restartPartitionMode, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionRestartProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionRestartProgressWithHttpOperationResponse(serviceId, partitionId, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionRestartProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionRestartProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionRestartProgress(serviceId, partitionId, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionRestartProgress(serviceId, partitionId, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up. Possible values
   * include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startNodeTransitionWithHttpOperationResponse(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up. Possible values
   * include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startNodeTransition(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeTransitionProgress>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeTransitionProgressWithHttpOperationResponse(nodeName, operationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeTransitionProgress(nodeName, operationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NodeTransitionProgress} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeTransitionProgress} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeTransitionProgress(nodeName, operationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeTransitionProgress(nodeName, operationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeTransitionProgress(nodeName, operationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   *
   * - 65535 - select all
   * - 1 - select PartitionDataLoss.
   * - 2 - select PartitionQuorumLoss.
   * - 4 - select PartitionRestart.
   * - 8 - select NodeTransition.
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   *
   * - 65535 - select All
   * - 1 - select Running
   * - 2 - select RollingBack
   * - 8 - select Completed
   * - 16 - select Faulted
   * - 32 - select Cancelled
   * - 64 - select ForceCancelled
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFaultOperationListWithHttpOperationResponse(typeFilter, stateFilter, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFaultOperationList(typeFilter, stateFilter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   *
   * - 65535 - select all
   * - 1 - select PartitionDataLoss.
   * - 2 - select PartitionQuorumLoss.
   * - 4 - select PartitionRestart.
   * - 8 - select NodeTransition.
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   *
   * - 65535 - select All
   * - 1 - select Running
   * - 2 - select RollingBack
   * - 8 - select Completed
   * - 16 - select Faulted
   * - 32 - select Cancelled
   * - 64 - select ForceCancelled
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFaultOperationList(typeFilter, stateFilter, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFaultOperationList(typeFilter, stateFilter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFaultOperationList(typeFilter, stateFilter, options, optionalCallback);
    }
  }

  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following APIs start fault operations that may be cancelled by using
   * CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart,
   * StartNodeTransition.
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will be/is
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully roll back and clean
   * up internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  cancelOperationWithHttpOperationResponse(operationId, force, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._cancelOperation(operationId, force, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following APIs start fault operations that may be cancelled by using
   * CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart,
   * StartNodeTransition.
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will be/is
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully roll back and clean
   * up internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelOperation(operationId, force, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._cancelOperation(operationId, force, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._cancelOperation(operationId, force, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a backup policy.
   *
   * Creates a backup policy which can be associated later with a Service Fabric
   * application, service or a partition for periodic backup.
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
   * policy to retain backups in storage.
   *
   * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createBackupPolicyWithHttpOperationResponse(backupPolicyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createBackupPolicy(backupPolicyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a backup policy.
   *
   * Creates a backup policy which can be associated later with a Service Fabric
   * application, service or a partition for periodic backup.
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
   * policy to retain backups in storage.
   *
   * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createBackupPolicy(backupPolicyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createBackupPolicy(backupPolicyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createBackupPolicy(backupPolicyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the backup policy.
   *
   * Deletes an existing backup policy. A backup policy must be created before it
   * can be deleted. A currently active backup policy, associated with any
   * Service Fabric application, service or partition, cannot be deleted without
   * first deleting the mapping.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupPolicyWithHttpOperationResponse(backupPolicyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupPolicy(backupPolicyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the backup policy.
   *
   * Deletes an existing backup policy. A backup policy must be created before it
   * can be deleted. A currently active backup policy, associated with any
   * Service Fabric application, service or partition, cannot be deleted without
   * first deleting the mapping.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupPolicy(backupPolicyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupPolicy(backupPolicyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupPolicy(backupPolicyName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all the backup policies configured.
   *
   * Get a list of all the backup policies configured.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupPolicyDescriptionList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupPolicyListWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupPolicyList(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all the backup policies configured.
   *
   * Get a list of all the backup policies configured.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupPolicyDescriptionList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupPolicyDescriptionList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupPolicyList(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupPolicyList(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupPolicyList(options, optionalCallback);
    }
  }

  /**
   * @summary Gets a particular backup policy by name.
   *
   * Gets a particular backup policy identified by {backupPolicyName}
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupPolicyDescription>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupPolicyByNameWithHttpOperationResponse(backupPolicyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupPolicyByName(backupPolicyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a particular backup policy by name.
   *
   * Gets a particular backup policy identified by {backupPolicyName}
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupPolicyDescription} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupPolicyDescription} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupPolicyByName(backupPolicyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupPolicyByName(backupPolicyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupPolicyByName(backupPolicyName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of backup entities that are associated with this
   * policy.
   *
   * Returns a list of Service Fabric application, service or partition which are
   * associated with this backup policy.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupEntityList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllEntitiesBackedUpByPolicyWithHttpOperationResponse(backupPolicyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllEntitiesBackedUpByPolicy(backupPolicyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of backup entities that are associated with this
   * policy.
   *
   * Returns a list of Service Fabric application, service or partition which are
   * associated with this backup policy.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupEntityList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupEntityList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllEntitiesBackedUpByPolicy(backupPolicyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllEntitiesBackedUpByPolicy(backupPolicyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllEntitiesBackedUpByPolicy(backupPolicyName, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the backup policy.
   *
   * Updates the backup policy identified by {backupPolicyName}
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
   * policy to retain backups in storage.
   *
   * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
   * Polymorphic Discriminator
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateBackupPolicyWithHttpOperationResponse(backupPolicyDescription, backupPolicyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateBackupPolicy(backupPolicyDescription, backupPolicyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the backup policy.
   *
   * Updates the backup policy identified by {backupPolicyName}
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [backupPolicyDescription.retentionPolicy] Describes the
   * policy to retain backups in storage.
   *
   * @param {string} backupPolicyDescription.retentionPolicy.retentionPolicyType
   * Polymorphic Discriminator
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupPolicy(backupPolicyDescription, backupPolicyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateBackupPolicy(backupPolicyDescription, backupPolicyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateBackupPolicy(backupPolicyDescription, backupPolicyName, options, optionalCallback);
    }
  }

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric application.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric application. Each partition is backed up individually as per
   * the specified backup policy description.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableApplicationBackupWithHttpOperationResponse(applicationId, enableBackupDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enableApplicationBackup(applicationId, enableBackupDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric application.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric application. Each partition is backed up individually as per
   * the specified backup policy description.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enableApplicationBackup(applicationId, enableBackupDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enableApplicationBackup(applicationId, enableBackupDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enableApplicationBackup(applicationId, enableBackupDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Disables periodic backup of Service Fabric application.
   *
   * Disables periodic backup of Service Fabric application which was previously
   * enabled.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableApplicationBackupWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disableApplicationBackup(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Disables periodic backup of Service Fabric application.
   *
   * Disables periodic backup of Service Fabric application which was previously
   * enabled.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disableApplicationBackup(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disableApplicationBackup(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disableApplicationBackup(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Service Fabric application backup configuration
   * information.
   *
   * Gets the Service Fabric backup configuration information for the application
   * and the services and partitions under this application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupConfigurationInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationBackupConfigurationInfoWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationBackupConfigurationInfo(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Service Fabric application backup configuration
   * information.
   *
   * Gets the Service Fabric backup configuration information for the application
   * and the services and partitions under this application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupConfigurationInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupConfigurationInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationBackupConfigurationInfo(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationBackupConfigurationInfo(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationBackupConfigurationInfo(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of backups available for every partition in this
   * application.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric application. The server enumerates all the backups available at the
   * backup location configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationBackupListWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationBackupList(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of backups available for every partition in this
   * application.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric application. The server enumerates all the backups available at the
   * backup location configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationBackupList(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationBackupList(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationBackupList(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Suspends periodic backup for the specified Service Fabric
   * application.
   *
   * The application which is configured to take periodic backups, is suspended
   * for taking further backups till it is resumed again. This operation applies
   * to the entire application's hierarchy. It means all the services and
   * partitions under this application are now suspended for backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  suspendApplicationBackupWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._suspendApplicationBackup(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Suspends periodic backup for the specified Service Fabric
   * application.
   *
   * The application which is configured to take periodic backups, is suspended
   * for taking further backups till it is resumed again. This operation applies
   * to the entire application's hierarchy. It means all the services and
   * partitions under this application are now suspended for backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendApplicationBackup(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._suspendApplicationBackup(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._suspendApplicationBackup(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Resumes periodic backup of a Service Fabric application which was
   * previously suspended.
   *
   * The previously suspended Service Fabric application resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeApplicationBackupWithHttpOperationResponse(applicationId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeApplicationBackup(applicationId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resumes periodic backup of a Service Fabric application which was
   * previously suspended.
   *
   * The previously suspended Service Fabric application resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeApplicationBackup(applicationId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeApplicationBackup(applicationId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeApplicationBackup(applicationId, options, optionalCallback);
    }
  }

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric service.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric service. Each partition is backed up individually as per the
   * specified backup policy description. In case the application, which the
   * service is part of, is already enabled for backup then this operation would
   * override the policy being used to take the periodic backup for this service
   * and its partitions (unless explicitly overridden at the partition level).
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enableServiceBackupWithHttpOperationResponse(serviceId, enableBackupDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enableServiceBackup(serviceId, enableBackupDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric service.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric service. Each partition is backed up individually as per the
   * specified backup policy description. In case the application, which the
   * service is part of, is already enabled for backup then this operation would
   * override the policy being used to take the periodic backup for this service
   * and its partitions (unless explicitly overridden at the partition level).
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enableServiceBackup(serviceId, enableBackupDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enableServiceBackup(serviceId, enableBackupDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enableServiceBackup(serviceId, enableBackupDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Disables periodic backup of Service Fabric service which was
   * previously enabled.
   *
   * Disables periodic backup of Service Fabric service which was previously
   * enabled. Backup must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application, which this
   * service is part of, this service would continue to be periodically backed up
   * as per the policy mapped at the application level.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disableServiceBackupWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disableServiceBackup(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Disables periodic backup of Service Fabric service which was
   * previously enabled.
   *
   * Disables periodic backup of Service Fabric service which was previously
   * enabled. Backup must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application, which this
   * service is part of, this service would continue to be periodically backed up
   * as per the policy mapped at the application level.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disableServiceBackup(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disableServiceBackup(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disableServiceBackup(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Service Fabric service backup configuration information.
   *
   * Gets the Service Fabric backup configuration information for the service and
   * the partitions under this service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupConfigurationInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceBackupConfigurationInfoWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceBackupConfigurationInfo(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Service Fabric service backup configuration information.
   *
   * Gets the Service Fabric backup configuration information for the service and
   * the partitions under this service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupConfigurationInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupConfigurationInfoList} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceBackupConfigurationInfo(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceBackupConfigurationInfo(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceBackupConfigurationInfo(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of backups available for every partition in this
   * service.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric service. The server enumerates all the backups available in the
   * backup store configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceBackupListWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceBackupList(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of backups available for every partition in this
   * service.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric service. The server enumerates all the backups available in the
   * backup store configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceBackupList(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceBackupList(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceBackupList(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Suspends periodic backup for the specified Service Fabric service.
   *
   * The service which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again. This operation applies to
   * the entire service's hierarchy. It means all the partitions under this
   * service are now suspended for backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  suspendServiceBackupWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._suspendServiceBackup(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Suspends periodic backup for the specified Service Fabric service.
   *
   * The service which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again. This operation applies to
   * the entire service's hierarchy. It means all the partitions under this
   * service are now suspended for backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendServiceBackup(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._suspendServiceBackup(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._suspendServiceBackup(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Resumes periodic backup of a Service Fabric service which was
   * previously suspended.
   *
   * The previously suspended Service Fabric service resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumeServiceBackupWithHttpOperationResponse(serviceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumeServiceBackup(serviceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resumes periodic backup of a Service Fabric service which was
   * previously suspended.
   *
   * The previously suspended Service Fabric service resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeServiceBackup(serviceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumeServiceBackup(serviceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumeServiceBackup(serviceId, options, optionalCallback);
    }
  }

  /**
   * @summary Enables periodic backup of the stateful persisted partition.
   *
   * Enables periodic backup of stateful persisted partition. Each partition is
   * backed up as per the specified backup policy description. In case the
   * application or service, which is partition is part of, is already enabled
   * for backup then this operation would override the policy being used to take
   * the periodic backup of this partition.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  enablePartitionBackupWithHttpOperationResponse(partitionId, enableBackupDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._enablePartitionBackup(partitionId, enableBackupDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enables periodic backup of the stateful persisted partition.
   *
   * Enables periodic backup of stateful persisted partition. Each partition is
   * backed up as per the specified backup policy description. In case the
   * application or service, which is partition is part of, is already enabled
   * for backup then this operation would override the policy being used to take
   * the periodic backup of this partition.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  enablePartitionBackup(partitionId, enableBackupDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._enablePartitionBackup(partitionId, enableBackupDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._enablePartitionBackup(partitionId, enableBackupDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Disables periodic backup of Service Fabric partition which was
   * previously enabled.
   *
   * Disables periodic backup of partition which was previously enabled. Backup
   * must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application or service,
   * which this partition is part of, this partition would continue to be
   * periodically backed up as per the policy mapped at the higher level entity.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  disablePartitionBackupWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._disablePartitionBackup(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Disables periodic backup of Service Fabric partition which was
   * previously enabled.
   *
   * Disables periodic backup of partition which was previously enabled. Backup
   * must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application or service,
   * which this partition is part of, this partition would continue to be
   * periodically backed up as per the policy mapped at the higher level entity.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.disableBackupDescription] Specifies the parameters
   * to disable backup for any backup entity.
   *
   * @param {boolean} options.disableBackupDescription.cleanBackup Boolean flag
   * to delete backups. It can be set to true for deleting all the backups which
   * were created for the backup entity that is getting disabled for backup.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  disablePartitionBackup(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._disablePartitionBackup(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._disablePartitionBackup(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the partition backup configuration information
   *
   * Gets the Service Fabric Backup configuration information for the specified
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionBackupConfigurationInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionBackupConfigurationInfoWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionBackupConfigurationInfo(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the partition backup configuration information
   *
   * Gets the Service Fabric Backup configuration information for the specified
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PartitionBackupConfigurationInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionBackupConfigurationInfo} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupConfigurationInfo(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionBackupConfigurationInfo(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionBackupConfigurationInfo(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of backups available for the specified partition.
   *
   * Returns a list of backups available for the specified partition. The server
   * enumerates all the backups available in the backup store configured in the
   * backup policy. It also allows filtering of the result based on start and end
   * datetime or just fetching the latest available backup for the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionBackupListWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionBackupList(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of backups available for the specified partition.
   *
   * Returns a list of backups available for the specified partition. The server
   * enumerates all the backups available in the backup store configured in the
   * backup policy. It also allows filtering of the result based on start and end
   * datetime or just fetching the latest available backup for the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupList(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionBackupList(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionBackupList(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Suspends periodic backup for the specified partition.
   *
   * The partition which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  suspendPartitionBackupWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._suspendPartitionBackup(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Suspends periodic backup for the specified partition.
   *
   * The partition which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendPartitionBackup(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._suspendPartitionBackup(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._suspendPartitionBackup(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Resumes periodic backup of partition which was previously
   * suspended.
   *
   * The previously suspended partition resumes taking periodic backup as per the
   * backup policy currently configured for the same.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resumePartitionBackupWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resumePartitionBackup(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resumes periodic backup of partition which was previously
   * suspended.
   *
   * The previously suspended partition resumes taking periodic backup as per the
   * backup policy currently configured for the same.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resumePartitionBackup(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resumePartitionBackup(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resumePartitionBackup(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Triggers backup of the partition's state.
   *
   * Creates a backup of the stateful persisted partition's state. In case the
   * partition is already being periodically backed up, then by default the new
   * backup is created at the same backup storage. One can also override the same
   * by specifying the backup storage details as part of the request body. Once
   * the backup is initiated, its progress can be tracked using the
   * GetBackupProgress operation.
   * In case, the operation times out, specify a greater backup timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.backupPartitionDescription] Describes the
   * parameters to backup the partition now. If not present, backup operation
   * uses default parameters from the backup policy current associated with this
   * partition.
   *
   * @param {object} [options.backupPartitionDescription.backupStorage] Specifies
   * the details of the backup storage where to save the backup.
   *
   * @param {string}
   * [options.backupPartitionDescription.backupStorage.friendlyName] Friendly
   * name for this backup storage.
   *
   * @param {string} options.backupPartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {number} [options.backupTimeout] Specifies the maximum amount of
   * time, in minutes, to wait for the backup operation to complete. Post that,
   * the operation completes with timeout error. However, in certain corner cases
   * it could be that though the operation returns back timeout, the backup
   * actually goes through. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. The default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupPartitionWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backupPartition(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Triggers backup of the partition's state.
   *
   * Creates a backup of the stateful persisted partition's state. In case the
   * partition is already being periodically backed up, then by default the new
   * backup is created at the same backup storage. One can also override the same
   * by specifying the backup storage details as part of the request body. Once
   * the backup is initiated, its progress can be tracked using the
   * GetBackupProgress operation.
   * In case, the operation times out, specify a greater backup timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.backupPartitionDescription] Describes the
   * parameters to backup the partition now. If not present, backup operation
   * uses default parameters from the backup policy current associated with this
   * partition.
   *
   * @param {object} [options.backupPartitionDescription.backupStorage] Specifies
   * the details of the backup storage where to save the backup.
   *
   * @param {string}
   * [options.backupPartitionDescription.backupStorage.friendlyName] Friendly
   * name for this backup storage.
   *
   * @param {string} options.backupPartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {number} [options.backupTimeout] Specifies the maximum amount of
   * time, in minutes, to wait for the backup operation to complete. Post that,
   * the operation completes with timeout error. However, in certain corner cases
   * it could be that though the operation returns back timeout, the backup
   * actually goes through. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. The default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backupPartition(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backupPartition(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backupPartition(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest backup triggered for this partition.
   *
   * Returns information about the state of the latest backup along with details
   * or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionBackupProgressWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionBackupProgress(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest backup triggered for this partition.
   *
   * Returns information about the state of the latest backup along with details
   * or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupProgressInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupProgress(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionBackupProgress(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionBackupProgress(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Triggers restore of the state of the partition using the specified
   * restore partition description.
   *
   * Restores the state of a of the stateful persisted partition using the
   * specified backup point. In case the partition is already being periodically
   * backed up, then by default the backup point is looked for in the storage
   * specified in backup policy. One can also override the same by specifying the
   * backup storage details as part of the restore partition description in body.
   * Once the restore is initiated, its progress can be tracked using the
   * GetRestoreProgress operation.
   * In case, the operation times out, specify a greater restore timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} restorePartitionDescription Describes the parameters to
   * restore the partition.
   *
   * @param {uuid} restorePartitionDescription.backupId Unique backup ID.
   *
   * @param {string} restorePartitionDescription.backupLocation Location of the
   * backup relative to the backup storage specified/ configured.
   *
   * @param {object} [restorePartitionDescription.backupStorage] Location of the
   * backup from where the partition will be restored.
   *
   * @param {string} [restorePartitionDescription.backupStorage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} restorePartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.restoreTimeout] Specifies the maximum amount of
   * time to wait, in minutes, for the restore operation to complete. Post that,
   * the operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it
   * completes with timeout. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. the default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restorePartitionWithHttpOperationResponse(partitionId, restorePartitionDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restorePartition(partitionId, restorePartitionDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Triggers restore of the state of the partition using the specified
   * restore partition description.
   *
   * Restores the state of a of the stateful persisted partition using the
   * specified backup point. In case the partition is already being periodically
   * backed up, then by default the backup point is looked for in the storage
   * specified in backup policy. One can also override the same by specifying the
   * backup storage details as part of the restore partition description in body.
   * Once the restore is initiated, its progress can be tracked using the
   * GetRestoreProgress operation.
   * In case, the operation times out, specify a greater restore timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} restorePartitionDescription Describes the parameters to
   * restore the partition.
   *
   * @param {uuid} restorePartitionDescription.backupId Unique backup ID.
   *
   * @param {string} restorePartitionDescription.backupLocation Location of the
   * backup relative to the backup storage specified/ configured.
   *
   * @param {object} [restorePartitionDescription.backupStorage] Location of the
   * backup from where the partition will be restored.
   *
   * @param {string} [restorePartitionDescription.backupStorage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} restorePartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.restoreTimeout] Specifies the maximum amount of
   * time to wait, in minutes, for the restore operation to complete. Post that,
   * the operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it
   * completes with timeout. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. the default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restorePartition(partitionId, restorePartitionDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restorePartition(partitionId, restorePartitionDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restorePartition(partitionId, restorePartitionDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets details for the latest restore operation triggered for this
   * partition.
   *
   * Returns information about the state of the latest restore operation along
   * with details or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreProgressInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionRestoreProgressWithHttpOperationResponse(partitionId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionRestoreProgress(partitionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets details for the latest restore operation triggered for this
   * partition.
   *
   * Returns information about the state of the latest restore operation along
   * with details or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreProgressInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionRestoreProgress(partitionId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionRestoreProgress(partitionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionRestoreProgress(partitionId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the list of backups available for the specified backed up
   * entity at the specified backup location.
   *
   * Gets the list of backups available for the specified backed up entity
   * (Application, Service or Partition) at the specified backup location
   * (FileShare or Azure Blob Storage).
   *
   * @param {object} getBackupByStorageQueryDescription Describes the filters and
   * backup storage details to be used for enumerating backups.
   *
   * @param {date} [getBackupByStorageQueryDescription.startDateTimeFilter]
   * Specifies the start date time in ISO8601 from which to enumerate backups. If
   * not specified, backups are enumerated from the beginning.
   *
   * @param {date} [getBackupByStorageQueryDescription.endDateTimeFilter]
   * Specifies the end date time in ISO8601 till which to enumerate backups. If
   * not specified, backups are enumerated till the end.
   *
   * @param {boolean} [getBackupByStorageQueryDescription.latest] If specified as
   * true, gets the most recent backup (within the specified time range) for
   * every partition under the specified backup entity.
   *
   * @param {object} getBackupByStorageQueryDescription.storage Describes the
   * parameters for the backup storage from where to enumerate backups. This is
   * optional and by default backups are enumerated from the backup storage where
   * this backup entity is currently being backed up (as specified in backup
   * policy). This parameter is useful to be able to enumerate backups from
   * another cluster where you may intend to restore.
   *
   * @param {string} [getBackupByStorageQueryDescription.storage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} getBackupByStorageQueryDescription.storage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} getBackupByStorageQueryDescription.backupEntity Indicates
   * the entity for which to enumerate backups.
   *
   * @param {string} getBackupByStorageQueryDescription.backupEntity.entityKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupsFromBackupLocationWithHttpOperationResponse(getBackupByStorageQueryDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupsFromBackupLocation(getBackupByStorageQueryDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the list of backups available for the specified backed up
   * entity at the specified backup location.
   *
   * Gets the list of backups available for the specified backed up entity
   * (Application, Service or Partition) at the specified backup location
   * (FileShare or Azure Blob Storage).
   *
   * @param {object} getBackupByStorageQueryDescription Describes the filters and
   * backup storage details to be used for enumerating backups.
   *
   * @param {date} [getBackupByStorageQueryDescription.startDateTimeFilter]
   * Specifies the start date time in ISO8601 from which to enumerate backups. If
   * not specified, backups are enumerated from the beginning.
   *
   * @param {date} [getBackupByStorageQueryDescription.endDateTimeFilter]
   * Specifies the end date time in ISO8601 till which to enumerate backups. If
   * not specified, backups are enumerated till the end.
   *
   * @param {boolean} [getBackupByStorageQueryDescription.latest] If specified as
   * true, gets the most recent backup (within the specified time range) for
   * every partition under the specified backup entity.
   *
   * @param {object} getBackupByStorageQueryDescription.storage Describes the
   * parameters for the backup storage from where to enumerate backups. This is
   * optional and by default backups are enumerated from the backup storage where
   * this backup entity is currently being backed up (as specified in backup
   * policy). This parameter is useful to be able to enumerate backups from
   * another cluster where you may intend to restore.
   *
   * @param {string} [getBackupByStorageQueryDescription.storage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} getBackupByStorageQueryDescription.storage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} getBackupByStorageQueryDescription.backupEntity Indicates
   * the entity for which to enumerate backups.
   *
   * @param {string} getBackupByStorageQueryDescription.backupEntity.entityKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupsFromBackupLocation(getBackupByStorageQueryDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupsFromBackupLocation(getBackupByStorageQueryDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupsFromBackupLocation(getBackupByStorageQueryDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a Service Fabric name.
   *
   * Creates the specified Service Fabric name.
   *
   * @param {object} nameDescription Describes the Service Fabric name to be
   * created.
   *
   * @param {string} nameDescription.name The Service Fabric name, including the
   * 'fabric:' URI scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createNameWithHttpOperationResponse(nameDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createName(nameDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a Service Fabric name.
   *
   * Creates the specified Service Fabric name.
   *
   * @param {object} nameDescription Describes the Service Fabric name to be
   * created.
   *
   * @param {string} nameDescription.name The Service Fabric name, including the
   * 'fabric:' URI scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createName(nameDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createName(nameDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createName(nameDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Returns whether the Service Fabric name exists.
   *
   * Returns whether the specified Service Fabric name exists.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNameExistsInfoWithHttpOperationResponse(nameId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNameExistsInfo(nameId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns whether the Service Fabric name exists.
   *
   * Returns whether the specified Service Fabric name exists.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNameExistsInfo(nameId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNameExistsInfo(nameId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNameExistsInfo(nameId, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a Service Fabric name.
   *
   * Deletes the specified Service Fabric name. A name must be created before it
   * can be deleted. Deleting a name with child properties will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteNameWithHttpOperationResponse(nameId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteName(nameId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a Service Fabric name.
   *
   * Deletes the specified Service Fabric name. A name must be created before it
   * can be deleted. Deleting a name with child properties will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteName(nameId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteName(nameId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteName(nameId, options, optionalCallback);
    }
  }

  /**
   * @summary Enumerates all the Service Fabric names under a given name.
   *
   * Enumerates all the Service Fabric names under a given name. If the subnames
   * do not fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. Querying a name
   * that doesn't exist will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Allows specifying that the search
   * performed should be recursive.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedSubNameInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSubNameInfoListWithHttpOperationResponse(nameId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSubNameInfoList(nameId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Enumerates all the Service Fabric names under a given name.
   *
   * Enumerates all the Service Fabric names under a given name. If the subnames
   * do not fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. Querying a name
   * that doesn't exist will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Allows specifying that the search
   * performed should be recursive.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedSubNameInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedSubNameInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSubNameInfoList(nameId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSubNameInfoList(nameId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSubNameInfoList(nameId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets information on all Service Fabric properties under a given
   * name.
   *
   * A Service Fabric name can have one or more named properties that store
   * custom information. This operation gets the information about these
   * properties in a paged list. The information includes name, value, and
   * metadata about each of the properties.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeValues] Allows specifying whether to
   * include the values of the properties returned. True if values should be
   * returned with the metadata; False to return only property metadata.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedPropertyInfoList>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPropertyInfoListWithHttpOperationResponse(nameId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPropertyInfoList(nameId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets information on all Service Fabric properties under a given
   * name.
   *
   * A Service Fabric name can have one or more named properties that store
   * custom information. This operation gets the information about these
   * properties in a paged list. The information includes name, value, and
   * metadata about each of the properties.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeValues] Allows specifying whether to
   * include the values of the properties returned. True if values should be
   * returned with the metadata; False to return only property metadata.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PagedPropertyInfoList} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedPropertyInfoList} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPropertyInfoList(nameId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPropertyInfoList(nameId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPropertyInfoList(nameId, options, optionalCallback);
    }
  }

  /**
   * @summary Creates or updates a Service Fabric property.
   *
   * Creates or updates the specified Service Fabric property under a given name.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyDescription Describes the Service Fabric property to
   * be created.
   *
   * @param {string} propertyDescription.propertyName The name of the Service
   * Fabric property.
   *
   * @param {string} [propertyDescription.customTypeId] The property's custom
   * type ID. Using this property, the user is able to tag the type of the value
   * of the property.
   *
   * @param {object} propertyDescription.value Describes a Service Fabric
   * property value.
   *
   * @param {string} propertyDescription.value.kind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  putPropertyWithHttpOperationResponse(nameId, propertyDescription, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._putProperty(nameId, propertyDescription, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates or updates a Service Fabric property.
   *
   * Creates or updates the specified Service Fabric property under a given name.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyDescription Describes the Service Fabric property to
   * be created.
   *
   * @param {string} propertyDescription.propertyName The name of the Service
   * Fabric property.
   *
   * @param {string} [propertyDescription.customTypeId] The property's custom
   * type ID. Using this property, the user is able to tag the type of the value
   * of the property.
   *
   * @param {object} propertyDescription.value Describes a Service Fabric
   * property value.
   *
   * @param {string} propertyDescription.value.kind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  putProperty(nameId, propertyDescription, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._putProperty(nameId, propertyDescription, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._putProperty(nameId, propertyDescription, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the specified Service Fabric property.
   *
   * Gets the specified Service Fabric property under a given name. This will
   * always return both value and metadata.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PropertyInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPropertyInfoWithHttpOperationResponse(nameId, propertyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPropertyInfo(nameId, propertyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the specified Service Fabric property.
   *
   * Gets the specified Service Fabric property under a given name. This will
   * always return both value and metadata.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PropertyInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PropertyInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPropertyInfo(nameId, propertyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPropertyInfo(nameId, propertyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPropertyInfo(nameId, propertyName, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the specified Service Fabric property.
   *
   * Deletes the specified Service Fabric property under a given name. A property
   * must be created before it can be deleted.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletePropertyWithHttpOperationResponse(nameId, propertyName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteProperty(nameId, propertyName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the specified Service Fabric property.
   *
   * Deletes the specified Service Fabric property under a given name. A property
   * must be created before it can be deleted.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteProperty(nameId, propertyName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteProperty(nameId, propertyName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteProperty(nameId, propertyName, options, optionalCallback);
    }
  }

  /**
   * @summary Submits a property batch.
   *
   * Submits a batch of property operations. Either all or none of the operations
   * will be committed.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyBatchDescriptionList Describes the property batch
   * operations to be submitted.
   *
   * @param {array} [propertyBatchDescriptionList.operations] A list of the
   * property batch operations to be executed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PropertyBatchInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  submitPropertyBatchWithHttpOperationResponse(nameId, propertyBatchDescriptionList, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._submitPropertyBatch(nameId, propertyBatchDescriptionList, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Submits a property batch.
   *
   * Submits a batch of property operations. Either all or none of the operations
   * will be committed.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyBatchDescriptionList Describes the property batch
   * operations to be submitted.
   *
   * @param {array} [propertyBatchDescriptionList.operations] A list of the
   * property batch operations to be executed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PropertyBatchInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PropertyBatchInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  submitPropertyBatch(nameId, propertyBatchDescriptionList, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._submitPropertyBatch(nameId, propertyBatchDescriptionList, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._submitPropertyBatch(nameId, propertyBatchDescriptionList, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Cluster-related events.
   *
   * The response is list of ClusterEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getClusterEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getClusterEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Cluster-related events.
   *
   * The response is list of ClusterEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getClusterEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getClusterEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Containers-related events.
   *
   * The response is list of ContainerInstanceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getContainersEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getContainersEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Containers-related events.
   *
   * The response is list of ContainerInstanceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getContainersEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getContainersEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getContainersEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a Node-related events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodeEventListWithHttpOperationResponse(nodeName, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodeEventList(nodeName, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a Node-related events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeEventList(nodeName, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodeEventList(nodeName, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodeEventList(nodeName, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Nodes-related Events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getNodesEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getNodesEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Nodes-related Events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodesEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getNodesEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getNodesEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an Application-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationEventListWithHttpOperationResponse(applicationId, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationEventList(applicationId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an Application-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationEventList(applicationId, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationEventList(applicationId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationEventList(applicationId, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Applications-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getApplicationsEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getApplicationsEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Applications-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationsEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getApplicationsEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getApplicationsEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a Service-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServiceEventListWithHttpOperationResponse(serviceId, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServiceEventList(serviceId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a Service-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceEventList(serviceId, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServiceEventList(serviceId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServiceEventList(serviceId, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Services-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getServicesEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getServicesEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Services-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getServicesEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getServicesEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getServicesEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a Partition-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionEventListWithHttpOperationResponse(partitionId, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionEventList(partitionId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a Partition-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionEventList(partitionId, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionEventList(partitionId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionEventList(partitionId, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Partitions-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionsEventListWithHttpOperationResponse(startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionsEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Partitions-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionsEventList(startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionsEventList(startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionsEventList(startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a Partition Replica-related events.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionReplicaEventListWithHttpOperationResponse(partitionId, replicaId, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionReplicaEventList(partitionId, replicaId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a Partition Replica-related events.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionReplicaEventList(partitionId, replicaId, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionReplicaEventList(partitionId, replicaId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionReplicaEventList(partitionId, replicaId, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all Replicas-related events for a Partition.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPartitionReplicasEventListWithHttpOperationResponse(partitionId, startTimeUtc, endTimeUtc, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPartitionReplicasEventList(partitionId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all Replicas-related events for a Partition.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionReplicasEventList(partitionId, startTimeUtc, endTimeUtc, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPartitionReplicasEventList(partitionId, startTimeUtc, endTimeUtc, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPartitionReplicasEventList(partitionId, startTimeUtc, endTimeUtc, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all correlated events for a given event.
   *
   * The response is list of FabricEvents.
   *
   * @param {string} eventInstanceId The EventInstanceId.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCorrelatedEventListWithHttpOperationResponse(eventInstanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCorrelatedEventList(eventInstanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all correlated events for a given event.
   *
   * The response is list of FabricEvents.
   *
   * @param {string} eventInstanceId The EventInstanceId.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCorrelatedEventList(eventInstanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCorrelatedEventList(eventInstanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCorrelatedEventList(eventInstanceId, options, optionalCallback);
    }
  }

}

module.exports = ServiceFabricClient;
module.exports['default'] = ServiceFabricClient;
module.exports.ServiceFabricClient = ServiceFabricClient;
module.exports.ServiceFabricModels = models;
