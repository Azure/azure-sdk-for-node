/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { ServiceClient, ServiceClientOptions, ServiceCallback, HttpOperationResponse } from 'ms-rest';
import * as models from "./models";

export default class ServiceFabricClient extends ServiceClient {
  /**
   * @class
   * Initializes a new instance of the ServiceFabricClient class.
   * @constructor
   *
   * @param {string} [baseUri] - The base URI of the service.
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(baseUri?: string, options?: ServiceClientOptions);


  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand-alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (e.g. when using Azure portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterManifest>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterManifestWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterManifest>>;

  /**
   * @summary Get the Service Fabric cluster manifest.
   *
   * Get the Service Fabric cluster manifest. The cluster manifest contains
   * properties of the cluster that include different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * These properties are specified as part of the ClusterConfig.JSON file while
   * deploying a stand-alone cluster. However, most of the information in the
   * cluster manifest
   * is generated internally by service fabric during cluster deployment in other
   * deployment scenarios (e.g. when using Azure portal).
   *
   * The contents of the cluster manifest are for informational purposes only and
   * users are not expected to take a dependency on the format of the file
   * contents or its interpretation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterManifest} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterManifest} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterManifest} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterManifest(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterManifest>;
  getClusterManifest(callback: ServiceCallback<models.ClusterManifest>): void;
  getClusterManifest(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterManifest>): void;


  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterHealthWithHttpOperationResponse(options?: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterHealth>>;

  /**
   * @summary Gets the health of a Service Fabric cluster.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealth(options?: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterHealth>;
  getClusterHealth(callback: ServiceCallback<models.ClusterHealth>): void;
  getClusterHealth(options: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterHealth>): void;


  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterHealthUsingPolicyWithHttpOperationResponse(options?: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, clusterHealthPolicies? : models.ClusterHealthPolicies, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterHealth>>;

  /**
   * @summary Gets the health of a Service Fabric cluster using the specified
   * policy.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to
   * filter the collection of nodes and applications returned based on their
   * aggregated health state.
   * Use ClusterHealthPolicies to override the health policies used to evaluate
   * the health.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.nodesHealthStateFilter] Allows filtering of the
   * node health state objects returned in the result of cluster health query
   * based on their health state. The possible values for this parameter include
   * integer value of one of the
   * following health states. Only nodes that match the filter are returned. All
   * nodes are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.applicationsHealthStateFilter] Allows filtering of
   * the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from
   * members or bitwise operations
   * on members of HealthStateFilter enumeration. Only applications that match
   * the filter are returned.
   * All applications are used to evaluate the aggregated health state. If not
   * specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications
   * with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {boolean} [options.includeSystemApplicationHealthStatistics]
   * Indicates whether the health statistics should include the fabric:/System
   * application health statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health
   * statistics include the entities that belong to the fabric:/System
   * application.
   * Otherwise, the query result includes health statistics only for user
   * applications.
   * The health statistics must be included in the query result for this
   * parameter to be applied.
   *
   * @param {object} [options.clusterHealthPolicies] Describes the health
   * policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined
   * in the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   *
   * @param {array} [options.clusterHealthPolicies.applicationHealthPolicyMap]
   * Defines a map that contains specific application health policies for
   * different applications.
   * Each entry specifies as key the application name and as value an
   * ApplicationHealthPolicy used to evaluate the application health.
   * If an application is not specified in the map, the application health
   * evaluation uses the ApplicationHealthPolicy found in its application
   * manifest or the default application health policy (if no health policy is
   * defined in the manifest).
   * The map is empty by default.
   *
   * @param {object} [options.clusterHealthPolicies.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthPolicies.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicies.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthPolicies.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthUsingPolicy(options?: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, clusterHealthPolicies? : models.ClusterHealthPolicies, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterHealth>;
  getClusterHealthUsingPolicy(callback: ServiceCallback<models.ClusterHealth>): void;
  getClusterHealthUsingPolicy(options: { nodesHealthStateFilter? : number, applicationsHealthStateFilter? : number, eventsHealthStateFilter? : number, excludeHealthStatistics? : boolean, includeSystemApplicationHealthStatistics? : boolean, clusterHealthPolicies? : models.ClusterHealthPolicies, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterHealth>): void;


  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterHealthChunkWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterHealthChunk>>;

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. Includes
   * the aggregated health state of the cluster, but none of the cluster
   * entities.
   * To expand the cluster health and get the health state of all or some of the
   * entities, use the POST URI and specify the cluster health chunk query
   * description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterHealthChunk} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunk(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterHealthChunk>;
  getClusterHealthChunk(callback: ServiceCallback<models.ClusterHealthChunk>): void;
  getClusterHealthChunk(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterHealthChunk>): void;


  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy] Defines a
   * health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterHealthChunk>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithHttpOperationResponse(options?: { clusterHealthChunkQueryDescription? : models.ClusterHealthChunkQueryDescription, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterHealthChunk>>;

  /**
   * @summary Gets the health of a Service Fabric cluster using health chunks.
   *
   * Gets the health of a Service Fabric cluster using health chunks. The health
   * evaluation is done based on the input cluster health chunk query
   * description.
   * The query description allows users to specify health policies for evaluating
   * the cluster and its children.
   * Users can specify very flexible filters to select which cluster entities to
   * return. The selection can be done based on the entities health state and
   * based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.clusterHealthChunkQueryDescription] Describes the
   * cluster and application health policies used to evaluate the cluster health
   * and the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster
   * events and the cluster nodes. If not present, the health evaluation uses the
   * cluster health policy defined in the cluster manifest or the default cluster
   * health policy.
   * By default, each application is evaluated using its specific application
   * health policy, defined in the application manifest, or the default health
   * policy, if no policy is defined in manifest.
   * If the application health policy map is specified, and it has an entry for
   * an application, the specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to
   * include in response. The selection can be done based on the entities health
   * state and based on the hierarchy.
   * The query can return multi-level children of the entities based on the
   * specified filters. For example, it can return one application with a
   * specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas
   * for one of these services.
   *
   * @param {array} [options.clusterHealthChunkQueryDescription.nodeFilters]
   * Defines a list of filters that specify which nodes to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used
   * to evaluate the cluster's aggregated health state, regardless of the input
   * filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state
   * Error and another filter to always include a node identified by its
   * NodeName.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationFilters] Defines a
   * list of filters that specify which applications to be included in the
   * returned cluster health chunk.
   * If no filters are specified, no applications are returned. All the
   * applications are used to evaluate the cluster's aggregated health state,
   * regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health
   * state Error and another filter to always include applications of a specified
   * application type.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy] Defines a
   * health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [options.clusterHealthChunkQueryDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterHealthChunk} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterHealthChunk} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterHealthChunk} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterHealthChunkUsingPolicyAndAdvancedFilters(options?: { clusterHealthChunkQueryDescription? : models.ClusterHealthChunkQueryDescription, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterHealthChunk>;
  getClusterHealthChunkUsingPolicyAndAdvancedFilters(callback: ServiceCallback<models.ClusterHealthChunk>): void;
  getClusterHealthChunkUsingPolicyAndAdvancedFilters(options: { clusterHealthChunkQueryDescription? : models.ClusterHealthChunkQueryDescription, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterHealthChunk>): void;


  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportClusterHealthWithHttpOperationResponse(healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric cluster.
   *
   * Sends a health report on a Service Fabric cluster. The report must contain
   * the information about the source of the health report and property on which
   * it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetClusterHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportClusterHealth(healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportClusterHealth(healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportClusterHealth(healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getProvisionedFabricCodeVersionInfoListWithHttpOperationResponse(options?: { codeVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.FabricCodeVersionInfo[]>>;

  /**
   * @summary Gets a list of fabric code versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric code versions that are provisioned
   * in the cluster. The parameter CodeVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.codeVersion] The product version of Service Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricCodeVersionInfoList(options?: { codeVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.FabricCodeVersionInfo[]>;
  getProvisionedFabricCodeVersionInfoList(callback: ServiceCallback<models.FabricCodeVersionInfo[]>): void;
  getProvisionedFabricCodeVersionInfoList(options: { codeVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.FabricCodeVersionInfo[]>): void;


  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getProvisionedFabricConfigVersionInfoListWithHttpOperationResponse(options?: { configVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.FabricConfigVersionInfo[]>>;

  /**
   * @summary Gets a list of fabric config versions that are provisioned in a
   * Service Fabric cluster.
   *
   * Gets a list of information about fabric config versions that are provisioned
   * in the cluster. The parameter ConfigVersion can be used to optionally filter
   * the output to only that particular version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.configVersion] The config version of Service
   * Fabric.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getProvisionedFabricConfigVersionInfoList(options?: { configVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.FabricConfigVersionInfo[]>;
  getProvisionedFabricConfigVersionInfoList(callback: ServiceCallback<models.FabricConfigVersionInfo[]>): void;
  getProvisionedFabricConfigVersionInfoList(options: { configVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.FabricConfigVersionInfo[]>): void;


  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, get the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterUpgradeProgressObject>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterUpgradeProgressWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterUpgradeProgressObject>>;

  /**
   * @summary Gets the progress of the current cluster upgrade.
   *
   * Gets the current progress of the ongoing cluster upgrade. If no upgrade is
   * currently in progress, get the last state of the previous cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterUpgradeProgressObject} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterUpgradeProgressObject} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterUpgradeProgressObject} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterUpgradeProgress(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterUpgradeProgressObject>;
  getClusterUpgradeProgress(callback: ServiceCallback<models.ClusterUpgradeProgressObject>): void;
  getClusterUpgradeProgress(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterUpgradeProgressObject>): void;


  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * The cluster configuration contains properties of the cluster that include
   * different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfiguration>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterConfigurationWithHttpOperationResponse(configurationApiVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterConfiguration>>;

  /**
   * @summary Get the Service Fabric standalone cluster configuration.
   *
   * The cluster configuration contains properties of the cluster that include
   * different node types on the cluster,
   * security configurations, fault, and upgrade domain topologies, etc.
   *
   * @param {string} configurationApiVersion The API version of the Standalone
   * cluster json configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterConfiguration} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterConfiguration} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfiguration} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfiguration(configurationApiVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterConfiguration>;
  getClusterConfiguration(configurationApiVersion: string, callback: ServiceCallback<models.ClusterConfiguration>): void;
  getClusterConfiguration(configurationApiVersion: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterConfiguration>): void;


  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status details of a Service Fabric
   * standalone cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ClusterConfigurationUpgradeStatusInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterConfigurationUpgradeStatusWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterConfigurationUpgradeStatusInfo>>;

  /**
   * @summary Get the cluster configuration upgrade status of a Service Fabric
   * standalone cluster.
   *
   * Get the cluster configuration upgrade status details of a Service Fabric
   * standalone cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ClusterConfigurationUpgradeStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ClusterConfigurationUpgradeStatusInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ClusterConfigurationUpgradeStatusInfo} for
   *                      more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterConfigurationUpgradeStatus(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterConfigurationUpgradeStatusInfo>;
  getClusterConfigurationUpgradeStatus(callback: ServiceCallback<models.ClusterConfigurationUpgradeStatusInfo>): void;
  getClusterConfigurationUpgradeStatus(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterConfigurationUpgradeStatusInfo>): void;


  /**
   * @summary Get the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Get the service state of Service Fabric Upgrade Orchestration Service. This
   * API is internally used for support purposes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UpgradeOrchestrationServiceState>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getUpgradeOrchestrationServiceStateWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.UpgradeOrchestrationServiceState>>;

  /**
   * @summary Get the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Get the service state of Service Fabric Upgrade Orchestration Service. This
   * API is internally used for support purposes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {UpgradeOrchestrationServiceState} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {UpgradeOrchestrationServiceState} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UpgradeOrchestrationServiceState} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getUpgradeOrchestrationServiceState(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.UpgradeOrchestrationServiceState>;
  getUpgradeOrchestrationServiceState(callback: ServiceCallback<models.UpgradeOrchestrationServiceState>): void;
  getUpgradeOrchestrationServiceState(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.UpgradeOrchestrationServiceState>): void;


  /**
   * @summary Update the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Update the service state of Service Fabric Upgrade Orchestration Service.
   * This API is internally used for support purposes.
   *
   * @param {object} upgradeOrchestrationServiceState Service state of Service
   * Fabric Upgrade Orchestration Service.
   *
   * @param {string} [upgradeOrchestrationServiceState.serviceState] The state of
   * Service Fabric Upgrade Orchestration Service.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UpgradeOrchestrationServiceStateSummary>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  setUpgradeOrchestrationServiceStateWithHttpOperationResponse(upgradeOrchestrationServiceState: models.UpgradeOrchestrationServiceState, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.UpgradeOrchestrationServiceStateSummary>>;

  /**
   * @summary Update the service state of Service Fabric Upgrade Orchestration
   * Service.
   *
   * Update the service state of Service Fabric Upgrade Orchestration Service.
   * This API is internally used for support purposes.
   *
   * @param {object} upgradeOrchestrationServiceState Service state of Service
   * Fabric Upgrade Orchestration Service.
   *
   * @param {string} [upgradeOrchestrationServiceState.serviceState] The state of
   * Service Fabric Upgrade Orchestration Service.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {UpgradeOrchestrationServiceStateSummary} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {UpgradeOrchestrationServiceStateSummary} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UpgradeOrchestrationServiceStateSummary} for
   *                      more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState: models.UpgradeOrchestrationServiceState, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.UpgradeOrchestrationServiceStateSummary>;
  setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState: models.UpgradeOrchestrationServiceState, callback: ServiceCallback<models.UpgradeOrchestrationServiceStateSummary>): void;
  setUpgradeOrchestrationServiceState(upgradeOrchestrationServiceState: models.UpgradeOrchestrationServiceState, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.UpgradeOrchestrationServiceStateSummary>): void;


  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  provisionClusterWithHttpOperationResponse(provisionFabricDescription: models.ProvisionFabricDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Provision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * Validate and provision the code or configuration packages of a Service
   * Fabric cluster.
   *
   * @param {object} provisionFabricDescription Describes the parameters for
   * provisioning a cluster.
   *
   * @param {string} [provisionFabricDescription.codeFilePath] The cluster code
   * package file path.
   *
   * @param {string} [provisionFabricDescription.clusterManifestFilePath] The
   * cluster manifest file path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionCluster(provisionFabricDescription: models.ProvisionFabricDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  provisionCluster(provisionFabricDescription: models.ProvisionFabricDescription, callback: ServiceCallback<void>): void;
  provisionCluster(provisionFabricDescription: models.ProvisionFabricDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * It is supported to unprovision code and configuration separately.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  unprovisionClusterWithHttpOperationResponse(unprovisionFabricDescription: models.UnprovisionFabricDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Unprovision the code or configuration packages of a Service Fabric
   * cluster.
   *
   * It is supported to unprovision code and configuration separately.
   *
   * @param {object} unprovisionFabricDescription Describes the parameters for
   * unprovisioning a cluster.
   *
   * @param {string} [unprovisionFabricDescription.codeVersion] The cluster code
   * package version.
   *
   * @param {string} [unprovisionFabricDescription.configVersion] The cluster
   * manifest version.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionCluster(unprovisionFabricDescription: models.UnprovisionFabricDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  unprovisionCluster(unprovisionFabricDescription: models.UnprovisionFabricDescription, callback: ServiceCallback<void>): void;
  unprovisionCluster(unprovisionFabricDescription: models.UnprovisionFabricDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Rollback the upgrade of a Service Fabric cluster.
   *
   * Rollback the code or configuration upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  rollbackClusterUpgradeWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Rollback the upgrade of a Service Fabric cluster.
   *
   * Rollback the code or configuration upgrade of a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackClusterUpgrade(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  rollbackClusterUpgrade(callback: ServiceCallback<void>): void;
  rollbackClusterUpgrade(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster code or configuration upgrade move on to the next upgrade
   * domain if appropriate.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resumeClusterUpgradeWithHttpOperationResponse(resumeClusterUpgradeDescription: models.ResumeClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Make the cluster upgrade move on to the next upgrade domain.
   *
   * Make the cluster code or configuration upgrade move on to the next upgrade
   * domain if appropriate.
   *
   * @param {object} resumeClusterUpgradeDescription Describes the parameters for
   * resuming a cluster upgrade.
   *
   * @param {string} resumeClusterUpgradeDescription.upgradeDomain The next
   * upgrade domain for this cluster upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeClusterUpgrade(resumeClusterUpgradeDescription: models.ResumeClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resumeClusterUpgrade(resumeClusterUpgradeDescription: models.ResumeClusterUpgradeDescription, callback: ServiceCallback<void>): void;
  resumeClusterUpgrade(resumeClusterUpgradeDescription: models.ResumeClusterUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startClusterUpgradeWithHttpOperationResponse(startClusterUpgradeDescription: models.StartClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Start upgrading the code or configuration version of a Service
   * Fabric cluster.
   *
   * Validate the supplied upgrade parameters and start upgrading the code or
   * configuration version of a Service Fabric cluster if the parameters are
   * valid.
   *
   * @param {object} startClusterUpgradeDescription Describes the parameters for
   * starting a cluster upgrade.
   *
   * @param {string} [startClusterUpgradeDescription.codeVersion] The cluster
   * code version.
   *
   * @param {string} [startClusterUpgradeDescription.configVersion] The cluster
   * configuration version.
   *
   * @param {string} [startClusterUpgradeDescription.upgradeKind] The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [startClusterUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [startClusterUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [startClusterUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [startClusterUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [startClusterUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [startClusterUpgradeDescription.clusterHealthPolicy] Defines
   * a health policy used to evaluate the health of the cluster or of a cluster
   * node.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [startClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [startClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [startClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [startClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [startClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [startClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterUpgrade(startClusterUpgradeDescription: models.StartClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startClusterUpgrade(startClusterUpgradeDescription: models.StartClusterUpgradeDescription, callback: ServiceCallback<void>): void;
  startClusterUpgrade(startClusterUpgradeDescription: models.StartClusterUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform a health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startClusterConfigurationUpgradeWithHttpOperationResponse(clusterConfigurationUpgradeDescription: models.ClusterConfigurationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Start upgrading the configuration of a Service Fabric standalone
   * cluster.
   *
   * Validate the supplied configuration upgrade parameters and start upgrading
   * the cluster configuration if the parameters are valid.
   *
   * @param {object} clusterConfigurationUpgradeDescription Parameters for a
   * standalone cluster configuration upgrade.
   *
   * @param {string} clusterConfigurationUpgradeDescription.clusterConfig The
   * cluster configuration.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckRetryTimeout] The length
   * of time between attempts to perform a health checks if the application or
   * cluster is not healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckWaitDurationInSeconds]
   * The length of time to wait after completing an upgrade domain before
   * starting the health checks process.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.healthCheckStableDurationInSeconds]
   * The length of time that the application or cluster must remain healthy.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeDomainTimeoutInSeconds] The
   * timeout for the upgrade domain.
   *
   * @param {moment.duration}
   * [clusterConfigurationUpgradeDescription.upgradeTimeoutInSeconds] The upgrade
   * timeout.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes during the upgrade. Allowed
   * values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentDeltaUnhealthyNodes] The
   * maximum allowed percentage of delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100.
   *
   * @param {number}
   * [clusterConfigurationUpgradeDescription.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain delta health degradation
   * during the upgrade. Allowed values are integer values from zero to 100.
   *
   * @param {object}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies] Defines
   * the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [clusterConfigurationUpgradeDescription.applicationHealthPolicies.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription: models.ClusterConfigurationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription: models.ClusterConfigurationUpgradeDescription, callback: ServiceCallback<void>): void;
  startClusterConfigurationUpgrade(clusterConfigurationUpgradeDescription: models.ClusterConfigurationUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters used during a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] The type of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster or of a
   * cluster node.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateClusterUpgradeWithHttpOperationResponse(updateClusterUpgradeDescription: models.UpdateClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Update the upgrade parameters of a Service Fabric cluster upgrade.
   *
   * Update the upgrade parameters used during a Service Fabric cluster upgrade.
   *
   * @param {object} updateClusterUpgradeDescription Parameters for updating a
   * cluster upgrade.
   *
   * @param {string} [updateClusterUpgradeDescription.upgradeKind] The type of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling', 'Rolling_ForceRestart'
   *
   * @param {object} [updateClusterUpgradeDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * updateClusterUpgradeDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.updateDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {number}
   * [updateClusterUpgradeDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [updateClusterUpgradeDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster or of a
   * cluster node.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyNodes]
   * The maximum allowed percentage of unhealthy nodes before reporting an error.
   * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.maxPercentUnhealthyApplications]
   * The maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {boolean}
   * [updateClusterUpgradeDescription.enableDeltaHealthEvaluation] When true,
   * enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   *
   * @param {object} [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy]
   * Defines a health policy used to evaluate the health of the cluster during a
   * cluster upgrade.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentDeltaUnhealthyNodes]
   * The maximum allowed percentage of nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the nodes at
   * the beginning of upgrade and the state of the nodes at the time of the
   * health evaluation. The check is performed after every upgrade domain upgrade
   * completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   *
   * @param {number}
   * [updateClusterUpgradeDescription.clusterUpgradeHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
   * The maximum allowed percentage of upgrade domain nodes health degradation
   * allowed during cluster upgrades. The delta is measured between the state of
   * the upgrade domain nodes at the beginning of upgrade and the state of the
   * upgrade domain nodes at the time of the health evaluation. The check is
   * performed after every upgrade domain upgrade completion for all completed
   * upgrade domains to make sure the state of the upgrade domains is within
   * tolerated limits. The default value is 15%.
   *
   * @param {object} [updateClusterUpgradeDescription.applicationHealthPolicyMap]
   * Defines the application health policy map used to evaluate the health of an
   * application or one of its children entities.
   *
   * @param {array}
   * [updateClusterUpgradeDescription.applicationHealthPolicyMap.applicationHealthPolicyMap]
   * The wrapper that contains the map with application health policies used to
   * evaluate specific applications in the cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateClusterUpgrade(updateClusterUpgradeDescription: models.UpdateClusterUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  updateClusterUpgrade(updateClusterUpgradeDescription: models.UpdateClusterUpgradeDescription, callback: ServiceCallback<void>): void;
  updateClusterUpgrade(updateClusterUpgradeDescription: models.UpdateClusterUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AadMetadataObject>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAadMetadataWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.AadMetadataObject>>;

  /**
   * @summary Gets the Azure Active Directory metadata used for secured
   * connection to cluster.
   *
   * Gets the Azure Active Directory metadata used for secured connection to
   * cluster.
   * This API is not supposed to be called separately. It provides information
   * needed to set up an Azure Active Directory secured connection with a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {AadMetadataObject} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {AadMetadataObject} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AadMetadataObject} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAadMetadata(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.AadMetadataObject>;
  getAadMetadata(callback: ServiceCallback<models.AadMetadataObject>): void;
  getAadMetadata(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.AadMetadataObject>): void;


  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the nodes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedNodeInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeInfoListWithHttpOperationResponse(options?: { continuationToken? : string, nodeStatusFilter? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedNodeInfoList>>;

  /**
   * @summary Gets the list of nodes in the Service Fabric cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the nodes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.nodeStatusFilter] Allows filtering the nodes based
   * on the NodeStatus. Only the nodes that are matching the specified filter
   * value will be returned. The filter value can be one of the following.
   * Possible values include: 'default', 'all', 'up', 'down', 'enabling',
   * 'disabling', 'disabled', 'unknown', 'removed'
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedNodeInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedNodeInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedNodeInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfoList(options?: { continuationToken? : string, nodeStatusFilter? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedNodeInfoList>;
  getNodeInfoList(callback: ServiceCallback<models.PagedNodeInfoList>): void;
  getNodeInfoList(options: { continuationToken? : string, nodeStatusFilter? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedNodeInfoList>): void;


  /**
   * @summary Gets the information about a specific node in the Service Fabric
   * cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeInfoWithHttpOperationResponse(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeInfo>>;

  /**
   * @summary Gets the information about a specific node in the Service Fabric
   * cluster.
   *
   * The response includes the name, status, ID, health, uptime, and other
   * details about the node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {NodeInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {NodeInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeInfo(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeInfo>;
  getNodeInfo(nodeName: string, callback: ServiceCallback<models.NodeInfo>): void;
  getNodeInfo(nodeName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeInfo>): void;


  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeHealthWithHttpOperationResponse(nodeName: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeHealth>>;

  /**
   * @summary Gets the health of a Service Fabric node.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. If the node that you specify by name does not exist in the
   * health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {NodeHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealth(nodeName: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeHealth>;
  getNodeHealth(nodeName: string, callback: ServiceCallback<models.NodeHealth>): void;
  getNodeHealth(nodeName: string, options: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeHealth>): void;


  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeHealthUsingPolicyWithHttpOperationResponse(nodeName: string, options?: { eventsHealthStateFilter? : number, clusterHealthPolicy? : models.ClusterHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeHealth>>;

  /**
   * @summary Gets the health of a Service Fabric node, by using the specified
   * health policy.
   *
   * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to
   * filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicy in the POST body to override the
   * health policies used to evaluate the health. If the node that you specify by
   * name does not exist in the health store, this returns an error.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.clusterHealthPolicy] Describes the health policies
   * used to evaluate the health of a cluster or node. If not present, the health
   * evaluation uses the health policy from cluster manifest or the default
   * health policy.
   *
   * @param {boolean} [options.clusterHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number} [options.clusterHealthPolicy.maxPercentUnhealthyNodes] The
   * maximum allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [options.clusterHealthPolicy.maxPercentUnhealthyApplications] The maximum
   * allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be
   * 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array} [options.clusterHealthPolicy.applicationTypeHealthPolicyMap]
   * Defines a map with max percentage unhealthy applications for specific
   * application types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {NodeHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {NodeHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeHealthUsingPolicy(nodeName: string, options?: { eventsHealthStateFilter? : number, clusterHealthPolicy? : models.ClusterHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeHealth>;
  getNodeHealthUsingPolicy(nodeName: string, callback: ServiceCallback<models.NodeHealth>): void;
  getNodeHealthUsingPolicy(nodeName: string, options: { eventsHealthStateFilter? : number, clusterHealthPolicy? : models.ClusterHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportNodeHealthWithHttpOperationResponse(nodeName: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric node.
   *
   * Reports health state of the specified Service Fabric node. The report must
   * contain the information about the source of the health report and property
   * on which it is reported.
   * The report is sent to a Service Fabric gateway node, which forwards to the
   * health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run GetNodeHealth
   * and check that the report appears in the HealthEvents section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportNodeHealth(nodeName: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportNodeHealth(nodeName: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportNodeHealth(nodeName: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Retrieves the load information of a Service Fabric node for all the metrics
   * that have load or capacity defined.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeLoadInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeLoadInfoWithHttpOperationResponse(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeLoadInfo>>;

  /**
   * @summary Gets the load information of a Service Fabric node.
   *
   * Retrieves the load information of a Service Fabric node for all the metrics
   * that have load or capacity defined.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {NodeLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {NodeLoadInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeLoadInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeLoadInfo(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeLoadInfo>;
  getNodeLoadInfo(nodeName: string, callback: ServiceCallback<models.NodeLoadInfo>): void;
  getNodeLoadInfo(nodeName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeLoadInfo>): void;


  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node that is deactivated with
   * the Pause intent can be deactivated further with Restart, but not the other
   * way around. Nodes may be reactivated using the Activate a node operation any
   * time after they are deactivated. If the deactivation is not complete, this
   * will cancel the deactivation. A node that goes down and comes back up while
   * deactivated will still need to be reactivated before services will be placed
   * on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following. Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  disableNodeWithHttpOperationResponse(nodeName: string, deactivationIntentDescription: models.DeactivationIntentDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deactivate a Service Fabric cluster node with the specified
   * deactivation intent.
   *
   * Deactivate a Service Fabric cluster node with the specified deactivation
   * intent. Once the deactivation is in progress, the deactivation intent can be
   * increased, but not decreased (for example, a node that is deactivated with
   * the Pause intent can be deactivated further with Restart, but not the other
   * way around. Nodes may be reactivated using the Activate a node operation any
   * time after they are deactivated. If the deactivation is not complete, this
   * will cancel the deactivation. A node that goes down and comes back up while
   * deactivated will still need to be reactivated before services will be placed
   * on that node.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deactivationIntentDescription Describes the intent or reason
   * for deactivating the node.
   *
   * @param {string} [deactivationIntentDescription.deactivationIntent] Describes
   * the intent or reason for deactivating the node. The possible values are
   * following. Possible values include: 'Pause', 'Restart', 'RemoveData'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  disableNode(nodeName: string, deactivationIntentDescription: models.DeactivationIntentDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  disableNode(nodeName: string, deactivationIntentDescription: models.DeactivationIntentDescription, callback: ServiceCallback<void>): void;
  disableNode(nodeName: string, deactivationIntentDescription: models.DeactivationIntentDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Activate a Service Fabric cluster node that is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node that is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  enableNodeWithHttpOperationResponse(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Activate a Service Fabric cluster node that is currently
   * deactivated.
   *
   * Activates a Service Fabric cluster node that is currently deactivated. Once
   * activated, the node will again become a viable target for placing new
   * replicas, and any deactivated replicas remaining on the node will be
   * reactivated.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  enableNode(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  enableNode(nodeName: string, callback: ServiceCallback<void>): void;
  enableNode(nodeName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * This implies that it is not possible to recover the persisted state of that
   * node. This generally happens if a hard disk has been wiped clean, or if a
   * hard disk crashes. The node has to be down for this operation to be
   * successful. This operation lets Service Fabric know that the replicas on
   * that node no longer exist, and that Service Fabric should stop waiting for
   * those replicas to come back up. Do not run this cmdlet if the state on the
   * node has not been removed and the node can come back up with its state
   * intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  removeNodeStateWithHttpOperationResponse(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Notifies Service Fabric that the persisted state on a node has been
   * permanently removed or lost.
   *
   * This implies that it is not possible to recover the persisted state of that
   * node. This generally happens if a hard disk has been wiped clean, or if a
   * hard disk crashes. The node has to be down for this operation to be
   * successful. This operation lets Service Fabric know that the replicas on
   * that node no longer exist, and that Service Fabric should stop waiting for
   * those replicas to come back up. Do not run this cmdlet if the state on the
   * node has not been removed and the node can come back up with its state
   * intact.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  removeNodeState(nodeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  removeNodeState(nodeName: string, callback: ServiceCallback<void>): void;
  removeNodeState(nodeName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance ID of the
   * target node. If instance ID is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance ID. The instance ID can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case-sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  restartNodeWithHttpOperationResponse(nodeName: string, restartNodeDescription: models.RestartNodeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Restarts a Service Fabric cluster node.
   *
   * Restarts a Service Fabric cluster node that is already started.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} restartNodeDescription The instance of the node to be
   * restarted and a flag indicating the need to take dump of the fabric process.
   *
   * @param {string} restartNodeDescription.nodeInstanceId The instance ID of the
   * target node. If instance ID is specified the node is restarted only if it
   * matches with the current instance of the node. A default value of "0" would
   * match any instance ID. The instance ID can be obtained using get node query.
   *
   * @param {string} [restartNodeDescription.createFabricDump] Specify True to
   * create a dump of the fabric node process. This is case-sensitive. Possible
   * values include: 'False', 'True'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  restartNode(nodeName: string, restartNodeDescription: models.RestartNodeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  restartNode(nodeName: string, restartNodeDescription: models.RestartNodeDescription, callback: ServiceCallback<void>): void;
  restartNode(nodeName: string, restartNodeDescription: models.RestartNodeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status, and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token, which can be used to get the next page. For example,
   * if there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationTypeInfoListWithHttpOperationResponse(options?: { applicationTypeDefinitionKindFilter? : number, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedApplicationTypeInfoList>>;

  /**
   * @summary Gets the list of application types in the Service Fabric cluster.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. Each
   * version of an application type is returned as one application type. The
   * response includes the name, version, status, and other details about the
   * application type. This is a paged query, meaning that if not all of the
   * application types fit in a page, one page of results is returned as well as
   * a continuation token, which can be used to get the next page. For example,
   * if there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationTypeDefinitionKindFilter] Used to filter
   * on ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind
   * value. The value is 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind
   * value Compose. The value is 2.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedApplicationTypeInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoList(options?: { applicationTypeDefinitionKindFilter? : number, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedApplicationTypeInfoList>;
  getApplicationTypeInfoList(callback: ServiceCallback<models.PagedApplicationTypeInfoList>): void;
  getApplicationTypeInfoList(options: { applicationTypeDefinitionKindFilter? : number, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedApplicationTypeInfoList>): void;


  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status, and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.applicationTypeVersion] The version of the
   * application type.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationTypeInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationTypeInfoListByNameWithHttpOperationResponse(applicationTypeName: string, options?: { applicationTypeVersion? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedApplicationTypeInfoList>>;

  /**
   * @summary Gets the list of application types in the Service Fabric cluster
   * matching exactly the specified name.
   *
   * Returns the information about the application types that are provisioned or
   * in the process of being provisioned in the Service Fabric cluster. These
   * results are of application types whose name match exactly the one specified
   * as the parameter, and which comply with the given query parameters. All
   * versions of the application type matching the application type name are
   * returned, with each version returned as one application type. The response
   * includes the name, version, status, and other details about the application
   * type. This is a paged query, meaning that if not all of the application
   * types fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. For example, if
   * there are 10 application types but a page only fits the first three
   * application types, or if max results is set to 3, then three is returned. To
   * access the rest of the results, retrieve subsequent pages by using the
   * returned continuation token in the next query. An empty continuation token
   * is returned if there are no subsequent pages.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.applicationTypeVersion] The version of the
   * application type.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedApplicationTypeInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedApplicationTypeInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationTypeInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationTypeInfoListByName(applicationTypeName: string, options?: { applicationTypeVersion? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedApplicationTypeInfoList>;
  getApplicationTypeInfoListByName(applicationTypeName: string, callback: ServiceCallback<models.PagedApplicationTypeInfoList>): void;
  getApplicationTypeInfoListByName(applicationTypeName: string, options: { applicationTypeVersion? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedApplicationTypeInfoList>): void;


  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster using the '.sfpkg' package in the external store or using the
   * application package in the image store.
   *
   * Provisions a Service Fabric application type with the cluster. The provision
   * is required before any new applications can be instantiated.
   * The provision operation can be performed either on the application package
   * specified by the relativePathInImageStore, or by using the URI of the
   * external '.sfpkg'.
   *
   * @param {object} provisionApplicationTypeDescriptionBaseRequiredBodyParam The
   * base type of provision application type description which supports either
   * image store-based provision or external store-based provision.
   *
   * @param {boolean}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.async Indicates
   * whether or not provisioning should occur asynchronously. When set to true,
   * the provision operation returns when the request is accepted by the system,
   * and the provision operation continues without any timeout limit. The default
   * value is false. For large application packages, we recommend setting the
   * value to true.
   *
   * @param {string}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.kind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  provisionApplicationTypeWithHttpOperationResponse(provisionApplicationTypeDescriptionBaseRequiredBodyParam: models.ProvisionApplicationTypeDescriptionBase, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Provisions or registers a Service Fabric application type with the
   * cluster using the '.sfpkg' package in the external store or using the
   * application package in the image store.
   *
   * Provisions a Service Fabric application type with the cluster. The provision
   * is required before any new applications can be instantiated.
   * The provision operation can be performed either on the application package
   * specified by the relativePathInImageStore, or by using the URI of the
   * external '.sfpkg'.
   *
   * @param {object} provisionApplicationTypeDescriptionBaseRequiredBodyParam The
   * base type of provision application type description which supports either
   * image store-based provision or external store-based provision.
   *
   * @param {boolean}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.async Indicates
   * whether or not provisioning should occur asynchronously. When set to true,
   * the provision operation returns when the request is accepted by the system,
   * and the provision operation continues without any timeout limit. The default
   * value is false. For large application packages, we recommend setting the
   * value to true.
   *
   * @param {string}
   * provisionApplicationTypeDescriptionBaseRequiredBodyParam.kind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam: models.ProvisionApplicationTypeDescriptionBase, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam: models.ProvisionApplicationTypeDescriptionBase, callback: ServiceCallback<void>): void;
  provisionApplicationType(provisionApplicationTypeDescriptionBaseRequiredBodyParam: models.ProvisionApplicationTypeDescriptionBase, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * This operation can only be performed if all application instances of the
   * application type have been deleted. Once the application type is
   * unregistered, no new application instances can be created for this
   * particular application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} unprovisionApplicationTypeDescriptionInfo The relative path
   * for the application package in the image store specified during the prior
   * copy operation.
   *
   * @param {string}
   * unprovisionApplicationTypeDescriptionInfo.applicationTypeVersion The version
   * of the application type as defined in the application manifest.
   *
   * @param {boolean} [unprovisionApplicationTypeDescriptionInfo.async] The flag
   * indicating whether or not unprovision should occur asynchronously. When set
   * to true, the unprovision operation returns when the request is accepted by
   * the system, and the unprovision operation continues without any timeout
   * limit. The default value is false. However, we recommend setting it to true
   * for large application packages that were provisioned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  unprovisionApplicationTypeWithHttpOperationResponse(applicationTypeName: string, unprovisionApplicationTypeDescriptionInfo: models.UnprovisionApplicationTypeDescriptionInfo, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Removes or unregisters a Service Fabric application type from the
   * cluster.
   *
   * This operation can only be performed if all application instances of the
   * application type have been deleted. Once the application type is
   * unregistered, no new application instances can be created for this
   * particular application type.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {object} unprovisionApplicationTypeDescriptionInfo The relative path
   * for the application package in the image store specified during the prior
   * copy operation.
   *
   * @param {string}
   * unprovisionApplicationTypeDescriptionInfo.applicationTypeVersion The version
   * of the application type as defined in the application manifest.
   *
   * @param {boolean} [unprovisionApplicationTypeDescriptionInfo.async] The flag
   * indicating whether or not unprovision should occur asynchronously. When set
   * to true, the unprovision operation returns when the request is accepted by
   * the system, and the unprovision operation continues without any timeout
   * limit. The default value is false. However, we recommend setting it to true
   * for large application packages that were provisioned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  unprovisionApplicationType(applicationTypeName: string, unprovisionApplicationTypeDescriptionInfo: models.UnprovisionApplicationTypeDescriptionInfo, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  unprovisionApplicationType(applicationTypeName: string, unprovisionApplicationTypeDescriptionInfo: models.UnprovisionApplicationTypeDescriptionInfo, callback: ServiceCallback<void>): void;
  unprovisionApplicationType(applicationTypeName: string, unprovisionApplicationTypeDescriptionInfo: models.UnprovisionApplicationTypeDescriptionInfo, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * provided application type must exist. Otherwise, a 404 status is returned.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceTypeInfoListWithHttpOperationResponse(applicationTypeName: string, applicationTypeVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceTypeInfo[]>>;

  /**
   * @summary Gets the list containing the information about service types that
   * are supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types that are
   * supported by a provisioned application type in a Service Fabric cluster. The
   * provided application type must exist. Otherwise, a 404 status is returned.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceTypeInfoList(applicationTypeName: string, applicationTypeVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceTypeInfo[]>;
  getServiceTypeInfoList(applicationTypeName: string, applicationTypeVersion: string, callback: ServiceCallback<models.ServiceTypeInfo[]>): void;
  getServiceTypeInfoList(applicationTypeName: string, applicationTypeVersion: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceTypeInfo[]>): void;


  /**
   * @summary Gets the information about a specific service type that is
   * supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the information about a specific service type that is supported by a
   * provisioned application type in a Service Fabric cluster. The provided
   * application type must exist. Otherwise, a 404 status is returned. A 204
   * response is returned if the specificed service type is not found in the
   * cluster.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceTypeInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceTypeInfoByNameWithHttpOperationResponse(applicationTypeName: string, applicationTypeVersion: string, serviceTypeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceTypeInfo>>;

  /**
   * @summary Gets the information about a specific service type that is
   * supported by a provisioned application type in a Service Fabric cluster.
   *
   * Gets the information about a specific service type that is supported by a
   * provisioned application type in a Service Fabric cluster. The provided
   * application type must exist. Otherwise, a 404 status is returned. A 204
   * response is returned if the specificed service type is not found in the
   * cluster.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceTypeInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceTypeInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceTypeInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceTypeInfoByName(applicationTypeName: string, applicationTypeVersion: string, serviceTypeName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceTypeInfo>;
  getServiceTypeInfoByName(applicationTypeName: string, applicationTypeVersion: string, serviceTypeName: string, callback: ServiceCallback<models.ServiceTypeInfo>): void;
  getServiceTypeInfoByName(applicationTypeName: string, applicationTypeVersion: string, serviceTypeName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceTypeInfo>): void;


  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceTypeManifest>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceManifestWithHttpOperationResponse(applicationTypeName: string, applicationTypeVersion: string, serviceManifestName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceTypeManifest>>;

  /**
   * @summary Gets the manifest describing a service type.
   *
   * Gets the manifest describing a service type. The response contains the
   * service manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceTypeManifest} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceTypeManifest} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceManifest(applicationTypeName: string, applicationTypeVersion: string, serviceManifestName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceTypeManifest>;
  getServiceManifest(applicationTypeName: string, applicationTypeVersion: string, serviceManifestName: string, callback: ServiceCallback<models.ServiceTypeManifest>): void;
  getServiceManifest(applicationTypeName: string, applicationTypeVersion: string, serviceManifestName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceTypeManifest>): void;


  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation ID of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServiceTypeInfoListWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServiceTypeInfo[]>>;

  /**
   * @summary Gets the list containing the information about service types from
   * the applications deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about service types from the
   * applications deployed on a node in a Service Fabric cluster. The response
   * includes the name of the service type, its registration status, the code
   * package that registered it and activation ID of the service package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoList(nodeName: string, applicationId: string, options?: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServiceTypeInfo[]>;
  getDeployedServiceTypeInfoList(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedServiceTypeInfo[]>): void;
  getDeployedServiceTypeInfoList(nodeName: string, applicationId: string, options: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServiceTypeInfo[]>): void;


  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation ID of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation ID.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServiceTypeInfoByNameWithHttpOperationResponse(nodeName: string, applicationId: string, serviceTypeName: string, options?: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServiceTypeInfo[]>>;

  /**
   * @summary Gets the information about a specified service type of the
   * application deployed on a node in a Service Fabric cluster.
   *
   * Gets the list containing the information about a specific service type from
   * the applications deployed on a node in a Service Fabric cluster. The
   * response includes the name of the service type, its registration status, the
   * code package that registered it and activation ID of the service package.
   * Each entry represents one activation of a service type, differentiated by
   * the activation ID.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceTypeName Specifies the name of a Service Fabric
   * service type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of the service
   * manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service
   * types that are defined in this service manifest.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceTypeInfoByName(nodeName: string, applicationId: string, serviceTypeName: string, options?: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServiceTypeInfo[]>;
  getDeployedServiceTypeInfoByName(nodeName: string, applicationId: string, serviceTypeName: string, callback: ServiceCallback<models.DeployedServiceTypeInfo[]>): void;
  getDeployedServiceTypeInfoByName(nodeName: string, applicationId: string, serviceTypeName: string, options: { serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServiceTypeInfo[]>): void;


  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name The name of the application,
   * including the 'fabric:' URI scheme.
   *
   * @param {string} applicationDescription.typeName The application type name as
   * defined in the application manifest.
   *
   * @param {string} applicationDescription.typeVersion The version of the
   * application type as defined in the application manifest.
   *
   * @param {array} [applicationDescription.parameterList] List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {object} [applicationDescription.applicationCapacity] Describes
   * capacity information for services of this application. This description can
   * be used for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can
   * run on
   * - Limiting the custom capacity metrics to limit the total consumption of
   * this metric by the services of this application
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics] List of
   * application capacity metric description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createApplicationWithHttpOperationResponse(applicationDescription: models.ApplicationDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates a Service Fabric application.
   *
   * Creates a Service Fabric application using the specified description.
   *
   * @param {object} applicationDescription Description for creating an
   * application.
   *
   * @param {string} applicationDescription.name The name of the application,
   * including the 'fabric:' URI scheme.
   *
   * @param {string} applicationDescription.typeName The application type name as
   * defined in the application manifest.
   *
   * @param {string} applicationDescription.typeVersion The version of the
   * application type as defined in the application manifest.
   *
   * @param {array} [applicationDescription.parameterList] List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {object} [applicationDescription.applicationCapacity] Describes
   * capacity information for services of this application. This description can
   * be used for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can
   * run on
   * - Limiting the custom capacity metrics to limit the total consumption of
   * this metric by the services of this application
   *
   * @param {number} [applicationDescription.applicationCapacity.minimumNodes]
   * The minimum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. If this property is set to
   * zero, no capacity will be reserved. The value of this property cannot be
   * more than the value of the MaximumNodes property.
   *
   * @param {number} [applicationDescription.applicationCapacity.maximumNodes]
   * The maximum number of nodes where Service Fabric will reserve capacity for
   * this application. Note that this does not mean that the services of this
   * application will be placed on all of those nodes. By default, the value of
   * this property is zero and it means that the services can be placed on any
   * node.
   *
   * @param {array}
   * [applicationDescription.applicationCapacity.applicationMetrics] List of
   * application capacity metric description.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createApplication(applicationDescription: models.ApplicationDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createApplication(applicationDescription: models.ApplicationDescription, callback: ServiceCallback<void>): void;
  createApplication(applicationDescription: models.ApplicationDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * An application must be created before it can be deleted. Deleting an
   * application will delete all services that are part of that application. By
   * default, Service Fabric will try to close service replicas in a graceful
   * manner and then delete the service. However, if a service is having issues
   * closing the replica gracefully, the delete operation may take a long time or
   * get stuck. Use the optional ForceRemove flag to skip the graceful close
   * sequence and forcefully delete the application and all of its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteApplicationWithHttpOperationResponse(applicationId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes an existing Service Fabric application.
   *
   * An application must be created before it can be deleted. Deleting an
   * application will delete all services that are part of that application. By
   * default, Service Fabric will try to close service replicas in a graceful
   * manner and then delete the service. However, if a service is having issues
   * closing the replica gracefully, the delete operation may take a long time or
   * get stuck. Use the optional ForceRemove flag to skip the graceful close
   * sequence and forcefully delete the application and all of its services.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplication(applicationId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteApplication(applicationId: string, callback: ServiceCallback<void>): void;
  deleteApplication(applicationId: string, options: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the application is
   * occupying currently, and application load metric information about the
   * application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationLoadInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationLoadInfoWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationLoadInfo>>;

  /**
   * @summary Gets load information about a Service Fabric application.
   *
   * Returns the load information about the application that was created or in
   * the process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * minimum nodes, maximum nodes, the number of nodes the application is
   * occupying currently, and application load metric information about the
   * application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationLoadInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationLoadInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationLoadInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationLoadInfo(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationLoadInfo>;
  getApplicationLoadInfo(applicationId: string, callback: ServiceCallback<models.ApplicationLoadInfo>): void;
  getApplicationLoadInfo(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationLoadInfo>): void;


  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match the specified filters.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match the
   * specified filters. The response includes the name, type, status, parameters,
   * and other details about the application. If the applications do not fit in a
   * page, one page of results is returned as well as a continuation token, which
   * can be used to get the next page. Filters ApplicationTypeName and
   * ApplicationDefinitionKindFilter cannot be specified at the same time.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedApplicationInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationInfoListWithHttpOperationResponse(options?: { applicationDefinitionKindFilter? : number, applicationTypeName? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedApplicationInfoList>>;

  /**
   * @summary Gets the list of applications created in the Service Fabric cluster
   * that match the specified filters.
   *
   * Gets the information about the applications that were created or in the
   * process of being created in the Service Fabric cluster and match the
   * specified filters. The response includes the name, type, status, parameters,
   * and other details about the application. If the applications do not fit in a
   * page, one page of results is returned as well as a continuation token, which
   * can be used to get the next page. Filters ApplicationTypeName and
   * ApplicationDefinitionKindFilter cannot be specified at the same time.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.applicationDefinitionKindFilter] Used to filter on
   * ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting
   * "All". The value is 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value.
   * The value is 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The
   * value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value
   * Compose. The value is 2.
   *
   * @param {string} [options.applicationTypeName] The application type name used
   * to filter the applications to query for. This value should not contain the
   * application type version.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedApplicationInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedApplicationInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedApplicationInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfoList(options?: { applicationDefinitionKindFilter? : number, applicationTypeName? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedApplicationInfoList>;
  getApplicationInfoList(callback: ServiceCallback<models.PagedApplicationInfoList>): void;
  getApplicationInfoList(options: { applicationDefinitionKindFilter? : number, applicationTypeName? : string, excludeApplicationParameters? : boolean, continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedApplicationInfoList>): void;


  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters, and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationInfoWithHttpOperationResponse(applicationId: string, options?: { excludeApplicationParameters? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationInfo>>;

  /**
   * @summary Gets information about a Service Fabric application.
   *
   * Returns the information about the application that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * type, status, parameters, and other details about the application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.excludeApplicationParameters] The flag that
   * specifies whether application parameters will be excluded from the result.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationInfo(applicationId: string, options?: { excludeApplicationParameters? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationInfo>;
  getApplicationInfo(applicationId: string, callback: ServiceCallback<models.ApplicationInfo>): void;
  getApplicationInfo(applicationId: string, options: { excludeApplicationParameters? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationInfo>): void;


  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the health store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationHealthWithHttpOperationResponse(applicationId: string, options?: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationHealth>>;

  /**
   * @summary Gets the health of the service fabric application.
   *
   * Returns the heath state of the service fabric application. The response
   * reports either Ok, Error or Warning health state. If the entity is not found
   * in the health store, it will return Error.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealth(applicationId: string, options?: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationHealth>;
  getApplicationHealth(applicationId: string, callback: ServiceCallback<models.ApplicationHealth>): void;
  getApplicationHealth(applicationId: string, options: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationHealth>): void;


  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationHealthUsingPolicyWithHttpOperationResponse(applicationId: string, options?: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationHealth>>;

  /**
   * @summary Gets the health of a Service Fabric application using the specified
   * policy.
   *
   * Gets the health of a Service Fabric application. Use EventsHealthStateFilter
   * to filter the collection of health events reported on the node based on the
   * health state. Use ClusterHealthPolicies to override the health policies used
   * to evaluate the health.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedApplicationsHealthStateFilter] Allows
   * filtering of the deployed applications health state objects returned in the
   * result of application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states. Only deployed applications that match the filter
   * will be returned.
   * All deployed applications are used to evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a
   * combination of these values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed
   * applications with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.servicesHealthStateFilter] Allows filtering of the
   * services health state objects returned in the result of services health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only services that match the filter are returned. All services are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of services with HealthState value of OK (2) and Warning
   * (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationHealthUsingPolicy(applicationId: string, options?: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationHealth>;
  getApplicationHealthUsingPolicy(applicationId: string, callback: ServiceCallback<models.ApplicationHealth>): void;
  getApplicationHealthUsingPolicy(applicationId: string, options: { eventsHealthStateFilter? : number, deployedApplicationsHealthStateFilter? : number, servicesHealthStateFilter? : number, excludeHealthStatistics? : boolean, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportApplicationHealthWithHttpOperationResponse(applicationId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric application.
   *
   * Reports health state of the specified Service Fabric application. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Application, which forwards
   * to the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get application
   * health and check that the report appears in the HealthEvents section.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportApplicationHealth(applicationId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportApplicationHealth(applicationId: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportApplicationHealth(applicationId: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name The name of the target
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   * The target application type version (found in the application manifest) for
   * the application upgrade.
   *
   * @param {array} applicationUpgradeDescription.parameters List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {string} applicationUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   * Defines a health policy used to evaluate the health of an application or one
   * of its children entities.
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startApplicationUpgradeWithHttpOperationResponse(applicationId: string, applicationUpgradeDescription: models.ApplicationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Starts upgrading an application in the Service Fabric cluster.
   *
   * Validates the supplied application upgrade parameters and starts upgrading
   * the application if the parameters are valid.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeDescription Parameters for an application
   * upgrade.
   *
   * @param {string} applicationUpgradeDescription.name The name of the target
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeDescription.targetApplicationTypeVersion
   * The target application type version (found in the application manifest) for
   * the application upgrade.
   *
   * @param {array} applicationUpgradeDescription.parameters List of application
   * parameters with overridden values from their default values specified in the
   * application manifest.
   *
   * @param {string} applicationUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [applicationUpgradeDescription.rollingUpgradeMode] The mode
   * used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [applicationUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds] The
   * maximum amount of time to block processing of an upgrade domain and prevent
   * loss of availability when there are unexpected issues. When this timeout
   * expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [applicationUpgradeDescription.forceRestart] If true, then
   * processes are forcefully restarted during upgrade even when the code version
   * has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [applicationUpgradeDescription.monitoringPolicy] Describes
   * the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [applicationUpgradeDescription.applicationHealthPolicy]
   * Defines a health policy used to evaluate the health of an application or one
   * of its children entities.
   *
   * @param {boolean}
   * [applicationUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startApplicationUpgrade(applicationId: string, applicationUpgradeDescription: models.ApplicationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startApplicationUpgrade(applicationId: string, applicationUpgradeDescription: models.ApplicationUpgradeDescription, callback: ServiceCallback<void>): void;
  startApplicationUpgrade(applicationId: string, applicationUpgradeDescription: models.ApplicationUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationUpgradeWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationUpgradeProgressInfo>>;

  /**
   * @summary Gets details for the latest upgrade performed on this application.
   *
   * Returns information about the state of the latest application upgrade along
   * with details to aid debugging application health issues.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationUpgradeProgressInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationUpgradeProgressInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationUpgrade(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationUpgradeProgressInfo>;
  getApplicationUpgrade(applicationId: string, callback: ServiceCallback<models.ApplicationUpgradeProgressInfo>): void;
  getApplicationUpgrade(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationUpgradeProgressInfo>): void;


  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart] If
   * true, then processes are forcefully restarted during upgrade even when the
   * code version has not changed (the upgrade only changes configuration or
   * data).
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateApplicationUpgradeWithHttpOperationResponse(applicationId: string, applicationUpgradeUpdateDescription: models.ApplicationUpgradeUpdateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Updates an ongoing application upgrade in the Service Fabric
   * cluster.
   *
   * Updates the parameters of an ongoing application upgrade from the ones
   * specified at the time of starting the application upgrade. This may be
   * required to mitigate stuck application upgrades due to incorrect parameters
   * or issues in the application to make progress.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} applicationUpgradeUpdateDescription Parameters for updating
   * an existing application upgrade.
   *
   * @param {string} applicationUpgradeUpdateDescription.name The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} applicationUpgradeUpdateDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [applicationUpgradeUpdateDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [applicationUpgradeUpdateDescription.updateDescription]
   * Describes the parameters for updating a rolling upgrade of application or
   * cluster.
   *
   * @param {string}
   * applicationUpgradeUpdateDescription.updateDescription.rollingUpgradeMode The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {boolean}
   * [applicationUpgradeUpdateDescription.updateDescription.forceRestart] If
   * true, then processes are forcefully restarted during upgrade even when the
   * code version has not changed (the upgrade only changes configuration or
   * data).
   *
   * @param {number}
   * [applicationUpgradeUpdateDescription.updateDescription.replicaSetCheckTimeoutInMilliseconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [applicationUpgradeUpdateDescription.updateDescription.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationUpgrade(applicationId: string, applicationUpgradeUpdateDescription: models.ApplicationUpgradeUpdateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  updateApplicationUpgrade(applicationId: string, applicationUpgradeUpdateDescription: models.ApplicationUpgradeUpdateDescription, callback: ServiceCallback<void>): void;
  updateApplicationUpgrade(applicationId: string, applicationUpgradeUpdateDescription: models.ApplicationUpgradeUpdateDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resumeApplicationUpgradeWithHttpOperationResponse(applicationId: string, resumeApplicationUpgradeDescription: models.ResumeApplicationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Resumes upgrading an application in the Service Fabric cluster.
   *
   * Resumes an unmonitored manual Service Fabric application upgrade. Service
   * Fabric upgrades one upgrade domain at a time. For unmonitored manual
   * upgrades, after Service Fabric finishes an upgrade domain, it waits for you
   * to call this API before proceeding to the next upgrade domain.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} resumeApplicationUpgradeDescription Describes the parameters
   * for resuming an application upgrade.
   *
   * @param {string} resumeApplicationUpgradeDescription.upgradeDomainName The
   * name of the upgrade domain in which to resume the upgrade.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeApplicationUpgrade(applicationId: string, resumeApplicationUpgradeDescription: models.ResumeApplicationUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resumeApplicationUpgrade(applicationId: string, resumeApplicationUpgradeDescription: models.ResumeApplicationUpgradeDescription, callback: ServiceCallback<void>): void;
  resumeApplicationUpgrade(applicationId: string, resumeApplicationUpgradeDescription: models.ResumeApplicationUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to roll back the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version,
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  rollbackApplicationUpgradeWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Starts rolling back the currently on-going upgrade of an
   * application in the Service Fabric cluster.
   *
   * Starts rolling back the current application upgrade to the previous version.
   * This API can only be used to roll back the current in-progress upgrade that
   * is rolling forward to new version. If the application is not currently being
   * upgraded use StartApplicationUpgrade API to upgrade it to desired version,
   * including rolling back to a previous version.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  rollbackApplicationUpgrade(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  rollbackApplicationUpgrade(applicationId: string, callback: ServiceCallback<void>): void;
  rollbackApplicationUpgrade(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node. The results
   * do not include information about deployed system applications unless
   * explicitly queried for by ID. Results encompass deployed applications in
   * active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedDeployedApplicationInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedApplicationInfoListWithHttpOperationResponse(nodeName: string, options?: { timeout? : number, includeHealthState? : boolean, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedDeployedApplicationInfoList>>;

  /**
   * @summary Gets the list of applications deployed on a Service Fabric node.
   *
   * Gets the list of applications deployed on a Service Fabric node. The results
   * do not include information about deployed system applications unless
   * explicitly queried for by ID. Results encompass deployed applications in
   * active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedDeployedApplicationInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedDeployedApplicationInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedDeployedApplicationInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfoList(nodeName: string, options?: { timeout? : number, includeHealthState? : boolean, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedDeployedApplicationInfoList>;
  getDeployedApplicationInfoList(nodeName: string, callback: ServiceCallback<models.PagedDeployedApplicationInfoList>): void;
  getDeployedApplicationInfoList(nodeName: string, options: { timeout? : number, includeHealthState? : boolean, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedDeployedApplicationInfoList>): void;


  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * This query returns system application information if the application ID
   * provided is for system application. Results encompass deployed applications
   * in active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedApplicationInfoWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { timeout? : number, includeHealthState? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedApplicationInfo>>;

  /**
   * @summary Gets the information about an application deployed on a Service
   * Fabric node.
   *
   * This query returns system application information if the application ID
   * provided is for system application. Results encompass deployed applications
   * in active, activating, and downloading states. This query requires that the
   * node name corresponds to a node on the cluster. The query fails if the
   * provided node name does not point to any active Service Fabric nodes on the
   * cluster.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.includeHealthState] Include the health state of an
   * entity.
   * If this parameter is false or not specified, then the health state returned
   * is "Unknown".
   * When set to true, the query goes in parallel to the node and the health
   * system service before the results are merged.
   * As a result, the query is more expensive and may take a longer time.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedApplicationInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedApplicationInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationInfo(nodeName: string, applicationId: string, options?: { timeout? : number, includeHealthState? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedApplicationInfo>;
  getDeployedApplicationInfo(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedApplicationInfo>): void;
  getDeployedApplicationInfo(nodeName: string, applicationId: string, options: { timeout? : number, includeHealthState? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedApplicationInfo>): void;


  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedApplicationHealthWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedApplicationHealth>>;

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node. Use EventsHealthStateFilter to optionally filter for the
   * collection of HealthEvent objects reported on the deployed application based
   * on health state. Use DeployedServicePackagesHealthStateFilter to optionally
   * filter for DeployedServicePackageHealth children based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedApplicationHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealth(nodeName: string, applicationId: string, options?: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedApplicationHealth>;
  getDeployedApplicationHealth(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedApplicationHealth>): void;
  getDeployedApplicationHealth(nodeName: string, applicationId: string, options: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedApplicationHealth>): void;


  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedApplicationHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedApplicationHealthUsingPolicyWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedApplicationHealth>>;

  /**
   * @summary Gets the information about health of an application deployed on a
   * Service Fabric node. using the specified policy.
   *
   * Gets the information about health of an application deployed on a Service
   * Fabric node using the specified policy. Use EventsHealthStateFilter to
   * optionally filter for the collection of HealthEvent objects reported on the
   * deployed application based on health state. Use
   * DeployedServicePackagesHealthStateFilter to optionally filter for
   * DeployedServicePackageHealth children based on health state. Use
   * ApplicationHealthPolicy to optionally override the health policies used to
   * evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the deployed application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.deployedServicePackagesHealthStateFilter] Allows
   * filtering of the deployed service package health state objects returned in
   * the result of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only deployed service packages that match the filter are returned. All
   * deployed service packages are used to evaluate the aggregated health state
   * of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a
   * combination of these values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service
   * packages with HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedApplicationHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedApplicationHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedApplicationHealth} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedApplicationHealthUsingPolicy(nodeName: string, applicationId: string, options?: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedApplicationHealth>;
  getDeployedApplicationHealthUsingPolicy(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedApplicationHealth>): void;
  getDeployedApplicationHealthUsingPolicy(nodeName: string, applicationId: string, options: { eventsHealthStateFilter? : number, deployedServicePackagesHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedApplicationHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportDeployedApplicationHealthWithHttpOperationResponse(nodeName: string, applicationId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric application deployed on
   * a Service Fabric node.
   *
   * Reports health state of the application deployed on a Service Fabric node.
   * The report must contain the information about the source of the health
   * report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * application health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedApplicationHealth(nodeName: string, applicationId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportDeployedApplicationHealth(nodeName: string, applicationId: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportDeployedApplicationHealth(nodeName: string, applicationId: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the manifest describing an application type.
   *
   * The response contains the application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationTypeManifest>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationManifestWithHttpOperationResponse(applicationTypeName: string, applicationTypeVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationTypeManifest>>;

  /**
   * @summary Gets the manifest describing an application type.
   *
   * The response contains the application manifest XML as a string.
   *
   * @param {string} applicationTypeName The name of the application type.
   *
   * @param {string} applicationTypeVersion The version of the application type.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationTypeManifest} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationTypeManifest} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationTypeManifest} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationManifest(applicationTypeName: string, applicationTypeVersion: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationTypeManifest>;
  getApplicationManifest(applicationTypeName: string, applicationTypeVersion: string, callback: ServiceCallback<models.ApplicationTypeManifest>): void;
  getApplicationManifest(applicationTypeName: string, applicationTypeVersion: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationTypeManifest>): void;


  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application ID.
   *
   * Returns the information about all services belonging to the application
   * specified by the application ID.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServiceInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceInfoListWithHttpOperationResponse(applicationId: string, options?: { serviceTypeName? : string, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedServiceInfoList>>;

  /**
   * @summary Gets the information about all services belonging to the
   * application specified by the application ID.
   *
   * Returns the information about all services belonging to the application
   * specified by the application ID.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceTypeName] The service type name used to
   * filter the services to query for.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedServiceInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedServiceInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServiceInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfoList(applicationId: string, options?: { serviceTypeName? : string, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedServiceInfoList>;
  getServiceInfoList(applicationId: string, callback: ServiceCallback<models.PagedServiceInfoList>): void;
  getServiceInfoList(applicationId: string, options: { serviceTypeName? : string, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedServiceInfoList>): void;


  /**
   * @summary Gets the information about the specific service belonging to the
   * Service Fabric application.
   *
   * Returns the information about the specified service belonging to the
   * specified Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceInfoWithHttpOperationResponse(applicationId: string, serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceInfo>>;

  /**
   * @summary Gets the information about the specific service belonging to the
   * Service Fabric application.
   *
   * Returns the information about the specified service belonging to the
   * specified Service Fabric application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceInfo(applicationId: string, serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceInfo>;
  getServiceInfo(applicationId: string, serviceId: string, callback: ServiceCallback<models.ServiceInfo>): void;
  getServiceInfo(applicationId: string, serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceInfo>): void;


  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * Gets the name of the application for the specified service. A 404
   * FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the
   * provided service ID does not exist.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationNameInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationNameInfoWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationNameInfo>>;

  /**
   * @summary Gets the name of the Service Fabric application for a service.
   *
   * Gets the name of the application for the specified service. A 404
   * FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the
   * provided service ID does not exist.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationNameInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationNameInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationNameInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationNameInfo(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationNameInfo>;
  getApplicationNameInfo(serviceId: string, callback: ServiceCallback<models.ApplicationNameInfo>): void;
  getApplicationNameInfo(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationNameInfo>): void;


  /**
   * @summary Creates the specified Service Fabric service.
   *
   * This api allows creating a new Service Fabric stateless or stateful service
   * under a specified Service Fabric application. The description for creating
   * the service includes partitioning information and optional properties for
   * placement and load balancing. Some of the properties can later be modified
   * using `UpdateService` API.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName] The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceName The full name of the service
   * with 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceTypeName Name of the service type
   * as specified in the service manifest.
   *
   * @param {array} [serviceDescription.initializationData] The initialization
   * data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   *
   * @param {object} serviceDescription.partitionDescription The partition
   * description as an object.
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceDescription.serviceLoadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceDescription.servicePlacementPolicies] The service
   * placement policies.
   *
   * @param {string} [serviceDescription.defaultMoveCost] The move cost for the
   * service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible values
   * include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {array} [serviceDescription.scalingPolicies] Scaling policies for
   * this service.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createServiceWithHttpOperationResponse(applicationId: string, serviceDescription: models.ServiceDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates the specified Service Fabric service.
   *
   * This api allows creating a new Service Fabric stateless or stateful service
   * under a specified Service Fabric application. The description for creating
   * the service includes partitioning information and optional properties for
   * placement and load balancing. Some of the properties can later be modified
   * using `UpdateService` API.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceDescription The information necessary to create a
   * service.
   *
   * @param {string} [serviceDescription.applicationName] The name of the
   * application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceName The full name of the service
   * with 'fabric:' URI scheme.
   *
   * @param {string} serviceDescription.serviceTypeName Name of the service type
   * as specified in the service manifest.
   *
   * @param {array} [serviceDescription.initializationData] The initialization
   * data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   *
   * @param {object} serviceDescription.partitionDescription The partition
   * description as an object.
   *
   * @param {string} serviceDescription.partitionDescription.partitionScheme
   * Polymorphic Discriminator
   *
   * @param {string} [serviceDescription.placementConstraints] The placement
   * constraints as a string. Placement constraints are boolean expressions on
   * node properties and allow for restricting a service to particular nodes
   * based on the service requirements. For example, to place a service on nodes
   * where NodeType is blue specify the following: "NodeColor == blue)".
   *
   * @param {array} [serviceDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceDescription.serviceLoadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceDescription.servicePlacementPolicies] The service
   * placement policies.
   *
   * @param {string} [serviceDescription.defaultMoveCost] The move cost for the
   * service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {boolean} [serviceDescription.isDefaultMoveCostSpecified] Indicates
   * if the DefaultMoveCost property is specified.
   *
   * @param {string} [serviceDescription.servicePackageActivationMode] The
   * activation mode of service package to be used for a service. Possible values
   * include: 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceDescription.serviceDnsName] The DNS name of the
   * service. It requires the DNS system service to be enabled in Service Fabric
   * cluster.
   *
   * @param {array} [serviceDescription.scalingPolicies] Scaling policies for
   * this service.
   *
   * @param {string} serviceDescription.serviceKind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createService(applicationId: string, serviceDescription: models.ServiceDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createService(applicationId: string, serviceDescription: models.ServiceDescription, callback: ServiceCallback<void>): void;
  createService(applicationId: string, serviceDescription: models.ServiceDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Creates a Service Fabric service from the service template.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest. A service template contains the properties that will
   * be same for the service instance of the same type. The API allows overriding
   * the properties that are usually different for different services of the same
   * service type.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName The name of
   * the application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceName The full name of
   * the service with 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName Name of the
   * service type as specified in the service manifest.
   *
   * @param {array} [serviceFromTemplateDescription.initializationData] The
   * initialization data for the newly created service instance.
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] The activation
   * mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createServiceFromTemplateWithHttpOperationResponse(applicationId: string, serviceFromTemplateDescription: models.ServiceFromTemplateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates a Service Fabric service from the service template.
   *
   * Creates a Service Fabric service from the service template defined in the
   * application manifest. A service template contains the properties that will
   * be same for the service instance of the same type. The API allows overriding
   * the properties that are usually different for different services of the same
   * service type.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} serviceFromTemplateDescription Describes the service that
   * needs to be created from the template defined in the application manifest.
   *
   * @param {string} serviceFromTemplateDescription.applicationName The name of
   * the application, including the 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceName The full name of
   * the service with 'fabric:' URI scheme.
   *
   * @param {string} serviceFromTemplateDescription.serviceTypeName Name of the
   * service type as specified in the service manifest.
   *
   * @param {array} [serviceFromTemplateDescription.initializationData] The
   * initialization data for the newly created service instance.
   *
   * @param {string}
   * [serviceFromTemplateDescription.servicePackageActivationMode] The activation
   * mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   *
   * @param {string} [serviceFromTemplateDescription.serviceDnsName] The DNS name
   * of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createServiceFromTemplate(applicationId: string, serviceFromTemplateDescription: models.ServiceFromTemplateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createServiceFromTemplate(applicationId: string, serviceFromTemplateDescription: models.ServiceFromTemplateDescription, callback: ServiceCallback<void>): void;
  createServiceFromTemplate(applicationId: string, serviceFromTemplateDescription: models.ServiceFromTemplateDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * A service must be created before it can be deleted. By default, Service
   * Fabric will try to close service replicas in a graceful manner and then
   * delete the service. However, if the service is having issues closing the
   * replica gracefully, the delete operation may take a long time or get stuck.
   * Use the optional ForceRemove flag to skip the graceful close sequence and
   * forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteServiceWithHttpOperationResponse(serviceId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes an existing Service Fabric service.
   *
   * A service must be created before it can be deleted. By default, Service
   * Fabric will try to close service replicas in a graceful manner and then
   * delete the service. However, if the service is having issues closing the
   * replica gracefully, the delete operation may take a long time or get stuck.
   * Use the optional ForceRemove flag to skip the graceful close sequence and
   * forcefully delete the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteService(serviceId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteService(serviceId: string, callback: ServiceCallback<void>): void;
  deleteService(serviceId: string, options: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Updates a Service Fabric service using the specified update
   * description.
   *
   * This API allows updating properties of a running Service Fabric service. The
   * set of properties that can be updated are a subset of the properties that
   * were specified at the time of creating the service. The current set of
   * properties can be obtained using `GetServiceDescription` API. Note that
   * updating the properties of a running service is different than upgrading
   * your application using `StartApplicationUpgrade` API. The upgrade is a long
   * running background operation that involves moving the application from one
   * version to another, one upgrade domain at a time, whereas update applies the
   * new properties immediately to the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceUpdateDescription.loadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies] The
   * service placement policies.
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] The move cost for
   * the service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {array} [serviceUpdateDescription.scalingPolicies] Scaling policies
   * for this service.
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateServiceWithHttpOperationResponse(serviceId: string, serviceUpdateDescription: models.ServiceUpdateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Updates a Service Fabric service using the specified update
   * description.
   *
   * This API allows updating properties of a running Service Fabric service. The
   * set of properties that can be updated are a subset of the properties that
   * were specified at the time of creating the service. The current set of
   * properties can be obtained using `GetServiceDescription` API. Note that
   * updating the properties of a running service is different than upgrading
   * your application using `StartApplicationUpgrade` API. The upgrade is a long
   * running background operation that involves moving the application from one
   * version to another, one upgrade domain at a time, whereas update applies the
   * new properties immediately to the service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} serviceUpdateDescription The information necessary to update
   * a service.
   *
   * @param {string} [serviceUpdateDescription.flags] Flags indicating whether
   * other properties are set. Each of the associated properties corresponds to a
   * flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise
   * 'OR' operator.
   * For example, if the provided value is 6 then the flags for
   * ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the
   * TargetReplicaSetSize property (for Stateful services) or the InstanceCount
   * property (for Stateless services) is set. The value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration
   * property is set. The value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is
   * set. The value is 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration
   * property is set. The value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The
   * value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set.
   * The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is
   * set. The value is 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value
   * is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is
   * 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value
   * is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value
   * is 1024.
   *
   * @param {string} [serviceUpdateDescription.placementConstraints] The
   * placement constraints as a string. Placement constraints are boolean
   * expressions on node properties and allow for restricting a service to
   * particular nodes based on the service requirements. For example, to place a
   * service on nodes where NodeType is blue specify the following: "NodeColor ==
   * blue)".
   *
   * @param {array} [serviceUpdateDescription.correlationScheme] The correlation
   * scheme.
   *
   * @param {array} [serviceUpdateDescription.loadMetrics] The service load
   * metrics.
   *
   * @param {array} [serviceUpdateDescription.servicePlacementPolicies] The
   * service placement policies.
   *
   * @param {string} [serviceUpdateDescription.defaultMoveCost] The move cost for
   * the service. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   *
   * @param {array} [serviceUpdateDescription.scalingPolicies] Scaling policies
   * for this service.
   *
   * @param {string} serviceUpdateDescription.serviceKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateService(serviceId: string, serviceUpdateDescription: models.ServiceUpdateDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  updateService(serviceId: string, serviceUpdateDescription: models.ServiceUpdateDescription, callback: ServiceCallback<void>): void;
  updateService(serviceId: string, serviceUpdateDescription: models.ServiceUpdateDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceDescriptionWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceDescription>>;

  /**
   * @summary Gets the description of an existing Service Fabric service.
   *
   * Gets the description of an existing Service Fabric service. A service must
   * be created before its description can be obtained.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceDescription} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceDescription(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceDescription>;
  getServiceDescription(serviceId: string, callback: ServiceCallback<models.ServiceDescription>): void;
  getServiceDescription(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceDescription>): void;


  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceHealthWithHttpOperationResponse(serviceId: string, options?: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceHealth>>;

  /**
   * @summary Gets the health of the specified Service Fabric service.
   *
   * Gets the health information of the specified service.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealth(serviceId: string, options?: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceHealth>;
  getServiceHealth(serviceId: string, callback: ServiceCallback<models.ServiceHealth>): void;
  getServiceHealth(serviceId: string, options: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceHealth>): void;


  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceHealthUsingPolicyWithHttpOperationResponse(serviceId: string, options?: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceHealth>>;

  /**
   * @summary Gets the health of the specified Service Fabric service, by using
   * the specified health policy.
   *
   * Gets the health information of the specified service.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use PartitionsHealthStateFilter to filter the collection of partitions
   * returned.
   * If you specify a service that does not exist in the health store, this
   * request returns an error.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.partitionsHealthStateFilter] Allows filtering of
   * the partitions health state objects returned in the result of service health
   * query based on their health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only partitions that match the filter are returned. All partitions are used
   * to evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is
   * 6 then health state of partitions with HealthState value of OK (2) and
   * Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceHealthUsingPolicy(serviceId: string, options?: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceHealth>;
  getServiceHealthUsingPolicy(serviceId: string, callback: ServiceCallback<models.ServiceHealth>): void;
  getServiceHealthUsingPolicy(serviceId: string, options: { eventsHealthStateFilter? : number, partitionsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportServiceHealthWithHttpOperationResponse(serviceId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric service.
   *
   * Reports health state of the specified Service Fabric service. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetServiceHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportServiceHealth(serviceId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportServiceHealth(serviceId: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportServiceHealth(serviceId: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
   * the partition. This is valid for the partitions with partitioning scheme as
   * Named. The value is 3.
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was gotten previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResolvedServicePartition>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resolveServiceWithHttpOperationResponse(serviceId: string, options?: { partitionKeyType? : number, partitionKeyValue? : string, previousRspVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ResolvedServicePartition>>;

  /**
   * @summary Resolve a Service Fabric partition.
   *
   * Resolve a Service Fabric service partition to get the endpoints of the
   * service replicas.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.partitionKeyType] Key type for the partition. This
   * parameter is required if the partition scheme for the service is Int64Range
   * or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not
   * specified. This is valid for the partitions with partitioning scheme as
   * Singleton. This is the default value. The value is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an
   * int64 partition key. This is valid for the partitions with partitioning
   * scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of
   * the partition. This is valid for the partitions with partitioning scheme as
   * Named. The value is 3.
   *
   * @param {string} [options.partitionKeyValue] Partition key. This is required
   * if the partition scheme for the service is Int64Range or Named.
   *
   * @param {string} [options.previousRspVersion] The value in the Version field
   * of the response that was received previously. This is required if the user
   * knows that the result that was gotten previously is stale.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ResolvedServicePartition} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ResolvedServicePartition} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResolvedServicePartition} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resolveService(serviceId: string, options?: { partitionKeyType? : number, partitionKeyValue? : string, previousRspVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ResolvedServicePartition>;
  resolveService(serviceId: string, callback: ServiceCallback<models.ResolvedServicePartition>): void;
  resolveService(serviceId: string, options: { partitionKeyType? : number, partitionKeyValue? : string, previousRspVersion? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ResolvedServicePartition>): void;


  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * The response includes the partition ID, partitioning scheme information,
   * keys supported by the partition, status, health, and other details about the
   * partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServicePartitionInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionInfoListWithHttpOperationResponse(serviceId: string, options?: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedServicePartitionInfoList>>;

  /**
   * @summary Gets the list of partitions of a Service Fabric service.
   *
   * The response includes the partition ID, partitioning scheme information,
   * keys supported by the partition, status, health, and other details about the
   * partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedServicePartitionInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedServicePartitionInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServicePartitionInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfoList(serviceId: string, options?: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedServicePartitionInfoList>;
  getPartitionInfoList(serviceId: string, callback: ServiceCallback<models.PagedServicePartitionInfoList>): void;
  getPartitionInfoList(serviceId: string, options: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedServicePartitionInfoList>): void;


  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * Gets the information about the specified partition. The response includes
   * the partition ID, partitioning scheme information, keys supported by the
   * partition, status, health, and other details about the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServicePartitionInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionInfoWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServicePartitionInfo>>;

  /**
   * @summary Gets the information about a Service Fabric partition.
   *
   * Gets the information about the specified partition. The response includes
   * the partition ID, partitioning scheme information, keys supported by the
   * partition, status, health, and other details about the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServicePartitionInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServicePartitionInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServicePartitionInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionInfo(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServicePartitionInfo>;
  getPartitionInfo(partitionId: string, callback: ServiceCallback<models.ServicePartitionInfo>): void;
  getPartitionInfo(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServicePartitionInfo>): void;


  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * Gets name of the service for the specified partition. A 404 error is
   * returned if the partition ID does not exist in the cluster.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceNameInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceNameInfoWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceNameInfo>>;

  /**
   * @summary Gets the name of the Service Fabric service for a partition.
   *
   * Gets name of the service for the specified partition. A 404 error is
   * returned if the partition ID does not exist in the cluster.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceNameInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceNameInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceNameInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceNameInfo(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceNameInfo>;
  getServiceNameInfo(partitionId: string, callback: ServiceCallback<models.ServiceNameInfo>): void;
  getServiceNameInfo(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceNameInfo>): void;


  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionHealthWithHttpOperationResponse(partitionId: string, options?: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionHealth>>;

  /**
   * @summary Gets the health of the specified Service Fabric partition.
   *
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the service based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealth(partitionId: string, options?: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionHealth>;
  getPartitionHealth(partitionId: string, callback: ServiceCallback<models.PartitionHealth>): void;
  getPartitionHealth(partitionId: string, options: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionHealth>): void;


  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionHealthUsingPolicyWithHttpOperationResponse(partitionId: string, options?: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionHealth>>;

  /**
   * @summary Gets the health of the specified Service Fabric partition, by using
   * the specified health policy.
   *
   * Gets the health information of the specified partition.
   * If the application health policy is specified, the health evaluation uses it
   * to get the aggregated health state.
   * If the policy is not specified, the health evaluation uses the application
   * health policy defined in the application manifest, or the default health
   * policy, if no policy is defined in the manifest.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the partition based on the health state.
   * Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState
   * objects on the partition. Use ApplicationHealthPolicy in the POST body to
   * override the health policies used to evaluate the health.
   * If you specify a partition that does not exist in the health store, this
   * request returns an error.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.replicasHealthStateFilter] Allows filtering the
   * collection of ReplicaHealthState objects on the partition. The value can be
   * obtained from members or bitwise operations on members of HealthStateFilter.
   * Only replicas that match the filter will be returned. All replicas will be
   * used to evaluate the aggregated health state. If not specified, all entries
   * will be returned.The state values are flag-based enumeration, so the value
   * could be a combination of these values obtained using bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with
   * HealthState value of OK (2) and Warning (4) will be returned. The possible
   * values for this parameter include integer value of one of the following
   * health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {boolean} [options.excludeHealthStatistics] Indicates whether the
   * health statistics should be returned as part of the query result. False by
   * default.
   * The statistics show the number of children entities in health state Ok,
   * Warning, and Error.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionHealthUsingPolicy(partitionId: string, options?: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionHealth>;
  getPartitionHealthUsingPolicy(partitionId: string, callback: ServiceCallback<models.PartitionHealth>): void;
  getPartitionHealthUsingPolicy(partitionId: string, options: { eventsHealthStateFilter? : number, replicasHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, excludeHealthStatistics? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportPartitionHealthWithHttpOperationResponse(partitionId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric partition.
   *
   * Reports health state of the specified Service Fabric partition. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Partition, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetPartitionHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportPartitionHealth(partitionId: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportPartitionHealth(partitionId: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportPartitionHealth(partitionId: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the load information of the specified Service Fabric
   * partition.
   *
   * Returns information about the load of a specified partition.
   * The response includes a list of load reports for a Service Fabric partition.
   * Each report includes the load metric name, value, and last reported time in
   * UTC.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionLoadInformation>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionLoadInformationWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionLoadInformation>>;

  /**
   * @summary Gets the load information of the specified Service Fabric
   * partition.
   *
   * Returns information about the load of a specified partition.
   * The response includes a list of load reports for a Service Fabric partition.
   * Each report includes the load metric name, value, and last reported time in
   * UTC.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionLoadInformation} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionLoadInformation} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionLoadInformation} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionLoadInformation(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionLoadInformation>;
  getPartitionLoadInformation(partitionId: string, callback: ServiceCallback<models.PartitionLoadInformation>): void;
  getPartitionLoadInformation(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionLoadInformation>): void;


  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resetPartitionLoadWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Resets the current load of a Service Fabric partition.
   *
   * Resets the current load of a Service Fabric partition to the default load
   * for the service.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resetPartitionLoad(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resetPartitionLoad(partitionId: string, callback: ServiceCallback<void>): void;
  resetPartitionLoad(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition that is currently stuck in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  recoverPartitionWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover a specific partition that is currently stuck in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverPartition(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  recoverPartition(partitionId: string, callback: ServiceCallback<void>): void;
  recoverPartition(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service that is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service that is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  recoverServicePartitionsWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the specified service that is currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the specified service that is currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverServicePartitions(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  recoverServicePartitions(serviceId: string, callback: ServiceCallback<void>): void;
  recoverServicePartitions(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services that are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services that are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  recoverSystemPartitionsWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover the system services that are currently stuck in quorum loss.
   *
   * Indicates to the Service Fabric cluster that it should attempt to recover
   * the system services that are currently stuck in quorum loss. This operation
   * should only be performed if it is known that the replicas that are down
   * cannot be recovered. Incorrect use of this API can cause potential data
   * loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSystemPartitions(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  recoverSystemPartitions(callback: ServiceCallback<void>): void;
  recoverSystemPartitions(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  recoverAllPartitionsWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Indicates to the Service Fabric cluster that it should attempt to
   * recover any services (including system services) which are currently stuck
   * in quorum loss.
   *
   * This operation should only be performed if it is known that the replicas
   * that are down cannot be recovered. Incorrect use of this API can cause
   * potential data loss.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverAllPartitions(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  recoverAllPartitions(callback: ServiceCallback<void>): void;
  recoverAllPartitions(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createRepairTaskWithHttpOperationResponse(repairTask: models.RepairTask, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTaskUpdateInfo>>;

  /**
   * @summary Creates a new repair task.
   *
   * For clusters that have the Repair Manager Service configured,
   * this API provides a way to create repair tasks that run automatically or
   * manually.
   * For repair tasks that run automatically, an appropriate repair executor
   * must be running for each repair action to run automatically.
   * These are currently only available in specially-configured Azure Cloud
   * Services.
   *
   * To create a manual repair task, provide the set of impacted node names and
   * the
   * expected impact. When the state of the created repair task changes to
   * approved,
   * you can safely perform repair actions on those nodes.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RepairTaskUpdateInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createRepairTask(repairTask: models.RepairTask, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTaskUpdateInfo>;
  createRepairTask(repairTask: models.RepairTask, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;
  createRepairTask(repairTask: models.RepairTask, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;


  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  cancelRepairTaskWithHttpOperationResponse(repairTaskCancelDescription: models.RepairTaskCancelDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTaskUpdateInfo>>;

  /**
   * @summary Requests the cancellation of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskCancelDescription Describes the repair task to be
   * cancelled.
   *
   * @param {string} repairTaskCancelDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskCancelDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {boolean} [repairTaskCancelDescription.requestAbort] _True_ if the
   * repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has
   * not yet started.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RepairTaskUpdateInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelRepairTask(repairTaskCancelDescription: models.RepairTaskCancelDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTaskUpdateInfo>;
  cancelRepairTask(repairTaskCancelDescription: models.RepairTaskCancelDescription, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;
  cancelRepairTask(repairTaskCancelDescription: models.RepairTaskCancelDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;


  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteRepairTaskWithHttpOperationResponse(repairTaskDeleteDescription: models.RepairTaskDeleteDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes a completed repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskDeleteDescription Describes the repair task to be
   * deleted.
   *
   * @param {string} repairTaskDeleteDescription.taskId The ID of the completed
   * repair task to be deleted.
   *
   * @param {string} [repairTaskDeleteDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRepairTask(repairTaskDeleteDescription: models.RepairTaskDeleteDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteRepairTask(repairTaskDeleteDescription: models.RepairTaskDeleteDescription, callback: ServiceCallback<void>): void;
  deleteRepairTask(repairTaskDeleteDescription: models.RepairTaskDeleteDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getRepairTaskListWithHttpOperationResponse(options?: { taskIdFilter? : string, stateFilter? : number, executorFilter? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTask[]>>;

  /**
   * @summary Gets a list of repair tasks matching the given filters.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.taskIdFilter] The repair task ID prefix to be
   * matched.
   *
   * @param {number} [options.stateFilter] A bitwise-OR of the following values,
   * specifying which task states should be included in the result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   *
   * @param {string} [options.executorFilter] The name of the repair executor
   * whose claimed tasks should be included in the list.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getRepairTaskList(options?: { taskIdFilter? : string, stateFilter? : number, executorFilter? : string, customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTask[]>;
  getRepairTaskList(callback: ServiceCallback<models.RepairTask[]>): void;
  getRepairTaskList(options: { taskIdFilter? : string, stateFilter? : number, executorFilter? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTask[]>): void;


  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  forceApproveRepairTaskWithHttpOperationResponse(repairTaskApproveDescription: models.RepairTaskApproveDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTaskUpdateInfo>>;

  /**
   * @summary Forces the approval of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskApproveDescription Describes the repair task to be
   * approved.
   *
   * @param {string} repairTaskApproveDescription.taskId The ID of the repair
   * task.
   *
   * @param {string} [repairTaskApproveDescription.version] The current version
   * number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If
   * zero, then no version check is performed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RepairTaskUpdateInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  forceApproveRepairTask(repairTaskApproveDescription: models.RepairTaskApproveDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTaskUpdateInfo>;
  forceApproveRepairTask(repairTaskApproveDescription: models.RepairTaskApproveDescription, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;
  forceApproveRepairTask(repairTaskApproveDescription: models.RepairTaskApproveDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;


  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateRepairTaskHealthPolicyWithHttpOperationResponse(repairTaskUpdateHealthPolicyDescription: models.RepairTaskUpdateHealthPolicyDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTaskUpdateInfo>>;

  /**
   * @summary Updates the health policy of the given repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTaskUpdateHealthPolicyDescription Describes the repair
   * task healthy policy to be updated.
   *
   * @param {string} repairTaskUpdateHealthPolicyDescription.taskId The ID of the
   * repair task to be updated.
   *
   * @param {string} [repairTaskUpdateHealthPolicyDescription.version] The
   * current version number of the repair task. If non-zero, then the request
   * will only succeed if this value matches the actual current value of the
   * repair task. If zero, then no version check is performed.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performPreparingHealthCheck] A
   * boolean indicating if health check is to be performed in the Preparing stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {boolean}
   * [repairTaskUpdateHealthPolicyDescription.performRestoringHealthCheck] A
   * boolean indicating if health check is to be performed in the Restoring stage
   * of the repair task. If not specified the existing value should not be
   * altered. Otherwise, specify the desired new value.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RepairTaskUpdateInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription: models.RepairTaskUpdateHealthPolicyDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTaskUpdateInfo>;
  updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription: models.RepairTaskUpdateHealthPolicyDescription, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;
  updateRepairTaskHealthPolicy(repairTaskUpdateHealthPolicyDescription: models.RepairTaskUpdateHealthPolicyDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;


  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RepairTaskUpdateInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateRepairExecutionStateWithHttpOperationResponse(repairTask: models.RepairTask, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RepairTaskUpdateInfo>>;

  /**
   * @summary Updates the execution state of a repair task.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {object} repairTask Describes the repair task to be created or
   * updated.
   *
   * @param {string} repairTask.taskId The ID of the repair task.
   *
   * @param {string} [repairTask.version] The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When
   * updating a repair task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version
   * is set to a non-zero value, then the
   * update will only succeed if the actual current version of the repair task
   * matches this value.
   *
   * @param {string} [repairTask.description] A description of the purpose of the
   * repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.state The workflow state of the repair task.
   * Valid initial states are Created, Claimed, and Preparing. Possible values
   * include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   *
   * @param {number} [repairTask.flags] A bitwise-OR of the following values,
   * which gives additional details about the status of the repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   *
   * @param {string} repairTask.action The requested repair action. Must be
   * specified when the repair task is created, and is immutable once set.
   *
   * @param {object} [repairTask.target] The target object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   *
   * @param {string} repairTask.target.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.executor] The name of the repair executor. Must
   * be specified in Claimed and later states, and is immutable once set.
   *
   * @param {string} [repairTask.executorData] A data string that the repair
   * executor can use to store its internal state.
   *
   * @param {object} [repairTask.impact] The impact object determines what
   * actions the system will take to prepare for the impact of the repair, prior
   * to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the
   * Preparing state, and is immutable once set.
   *
   * @param {string} repairTask.impact.kind Polymorphic Discriminator
   *
   * @param {string} [repairTask.resultStatus] A value describing the overall
   * result of the repair task execution. Must be specified in the Restoring and
   * later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   *
   * @param {number} [repairTask.resultCode] A numeric value providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {string} [repairTask.resultDetails] A string providing additional
   * details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once
   * set.
   *
   * @param {object} [repairTask.history] An object that contains timestamps of
   * the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   *
   * @param {date} [repairTask.history.createdUtcTimestamp] The time when the
   * repair task entered the Created state.
   *
   * @param {date} [repairTask.history.claimedUtcTimestamp] The time when the
   * repair task entered the Claimed state.
   *
   * @param {date} [repairTask.history.preparingUtcTimestamp] The time when the
   * repair task entered the Preparing state.
   *
   * @param {date} [repairTask.history.approvedUtcTimestamp] The time when the
   * repair task entered the Approved state
   *
   * @param {date} [repairTask.history.executingUtcTimestamp] The time when the
   * repair task entered the Executing state
   *
   * @param {date} [repairTask.history.restoringUtcTimestamp] The time when the
   * repair task entered the Restoring state
   *
   * @param {date} [repairTask.history.completedUtcTimestamp] The time when the
   * repair task entered the Completed state
   *
   * @param {date} [repairTask.history.preparingHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.preparingHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Preparing state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckStartUtcTimestamp] The
   * time when the repair task started the health check in the Restoring state.
   *
   * @param {date} [repairTask.history.restoringHealthCheckEndUtcTimestamp] The
   * time when the repair task completed the health check in the Restoring state.
   *
   * @param {string} [repairTask.preparingHealthCheckState] The workflow state of
   * the health check when the repair task is in the Preparing state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {string} [repairTask.restoringHealthCheckState] The workflow state of
   * the health check when the repair task is in the Restoring state. Possible
   * values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped',
   * 'TimedOut'
   *
   * @param {boolean} [repairTask.performPreparingHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Preparing state.
   *
   * @param {boolean} [repairTask.performRestoringHealthCheck] A value to
   * determine if health checks will be performed when the repair task enters the
   * Restoring state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RepairTaskUpdateInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RepairTaskUpdateInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RepairTaskUpdateInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRepairExecutionState(repairTask: models.RepairTask, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RepairTaskUpdateInfo>;
  updateRepairExecutionState(repairTask: models.RepairTask, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;
  updateRepairExecutionState(repairTask: models.RepairTask, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RepairTaskUpdateInfo>): void;


  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The response includes the ID, role, status, health,
   * node name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedReplicaInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicaInfoListWithHttpOperationResponse(partitionId: string, options?: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedReplicaInfoList>>;

  /**
   * @summary Gets the information about replicas of a Service Fabric service
   * partition.
   *
   * The GetReplicas endpoint returns information about the replicas of the
   * specified partition. The response includes the ID, role, status, health,
   * node name, uptime, and other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedReplicaInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedReplicaInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedReplicaInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfoList(partitionId: string, options?: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedReplicaInfoList>;
  getReplicaInfoList(partitionId: string, callback: ServiceCallback<models.PagedReplicaInfoList>): void;
  getReplicaInfoList(partitionId: string, options: { continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedReplicaInfoList>): void;


  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The response includes the ID, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicaInfoWithHttpOperationResponse(partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReplicaInfo>>;

  /**
   * @summary Gets the information about a replica of a Service Fabric partition.
   *
   * The response includes the ID, role, status, health, node name, uptime, and
   * other details about the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ReplicaInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ReplicaInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaInfo(partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ReplicaInfo>;
  getReplicaInfo(partitionId: string, replicaId: string, callback: ServiceCallback<models.ReplicaInfo>): void;
  getReplicaInfo(partitionId: string, replicaId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReplicaInfo>): void;


  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicaHealthWithHttpOperationResponse(partitionId: string, replicaId: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReplicaHealth>>;

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance.
   *
   * Gets the health of a Service Fabric replica.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the replica based on the health state.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ReplicaHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealth(partitionId: string, replicaId: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ReplicaHealth>;
  getReplicaHealth(partitionId: string, replicaId: string, callback: ServiceCallback<models.ReplicaHealth>): void;
  getReplicaHealth(partitionId: string, replicaId: string, options: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReplicaHealth>): void;


  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReplicaHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicaHealthUsingPolicyWithHttpOperationResponse(partitionId: string, replicaId: string, options?: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReplicaHealth>>;

  /**
   * @summary Gets the health of a Service Fabric stateful service replica or
   * stateless service instance using the specified policy.
   *
   * Gets the health of a Service Fabric stateful service replica or stateless
   * service instance.
   * Use EventsHealthStateFilter to filter the collection of health events
   * reported on the cluster based on the health state.
   * Use ApplicationHealthPolicy to optionally override the health policies used
   * to evaluate the health. This API only uses 'ConsiderWarningAsError' field of
   * the ApplicationHealthPolicy. The rest of the fields are ignored while
   * evaluating the health of the replica.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ReplicaHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ReplicaHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReplicaHealth} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicaHealthUsingPolicy(partitionId: string, replicaId: string, options?: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ReplicaHealth>;
  getReplicaHealthUsingPolicy(partitionId: string, replicaId: string, callback: ServiceCallback<models.ReplicaHealth>): void;
  getReplicaHealthUsingPolicy(partitionId: string, replicaId: string, options: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReplicaHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} replicaHealthReportServiceKind The kind of service replica
   * (Stateless or Stateful) for which the health is being reported. Following
   * are the possible values. Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportReplicaHealthWithHttpOperationResponse(partitionId: string, replicaId: string, replicaHealthReportServiceKind: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric replica.
   *
   * Reports health state of the specified Service Fabric replica. The report
   * must contain the information about the source of the health report and
   * property on which it is reported.
   * The report is sent to a Service Fabric gateway Replica, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, run
   * GetReplicaHealth and check that the report appears in the HealthEvents
   * section.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} replicaHealthReportServiceKind The kind of service replica
   * (Stateless or Stateful) for which the health is being reported. Following
   * are the possible values. Possible values include: 'Stateless', 'Stateful'
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportReplicaHealth(partitionId: string, replicaId: string, replicaHealthReportServiceKind: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportReplicaHealth(partitionId: string, replicaId: string, replicaHealthReportServiceKind: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportReplicaHealth(partitionId: string, replicaId: string, replicaHealthReportServiceKind: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition ID, replica ID,
   * status of the replica, name of the service, name of the service type, and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServiceReplicaInfoListWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { partitionId? : string, serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServiceReplicaInfo[]>>;

  /**
   * @summary Gets the list of replicas deployed on a Service Fabric node.
   *
   * Gets the list containing the information about replicas deployed on a
   * Service Fabric node. The information include partition ID, replica ID,
   * status of the replica, name of the service, name of the service type, and
   * other information. Use PartitionId or ServiceManifestName query parameters
   * to return information about the deployed replicas matching the specified
   * values for those parameters.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {uuid} [options.partitionId] The identity of the partition.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaInfoList(nodeName: string, applicationId: string, options?: { partitionId? : string, serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServiceReplicaInfo[]>;
  getDeployedServiceReplicaInfoList(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedServiceReplicaInfo[]>): void;
  getDeployedServiceReplicaInfoList(nodeName: string, applicationId: string, options: { partitionId? : string, serviceManifestName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServiceReplicaInfo[]>): void;


  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServiceReplicaDetailInfoWithHttpOperationResponse(nodeName: string, partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServiceReplicaDetailInfo>>;

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedServiceReplicaDetailInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfo(nodeName: string, partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServiceReplicaDetailInfo>;
  getDeployedServiceReplicaDetailInfo(nodeName: string, partitionId: string, replicaId: string, callback: ServiceCallback<models.DeployedServiceReplicaDetailInfo>): void;
  getDeployedServiceReplicaDetailInfo(nodeName: string, partitionId: string, replicaId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServiceReplicaDetailInfo>): void;


  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServiceReplicaDetailInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServiceReplicaDetailInfoByPartitionIdWithHttpOperationResponse(nodeName: string, partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServiceReplicaDetailInfo>>;

  /**
   * @summary Gets the details of replica deployed on a Service Fabric node.
   *
   * Gets the details of the replica deployed on a Service Fabric node. The
   * information includes service kind, service name, current service operation,
   * current service operation start date time, partition ID, replica/instance
   * ID, reported load, and other information.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedServiceReplicaDetailInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedServiceReplicaDetailInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServiceReplicaDetailInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServiceReplicaDetailInfoByPartitionId(nodeName: string, partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServiceReplicaDetailInfo>;
  getDeployedServiceReplicaDetailInfoByPartitionId(nodeName: string, partitionId: string, callback: ServiceCallback<models.DeployedServiceReplicaDetailInfo>): void;
  getDeployedServiceReplicaDetailInfoByPartitionId(nodeName: string, partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServiceReplicaDetailInfo>): void;


  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  restartReplicaWithHttpOperationResponse(nodeName: string, partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Restarts a service replica of a persisted service running on a
   * node.
   *
   * Restarts a service replica of a persisted service running on a node. Warning
   * - There are no safety checks performed when this API is used. Incorrect use
   * of this API can lead to availability loss for stateful services.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  restartReplica(nodeName: string, partitionId: string, replicaId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  restartReplica(nodeName: string, partitionId: string, replicaId: string, callback: ServiceCallback<void>): void;
  restartReplica(nodeName: string, partitionId: string, replicaId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services. In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  removeReplicaWithHttpOperationResponse(nodeName: string, partitionId: string, replicaId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Removes a service replica running on a node.
   *
   * This API simulates a Service Fabric replica failure by removing a replica
   * from a Service Fabric cluster. The removal closes the replica, transitions
   * the replica to the role None, and then removes all of the state information
   * of the replica from the cluster. This API tests the replica state removal
   * path, and simulates the report fault permanent path through client APIs.
   * Warning - There are no safety checks performed when this API is used.
   * Incorrect use of this API can lead to data loss for stateful services. In
   * addition, the forceRemove flag impacts all other replicas hosted in the same
   * process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceRemove] Remove a Service Fabric application
   * or service forcefully without going through the graceful shutdown sequence.
   * This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that
   * prevents graceful close of replicas.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  removeReplica(nodeName: string, partitionId: string, replicaId: string, options?: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  removeReplica(nodeName: string, partitionId: string, replicaId: string, callback: ServiceCallback<void>): void;
  removeReplica(nodeName: string, partitionId: string, replicaId: string, options: { forceRemove? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServicePackageInfoListWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServicePackageInfo[]>>;

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric
   * node.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoList(nodeName: string, applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServicePackageInfo[]>;
  getDeployedServicePackageInfoList(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedServicePackageInfo[]>): void;
  getDeployedServicePackageInfoList(nodeName: string, applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServicePackageInfo[]>): void;


  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServicePackageInfoListByNameWithHttpOperationResponse(nodeName: string, applicationId: string, servicePackageName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServicePackageInfo[]>>;

  /**
   * @summary Gets the list of service packages deployed on a Service Fabric node
   * matching exactly the specified name.
   *
   * Returns the information about the service packages deployed on a Service
   * Fabric node for the given application. These results are of service packages
   * whose name match exactly the service package name specified as the
   * parameter.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageInfoListByName(nodeName: string, applicationId: string, servicePackageName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServicePackageInfo[]>;
  getDeployedServicePackageInfoListByName(nodeName: string, applicationId: string, servicePackageName: string, callback: ServiceCallback<models.DeployedServicePackageInfo[]>): void;
  getDeployedServicePackageInfoListByName(nodeName: string, applicationId: string, servicePackageName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServicePackageInfo[]>): void;


  /**
   * @summary Gets the information about health of a service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServicePackageHealthWithHttpOperationResponse(nodeName: string, applicationId: string, servicePackageName: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServicePackageHealth>>;

  /**
   * @summary Gets the information about health of a service package for a
   * specific application deployed for a Service Fabric node and application.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. Use EventsHealthStateFilter
   * to optionally filter for the collection of HealthEvent objects reported on
   * the deployed service package based on health state.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedServicePackageHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, options?: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServicePackageHealth>;
  getDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, callback: ServiceCallback<models.DeployedServicePackageHealth>): void;
  getDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, options: { eventsHealthStateFilter? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServicePackageHealth>): void;


  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeployedServicePackageHealth>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedServicePackageHealthUsingPolicyWithHttpOperationResponse(nodeName: string, applicationId: string, servicePackageName: string, options?: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedServicePackageHealth>>;

  /**
   * @summary Gets the information about health of service package for a specific
   * application deployed on a Service Fabric node using the specified policy.
   *
   * Gets the information about health of a service package for a specific
   * application deployed on a Service Fabric node. using the specified policy.
   * Use EventsHealthStateFilter to optionally filter for the collection of
   * HealthEvent objects reported on the deployed service package based on health
   * state. Use ApplicationHealthPolicy to optionally override the health
   * policies used to evaluate the health. This API only uses
   * 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of
   * the fields are ignored while evaluating the health of the deployed service
   * package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.eventsHealthStateFilter] Allows filtering the
   * collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the
   * following health states.
   * Only events that match the filter are returned. All events are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based
   * enumeration, so the value could be a combination of these values, obtained
   * using the bitwise 'OR' operator. For example, If the provided value is 6
   * then all of the events with HealthState value of OK (2) and Warning (4) are
   * returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to
   * return no results on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The
   * value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value
   * is 8.
   * - All - Filter that matches input with any HealthState value. The value is
   * 65535.
   *
   * @param {object} [options.applicationHealthPolicy] Describes the health
   * policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from
   * application manifest or the default health policy.
   *
   * @param {boolean} [options.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [options.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The health
   * policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [options.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array} [options.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {DeployedServicePackageHealth} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {DeployedServicePackageHealth} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeployedServicePackageHealth} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedServicePackageHealthUsingPolicy(nodeName: string, applicationId: string, servicePackageName: string, options?: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedServicePackageHealth>;
  getDeployedServicePackageHealthUsingPolicy(nodeName: string, applicationId: string, servicePackageName: string, callback: ServiceCallback<models.DeployedServicePackageHealth>): void;
  getDeployedServicePackageHealthUsingPolicy(nodeName: string, applicationId: string, servicePackageName: string, options: { eventsHealthStateFilter? : number, applicationHealthPolicy? : models.ApplicationHealthPolicy, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedServicePackageHealth>): void;


  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  reportDeployedServicePackageHealthWithHttpOperationResponse(nodeName: string, applicationId: string, servicePackageName: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Sends a health report on the Service Fabric deployed service
   * package.
   *
   * Reports health state of the service package of the application deployed on a
   * Service Fabric node. The report must contain the information about the
   * source of the health report and property on which it is reported.
   * The report is sent to a Service Fabric gateway Service, which forwards to
   * the health store.
   * The report may be accepted by the gateway, but rejected by the health store
   * after extra validation.
   * For example, the health store may reject the report because of an invalid
   * parameter, like a stale sequence number.
   * To see whether the report was applied in the health store, get deployed
   * service package health and check that the report appears in the HealthEvents
   * section.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} servicePackageName The name of the service package.
   *
   * @param {object} healthInformation Describes the health information for the
   * health report. This information needs to be present in all of the health
   * reports sent to the health manager.
   *
   * @param {string} healthInformation.sourceId The source name that identifies
   * the client/watchdog/system component that generated the health information.
   *
   * @param {string} healthInformation.property The property of the health
   * information. An entity can have health reports for different properties.
   * The property is a string and not a fixed enumeration to allow the reporter
   * flexibility to categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state
   * of the available disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a
   * property "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for
   * the specified node.
   *
   * Together with the SourceId, the property uniquely identifies the health
   * information.
   *
   * @param {string} healthInformation.healthState The health state of a Service
   * Fabric entity such as Cluster, Node, Application, Service, Partition,
   * Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   *
   * @param {moment.duration} [healthInformation.timeToLiveInMilliSeconds] The
   * duration for which this health report is valid. This field uses ISO8601
   * format for specifying the duration.
   * When clients report periodically, they should send reports with higher
   * frequency than time to live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health
   * information
   * is either removed from health store, if RemoveWhenExpired is true, or
   * evaluated at error, if RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   *
   * @param {string} [healthInformation.description] The description of the
   * health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker
   * "[Truncated]", and total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from
   * the original string.
   *
   * @param {string} [healthInformation.sequenceNumber] The sequence number for
   * this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale
   * reports.
   * If not specified, a sequence number is auto-generated by the health client
   * when a report is added.
   *
   * @param {boolean} [healthInformation.removeWhenExpired] Value that indicates
   * whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it
   * expires.
   * If set to false, the report is treated as an error when expired. The value
   * of this property is false by default.
   * When clients report periodically, they should set RemoveWhenExpired false
   * (default).
   * This way, is the reporter has issues (eg. deadlock) and can't report, the
   * entity is evaluated at error when the health report expires.
   * This flags the entity as being in Error health state.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.immediate] A flag that indicates whether the
   * report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which
   * forwards to the health store.
   * If Immediate is set to true, the report is sent immediately from HTTP
   * Gateway to the health store, regardless of the fabric client settings that
   * the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail,
   * for example if the HTTP Gateway is closed or the message doesn't reach the
   * Gateway.
   * If Immediate is set to false, the report is sent based on the health client
   * settings from the HTTP Gateway. Therefore, it will be batched according to
   * the HealthReportSendInterval configuration.
   * This is the recommended setting because it allows the health client to
   * optimize health reporting messages to health store as well as health report
   * processing.
   * By default, reports are not sent immediately.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  reportDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, healthInformation: models.HealthInformation, options?: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  reportDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, healthInformation: models.HealthInformation, callback: ServiceCallback<void>): void;
  reportDeployedServicePackageHealth(nodeName: string, applicationId: string, servicePackageName: string, healthInformation: models.HealthInformation, options: { immediate? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Downloads all of the code packages associated with specified
   * service manifest on the specified node.
   *
   * This API provides a way to download code packages including the container
   * images on a specific node outside of the normal application deployment and
   * upgrade path. This is useful for the large code packages and container
   * images to be present on the node before the actual application deployment
   * and upgrade, thus significantly reducing the total time required for the
   * deployment or upgrade.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   * The name of service manifest whose packages need to be downloaded.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   * The application type name as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   * The version of the application type as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName The name of a
   * Service Fabric node.
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   * List of package sharing policy information.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deployServicePackageToNodeWithHttpOperationResponse(nodeName: string, deployServicePackageToNodeDescription: models.DeployServicePackageToNodeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Downloads all of the code packages associated with specified
   * service manifest on the specified node.
   *
   * This API provides a way to download code packages including the container
   * images on a specific node outside of the normal application deployment and
   * upgrade path. This is useful for the large code packages and container
   * images to be present on the node before the actual application deployment
   * and upgrade, thus significantly reducing the total time required for the
   * deployment or upgrade.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {object} deployServicePackageToNodeDescription Describes information
   * for deploying a service package to a Service Fabric node.
   *
   * @param {string} deployServicePackageToNodeDescription.serviceManifestName
   * The name of service manifest whose packages need to be downloaded.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeName
   * The application type name as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.applicationTypeVersion
   * The version of the application type as defined in the application manifest.
   *
   * @param {string} deployServicePackageToNodeDescription.nodeName The name of a
   * Service Fabric node.
   *
   * @param {array} [deployServicePackageToNodeDescription.packageSharingPolicy]
   * List of package sharing policy information.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deployServicePackageToNode(nodeName: string, deployServicePackageToNodeDescription: models.DeployServicePackageToNodeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deployServicePackageToNode(nodeName: string, deployServicePackageToNodeDescription: models.DeployServicePackageToNodeDescription, callback: ServiceCallback<void>): void;
  deployServicePackageToNode(nodeName: string, deployServicePackageToNodeDescription: models.DeployServicePackageToNodeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDeployedCodePackageInfoListWithHttpOperationResponse(nodeName: string, applicationId: string, options?: { serviceManifestName? : string, codePackageName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DeployedCodePackageInfo[]>>;

  /**
   * @summary Gets the list of code packages deployed on a Service Fabric node.
   *
   * Gets the list of code packages deployed on a Service Fabric node for the
   * given application.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceManifestName] The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} [options.codePackageName] The name of code package specified
   * in service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployedCodePackageInfoList(nodeName: string, applicationId: string, options?: { serviceManifestName? : string, codePackageName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.DeployedCodePackageInfo[]>;
  getDeployedCodePackageInfoList(nodeName: string, applicationId: string, callback: ServiceCallback<models.DeployedCodePackageInfo[]>): void;
  getDeployedCodePackageInfoList(nodeName: string, applicationId: string, options: { serviceManifestName? : string, codePackageName? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DeployedCodePackageInfo[]>): void;


  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   * The name of service manifest that specified this code package.
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId] The
   * ActivationId of a deployed service package. If ServicePackageActivationMode
   * specified at the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to
   * 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName The
   * name of the code package defined in the service manifest.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   * The instance ID for currently running entry point. For a code package setup
   * entry point (if specified) runs first and after it finishes main entry point
   * is started.
   * Each time entry point executable is run, its instance ID will change. If 0
   * is passed in as the code package instance ID, the API will restart the code
   * package with whatever instance ID it is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code
   * package only if the current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer, because
   * if ensures at most one restart of the code package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  restartDeployedCodePackageWithHttpOperationResponse(nodeName: string, applicationId: string, restartDeployedCodePackageDescription: models.RestartDeployedCodePackageDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Restarts a code package deployed on a Service Fabric node in a
   * cluster.
   *
   * Restarts a code package deployed on a Service Fabric node in a cluster. This
   * aborts the code package process, which will restart all the user service
   * replicas hosted in that process.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} restartDeployedCodePackageDescription Describes the deployed
   * code package on Service Fabric node to restart.
   *
   * @param {string} restartDeployedCodePackageDescription.serviceManifestName
   * The name of service manifest that specified this code package.
   *
   * @param {string}
   * [restartDeployedCodePackageDescription.servicePackageActivationId] The
   * ActivationId of a deployed service package. If ServicePackageActivationMode
   * specified at the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to
   * 'SharedProcess'), then value of ServicePackageActivationId
   * is always an empty string.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageName The
   * name of the code package defined in the service manifest.
   *
   * @param {string} restartDeployedCodePackageDescription.codePackageInstanceId
   * The instance ID for currently running entry point. For a code package setup
   * entry point (if specified) runs first and after it finishes main entry point
   * is started.
   * Each time entry point executable is run, its instance ID will change. If 0
   * is passed in as the code package instance ID, the API will restart the code
   * package with whatever instance ID it is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code
   * package only if the current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer, because
   * if ensures at most one restart of the code package.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  restartDeployedCodePackage(nodeName: string, applicationId: string, restartDeployedCodePackageDescription: models.RestartDeployedCodePackageDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  restartDeployedCodePackage(nodeName: string, applicationId: string, restartDeployedCodePackageDescription: models.RestartDeployedCodePackageDescription, callback: ServiceCallback<void>): void;
  restartDeployedCodePackage(nodeName: string, applicationId: string, restartDeployedCodePackageDescription: models.RestartDeployedCodePackageDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the container logs for container deployed on a Service Fabric
   * node.
   *
   * Gets the container logs for container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.tail] Number of lines to show from the end of the
   * logs. Default is 100. 'all' to show the complete logs.
   *
   * @param {boolean} [options.previous] Specifies whether to get container logs
   * from exited/dead containers of the code package instance.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ContainerLogs>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getContainerLogsDeployedOnNodeWithHttpOperationResponse(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, options?: { tail? : string, previous? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ContainerLogs>>;

  /**
   * @summary Gets the container logs for container deployed on a Service Fabric
   * node.
   *
   * Gets the container logs for container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.tail] Number of lines to show from the end of the
   * logs. Default is 100. 'all' to show the complete logs.
   *
   * @param {boolean} [options.previous] Specifies whether to get container logs
   * from exited/dead containers of the code package instance.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ContainerLogs} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ContainerLogs} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ContainerLogs} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getContainerLogsDeployedOnNode(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, options?: { tail? : string, previous? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ContainerLogs>;
  getContainerLogsDeployedOnNode(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, callback: ServiceCallback<models.ContainerLogs>): void;
  getContainerLogsDeployedOnNode(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, options: { tail? : string, previous? : boolean, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ContainerLogs>): void;


  /**
   * @summary Invoke container API on a container deployed on a Service Fabric
   * node.
   *
   * Invoke container API on a container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {string} codePackageInstanceId ID that uniquely identifies a code
   * package instance deployed on a service fabric node.
   *
   * @param {object} containerApiRequestBody Parameters for making container API
   * call
   *
   * @param {string} [containerApiRequestBody.httpVerb] HTTP verb of container
   * REST API, defaults to "GET"
   *
   * @param {string} containerApiRequestBody.uriPath URI path of container REST
   * API
   *
   * @param {string} [containerApiRequestBody.contentType] Content type of
   * container REST API request, defaults to "application/json"
   *
   * @param {string} [containerApiRequestBody.body] HTTP request body of
   * container REST API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ContainerApiResponse>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  invokeContainerApiWithHttpOperationResponse(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, codePackageInstanceId: string, containerApiRequestBody: models.ContainerApiRequestBody, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ContainerApiResponse>>;

  /**
   * @summary Invoke container API on a container deployed on a Service Fabric
   * node.
   *
   * Invoke container API on a container deployed on a Service Fabric node for
   * the given code package.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} serviceManifestName The name of a service manifest
   * registered as part of an application type in a Service Fabric cluster.
   *
   * @param {string} codePackageName The name of code package specified in
   * service manifest registered as part of an application type in a Service
   * Fabric cluster.
   *
   * @param {string} codePackageInstanceId ID that uniquely identifies a code
   * package instance deployed on a service fabric node.
   *
   * @param {object} containerApiRequestBody Parameters for making container API
   * call
   *
   * @param {string} [containerApiRequestBody.httpVerb] HTTP verb of container
   * REST API, defaults to "GET"
   *
   * @param {string} containerApiRequestBody.uriPath URI path of container REST
   * API
   *
   * @param {string} [containerApiRequestBody.contentType] Content type of
   * container REST API request, defaults to "application/json"
   *
   * @param {string} [containerApiRequestBody.body] HTTP request body of
   * container REST API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ContainerApiResponse} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ContainerApiResponse} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ContainerApiResponse} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeContainerApi(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, codePackageInstanceId: string, containerApiRequestBody: models.ContainerApiRequestBody, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ContainerApiResponse>;
  invokeContainerApi(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, codePackageInstanceId: string, containerApiRequestBody: models.ContainerApiRequestBody, callback: ServiceCallback<models.ContainerApiResponse>): void;
  invokeContainerApi(nodeName: string, applicationId: string, serviceManifestName: string, codePackageName: string, codePackageInstanceId: string, containerApiRequestBody: models.ContainerApiRequestBody, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ContainerApiResponse>): void;


  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Compose is a file format that describes multi-container applications. This
   * API allows deploying container based applications defined in compose format
   * in a Service Fabric cluster. Once the deployment is created, its status can
   * be tracked via the `GetComposeDeploymentStatus` API.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createComposeDeploymentWithHttpOperationResponse(createComposeDeploymentDescription: models.CreateComposeDeploymentDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates a Service Fabric compose deployment.
   *
   * Compose is a file format that describes multi-container applications. This
   * API allows deploying container based applications defined in compose format
   * in a Service Fabric cluster. Once the deployment is created, its status can
   * be tracked via the `GetComposeDeploymentStatus` API.
   *
   * @param {object} createComposeDeploymentDescription Describes the compose
   * deployment that needs to be created.
   *
   * @param {string} createComposeDeploymentDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} createComposeDeploymentDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [createComposeDeploymentDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryUserName] The
   * user name to connect to container registry.
   *
   * @param {string}
   * [createComposeDeploymentDescription.registryCredential.registryPassword] The
   * password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [createComposeDeploymentDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createComposeDeployment(createComposeDeploymentDescription: models.CreateComposeDeploymentDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createComposeDeployment(createComposeDeploymentDescription: models.CreateComposeDeploymentDescription, callback: ServiceCallback<void>): void;
  createComposeDeployment(createComposeDeploymentDescription: models.CreateComposeDeploymentDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status, and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentStatusInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getComposeDeploymentStatusWithHttpOperationResponse(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ComposeDeploymentStatusInfo>>;

  /**
   * @summary Gets information about a Service Fabric compose deployment.
   *
   * Returns the status of the compose deployment that was created or in the
   * process of being created in the Service Fabric cluster and whose name
   * matches the one specified as the parameter. The response includes the name,
   * status, and other details about the deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ComposeDeploymentStatusInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ComposeDeploymentStatusInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentStatusInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatus(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ComposeDeploymentStatusInfo>;
  getComposeDeploymentStatus(deploymentName: string, callback: ServiceCallback<models.ComposeDeploymentStatusInfo>): void;
  getComposeDeploymentStatus(deploymentName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ComposeDeploymentStatusInfo>): void;


  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status, and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token, which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedComposeDeploymentStatusInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getComposeDeploymentStatusListWithHttpOperationResponse(options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedComposeDeploymentStatusInfoList>>;

  /**
   * @summary Gets the list of compose deployments created in the Service Fabric
   * cluster.
   *
   * Gets the status about the compose deployments that were created or in the
   * process of being created in the Service Fabric cluster. The response
   * includes the name, status, and other details about the compose deployments.
   * If the list of deployments do not fit in a page, one page of results is
   * returned as well as a continuation token, which can be used to get the next
   * page.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedComposeDeploymentStatusInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedComposeDeploymentStatusInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedComposeDeploymentStatusInfoList} for
   *                      more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentStatusList(options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedComposeDeploymentStatusInfoList>;
  getComposeDeploymentStatusList(callback: ServiceCallback<models.PagedComposeDeploymentStatusInfoList>): void;
  getComposeDeploymentStatusList(options: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedComposeDeploymentStatusInfoList>): void;


  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ComposeDeploymentUpgradeProgressInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getComposeDeploymentUpgradeProgressWithHttpOperationResponse(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ComposeDeploymentUpgradeProgressInfo>>;

  /**
   * @summary Gets details for the latest upgrade performed on this Service
   * Fabric compose deployment.
   *
   * Returns the information about the state of the compose deployment upgrade
   * along with details to aid debugging application health issues.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ComposeDeploymentUpgradeProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ComposeDeploymentUpgradeProgressInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ComposeDeploymentUpgradeProgressInfo} for
   *                      more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getComposeDeploymentUpgradeProgress(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ComposeDeploymentUpgradeProgressInfo>;
  getComposeDeploymentUpgradeProgress(deploymentName: string, callback: ServiceCallback<models.ComposeDeploymentUpgradeProgressInfo>): void;
  getComposeDeploymentUpgradeProgress(deploymentName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ComposeDeploymentUpgradeProgressInfo>): void;


  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  removeComposeDeploymentWithHttpOperationResponse(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes an existing Service Fabric compose deployment from cluster.
   *
   * Deletes an existing Service Fabric compose deployment.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  removeComposeDeployment(deploymentName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  removeComposeDeployment(deploymentName: string, callback: ServiceCallback<void>): void;
  removeComposeDeployment(deploymentName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode] The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startComposeDeploymentUpgradeWithHttpOperationResponse(deploymentName: string, composeDeploymentUpgradeDescription: models.ComposeDeploymentUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Starts upgrading a compose deployment in the Service Fabric
   * cluster.
   *
   * Validates the supplied upgrade parameters and starts upgrading the
   * deployment if the parameters are valid.
   *
   * @param {string} deploymentName The identity of the deployment.
   *
   * @param {object} composeDeploymentUpgradeDescription Parameters for upgrading
   * compose deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.deploymentName The name
   * of the deployment.
   *
   * @param {string} composeDeploymentUpgradeDescription.composeFileContent The
   * content of the compose file that describes the deployment to create.
   *
   * @param {object} [composeDeploymentUpgradeDescription.registryCredential]
   * Credential information to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryUserName]
   * The user name to connect to container registry.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.registryCredential.registryPassword]
   * The password for supplied username to connect to container registry.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.registryCredential.passwordEncrypted]
   * Indicates that supplied container registry password is encrypted.
   *
   * @param {string} composeDeploymentUpgradeDescription.upgradeKind The kind of
   * upgrade out of the following possible values. Possible values include:
   * 'Invalid', 'Rolling'
   *
   * @param {string} [composeDeploymentUpgradeDescription.rollingUpgradeMode] The
   * mode used to monitor health during a rolling upgrade. The values are
   * UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
   * 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.upgradeReplicaSetCheckTimeoutInSeconds]
   * The maximum amount of time to block processing of an upgrade domain and
   * prevent loss of availability when there are unexpected issues. When this
   * timeout expires, processing of the upgrade domain will proceed regardless of
   * availability loss issues. The timeout is reset at the start of each upgrade
   * domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
   * 32-bit integer).
   *
   * @param {boolean} [composeDeploymentUpgradeDescription.forceRestart] If true,
   * then processes are forcefully restarted during upgrade even when the code
   * version has not changed (the upgrade only changes configuration or data).
   *
   * @param {object} [composeDeploymentUpgradeDescription.monitoringPolicy]
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.failureAction] The
   * compensating action to perform when a Monitored upgrade encounters
   * monitoring policy or health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the
   * upgrade will start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade
   * mode. Possible values include: 'Invalid', 'Rollback', 'Manual'
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckWaitDurationInMilliseconds]
   * The amount of time to wait after completing an upgrade domain before
   * applying health policies. It is first interpreted as a string representing
   * an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckStableDurationInMilliseconds]
   * The amount of time that the application or cluster must remain healthy
   * before the upgrade proceeds to the next upgrade domain. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.healthCheckRetryTimeoutInMilliseconds]
   * The amount of time to retry health evaluation when the application or
   * cluster is unhealthy before FailureAction is executed. It is first
   * interpreted as a string representing an ISO 8601 duration. If that fails,
   * then it is interpreted as a number representing the total number of
   * milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeTimeoutInMilliseconds]
   * The amount of time the overall upgrade has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {string}
   * [composeDeploymentUpgradeDescription.monitoringPolicy.upgradeDomainTimeoutInMilliseconds]
   * The amount of time each upgrade domain has to complete before FailureAction
   * is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the
   * total number of milliseconds.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy] Defines a
   * health policy used to evaluate the health of an application or one of its
   * children entities.
   *
   * @param {boolean}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.considerWarningAsError]
   * Indicates whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
   * The maximum allowed percentage of unhealthy deployed applications. Allowed
   * values are Byte values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed
   * applications that can be unhealthy before the application is considered in
   * error.
   * This is calculated by dividing the number of unhealthy deployed applications
   * over the number of nodes where the application is currently deployed on in
   * the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * @param {object}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy]
   * The health policy used by default to evaluate the health of a service type.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyPartitionsPerService]
   * The maximum allowed percentage of unhealthy partitions per service. Allowed
   * values are Byte values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions
   * that can be unhealthy before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * partition, the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions
   * over the total number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of
   * partitions. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyReplicasPerPartition]
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed
   * values are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that
   * can be unhealthy before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica,
   * the health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas
   * over the total number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of
   * replicas. Default percentage is zero.
   *
   * @param {number}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
   * The maximum maximum allowed percentage of unhealthy services. Allowed values
   * are Byte values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that
   * can be unhealthy before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service,
   * the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the
   * specific service type over the total number of services of the specific
   * service type.
   * The computation rounds up to tolerate one failure on small numbers of
   * services. Default percentage is zero.
   *
   * @param {array}
   * [composeDeploymentUpgradeDescription.applicationHealthPolicy.serviceTypeHealthPolicyMap]
   * The map with service type health policy per service type name. The map is
   * empty by default.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startComposeDeploymentUpgrade(deploymentName: string, composeDeploymentUpgradeDescription: models.ComposeDeploymentUpgradeDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startComposeDeploymentUpgrade(deploymentName: string, composeDeploymentUpgradeDescription: models.ComposeDeploymentUpgradeDescription, callback: ServiceCallback<void>): void;
  startComposeDeploymentUpgrade(deploymentName: string, composeDeploymentUpgradeDescription: models.ComposeDeploymentUpgradeDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Get the status of Chaos.
   *
   * Get the status of Chaos indicating whether or not Chaos is running, the
   * Chaos parameters used for running Chaos and the status of the Chaos
   * Schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Chaos>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getChaosWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Chaos>>;

  /**
   * @summary Get the status of Chaos.
   *
   * Get the status of Chaos indicating whether or not Chaos is running, the
   * Chaos parameters used for running Chaos and the status of the Chaos
   * Schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Chaos} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Chaos} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Chaos} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaos(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.Chaos>;
  getChaos(callback: ServiceCallback<models.Chaos>): void;
  getChaos(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Chaos>): void;


  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   * @param {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
   * health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected exception
   * happens during fault execution--to provide the cluster with some time to
   * recuperate--Chaos will wait for 30 minutes before the next health-check.
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
   * a map with max percentage unhealthy applications for specific application
   * types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object} [chaosParameters.context] Describes a map, which is a
   * collection of (string, string) type key-value pairs. The map can be used to
   * record information about
   * the Chaos run. There cannot be more than 100 such pairs and each string (key
   * or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   *
   * @param {object} [chaosParameters.context.map] Describes a map that contains
   * a collection of ChaosContextMapItem's.
   *
   * @param {object} [chaosParameters.chaosTargetFilter] List of cluster entities
   * to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types or
   * only to certain application instances. If ChaosTargetFilter is not used,
   * Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList] A
   * list of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the nodes
   * of these node types.
   * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
   * then node level faults (like NodeRestart) will never be enabled for the
   * nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.applicationInclusionList]
   * A list of application URI's to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas of
   * these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement constraints
   * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
   * absent from NodeTypeInclusionList, then applicationX will never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startChaosWithHttpOperationResponse(chaosParameters: models.ChaosParameters, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Starts Chaos in the cluster.
   *
   * If Chaos is not already running in the cluster, it starts Chaos with the
   * passed in Chaos parameters.
   * If Chaos is already running when this call is made, the call fails with the
   * error code FABRIC_E_CHAOS_ALREADY_RUNNING.
   * Refer to the article [Induce controlled Chaos in Service Fabric
   * clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos)
   * for more details.
   *
   * @param {object} chaosParameters Describes all the parameters to configure a
   * Chaos run.
   *
   * @param {string} [chaosParameters.timeToRunInSeconds] Total time (in seconds)
   * for which Chaos will run before automatically stopping. The maximum allowed
   * value is 4,294,967,295 (System.UInt32.MaxValue).
   *
   * @param {number} [chaosParameters.maxClusterStabilizationTimeoutInSeconds]
   * The maximum amount of time to wait for all cluster entities to become stable
   * and healthy. Chaos executes in iterations and at the start of each iteration
   * it validates the health of cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
   * event.
   *
   * @param {number} [chaosParameters.maxConcurrentFaults] MaxConcurrentFaults is
   * the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by
   * a validation phase.
   * The higher the concurrency, the more aggressive the injection of faults,
   * leading to inducing more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise
   * caution while moving up.
   *
   * @param {boolean} [chaosParameters.enableMoveReplicaFaults] Enables or
   * disables the move primary and move secondary faults.
   *
   * @param {number} [chaosParameters.waitTimeBetweenFaultsInSeconds] Wait time
   * (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the
   * simpler the sequence of state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise
   * caution while moving up.
   *
   * @param {number} [chaosParameters.waitTimeBetweenIterationsInSeconds]
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate.
   *
   * @param {object} [chaosParameters.clusterHealthPolicy] Passed-in cluster
   * health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected exception
   * happens during fault execution--to provide the cluster with some time to
   * recuperate--Chaos will wait for 30 minutes before the next health-check.
   *
   * @param {boolean}
   * [chaosParameters.clusterHealthPolicy.considerWarningAsError] Indicates
   * whether warnings are treated with the same severity as errors.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyNodes] The maximum
   * allowed percentage of unhealthy nodes before reporting an error. For
   * example, to allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can
   * be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the
   * health is evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over
   * the total number of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes.
   * Default percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so
   * this percentage should be configured to tolerate that.
   *
   * @param {number}
   * [chaosParameters.clusterHealthPolicy.maxPercentUnhealthyApplications] The
   * maximum allowed percentage of unhealthy applications before reporting an
   * error. For example, to allow 10% of applications to be unhealthy, this value
   * would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications
   * that can be unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy
   * application, the health is evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the
   * total number of application instances in the cluster, excluding applications
   * of application types that are included in the
   * ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of
   * applications. Default percentage is zero.
   *
   * @param {array}
   * [chaosParameters.clusterHealthPolicy.applicationTypeHealthPolicyMap] Defines
   * a map with max percentage unhealthy applications for specific application
   * types.
   * Each entry specifies as key the application type name and as value an
   * integer that represents the MaxPercentUnhealthyApplications percentage used
   * to evaluate the applications of the specified application type.
   *
   * The application type health policy map can be used during cluster health
   * evaluation to describe special application types.
   * The application types included in the map are evaluated against the
   * percentage specified in the map, and not with the global
   * MaxPercentUnhealthyApplications defined in the cluster health policy.
   * The applications of application types specified in the map are not counted
   * against the global pool of applications.
   * For example, if some applications of a type are critical, the cluster
   * administrator can add an entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications
   * set to 20% to tolerate some failures out of the thousands of application
   * instances.
   * The application type health policy map is used only if the cluster manifest
   * enables application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   *
   * @param {object} [chaosParameters.context] Describes a map, which is a
   * collection of (string, string) type key-value pairs. The map can be used to
   * record information about
   * the Chaos run. There cannot be more than 100 such pairs and each string (key
   * or value) can be at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the
   * context about the specific run.
   *
   * @param {object} [chaosParameters.context.map] Describes a map that contains
   * a collection of ChaosContextMapItem's.
   *
   * @param {object} [chaosParameters.chaosTargetFilter] List of cluster entities
   * to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types or
   * only to certain application instances. If ChaosTargetFilter is not used,
   * Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the
   * ChaosTargetFilter specification.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.nodeTypeInclusionList] A
   * list of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica,
   * restart replica, move primary, and move secondary) are enabled for the nodes
   * of these node types.
   * If a nodetype (say NodeTypeX) does not appear in the NodeTypeInclusionList,
   * then node level faults (like NodeRestart) will never be enabled for the
   * nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for
   * NodeTypeX if an application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this
   * number, a config upgrade is required for
   * MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   *
   * @param {array} [chaosParameters.chaosTargetFilter.applicationInclusionList]
   * A list of application URI's to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to
   * replica faults (restart replica, remove replica, move primary, and move
   * secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas of
   * these applications only.
   * If an application does not appear in this list, it can still be faulted in
   * some Chaos iteration if the application ends up on a node of a node type
   * that is included in NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement constraints
   * and applicationX is absent from ApplicationInclusionList and nodeTypeY is
   * absent from NodeTypeInclusionList, then applicationX will never be faulted.
   * At most 1000 application names can be included in this list, to increase
   * this number, a config upgrade is required for
   * MaxNumberOfApplicationsInChaosEntityFilter configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startChaos(chaosParameters: models.ChaosParameters, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startChaos(chaosParameters: models.ChaosParameters, callback: ServiceCallback<void>): void;
  startChaos(chaosParameters: models.ChaosParameters, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Stops Chaos if it is running in the cluster and put the Chaos
   * Schedule in a stopped state.
   *
   * Stops Chaos from executing new faults. In-flight faults will continue to
   * execute until they are complete. The current Chaos Schedule is put into a
   * stopped state.
   * Once a schedule is stopped, it will stay in the stopped state and not be
   * used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set
   * in order to resume scheduling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  stopChaosWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Stops Chaos if it is running in the cluster and put the Chaos
   * Schedule in a stopped state.
   *
   * Stops Chaos from executing new faults. In-flight faults will continue to
   * execute until they are complete. The current Chaos Schedule is put into a
   * stopped state.
   * Once a schedule is stopped, it will stay in the stopped state and not be
   * used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set
   * in order to resume scheduling.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  stopChaos(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  stopChaos(callback: ServiceCallback<void>): void;
  stopChaos(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the next segment of the Chaos events based on the continuation
   * token or the time range.
   *
   * To get the next segment of the Chaos events, you can specify the
   * ContinuationToken. To get the start of a new segment of Chaos events, you
   * can specify the time range
   * through StartTimeUtc and EndTimeUtc. You cannot specify both the
   * ContinuationToken and the time range in the same call.
   * When there are more than 100 Chaos events, the Chaos events are returned in
   * multiple segments where a segment contains no more than 100 Chaos events and
   * to get the next segment you make a call to this API with the continuation
   * token.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The Windows file time representing
   * the start time of the time range for which a Chaos report is to be
   * generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {string} [options.endTimeUtc] The Windows file time representing the
   * end time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ChaosEventsSegment>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getChaosEventsWithHttpOperationResponse(options?: { continuationToken? : string, startTimeUtc? : string, endTimeUtc? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ChaosEventsSegment>>;

  /**
   * @summary Gets the next segment of the Chaos events based on the continuation
   * token or the time range.
   *
   * To get the next segment of the Chaos events, you can specify the
   * ContinuationToken. To get the start of a new segment of Chaos events, you
   * can specify the time range
   * through StartTimeUtc and EndTimeUtc. You cannot specify both the
   * ContinuationToken and the time range in the same call.
   * When there are more than 100 Chaos events, the Chaos events are returned in
   * multiple segments where a segment contains no more than 100 Chaos events and
   * to get the next segment you make a call to this API with the continuation
   * token.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {string} [options.startTimeUtc] The Windows file time representing
   * the start time of the time range for which a Chaos report is to be
   * generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {string} [options.endTimeUtc] The Windows file time representing the
   * end time of the time range for which a Chaos report is to be generated.
   * Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx)
   * for details.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ChaosEventsSegment} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ChaosEventsSegment} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ChaosEventsSegment} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaosEvents(options?: { continuationToken? : string, startTimeUtc? : string, endTimeUtc? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ChaosEventsSegment>;
  getChaosEvents(callback: ServiceCallback<models.ChaosEventsSegment>): void;
  getChaosEvents(options: { continuationToken? : string, startTimeUtc? : string, endTimeUtc? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ChaosEventsSegment>): void;


  /**
   * @summary Get the Chaos Schedule defining when and how to run Chaos.
   *
   * Gets the version of the Chaos Schedule in use and the Chaos Schedule that
   * defines when and how to run Chaos.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ChaosScheduleDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getChaosScheduleWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ChaosScheduleDescription>>;

  /**
   * @summary Get the Chaos Schedule defining when and how to run Chaos.
   *
   * Gets the version of the Chaos Schedule in use and the Chaos Schedule that
   * defines when and how to run Chaos.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ChaosScheduleDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ChaosScheduleDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ChaosScheduleDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getChaosSchedule(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ChaosScheduleDescription>;
  getChaosSchedule(callback: ServiceCallback<models.ChaosScheduleDescription>): void;
  getChaosSchedule(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ChaosScheduleDescription>): void;


  /**
   * @summary Set the schedule used by Chaos.
   *
   * Chaos will automatically schedule runs based on the Chaos Schedule.
   * The Chaos Schedule will be updated if the provided version matches the
   * version on the server.
   * When updating the Chaos Schedule, the version on the server is incremented
   * by 1.
   * The version on the server will wrap back to 0 after reaching a large number.
   * If Chaos is running when this call is made, the call will fail.
   *
   * @param {object} chaosSchedule Describes the schedule used by Chaos.
   *
   * @param {number} [chaosSchedule.version] The version number of the Schedule.
   *
   * @param {object} [chaosSchedule.schedule] Defines the schedule used by Chaos.
   *
   * @param {date} [chaosSchedule.schedule.startDate] The date and time Chaos
   * will start using this schedule.
   *
   * @param {date} [chaosSchedule.schedule.expiryDate] The date and time Chaos
   * will continue to use this schedule until.
   *
   * @param {array} [chaosSchedule.schedule.chaosParametersDictionary] A mapping
   * of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
   *
   * @param {array} [chaosSchedule.schedule.jobs] A list of all Chaos Schedule
   * Jobs that will be automated by the schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  postChaosScheduleWithHttpOperationResponse(chaosSchedule: models.ChaosScheduleDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Set the schedule used by Chaos.
   *
   * Chaos will automatically schedule runs based on the Chaos Schedule.
   * The Chaos Schedule will be updated if the provided version matches the
   * version on the server.
   * When updating the Chaos Schedule, the version on the server is incremented
   * by 1.
   * The version on the server will wrap back to 0 after reaching a large number.
   * If Chaos is running when this call is made, the call will fail.
   *
   * @param {object} chaosSchedule Describes the schedule used by Chaos.
   *
   * @param {number} [chaosSchedule.version] The version number of the Schedule.
   *
   * @param {object} [chaosSchedule.schedule] Defines the schedule used by Chaos.
   *
   * @param {date} [chaosSchedule.schedule.startDate] The date and time Chaos
   * will start using this schedule.
   *
   * @param {date} [chaosSchedule.schedule.expiryDate] The date and time Chaos
   * will continue to use this schedule until.
   *
   * @param {array} [chaosSchedule.schedule.chaosParametersDictionary] A mapping
   * of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
   *
   * @param {array} [chaosSchedule.schedule.jobs] A list of all Chaos Schedule
   * Jobs that will be automated by the schedule.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  postChaosSchedule(chaosSchedule: models.ChaosScheduleDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  postChaosSchedule(chaosSchedule: models.ChaosScheduleDescription, callback: ServiceCallback<void>): void;
  postChaosSchedule(chaosSchedule: models.ChaosScheduleDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  uploadFileWithHttpOperationResponse(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Uploads contents of the file to the image store.
   *
   * Uploads contents of the file to the image store. Use this API if the file is
   * small enough to upload again if the connection fails. The file's data needs
   * to be added to the request body. The contents will be uploaded to the
   * specified path. Image store service uses a mark file to indicate the
   * availability of the folder. The mark file is an empty file named "_.dir".
   * The mark file is generated by the image store service when all files in a
   * folder are uploaded. When using File-by-File approach to upload application
   * package in REST, the image store service isn't aware of the file hierarchy
   * of the application package; you need to create a mark file per folder and
   * upload it last, to let the image store service know that the folder is
   * complete.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  uploadFile(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  uploadFile(contentPath: string, callback: ServiceCallback<void>): void;
  uploadFile(contentPath: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath. The contentPath is relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getImageStoreContentWithHttpOperationResponse(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ImageStoreContent>>;

  /**
   * @summary Gets the image store content information.
   *
   * Returns the information about the image store content at the specified
   * contentPath. The contentPath is relative to the root of the image store.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ImageStoreContent} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreContent(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ImageStoreContent>;
  getImageStoreContent(contentPath: string, callback: ServiceCallback<models.ImageStoreContent>): void;
  getImageStoreContent(contentPath: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ImageStoreContent>): void;


  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteImageStoreContentWithHttpOperationResponse(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes existing image store content.
   *
   * Deletes existing image store content being found within the given image
   * store relative path. This can be used to delete uploaded application
   * packages once they are provisioned.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteImageStoreContent(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteImageStoreContent(contentPath: string, callback: ServiceCallback<void>): void;
  deleteImageStoreContent(contentPath: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ImageStoreContent>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getImageStoreRootContentWithHttpOperationResponse(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ImageStoreContent>>;

  /**
   * @summary Gets the content information at the root of the image store.
   *
   * Returns the information about the image store content at the root of the
   * image store.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ImageStoreContent} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ImageStoreContent} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ImageStoreContent} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreRootContent(options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.ImageStoreContent>;
  getImageStoreRootContent(callback: ServiceCallback<models.ImageStoreContent>): void;
  getImageStoreRootContent(options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ImageStoreContent>): void;


  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  copyImageStoreContentWithHttpOperationResponse(imageStoreCopyDescription: models.ImageStoreCopyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Copies image store content internally
   *
   * Copies the image store content from the source image store relative path to
   * the destination image store relative path.
   *
   * @param {object} imageStoreCopyDescription Describes the copy description for
   * the image store.
   *
   * @param {string} imageStoreCopyDescription.remoteSource The relative path of
   * source image store content to be copied from.
   *
   * @param {string} imageStoreCopyDescription.remoteDestination The relative
   * path of destination image store content to be copied to.
   *
   * @param {array} [imageStoreCopyDescription.skipFiles] The list of the file
   * names to be skipped for copying.
   *
   * @param {boolean} [imageStoreCopyDescription.checkMarkFile] Indicates whether
   * to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether
   * the folder is well constructed. If the property is true and mark file does
   * not exist, the copy is skipped.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  copyImageStoreContent(imageStoreCopyDescription: models.ImageStoreCopyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  copyImageStoreContent(imageStoreCopyDescription: models.ImageStoreCopyDescription, callback: ServiceCallback<void>): void;
  copyImageStoreContent(imageStoreCopyDescription: models.ImageStoreCopyDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Cancels an image store upload session.
   *
   * The DELETE request will cause the existing upload session to expire and
   * remove any previously uploaded file chunks.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteImageStoreUploadSessionWithHttpOperationResponse(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Cancels an image store upload session.
   *
   * The DELETE request will cause the existing upload session to expire and
   * remove any previously uploaded file chunks.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteImageStoreUploadSession(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteImageStoreUploadSession(sessionId: string, callback: ServiceCallback<void>): void;
  deleteImageStoreUploadSession(sessionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Commit an image store upload session.
   *
   * When all file chunks have been uploaded, the upload session needs to be
   * committed explicitly to complete the upload. Image store preserves the
   * upload session until the expiration time, which is 30 minutes after the last
   * chunk received.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  commitImageStoreUploadSessionWithHttpOperationResponse(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Commit an image store upload session.
   *
   * When all file chunks have been uploaded, the upload session needs to be
   * committed explicitly to complete the upload. Image store preserves the
   * upload session until the expiration time, which is 30 minutes after the last
   * chunk received.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  commitImageStoreUploadSession(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  commitImageStoreUploadSession(sessionId: string, callback: ServiceCallback<void>): void;
  commitImageStoreUploadSession(sessionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Get the image store upload session by ID.
   *
   * Gets the image store upload session identified by the given ID. User can
   * query the upload session at any time during uploading.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UploadSession>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getImageStoreUploadSessionByIdWithHttpOperationResponse(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.UploadSession>>;

  /**
   * @summary Get the image store upload session by ID.
   *
   * Gets the image store upload session identified by the given ID. User can
   * query the upload session at any time during uploading.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {UploadSession} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {UploadSession} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UploadSession} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreUploadSessionById(sessionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.UploadSession>;
  getImageStoreUploadSessionById(sessionId: string, callback: ServiceCallback<models.UploadSession>): void;
  getImageStoreUploadSessionById(sessionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.UploadSession>): void;


  /**
   * @summary Get the image store upload session by relative path.
   *
   * Gets the image store upload session associated with the given image store
   * relative path. User can query the upload session at any time during
   * uploading.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UploadSession>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getImageStoreUploadSessionByPathWithHttpOperationResponse(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.UploadSession>>;

  /**
   * @summary Get the image store upload session by relative path.
   *
   * Gets the image store upload session associated with the given image store
   * relative path. User can query the upload session at any time during
   * uploading.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {UploadSession} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {UploadSession} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UploadSession} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getImageStoreUploadSessionByPath(contentPath: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.UploadSession>;
  getImageStoreUploadSessionByPath(contentPath: string, callback: ServiceCallback<models.UploadSession>): void;
  getImageStoreUploadSessionByPath(contentPath: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.UploadSession>): void;


  /**
   * @summary Uploads a file chunk to the image store relative path.
   *
   * Uploads a file chunk to the image store with the specified upload session ID
   * and image store relative path. This API allows user to resume the file
   * upload operation. user doesn't have to restart the file upload from scratch
   * whenever there is a network interruption. Use this option if the file size
   * is large.
   *
   * To perform a resumable file upload, user need to break the file into
   * multiple chunks and upload these chunks to the image store one-by-one.
   * Chunks don't have to be uploaded in order. If the file represented by the
   * image store relative path already exists, it will be overwritten when the
   * upload session commits.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {string} contentRange When uploading file chunks to the image store,
   * the Content-Range header field need to be configured and sent with a
   * request. The format should looks like "bytes
   * {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example,
   * Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300
   * through 5,000 and the total file length is 20,000 bytes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  uploadFileChunkWithHttpOperationResponse(contentPath: string, sessionId: string, contentRange: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Uploads a file chunk to the image store relative path.
   *
   * Uploads a file chunk to the image store with the specified upload session ID
   * and image store relative path. This API allows user to resume the file
   * upload operation. user doesn't have to restart the file upload from scratch
   * whenever there is a network interruption. Use this option if the file size
   * is large.
   *
   * To perform a resumable file upload, user need to break the file into
   * multiple chunks and upload these chunks to the image store one-by-one.
   * Chunks don't have to be uploaded in order. If the file represented by the
   * image store relative path already exists, it will be overwritten when the
   * upload session commits.
   *
   * @param {string} contentPath Relative path to file or folder in the image
   * store from its root.
   *
   * @param {uuid} sessionId A GUID generated by the user for a file uploading.
   * It identifies an image store upload session which keeps track of all file
   * chunks until it is committed.
   *
   * @param {string} contentRange When uploading file chunks to the image store,
   * the Content-Range header field need to be configured and sent with a
   * request. The format should looks like "bytes
   * {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example,
   * Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300
   * through 5,000 and the total file length is 20,000 bytes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  uploadFileChunk(contentPath: string, sessionId: string, contentRange: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  uploadFileChunk(contentPath: string, sessionId: string, contentRange: string, callback: ServiceCallback<void>): void;
  uploadFileChunk(contentPath: string, sessionId: string, contentRange: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  invokeInfrastructureCommandWithHttpOperationResponse(command: string, options?: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<string>>;

  /**
   * @summary Invokes an administrative command on the given Infrastructure
   * Service instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific commands to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {String} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureCommand(command: string, options?: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<string>;
  invokeInfrastructureCommand(command: string, callback: ServiceCallback<string>): void;
  invokeInfrastructureCommand(command: string, options: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<string>): void;


  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  invokeInfrastructureQueryWithHttpOperationResponse(command: string, options?: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<string>>;

  /**
   * @summary Invokes a read-only query on the given infrastructure service
   * instance.
   *
   * For clusters that have one or more instances of the Infrastructure Service
   * configured,
   * this API provides a way to send infrastructure-specific queries to a
   * particular
   * instance of the Infrastructure Service.
   *
   * Available commands and their corresponding response formats vary depending
   * upon
   * the infrastructure on which the cluster is running.
   *
   * This API supports the Service Fabric platform; it is not meant to be used
   * directly from your code.
   *
   * @param {string} command The text of the command to be invoked. The content
   * of the command is infrastructure-specific.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.serviceId] The identity of the infrastructure
   * service. This is the full name of the infrastructure service without the
   * 'fabric:' URI scheme. This parameter required only for the cluster that has
   * more than one instance of infrastructure service running.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {String} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  invokeInfrastructureQuery(command: string, options?: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<string>;
  invokeInfrastructureQuery(command: string, callback: ServiceCallback<string>): void;
  invokeInfrastructureQuery(command: string, options: { serviceId? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<string>): void;


  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode.
   *
   * - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * - FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce. Possible values include:
   * 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startDataLossWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, dataLossMode: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary This API will induce data loss for the specified partition. It will
   * trigger a call to the OnDataLossAsync API of the partition.
   *
   * This API will induce data loss for the specified partition. It will trigger
   * a call to the OnDataLoss API of the partition.
   * Actual data loss will depend on the specified DataLossMode.
   *
   * - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is
   * triggered for the partition but actual data loss depends on the presence of
   * in-flight replication.
   * - FullDataLoss - All replicas are removed hence all data is lost and
   * OnDataLoss is triggered.
   *
   * This API should only be called with a stateful service as the target.
   *
   * Calling this API with a system service as the target is not advised.
   *
   * Note:  Once this API has been called, it cannot be reversed. Calling
   * CancelOperation will only stop execution and clean up internal system state.
   * It will not restore data if the command has progressed far enough to cause
   * data loss.
   *
   * Call the GetDataLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} dataLossMode This enum is passed to the StartDataLoss API to
   * indicate what type of data loss to induce. Possible values include:
   * 'Invalid', 'PartialDataLoss', 'FullDataLoss'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startDataLoss(serviceId: string, partitionId: string, operationId: string, dataLossMode: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startDataLoss(serviceId: string, partitionId: string, operationId: string, dataLossMode: string, callback: ServiceCallback<void>): void;
  startDataLoss(serviceId: string, partitionId: string, operationId: string, dataLossMode: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionDataLossProgress>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDataLossProgressWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionDataLossProgress>>;

  /**
   * @summary Gets the progress of a partition data loss operation started using
   * the StartDataLoss API.
   *
   * Gets the progress of a data loss operation started with StartDataLoss, using
   * the OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionDataLossProgress} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionDataLossProgress} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionDataLossProgress} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataLossProgress(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionDataLossProgress>;
  getDataLossProgress(serviceId: string, partitionId: string, operationId: string, callback: ServiceCallback<models.PartitionDataLossProgress>): void;
  getDataLossProgress(serviceId: string, partitionId: string, operationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionDataLossProgress>): void;


  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * This API is useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce. Possible values include:
   * 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startQuorumLossWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, quorumLossMode: string, quorumLossDuration: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Induces quorum loss for a given stateful service partition.
   *
   * This API is useful for a temporary quorum loss situation on your service.
   *
   * Call the GetQuorumLossProgress API with the same OperationId to return
   * information on the operation started with this API.
   *
   * This can only be called on stateful persisted (HasPersistedState==true)
   * services.  Do not use this API on stateless services or stateful in-memory
   * only services.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} quorumLossMode This enum is passed to the StartQuorumLoss
   * API to indicate what type of quorum loss to induce. Possible values include:
   * 'Invalid', 'QuorumReplicas', 'AllReplicas'
   *
   * @param {number} quorumLossDuration The amount of time for which the
   * partition will be kept in quorum loss.  This must be specified in seconds.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startQuorumLoss(serviceId: string, partitionId: string, operationId: string, quorumLossMode: string, quorumLossDuration: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startQuorumLoss(serviceId: string, partitionId: string, operationId: string, quorumLossMode: string, quorumLossDuration: number, callback: ServiceCallback<void>): void;
  startQuorumLoss(serviceId: string, partitionId: string, operationId: string, quorumLossMode: string, quorumLossDuration: number, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionQuorumLossProgress>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getQuorumLossProgressWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionQuorumLossProgress>>;

  /**
   * @summary Gets the progress of a quorum loss operation on a partition started
   * using the StartQuorumLoss API.
   *
   * Gets the progress of a quorum loss operation started with StartQuorumLoss,
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionQuorumLossProgress} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionQuorumLossProgress} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionQuorumLossProgress} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getQuorumLossProgress(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionQuorumLossProgress>;
  getQuorumLossProgress(serviceId: string, partitionId: string, operationId: string, callback: ServiceCallback<models.PartitionQuorumLossProgress>): void;
  getQuorumLossProgress(serviceId: string, partitionId: string, operationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionQuorumLossProgress>): void;


  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode Describe which partitions to restart.
   * Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startPartitionRestartWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, restartPartitionMode: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary This API will restart some or all replicas or instances of the
   * specified partition.
   *
   * This API is useful for testing failover.
   *
   * If used to target a stateless service partition, RestartPartitionMode must
   * be AllReplicasOrInstances.
   *
   * Call the GetPartitionRestartProgress API using the same OperationId to get
   * the progress.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} restartPartitionMode Describe which partitions to restart.
   * Possible values include: 'Invalid', 'AllReplicasOrInstances',
   * 'OnlyActiveSecondaries'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startPartitionRestart(serviceId: string, partitionId: string, operationId: string, restartPartitionMode: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startPartitionRestart(serviceId: string, partitionId: string, operationId: string, restartPartitionMode: string, callback: ServiceCallback<void>): void;
  startPartitionRestart(serviceId: string, partitionId: string, operationId: string, restartPartitionMode: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionRestartProgress>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionRestartProgressWithHttpOperationResponse(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionRestartProgress>>;

  /**
   * @summary Gets the progress of a PartitionRestart operation started using
   * StartPartitionRestart.
   *
   * Gets the progress of a PartitionRestart started with StartPartitionRestart
   * using the provided OperationId.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionRestartProgress} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionRestartProgress} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionRestartProgress} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionRestartProgress(serviceId: string, partitionId: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionRestartProgress>;
  getPartitionRestartProgress(serviceId: string, partitionId: string, operationId: string, callback: ServiceCallback<models.PartitionRestartProgress>): void;
  getPartitionRestartProgress(serviceId: string, partitionId: string, operationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionRestartProgress>): void;


  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up. Possible values
   * include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  startNodeTransitionWithHttpOperationResponse(nodeName: string, operationId: string, nodeTransitionType: string, nodeInstanceId: string, stopDurationInSeconds: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Starts or stops a cluster node.
   *
   * Starts or stops a cluster node.  A cluster node is a process, not the OS
   * instance itself.  To start a node, pass in "Start" for the
   * NodeTransitionType parameter.
   * To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This
   * API starts the operation - when the API returns the node may not have
   * finished transitioning yet.
   * Call GetNodeTransitionProgress with the same OperationId to get the progress
   * of the operation.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {string} nodeTransitionType Indicates the type of transition to
   * perform.  NodeTransitionType.Start will start a stopped node.
   * NodeTransitionType.Stop will stop a node that is up. Possible values
   * include: 'Invalid', 'Start', 'Stop'
   *
   * @param {string} nodeInstanceId The node instance ID of the target node.
   * This can be determined through GetNodeInfo API.
   *
   * @param {number} stopDurationInSeconds The duration, in seconds, to keep the
   * node stopped.  The minimum value is 600, the maximum is 14400.  After this
   * time expires, the node will automatically come back up.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  startNodeTransition(nodeName: string, operationId: string, nodeTransitionType: string, nodeInstanceId: string, stopDurationInSeconds: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  startNodeTransition(nodeName: string, operationId: string, nodeTransitionType: string, nodeInstanceId: string, stopDurationInSeconds: number, callback: ServiceCallback<void>): void;
  startNodeTransition(nodeName: string, operationId: string, nodeTransitionType: string, nodeInstanceId: string, stopDurationInSeconds: number, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NodeTransitionProgress>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeTransitionProgressWithHttpOperationResponse(nodeName: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeTransitionProgress>>;

  /**
   * @summary Gets the progress of an operation started using
   * StartNodeTransition.
   *
   * Gets the progress of an operation started with StartNodeTransition using the
   * provided OperationId.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {NodeTransitionProgress} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {NodeTransitionProgress} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NodeTransitionProgress} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeTransitionProgress(nodeName: string, operationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeTransitionProgress>;
  getNodeTransitionProgress(nodeName: string, operationId: string, callback: ServiceCallback<models.NodeTransitionProgress>): void;
  getNodeTransitionProgress(nodeName: string, operationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeTransitionProgress>): void;


  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the a list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   *
   * - 65535 - select all
   * - 1 - select PartitionDataLoss.
   * - 2 - select PartitionQuorumLoss.
   * - 4 - select PartitionRestart.
   * - 8 - select NodeTransition.
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   *
   * - 65535 - select All
   * - 1 - select Running
   * - 2 - select RollingBack
   * - 8 - select Completed
   * - 16 - select Faulted
   * - 32 - select Cancelled
   * - 64 - select ForceCancelled
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getFaultOperationListWithHttpOperationResponse(typeFilter: number, stateFilter: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.OperationStatus[]>>;

  /**
   * @summary Gets a list of user-induced fault operations filtered by provided
   * input.
   *
   * Gets the a list of user-induced fault operations filtered by provided input.
   *
   * @param {number} typeFilter Used to filter on OperationType for user-induced
   * operations.
   *
   * - 65535 - select all
   * - 1 - select PartitionDataLoss.
   * - 2 - select PartitionQuorumLoss.
   * - 4 - select PartitionRestart.
   * - 8 - select NodeTransition.
   *
   * @param {number} stateFilter Used to filter on OperationState's for
   * user-induced operations.
   *
   * - 65535 - select All
   * - 1 - select Running
   * - 2 - select RollingBack
   * - 8 - select Completed
   * - 16 - select Faulted
   * - 32 - select Cancelled
   * - 64 - select ForceCancelled
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getFaultOperationList(typeFilter: number, stateFilter: number, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.OperationStatus[]>;
  getFaultOperationList(typeFilter: number, stateFilter: number, callback: ServiceCallback<models.OperationStatus[]>): void;
  getFaultOperationList(typeFilter: number, stateFilter: number, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.OperationStatus[]>): void;


  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following APIs start fault operations that may be cancelled by using
   * CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart,
   * StartNodeTransition.
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will be/is
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully rollback and clean up
   * internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  cancelOperationWithHttpOperationResponse(operationId: string, force: boolean, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Cancels a user-induced fault operation.
   *
   * The following APIs start fault operations that may be cancelled by using
   * CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart,
   * StartNodeTransition.
   *
   * If force is false, then the specified user-induced operation will be
   * gracefully stopped and cleaned up.  If force is true, the command will be
   * aborted, and some internal state
   * may be left behind.  Specifying force as true should be used with care.
   * Calling this API with force set to true is not allowed until this API has
   * already
   * been called on the same test command with force set to false first, or
   * unless the test command already has an OperationState of
   * OperationState.RollingBack.
   * Clarification: OperationState.RollingBack means that the system will be/is
   * cleaning up internal system state caused by executing the command.  It will
   * not restore data if the
   * test command was to cause data loss.  For example, if you call StartDataLoss
   * then call this API, the system will only clean up internal state from
   * running the command.
   * It will not restore the target partition's data, if the command progressed
   * far enough to cause data loss.
   *
   * Important note:  if this API is invoked with force==true, internal state may
   * be left behind.
   *
   * @param {uuid} operationId A GUID that identifies a call of this API.  This
   * is passed into the corresponding GetProgress API
   *
   * @param {boolean} force Indicates whether to gracefully rollback and clean up
   * internal system state modified by executing the user-induced operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelOperation(operationId: string, force: boolean, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  cancelOperation(operationId: string, force: boolean, callback: ServiceCallback<void>): void;
  cancelOperation(operationId: string, force: boolean, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Creates a backup policy.
   *
   * Creates a backup policy which can be associated later with a Service Fabric
   * application, service or a partition for periodic backup.
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createBackupPolicyWithHttpOperationResponse(backupPolicyDescription: models.BackupPolicyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates a backup policy.
   *
   * Creates a backup policy which can be associated later with a Service Fabric
   * application, service or a partition for periodic backup.
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, callback: ServiceCallback<void>): void;
  createBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Deletes the backup policy.
   *
   * Deletes an existing backup policy. A backup policy must be created before it
   * can be deleted. A currently active backup policy, associated with any
   * Service Fabric application, service or partition, cannot be deleted without
   * first deleting the mapping.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteBackupPolicyWithHttpOperationResponse(backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes the backup policy.
   *
   * Deletes an existing backup policy. A backup policy must be created before it
   * can be deleted. A currently active backup policy, associated with any
   * Service Fabric application, service or partition, cannot be deleted without
   * first deleting the mapping.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupPolicy(backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteBackupPolicy(backupPolicyName: string, callback: ServiceCallback<void>): void;
  deleteBackupPolicy(backupPolicyName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets all the backup policies configured.
   *
   * Get a list of all the backup policies configured.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupPolicyDescriptionList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getBackupPolicyListWithHttpOperationResponse(options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupPolicyDescriptionList>>;

  /**
   * @summary Gets all the backup policies configured.
   *
   * Get a list of all the backup policies configured.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupPolicyDescriptionList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupPolicyDescriptionList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupPolicyDescriptionList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupPolicyList(options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupPolicyDescriptionList>;
  getBackupPolicyList(callback: ServiceCallback<models.PagedBackupPolicyDescriptionList>): void;
  getBackupPolicyList(options: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupPolicyDescriptionList>): void;


  /**
   * @summary Gets a particular backup policy by name.
   *
   * Gets a particular backup policy identified by {backupPolicyName}
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupPolicyDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getBackupPolicyByNameWithHttpOperationResponse(backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.BackupPolicyDescription>>;

  /**
   * @summary Gets a particular backup policy by name.
   *
   * Gets a particular backup policy identified by {backupPolicyName}
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {BackupPolicyDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {BackupPolicyDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupPolicyDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupPolicyByName(backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.BackupPolicyDescription>;
  getBackupPolicyByName(backupPolicyName: string, callback: ServiceCallback<models.BackupPolicyDescription>): void;
  getBackupPolicyByName(backupPolicyName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.BackupPolicyDescription>): void;


  /**
   * @summary Gets the list of backup entities that are associated with this
   * policy.
   *
   * Returns a list of Service Fabric application, service or partition which are
   * associated with this backup policy.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupEntityList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllEntitiesBackedUpByPolicyWithHttpOperationResponse(backupPolicyName: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupEntityList>>;

  /**
   * @summary Gets the list of backup entities that are associated with this
   * policy.
   *
   * Returns a list of Service Fabric application, service or partition which are
   * associated with this backup policy.
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupEntityList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupEntityList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupEntityList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllEntitiesBackedUpByPolicy(backupPolicyName: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupEntityList>;
  getAllEntitiesBackedUpByPolicy(backupPolicyName: string, callback: ServiceCallback<models.PagedBackupEntityList>): void;
  getAllEntitiesBackedUpByPolicy(backupPolicyName: string, options: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupEntityList>): void;


  /**
   * @summary Updates the backup policy.
   *
   * Updates the backup policy identified by {backupPolicyName}
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateBackupPolicyWithHttpOperationResponse(backupPolicyDescription: models.BackupPolicyDescription, backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Updates the backup policy.
   *
   * Updates the backup policy identified by {backupPolicyName}
   *
   * @param {object} backupPolicyDescription Describes the backup policy.
   *
   * @param {string} backupPolicyDescription.name The unique name identifying
   * this backup policy.
   *
   * @param {boolean} backupPolicyDescription.autoRestoreOnDataLoss Specifies
   * whether to trigger restore automatically using the latest available backup
   * in case the partition experiences a data loss event.
   *
   * @param {number} backupPolicyDescription.maxIncrementalBackups Defines the
   * maximum number of incremental backups to be taken between two full backups.
   * This is just the upper limit. A full backup may be taken before specified
   * number of incremental backups are completed in one of the following
   * conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   *
   * @param {object} backupPolicyDescription.schedule Describes the backup
   * schedule parameters.
   *
   * @param {string} backupPolicyDescription.schedule.scheduleKind Polymorphic
   * Discriminator
   *
   * @param {object} backupPolicyDescription.storage Describes the details of
   * backup storage where to store the periodic backups.
   *
   * @param {string} [backupPolicyDescription.storage.friendlyName] Friendly name
   * for this backup storage.
   *
   * @param {string} backupPolicyDescription.storage.storageKind Polymorphic
   * Discriminator
   *
   * @param {string} backupPolicyName The name of the backup policy.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, backupPolicyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  updateBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, backupPolicyName: string, callback: ServiceCallback<void>): void;
  updateBackupPolicy(backupPolicyDescription: models.BackupPolicyDescription, backupPolicyName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric application.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric application. Each partition is backed up individually as per
   * the specified backup policy description.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  enableApplicationBackupWithHttpOperationResponse(applicationId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric application.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric application. Each partition is backed up individually as per
   * the specified backup policy description.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  enableApplicationBackup(applicationId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  enableApplicationBackup(applicationId: string, enableBackupDescription: models.EnableBackupDescription, callback: ServiceCallback<void>): void;
  enableApplicationBackup(applicationId: string, enableBackupDescription: models.EnableBackupDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Disables periodic backup of Service Fabric application.
   *
   * Disables periodic backup of Service Fabric application which was previously
   * enabled.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  disableApplicationBackupWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Disables periodic backup of Service Fabric application.
   *
   * Disables periodic backup of Service Fabric application which was previously
   * enabled.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  disableApplicationBackup(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  disableApplicationBackup(applicationId: string, callback: ServiceCallback<void>): void;
  disableApplicationBackup(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the Service Fabric application backup configuration
   * information.
   *
   * Gets the Service Fabric backup configuration information for the application
   * and the services and partitions under this application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupConfigurationInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationBackupConfigurationInfoWithHttpOperationResponse(applicationId: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupConfigurationInfoList>>;

  /**
   * @summary Gets the Service Fabric application backup configuration
   * information.
   *
   * Gets the Service Fabric backup configuration information for the application
   * and the services and partitions under this application.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupConfigurationInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupConfigurationInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupConfigurationInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationBackupConfigurationInfo(applicationId: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupConfigurationInfoList>;
  getApplicationBackupConfigurationInfo(applicationId: string, callback: ServiceCallback<models.PagedBackupConfigurationInfoList>): void;
  getApplicationBackupConfigurationInfo(applicationId: string, options: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupConfigurationInfoList>): void;


  /**
   * @summary Gets the list of backups available for every partition in this
   * application.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric application. The server enumerates all the backups available at the
   * backup location configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationBackupListWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupInfoList>>;

  /**
   * @summary Gets the list of backups available for every partition in this
   * application.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric application. The server enumerates all the backups available at the
   * backup location configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationBackupList(applicationId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupInfoList>;
  getApplicationBackupList(applicationId: string, callback: ServiceCallback<models.PagedBackupInfoList>): void;
  getApplicationBackupList(applicationId: string, options: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupInfoList>): void;


  /**
   * @summary Suspends periodic backup for the specified Service Fabric
   * application.
   *
   * The application which is configured to take periodic backups, is suspended
   * for taking further backups till it is resumed again. This operation applies
   * to the entire application's hierarchy. It means all the services and
   * partitions under this application are now suspended for backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  suspendApplicationBackupWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Suspends periodic backup for the specified Service Fabric
   * application.
   *
   * The application which is configured to take periodic backups, is suspended
   * for taking further backups till it is resumed again. This operation applies
   * to the entire application's hierarchy. It means all the services and
   * partitions under this application are now suspended for backup.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendApplicationBackup(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  suspendApplicationBackup(applicationId: string, callback: ServiceCallback<void>): void;
  suspendApplicationBackup(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Resumes periodic backup of a Service Fabric application which was
   * previously suspended.
   *
   * The previously suspended Service Fabric application resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resumeApplicationBackupWithHttpOperationResponse(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Resumes periodic backup of a Service Fabric application which was
   * previously suspended.
   *
   * The previously suspended Service Fabric application resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeApplicationBackup(applicationId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resumeApplicationBackup(applicationId: string, callback: ServiceCallback<void>): void;
  resumeApplicationBackup(applicationId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric service.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric service. Each partition is backed up individually as per the
   * specified backup policy description. In case the application, which the
   * service is part of, is already enabled for backup then this operation would
   * override the policy being used to take the periodic backup for this service
   * and its partitions (unless explicitly overridden at the partition level).
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  enableServiceBackupWithHttpOperationResponse(serviceId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Enables periodic backup of stateful partitions under this Service
   * Fabric service.
   *
   * Enables periodic backup of stateful partitions which are part of this
   * Service Fabric service. Each partition is backed up individually as per the
   * specified backup policy description. In case the application, which the
   * service is part of, is already enabled for backup then this operation would
   * override the policy being used to take the periodic backup for this service
   * and its partitions (unless explicitly overridden at the partition level).
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  enableServiceBackup(serviceId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  enableServiceBackup(serviceId: string, enableBackupDescription: models.EnableBackupDescription, callback: ServiceCallback<void>): void;
  enableServiceBackup(serviceId: string, enableBackupDescription: models.EnableBackupDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Disables periodic backup of Service Fabric service which was
   * previously enabled.
   *
   * Disables periodic backup of Service Fabric service which was previously
   * enabled. Backup must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application, which this
   * service is part of, this service would continue to be periodically backed up
   * as per the policy mapped at the application level.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  disableServiceBackupWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Disables periodic backup of Service Fabric service which was
   * previously enabled.
   *
   * Disables periodic backup of Service Fabric service which was previously
   * enabled. Backup must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application, which this
   * service is part of, this service would continue to be periodically backed up
   * as per the policy mapped at the application level.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  disableServiceBackup(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  disableServiceBackup(serviceId: string, callback: ServiceCallback<void>): void;
  disableServiceBackup(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the Service Fabric service backup configuration information.
   *
   * Gets the Service Fabric backup configuration information for the service and
   * the partitions under this service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupConfigurationInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceBackupConfigurationInfoWithHttpOperationResponse(serviceId: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupConfigurationInfoList>>;

  /**
   * @summary Gets the Service Fabric service backup configuration information.
   *
   * Gets the Service Fabric backup configuration information for the service and
   * the partitions under this service.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupConfigurationInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupConfigurationInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupConfigurationInfoList} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceBackupConfigurationInfo(serviceId: string, options?: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupConfigurationInfoList>;
  getServiceBackupConfigurationInfo(serviceId: string, callback: ServiceCallback<models.PagedBackupConfigurationInfoList>): void;
  getServiceBackupConfigurationInfo(serviceId: string, options: { continuationToken? : string, maxResults? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupConfigurationInfoList>): void;


  /**
   * @summary Gets the list of backups available for every partition in this
   * service.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric service. The server enumerates all the backups available in the
   * backup store configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceBackupListWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupInfoList>>;

  /**
   * @summary Gets the list of backups available for every partition in this
   * service.
   *
   * Returns a list of backups available for every partition in this Service
   * Fabric service. The server enumerates all the backups available in the
   * backup store configured in the backup policy. It also allows filtering of
   * the result based on start and end datetime or just fetching the latest
   * available backup for every partition.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceBackupList(serviceId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupInfoList>;
  getServiceBackupList(serviceId: string, callback: ServiceCallback<models.PagedBackupInfoList>): void;
  getServiceBackupList(serviceId: string, options: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupInfoList>): void;


  /**
   * @summary Suspends periodic backup for the specified Service Fabric service.
   *
   * The service which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again. This operation applies to
   * the entire service's hierarchy. It means all the partitions under this
   * service are now suspended for backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  suspendServiceBackupWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Suspends periodic backup for the specified Service Fabric service.
   *
   * The service which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again. This operation applies to
   * the entire service's hierarchy. It means all the partitions under this
   * service are now suspended for backup.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendServiceBackup(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  suspendServiceBackup(serviceId: string, callback: ServiceCallback<void>): void;
  suspendServiceBackup(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Resumes periodic backup of a Service Fabric service which was
   * previously suspended.
   *
   * The previously suspended Service Fabric service resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resumeServiceBackupWithHttpOperationResponse(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Resumes periodic backup of a Service Fabric service which was
   * previously suspended.
   *
   * The previously suspended Service Fabric service resumes taking periodic
   * backup as per the backup policy currently configured for the same.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resumeServiceBackup(serviceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resumeServiceBackup(serviceId: string, callback: ServiceCallback<void>): void;
  resumeServiceBackup(serviceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Enables periodic backup of the stateful persisted partition.
   *
   * Enables periodic backup of stateful persisted partition. Each partition is
   * backed up as per the specified backup policy description. In case the
   * application or service, which is partition is part of, is already enabled
   * for backup then this operation would override the policy being used to take
   * the periodic backup of this partition.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  enablePartitionBackupWithHttpOperationResponse(partitionId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Enables periodic backup of the stateful persisted partition.
   *
   * Enables periodic backup of stateful persisted partition. Each partition is
   * backed up as per the specified backup policy description. In case the
   * application or service, which is partition is part of, is already enabled
   * for backup then this operation would override the policy being used to take
   * the periodic backup of this partition.
   * Note only C# based Reliable Actor and Reliable Stateful services are
   * currently supported for periodic backup.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} enableBackupDescription Specifies the parameters for
   * enabling backup.
   *
   * @param {string} enableBackupDescription.backupPolicyName Name of the backup
   * policy to be used for enabling periodic backups.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  enablePartitionBackup(partitionId: string, enableBackupDescription: models.EnableBackupDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  enablePartitionBackup(partitionId: string, enableBackupDescription: models.EnableBackupDescription, callback: ServiceCallback<void>): void;
  enablePartitionBackup(partitionId: string, enableBackupDescription: models.EnableBackupDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Disables periodic backup of Service Fabric partition which was
   * previously enabled.
   *
   * Disables periodic backup of partition which was previously enabled. Backup
   * must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application or service,
   * which this partition is part of, this partition would continue to be
   * periodically backed up as per the policy mapped at the higher level entity.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  disablePartitionBackupWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Disables periodic backup of Service Fabric partition which was
   * previously enabled.
   *
   * Disables periodic backup of partition which was previously enabled. Backup
   * must be explicitly enabled before it can be disabled.
   * In case the backup is enabled for the Service Fabric application or service,
   * which this partition is part of, this partition would continue to be
   * periodically backed up as per the policy mapped at the higher level entity.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  disablePartitionBackup(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  disablePartitionBackup(partitionId: string, callback: ServiceCallback<void>): void;
  disablePartitionBackup(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the partition backup configuration information
   *
   * Gets the Service Fabric Backup configuration information for the specified
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PartitionBackupConfigurationInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionBackupConfigurationInfoWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionBackupConfigurationInfo>>;

  /**
   * @summary Gets the partition backup configuration information
   *
   * Gets the Service Fabric Backup configuration information for the specified
   * partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PartitionBackupConfigurationInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PartitionBackupConfigurationInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PartitionBackupConfigurationInfo} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupConfigurationInfo(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionBackupConfigurationInfo>;
  getPartitionBackupConfigurationInfo(partitionId: string, callback: ServiceCallback<models.PartitionBackupConfigurationInfo>): void;
  getPartitionBackupConfigurationInfo(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionBackupConfigurationInfo>): void;


  /**
   * @summary Gets the list of backups available for the specified partition.
   *
   * Returns a list of backups available for the specified partition. The server
   * enumerates all the backups available in the backup store configured in the
   * backup policy. It also allows filtering of the result based on start and end
   * datetime or just fetching the latest available backup for the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionBackupListWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupInfoList>>;

  /**
   * @summary Gets the list of backups available for the specified partition.
   *
   * Returns a list of backups available for the specified partition. The server
   * enumerates all the backups available in the backup store configured in the
   * backup policy. It also allows filtering of the result based on start and end
   * datetime or just fetching the latest available backup for the partition.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {boolean} [options.latest] Specifies whether to get only the most
   * recent backup available for a partition for the specified time range.
   *
   * @param {date} [options.startDateTimeFilter] Specify the start date time from
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, all backups from the beginning are enumerated.
   *
   * @param {date} [options.endDateTimeFilter] Specify the end date time till
   * which to enumerate backups, in datetime format. The date time must be
   * specified in ISO8601 format. This is an optional parameter. If not
   * specified, enumeration is done till the most recent backup.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupList(partitionId: string, options?: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupInfoList>;
  getPartitionBackupList(partitionId: string, callback: ServiceCallback<models.PagedBackupInfoList>): void;
  getPartitionBackupList(partitionId: string, options: { timeout? : number, latest? : boolean, startDateTimeFilter? : Date, endDateTimeFilter? : Date, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupInfoList>): void;


  /**
   * @summary Suspends periodic backup for the specified partition.
   *
   * The partition which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  suspendPartitionBackupWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Suspends periodic backup for the specified partition.
   *
   * The partition which is configured to take periodic backups, is suspended for
   * taking further backups till it is resumed again.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  suspendPartitionBackup(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  suspendPartitionBackup(partitionId: string, callback: ServiceCallback<void>): void;
  suspendPartitionBackup(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Resumes periodic backup of partition which was previously
   * suspended.
   *
   * The previously suspended partition resumes taking periodic backup as per the
   * backup policy currently configured for the same.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resumePartitionBackupWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Resumes periodic backup of partition which was previously
   * suspended.
   *
   * The previously suspended partition resumes taking periodic backup as per the
   * backup policy currently configured for the same.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resumePartitionBackup(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  resumePartitionBackup(partitionId: string, callback: ServiceCallback<void>): void;
  resumePartitionBackup(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Triggers backup of the partition's state.
   *
   * Creates a backup of the stateful persisted partition's state. In case the
   * partition is already being periodically backed up, then by default the new
   * backup is created at the same backup storage. One can also override the same
   * by specifying the backup storage details as part of the request body. Once
   * the backup is initiated, its progress can be tracked using the
   * GetBackupProgress operation.
   * In case, the operation times out, specify a greater backup timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.backupPartitionDescription] Describes the
   * parameters to backup the partition now. If not present, backup operation
   * uses default parameters from the backup policy current associated with this
   * partition.
   *
   * @param {object} [options.backupPartitionDescription.backupStorage] Specifies
   * the details of the backup storage where to save the backup.
   *
   * @param {string}
   * [options.backupPartitionDescription.backupStorage.friendlyName] Friendly
   * name for this backup storage.
   *
   * @param {string} options.backupPartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {number} [options.backupTimeout] Specifies the maximum amount of
   * time, in minutes, to wait for the backup operation to complete. Post that,
   * the operation completes with timeout error. However, in certain corner cases
   * it could be that though the operation returns back timeout, the backup
   * actually goes through. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. The default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  backupPartitionWithHttpOperationResponse(partitionId: string, options?: { backupPartitionDescription? : models.BackupPartitionDescription, backupTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Triggers backup of the partition's state.
   *
   * Creates a backup of the stateful persisted partition's state. In case the
   * partition is already being periodically backed up, then by default the new
   * backup is created at the same backup storage. One can also override the same
   * by specifying the backup storage details as part of the request body. Once
   * the backup is initiated, its progress can be tracked using the
   * GetBackupProgress operation.
   * In case, the operation times out, specify a greater backup timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.backupPartitionDescription] Describes the
   * parameters to backup the partition now. If not present, backup operation
   * uses default parameters from the backup policy current associated with this
   * partition.
   *
   * @param {object} [options.backupPartitionDescription.backupStorage] Specifies
   * the details of the backup storage where to save the backup.
   *
   * @param {string}
   * [options.backupPartitionDescription.backupStorage.friendlyName] Friendly
   * name for this backup storage.
   *
   * @param {string} options.backupPartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {number} [options.backupTimeout] Specifies the maximum amount of
   * time, in minutes, to wait for the backup operation to complete. Post that,
   * the operation completes with timeout error. However, in certain corner cases
   * it could be that though the operation returns back timeout, the backup
   * actually goes through. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. The default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  backupPartition(partitionId: string, options?: { backupPartitionDescription? : models.BackupPartitionDescription, backupTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  backupPartition(partitionId: string, callback: ServiceCallback<void>): void;
  backupPartition(partitionId: string, options: { backupPartitionDescription? : models.BackupPartitionDescription, backupTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets details for the latest backup triggered for this partition.
   *
   * Returns information about the state of the latest backup along with details
   * or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupProgressInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionBackupProgressWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.BackupProgressInfo>>;

  /**
   * @summary Gets details for the latest backup triggered for this partition.
   *
   * Returns information about the state of the latest backup along with details
   * or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {BackupProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {BackupProgressInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupProgressInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionBackupProgress(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.BackupProgressInfo>;
  getPartitionBackupProgress(partitionId: string, callback: ServiceCallback<models.BackupProgressInfo>): void;
  getPartitionBackupProgress(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.BackupProgressInfo>): void;


  /**
   * @summary Triggers restore of the state of the partition using the specified
   * restore partition description.
   *
   * Restores the state of a of the stateful persisted partition using the
   * specified backup point. In case the partition is already being periodically
   * backed up, then by default the backup point is looked for in the storage
   * specified in backup policy. One can also override the same by specifying the
   * backup storage details as part of the restore partition description in body.
   * Once the restore is initiated, its progress can be tracked using the
   * GetRestoreProgress operation.
   * In case, the operation times out, specify a greater restore timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} restorePartitionDescription Describes the parameters to
   * restore the partition.
   *
   * @param {uuid} restorePartitionDescription.backupId Unique backup ID.
   *
   * @param {string} restorePartitionDescription.backupLocation Location of the
   * backup relative to the backup storage specified/ configured.
   *
   * @param {object} [restorePartitionDescription.backupStorage] Location of the
   * backup from where the partition will be restored.
   *
   * @param {string} [restorePartitionDescription.backupStorage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} restorePartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.restoreTimeout] Specifies the maximum amount of
   * time to wait, in minutes, for the restore operation to complete. Post that,
   * the operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it
   * completes with timeout. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. the default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  restorePartitionWithHttpOperationResponse(partitionId: string, restorePartitionDescription: models.RestorePartitionDescription, options?: { restoreTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Triggers restore of the state of the partition using the specified
   * restore partition description.
   *
   * Restores the state of a of the stateful persisted partition using the
   * specified backup point. In case the partition is already being periodically
   * backed up, then by default the backup point is looked for in the storage
   * specified in backup policy. One can also override the same by specifying the
   * backup storage details as part of the restore partition description in body.
   * Once the restore is initiated, its progress can be tracked using the
   * GetRestoreProgress operation.
   * In case, the operation times out, specify a greater restore timeout value in
   * the query parameter.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} restorePartitionDescription Describes the parameters to
   * restore the partition.
   *
   * @param {uuid} restorePartitionDescription.backupId Unique backup ID.
   *
   * @param {string} restorePartitionDescription.backupLocation Location of the
   * backup relative to the backup storage specified/ configured.
   *
   * @param {object} [restorePartitionDescription.backupStorage] Location of the
   * backup from where the partition will be restored.
   *
   * @param {string} [restorePartitionDescription.backupStorage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} restorePartitionDescription.backupStorage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.restoreTimeout] Specifies the maximum amount of
   * time to wait, in minutes, for the restore operation to complete. Post that,
   * the operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it
   * completes with timeout. In case of timeout error, its recommended to invoke
   * this operation again with a greater timeout value. the default value for the
   * same is 10 minutes.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  restorePartition(partitionId: string, restorePartitionDescription: models.RestorePartitionDescription, options?: { restoreTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  restorePartition(partitionId: string, restorePartitionDescription: models.RestorePartitionDescription, callback: ServiceCallback<void>): void;
  restorePartition(partitionId: string, restorePartitionDescription: models.RestorePartitionDescription, options: { restoreTimeout? : number, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets details for the latest restore operation triggered for this
   * partition.
   *
   * Returns information about the state of the latest restore operation along
   * with details or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreProgressInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionRestoreProgressWithHttpOperationResponse(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RestoreProgressInfo>>;

  /**
   * @summary Gets details for the latest restore operation triggered for this
   * partition.
   *
   * Returns information about the state of the latest restore operation along
   * with details or failure reason in case of completion.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RestoreProgressInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RestoreProgressInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreProgressInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionRestoreProgress(partitionId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.RestoreProgressInfo>;
  getPartitionRestoreProgress(partitionId: string, callback: ServiceCallback<models.RestoreProgressInfo>): void;
  getPartitionRestoreProgress(partitionId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RestoreProgressInfo>): void;


  /**
   * @summary Gets the list of backups available for the specified backed up
   * entity at the specified backup location.
   *
   * Gets the list of backups available for the specified backed up entity
   * (Application, Service or Partition) at the specified backup location
   * (FileShare or Azure Blob Storage).
   *
   * @param {object} getBackupByStorageQueryDescription Describes the filters and
   * backup storage details to be used for enumerating backups.
   *
   * @param {date} [getBackupByStorageQueryDescription.startDateTimeFilter]
   * Specifies the start date time in ISO8601 from which to enumerate backups. If
   * not specified, backups are enumerated from the beginning.
   *
   * @param {date} [getBackupByStorageQueryDescription.endDateTimeFilter]
   * Specifies the end date time in ISO8601 till which to enumerate backups. If
   * not specified, backups are enumerated till the end.
   *
   * @param {boolean} [getBackupByStorageQueryDescription.latest] If specified as
   * true, gets the most recent backup (within the specified time range) for
   * every partition under the specified backup entity.
   *
   * @param {object} getBackupByStorageQueryDescription.storage Describes the
   * parameters for the backup storage from where to enumerate backups. This is
   * optional and by default backups are enumerated from the backup storage where
   * this backup entity is currently being backed up (as specified in backup
   * policy). This parameter is useful to be able to enumerate backups from
   * another cluster where you may intend to restore.
   *
   * @param {string} [getBackupByStorageQueryDescription.storage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} getBackupByStorageQueryDescription.storage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} getBackupByStorageQueryDescription.backupEntity Indicates
   * the entity for which to enumerate backups.
   *
   * @param {string} getBackupByStorageQueryDescription.backupEntity.entityKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedBackupInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getBackupsFromBackupLocationWithHttpOperationResponse(getBackupByStorageQueryDescription: models.GetBackupByStorageQueryDescription, options?: { timeout? : number, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedBackupInfoList>>;

  /**
   * @summary Gets the list of backups available for the specified backed up
   * entity at the specified backup location.
   *
   * Gets the list of backups available for the specified backed up entity
   * (Application, Service or Partition) at the specified backup location
   * (FileShare or Azure Blob Storage).
   *
   * @param {object} getBackupByStorageQueryDescription Describes the filters and
   * backup storage details to be used for enumerating backups.
   *
   * @param {date} [getBackupByStorageQueryDescription.startDateTimeFilter]
   * Specifies the start date time in ISO8601 from which to enumerate backups. If
   * not specified, backups are enumerated from the beginning.
   *
   * @param {date} [getBackupByStorageQueryDescription.endDateTimeFilter]
   * Specifies the end date time in ISO8601 till which to enumerate backups. If
   * not specified, backups are enumerated till the end.
   *
   * @param {boolean} [getBackupByStorageQueryDescription.latest] If specified as
   * true, gets the most recent backup (within the specified time range) for
   * every partition under the specified backup entity.
   *
   * @param {object} getBackupByStorageQueryDescription.storage Describes the
   * parameters for the backup storage from where to enumerate backups. This is
   * optional and by default backups are enumerated from the backup storage where
   * this backup entity is currently being backed up (as specified in backup
   * policy). This parameter is useful to be able to enumerate backups from
   * another cluster where you may intend to restore.
   *
   * @param {string} [getBackupByStorageQueryDescription.storage.friendlyName]
   * Friendly name for this backup storage.
   *
   * @param {string} getBackupByStorageQueryDescription.storage.storageKind
   * Polymorphic Discriminator
   *
   * @param {object} getBackupByStorageQueryDescription.backupEntity Indicates
   * the entity for which to enumerate backups.
   *
   * @param {string} getBackupByStorageQueryDescription.backupEntity.entityKind
   * Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.maxResults] The maximum number of results to be
   * returned as part of the paged queries. This parameter defines the upper
   * bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per
   * the max message size restrictions defined in the configuration. If this
   * parameter is zero or not specified, the paged query includes as many results
   * as possible that fit in the return message.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedBackupInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedBackupInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedBackupInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupsFromBackupLocation(getBackupByStorageQueryDescription: models.GetBackupByStorageQueryDescription, options?: { timeout? : number, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedBackupInfoList>;
  getBackupsFromBackupLocation(getBackupByStorageQueryDescription: models.GetBackupByStorageQueryDescription, callback: ServiceCallback<models.PagedBackupInfoList>): void;
  getBackupsFromBackupLocation(getBackupByStorageQueryDescription: models.GetBackupByStorageQueryDescription, options: { timeout? : number, continuationToken? : string, maxResults? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedBackupInfoList>): void;


  /**
   * @summary Creates a Service Fabric name.
   *
   * Creates the specified Service Fabric name.
   *
   * @param {object} nameDescription Describes the Service Fabric name to be
   * created.
   *
   * @param {string} nameDescription.name The Service Fabric name, including the
   * 'fabric:' URI scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createNameWithHttpOperationResponse(nameDescription: models.NameDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates a Service Fabric name.
   *
   * Creates the specified Service Fabric name.
   *
   * @param {object} nameDescription Describes the Service Fabric name to be
   * created.
   *
   * @param {string} nameDescription.name The Service Fabric name, including the
   * 'fabric:' URI scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createName(nameDescription: models.NameDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createName(nameDescription: models.NameDescription, callback: ServiceCallback<void>): void;
  createName(nameDescription: models.NameDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Returns whether the Service Fabric name exists.
   *
   * Returns whether the specified Service Fabric name exists.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNameExistsInfoWithHttpOperationResponse(nameId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Returns whether the Service Fabric name exists.
   *
   * Returns whether the specified Service Fabric name exists.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNameExistsInfo(nameId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  getNameExistsInfo(nameId: string, callback: ServiceCallback<void>): void;
  getNameExistsInfo(nameId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Deletes a Service Fabric name.
   *
   * Deletes the specified Service Fabric name. A name must be created before it
   * can be deleted. Deleting a name with child properties will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteNameWithHttpOperationResponse(nameId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes a Service Fabric name.
   *
   * Deletes the specified Service Fabric name. A name must be created before it
   * can be deleted. Deleting a name with child properties will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteName(nameId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteName(nameId: string, callback: ServiceCallback<void>): void;
  deleteName(nameId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Enumerates all the Service Fabric names under a given name.
   *
   * Enumerates all the Service Fabric names under a given name. If the subnames
   * do not fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. Querying a name
   * that doesn't exist will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Allows specifying that the search
   * performed should be recursive.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedSubNameInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getSubNameInfoListWithHttpOperationResponse(nameId: string, options?: { recursive? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedSubNameInfoList>>;

  /**
   * @summary Enumerates all the Service Fabric names under a given name.
   *
   * Enumerates all the Service Fabric names under a given name. If the subnames
   * do not fit in a page, one page of results is returned as well as a
   * continuation token, which can be used to get the next page. Querying a name
   * that doesn't exist will fail.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.recursive] Allows specifying that the search
   * performed should be recursive.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedSubNameInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedSubNameInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedSubNameInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getSubNameInfoList(nameId: string, options?: { recursive? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedSubNameInfoList>;
  getSubNameInfoList(nameId: string, callback: ServiceCallback<models.PagedSubNameInfoList>): void;
  getSubNameInfoList(nameId: string, options: { recursive? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedSubNameInfoList>): void;


  /**
   * @summary Gets information on all Service Fabric properties under a given
   * name.
   *
   * A Service Fabric name can have one or more named properties that store
   * custom information. This operation gets the information about these
   * properties in a paged list. The information includes name, value, and
   * metadata about each of the properties.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeValues] Allows specifying whether to
   * include the values of the properties returned. True if values should be
   * returned with the metadata; False to return only property metadata.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedPropertyInfoList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPropertyInfoListWithHttpOperationResponse(nameId: string, options?: { includeValues? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedPropertyInfoList>>;

  /**
   * @summary Gets information on all Service Fabric properties under a given
   * name.
   *
   * A Service Fabric name can have one or more named properties that store
   * custom information. This operation gets the information about these
   * properties in a paged list. The information includes name, value, and
   * metadata about each of the properties.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeValues] Allows specifying whether to
   * include the values of the properties returned. True if values should be
   * returned with the metadata; False to return only property metadata.
   *
   * @param {string} [options.continuationToken] The continuation token parameter
   * is used to obtain next set of results. A continuation token with a non-empty
   * value is included in the response of the API when the results from the
   * system do not fit in a single response. When this value is passed to the
   * next API call, the API returns next set of results. If there are no further
   * results, then the continuation token does not contain a value. The value of
   * this parameter should not be URL encoded.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedPropertyInfoList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedPropertyInfoList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedPropertyInfoList} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPropertyInfoList(nameId: string, options?: { includeValues? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedPropertyInfoList>;
  getPropertyInfoList(nameId: string, callback: ServiceCallback<models.PagedPropertyInfoList>): void;
  getPropertyInfoList(nameId: string, options: { includeValues? : boolean, continuationToken? : string, timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedPropertyInfoList>): void;


  /**
   * @summary Creates or updates a Service Fabric property.
   *
   * Creates or updates the specified Service Fabric property under a given name.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyDescription Describes the Service Fabric property to
   * be created.
   *
   * @param {string} propertyDescription.propertyName The name of the Service
   * Fabric property.
   *
   * @param {string} [propertyDescription.customTypeId] The property's custom
   * type ID. Using this property, the user is able to tag the type of the value
   * of the property.
   *
   * @param {object} propertyDescription.value Describes a Service Fabric
   * property value.
   *
   * @param {string} propertyDescription.value.kind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  putPropertyWithHttpOperationResponse(nameId: string, propertyDescription: models.PropertyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates or updates a Service Fabric property.
   *
   * Creates or updates the specified Service Fabric property under a given name.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyDescription Describes the Service Fabric property to
   * be created.
   *
   * @param {string} propertyDescription.propertyName The name of the Service
   * Fabric property.
   *
   * @param {string} [propertyDescription.customTypeId] The property's custom
   * type ID. Using this property, the user is able to tag the type of the value
   * of the property.
   *
   * @param {object} propertyDescription.value Describes a Service Fabric
   * property value.
   *
   * @param {string} propertyDescription.value.kind Polymorphic Discriminator
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  putProperty(nameId: string, propertyDescription: models.PropertyDescription, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  putProperty(nameId: string, propertyDescription: models.PropertyDescription, callback: ServiceCallback<void>): void;
  putProperty(nameId: string, propertyDescription: models.PropertyDescription, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the specified Service Fabric property.
   *
   * Gets the specified Service Fabric property under a given name. This will
   * always return both value and metadata.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PropertyInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPropertyInfoWithHttpOperationResponse(nameId: string, propertyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PropertyInfo>>;

  /**
   * @summary Gets the specified Service Fabric property.
   *
   * Gets the specified Service Fabric property under a given name. This will
   * always return both value and metadata.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PropertyInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PropertyInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PropertyInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPropertyInfo(nameId: string, propertyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PropertyInfo>;
  getPropertyInfo(nameId: string, propertyName: string, callback: ServiceCallback<models.PropertyInfo>): void;
  getPropertyInfo(nameId: string, propertyName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PropertyInfo>): void;


  /**
   * @summary Deletes the specified Service Fabric property.
   *
   * Deletes the specified Service Fabric property under a given name. A property
   * must be created before it can be deleted.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deletePropertyWithHttpOperationResponse(nameId: string, propertyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes the specified Service Fabric property.
   *
   * Deletes the specified Service Fabric property under a given name. A property
   * must be created before it can be deleted.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {string} propertyName Specifies the name of the property to get.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteProperty(nameId: string, propertyName: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteProperty(nameId: string, propertyName: string, callback: ServiceCallback<void>): void;
  deleteProperty(nameId: string, propertyName: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Submits a property batch.
   *
   * Submits a batch of property operations. Either all or none of the operations
   * will be committed.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyBatchDescriptionList Describes the property batch
   * operations to be submitted.
   *
   * @param {array} [propertyBatchDescriptionList.operations] A list of the
   * property batch operations to be executed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PropertyBatchInfo>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  submitPropertyBatchWithHttpOperationResponse(nameId: string, propertyBatchDescriptionList: models.PropertyBatchDescriptionList, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PropertyBatchInfo>>;

  /**
   * @summary Submits a property batch.
   *
   * Submits a batch of property operations. Either all or none of the operations
   * will be committed.
   *
   * @param {string} nameId The Service Fabric name, without the 'fabric:' URI
   * scheme.
   *
   * @param {object} propertyBatchDescriptionList Describes the property batch
   * operations to be submitted.
   *
   * @param {array} [propertyBatchDescriptionList.operations] A list of the
   * property batch operations to be executed.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PropertyBatchInfo} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PropertyBatchInfo} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PropertyBatchInfo} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  submitPropertyBatch(nameId: string, propertyBatchDescriptionList: models.PropertyBatchDescriptionList, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PropertyBatchInfo>;
  submitPropertyBatch(nameId: string, propertyBatchDescriptionList: models.PropertyBatchDescriptionList, callback: ServiceCallback<models.PropertyBatchInfo>): void;
  submitPropertyBatch(nameId: string, propertyBatchDescriptionList: models.PropertyBatchDescriptionList, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PropertyBatchInfo>): void;


  /**
   * @summary Gets all Cluster-related events.
   *
   * The response is list of ClusterEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getClusterEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ClusterEvent[]>>;

  /**
   * @summary Gets all Cluster-related events.
   *
   * The response is list of ClusterEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getClusterEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ClusterEvent[]>;
  getClusterEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ClusterEvent[]>): void;
  getClusterEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ClusterEvent[]>): void;


  /**
   * @summary Gets all Containers-related events.
   *
   * The response is list of ContainerInstanceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getContainersEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ContainerInstanceEvent[]>>;

  /**
   * @summary Gets all Containers-related events.
   *
   * The response is list of ContainerInstanceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getContainersEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ContainerInstanceEvent[]>;
  getContainersEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ContainerInstanceEvent[]>): void;
  getContainersEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ContainerInstanceEvent[]>): void;


  /**
   * @summary Gets a Node-related events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodeEventListWithHttpOperationResponse(nodeName: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeEvent[]>>;

  /**
   * @summary Gets a Node-related events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} nodeName The name of the node.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodeEventList(nodeName: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeEvent[]>;
  getNodeEventList(nodeName: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.NodeEvent[]>): void;
  getNodeEventList(nodeName: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeEvent[]>): void;


  /**
   * @summary Gets all Nodes-related Events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getNodesEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.NodeEvent[]>>;

  /**
   * @summary Gets all Nodes-related Events.
   *
   * The response is list of NodeEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getNodesEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.NodeEvent[]>;
  getNodesEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.NodeEvent[]>): void;
  getNodesEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.NodeEvent[]>): void;


  /**
   * @summary Gets an Application-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationEventListWithHttpOperationResponse(applicationId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationEvent[]>>;

  /**
   * @summary Gets an Application-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} applicationId The identity of the application. This is
   * typically the full name of the application without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the application name is "fabric:/myapp/app1", the
   * application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationEventList(applicationId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationEvent[]>;
  getApplicationEventList(applicationId: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ApplicationEvent[]>): void;
  getApplicationEventList(applicationId: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationEvent[]>): void;


  /**
   * @summary Gets all Applications-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationsEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationEvent[]>>;

  /**
   * @summary Gets all Applications-related events.
   *
   * The response is list of ApplicationEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationsEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationEvent[]>;
  getApplicationsEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ApplicationEvent[]>): void;
  getApplicationsEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationEvent[]>): void;


  /**
   * @summary Gets a Service-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceEventListWithHttpOperationResponse(serviceId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceEvent[]>>;

  /**
   * @summary Gets a Service-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} serviceId The identity of the service. This ID is typically
   * the full name of the service without the 'fabric:' URI scheme.
   * Starting from version 6.0, hierarchical names are delimited with the "~"
   * character.
   * For example, if the service name is "fabric:/myapp/app1/svc1", the service
   * identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in
   * previous versions.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServiceEventList(serviceId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceEvent[]>;
  getServiceEventList(serviceId: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ServiceEvent[]>): void;
  getServiceEventList(serviceId: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceEvent[]>): void;


  /**
   * @summary Gets all Services-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServicesEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceEvent[]>>;

  /**
   * @summary Gets all Services-related events.
   *
   * The response is list of ServiceEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServicesEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceEvent[]>;
  getServicesEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ServiceEvent[]>): void;
  getServicesEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceEvent[]>): void;


  /**
   * @summary Gets a Partition-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionEventListWithHttpOperationResponse(partitionId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionEvent[]>>;

  /**
   * @summary Gets a Partition-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionEvent[]>;
  getPartitionEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.PartitionEvent[]>): void;
  getPartitionEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionEvent[]>): void;


  /**
   * @summary Gets all Partitions-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionsEventListWithHttpOperationResponse(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PartitionEvent[]>>;

  /**
   * @summary Gets all Partitions-related events.
   *
   * The response is list of PartitionEvent objects.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionsEventList(startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.PartitionEvent[]>;
  getPartitionsEventList(startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.PartitionEvent[]>): void;
  getPartitionsEventList(startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PartitionEvent[]>): void;


  /**
   * @summary Gets a Partition Replica-related events.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionReplicaEventListWithHttpOperationResponse(partitionId: string, replicaId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReplicaEvent[]>>;

  /**
   * @summary Gets a Partition Replica-related events.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} replicaId The identifier of the replica.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionReplicaEventList(partitionId: string, replicaId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ReplicaEvent[]>;
  getPartitionReplicaEventList(partitionId: string, replicaId: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ReplicaEvent[]>): void;
  getPartitionReplicaEventList(partitionId: string, replicaId: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReplicaEvent[]>): void;


  /**
   * @summary Gets all Replicas-related events for a Partition.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getPartitionReplicasEventListWithHttpOperationResponse(partitionId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReplicaEvent[]>>;

  /**
   * @summary Gets all Replicas-related events for a Partition.
   *
   * The response is list of ReplicaEvent objects.
   *
   * @param {uuid} partitionId The identity of the partition.
   *
   * @param {string} startTimeUtc The start time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {string} endTimeUtc The end time of a lookup query in ISO UTC
   * yyyy-MM-ddTHH:mm:ssZ.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {string} [options.eventsTypesFilter] This is a comma separated string
   * specifying the types of FabricEvents that should only be included in the
   * response.
   *
   * @param {boolean} [options.excludeAnalysisEvents] This param disables the
   * retrieval of AnalysisEvents if true is passed.
   *
   * @param {boolean} [options.skipCorrelationLookup] This param disables the
   * search of CorrelatedEvents information if true is passed. otherwise the
   * CorrelationEvents get processed and HasCorrelatedEvents field in every
   * FabricEvent gets populated.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getPartitionReplicasEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, options?: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.ReplicaEvent[]>;
  getPartitionReplicasEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, callback: ServiceCallback<models.ReplicaEvent[]>): void;
  getPartitionReplicasEventList(partitionId: string, startTimeUtc: string, endTimeUtc: string, options: { timeout? : number, eventsTypesFilter? : string, excludeAnalysisEvents? : boolean, skipCorrelationLookup? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReplicaEvent[]>): void;


  /**
   * @summary Gets all correlated events for a given event.
   *
   * The response is list of FabricEvents.
   *
   * @param {string} eventInstanceId The EventInstanceId.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getCorrelatedEventListWithHttpOperationResponse(eventInstanceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.FabricEvent[]>>;

  /**
   * @summary Gets all correlated events for a given event.
   *
   * The response is list of FabricEvents.
   *
   * @param {string} eventInstanceId The EventInstanceId.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.timeout] The server timeout for performing the
   * operation in seconds. This timeout specifies the time duration that the
   * client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getCorrelatedEventList(eventInstanceId: string, options?: { timeout? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.FabricEvent[]>;
  getCorrelatedEventList(eventInstanceId: string, callback: ServiceCallback<models.FabricEvent[]>): void;
  getCorrelatedEventList(eventInstanceId: string, options: { timeout? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.FabricEvent[]>): void;


  /**
   * @summary Creates or updates an application resource.
   *
   * Creates an application with the specified name and description. If an
   * application with the same name already exists, then its description are
   * updated to the one indicated in this request.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} applicationResourceDescription Description for creating an
   * application resource.
   *
   * @param {string} [applicationResourceDescription.description] User readable
   * description of the application.
   *
   * @param {string} [applicationResourceDescription.debugParams] Internal use.
   *
   * @param {array} [applicationResourceDescription.services] describes the
   * services in the application.
   *
   * @param {object} [applicationResourceDescription.diagnostics] Describes the
   * diagnostics definition and usage for an application resource.
   *
   * @param {array} [applicationResourceDescription.diagnostics.sinks] List of
   * supported sinks that can be referenced.
   *
   * @param {boolean} [applicationResourceDescription.diagnostics.enabled] Status
   * of whether or not sinks are enabled.
   *
   * @param {array} [applicationResourceDescription.diagnostics.defaultSinkRefs]
   * The sinks to be used if diagnostics is enabled. Sink choices can be
   * overridden at the service and code package level.
   *
   * @param {string} applicationResourceDescription.name Application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createApplicationResourceWithHttpOperationResponse(applicationResourceName: string, applicationResourceDescription: models.ApplicationResourceDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates or updates an application resource.
   *
   * Creates an application with the specified name and description. If an
   * application with the same name already exists, then its description are
   * updated to the one indicated in this request.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} applicationResourceDescription Description for creating an
   * application resource.
   *
   * @param {string} [applicationResourceDescription.description] User readable
   * description of the application.
   *
   * @param {string} [applicationResourceDescription.debugParams] Internal use.
   *
   * @param {array} [applicationResourceDescription.services] describes the
   * services in the application.
   *
   * @param {object} [applicationResourceDescription.diagnostics] Describes the
   * diagnostics definition and usage for an application resource.
   *
   * @param {array} [applicationResourceDescription.diagnostics.sinks] List of
   * supported sinks that can be referenced.
   *
   * @param {boolean} [applicationResourceDescription.diagnostics.enabled] Status
   * of whether or not sinks are enabled.
   *
   * @param {array} [applicationResourceDescription.diagnostics.defaultSinkRefs]
   * The sinks to be used if diagnostics is enabled. Sink choices can be
   * overridden at the service and code package level.
   *
   * @param {string} applicationResourceDescription.name Application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createApplicationResource(applicationResourceName: string, applicationResourceDescription: models.ApplicationResourceDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createApplicationResource(applicationResourceName: string, applicationResourceDescription: models.ApplicationResourceDescription, callback: ServiceCallback<void>): void;
  createApplicationResource(applicationResourceName: string, applicationResourceDescription: models.ApplicationResourceDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the application with the given name.
   *
   * Gets the application with the given name. This includes the information
   * about the application's services and other runtime information.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ApplicationResourceDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getApplicationResourceWithHttpOperationResponse(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ApplicationResourceDescription>>;

  /**
   * @summary Gets the application with the given name.
   *
   * Gets the application with the given name. This includes the information
   * about the application's services and other runtime information.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ApplicationResourceDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ApplicationResourceDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ApplicationResourceDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getApplicationResource(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ApplicationResourceDescription>;
  getApplicationResource(applicationResourceName: string, callback: ServiceCallback<models.ApplicationResourceDescription>): void;
  getApplicationResource(applicationResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ApplicationResourceDescription>): void;


  /**
   * @summary Deletes the specified application.
   *
   * Deletes the application identified by the name.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteApplicationResourceWithHttpOperationResponse(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes the specified application.
   *
   * Deletes the application identified by the name.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteApplicationResource(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteApplicationResource(applicationResourceName: string, callback: ServiceCallback<void>): void;
  deleteApplicationResource(applicationResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets all the services in the application resource.
   *
   * The operation returns the service descriptions of all the services in the
   * application resource.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServiceResourceDescriptionList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServicesWithHttpOperationResponse(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedServiceResourceDescriptionList>>;

  /**
   * @summary Gets all the services in the application resource.
   *
   * The operation returns the service descriptions of all the services in the
   * application resource.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedServiceResourceDescriptionList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedServiceResourceDescriptionList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServiceResourceDescriptionList} for
   *                      more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getServices(applicationResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedServiceResourceDescriptionList>;
  getServices(applicationResourceName: string, callback: ServiceCallback<models.PagedServiceResourceDescriptionList>): void;
  getServices(applicationResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedServiceResourceDescriptionList>): void;


  /**
   * @summary Gets the description of the specified service in an application
   * resource.
   *
   * Gets the description of the service resource.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceResourceDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getServiceWithHttpOperationResponse(applicationResourceName: string, serviceResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResourceDescription>>;

  /**
   * @summary Gets the description of the specified service in an application
   * resource.
   *
   * Gets the description of the service resource.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceResourceDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceResourceDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceResourceDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getService(applicationResourceName: string, serviceResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResourceDescription>;
  getService(applicationResourceName: string, serviceResourceName: string, callback: ServiceCallback<models.ServiceResourceDescription>): void;
  getService(applicationResourceName: string, serviceResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResourceDescription>): void;


  /**
   * @summary Gets replicas of a given service in an applciation resource.
   *
   * Gets the information about all replicas of a given service of an
   * application. The information includes the runtime properties of the replica
   * instance.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PagedServiceResourceReplicaDescriptionList>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicasWithHttpOperationResponse(applicationResourceName: string, serviceResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PagedServiceResourceReplicaDescriptionList>>;

  /**
   * @summary Gets replicas of a given service in an applciation resource.
   *
   * Gets the information about all replicas of a given service of an
   * application. The information includes the runtime properties of the replica
   * instance.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {PagedServiceResourceReplicaDescriptionList} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {PagedServiceResourceReplicaDescriptionList} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PagedServiceResourceReplicaDescriptionList}
   *                      for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplicas(applicationResourceName: string, serviceResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.PagedServiceResourceReplicaDescriptionList>;
  getReplicas(applicationResourceName: string, serviceResourceName: string, callback: ServiceCallback<models.PagedServiceResourceReplicaDescriptionList>): void;
  getReplicas(applicationResourceName: string, serviceResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PagedServiceResourceReplicaDescriptionList>): void;


  /**
   * @summary Gets a specific replica of a given service in an application
   * resource.
   *
   * Gets the information about the specified replica of a given service of an
   * application. The information includes the runtime properties of the replica
   * instance.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {string} replicaName Service Fabric replica name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ServiceResourceReplicaDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReplicaWithHttpOperationResponse(applicationResourceName: string, serviceResourceName: string, replicaName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ServiceResourceReplicaDescription>>;

  /**
   * @summary Gets a specific replica of a given service in an application
   * resource.
   *
   * Gets the information about the specified replica of a given service of an
   * application. The information includes the runtime properties of the replica
   * instance.
   *
   * @param {string} applicationResourceName Service Fabric application resource
   * name.
   *
   * @param {string} serviceResourceName Service Fabric service resource name.
   *
   * @param {string} replicaName Service Fabric replica name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ServiceResourceReplicaDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ServiceResourceReplicaDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ServiceResourceReplicaDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReplica(applicationResourceName: string, serviceResourceName: string, replicaName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ServiceResourceReplicaDescription>;
  getReplica(applicationResourceName: string, serviceResourceName: string, replicaName: string, callback: ServiceCallback<models.ServiceResourceReplicaDescription>): void;
  getReplica(applicationResourceName: string, serviceResourceName: string, replicaName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ServiceResourceReplicaDescription>): void;


  /**
   * @summary Creates or updates a volume resource.
   *
   * Creates a volume resource with the specified name and description. If a
   * volume with the same name already exists, then its description is updated to
   * the one indicated in this request.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} volumeResourceDescription Description for creating a volume
   * resource.
   *
   * @param {string} [volumeResourceDescription.description] User readable
   * description of the volume.
   *
   * @param {object} [volumeResourceDescription.azureFileParameters] This type
   * describes a volume provided by an Azure Files file share.
   *
   * @param {string} volumeResourceDescription.azureFileParameters.accountName
   * Name of the Azure storage account for the File Share.
   *
   * @param {string} [volumeResourceDescription.azureFileParameters.accountKey]
   * Access key of the Azure storage account for the File Share.
   *
   * @param {string} volumeResourceDescription.azureFileParameters.shareName Name
   * of the Azure Files file share that provides storage for the volume.
   *
   * @param {string} volumeResourceDescription.name Volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createVolumeResourceWithHttpOperationResponse(volumeResourceName: string, volumeResourceDescription: models.VolumeResourceDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Creates or updates a volume resource.
   *
   * Creates a volume resource with the specified name and description. If a
   * volume with the same name already exists, then its description is updated to
   * the one indicated in this request.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} volumeResourceDescription Description for creating a volume
   * resource.
   *
   * @param {string} [volumeResourceDescription.description] User readable
   * description of the volume.
   *
   * @param {object} [volumeResourceDescription.azureFileParameters] This type
   * describes a volume provided by an Azure Files file share.
   *
   * @param {string} volumeResourceDescription.azureFileParameters.accountName
   * Name of the Azure storage account for the File Share.
   *
   * @param {string} [volumeResourceDescription.azureFileParameters.accountKey]
   * Access key of the Azure storage account for the File Share.
   *
   * @param {string} volumeResourceDescription.azureFileParameters.shareName Name
   * of the Azure Files file share that provides storage for the volume.
   *
   * @param {string} volumeResourceDescription.name Volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createVolumeResource(volumeResourceName: string, volumeResourceDescription: models.VolumeResourceDescription, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  createVolumeResource(volumeResourceName: string, volumeResourceDescription: models.VolumeResourceDescription, callback: ServiceCallback<void>): void;
  createVolumeResource(volumeResourceName: string, volumeResourceDescription: models.VolumeResourceDescription, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Gets the volume resource.
   *
   * Gets the information about the volume resource with a given name. This
   * information includes the volume description and other runtime information.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VolumeResourceDescription>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getVolumeResourceWithHttpOperationResponse(volumeResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VolumeResourceDescription>>;

  /**
   * @summary Gets the volume resource.
   *
   * Gets the information about the volume resource with a given name. This
   * information includes the volume description and other runtime information.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {VolumeResourceDescription} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {VolumeResourceDescription} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VolumeResourceDescription} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getVolumeResource(volumeResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VolumeResourceDescription>;
  getVolumeResource(volumeResourceName: string, callback: ServiceCallback<models.VolumeResourceDescription>): void;
  getVolumeResource(volumeResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VolumeResourceDescription>): void;


  /**
   * @summary Deletes the volume resource.
   *
   * Deletes the volume identified by the name.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteVolumeResourceWithHttpOperationResponse(volumeResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Deletes the volume resource.
   *
   * Deletes the volume identified by the name.
   *
   * @param {string} volumeResourceName Service Fabric volume resource name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteVolumeResource(volumeResourceName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteVolumeResource(volumeResourceName: string, callback: ServiceCallback<void>): void;
  deleteVolumeResource(volumeResourceName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;
}

export { ServiceFabricClient, models as ServiceFabricModels };
