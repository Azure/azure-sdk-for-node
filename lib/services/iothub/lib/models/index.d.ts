/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError } from "ms-rest-azure";
import * as moment from "moment";

export {

  BaseResource,
  CloudError
};

/**
 * The JSON-serialized leaf certificate
 */
export interface CertificateVerificationDescription {
  /**
   * base-64 representation of X509 certificate .cer file or just .pem file content.
   */
  certificate?: string;
}

/**
 * The description of an X509 CA Certificate.
 */
export interface CertificateProperties {
  /**
   * The certificate's subject name.
   */
  readonly subject?: string;
  /**
   * The certificate's expiration date and time.
   */
  readonly expiry?: Date;
  /**
   * The certificate's thumbprint.
   */
  readonly thumbprint?: string;
  /**
   * Determines whether certificate has been verified.
   */
  readonly isVerified?: boolean;
  /**
   * The certificate's create date and time.
   */
  readonly created?: Date;
  /**
   * The certificate's last update date and time.
   */
  readonly updated?: Date;
  /**
   * The certificate content
   */
  certificate?: string;
}

/**
 * The X509 Certificate.
 */
export interface CertificateDescription extends BaseResource {
  properties?: CertificateProperties;
  /**
   * The resource identifier.
  */
  readonly id?: string;
  /**
   * The name of the certificate.
  */
  readonly name?: string;
  /**
   * The entity tag.
  */
  readonly etag?: string;
  /**
   * The resource type.
  */
  readonly type?: string;
}

/**
 * The JSON-serialized array of Certificate objects.
*/
export interface CertificateListDescription {
  /**
   * The array of Certificate objects.
  */
  value?: CertificateDescription[];
}

/**
 * The JSON-serialized X509 Certificate.
*/
export interface CertificateBodyDescription {
  /**
   * base-64 representation of the X509 leaf certificate .cer file or just .pem file content.
  */
  certificate?: string;
}

/**
 * The description of an X509 CA Certificate including the challenge nonce issued for the
 * Proof-Of-Possession flow.
*/
export interface CertificatePropertiesWithNonce {
  /**
   * The certificate's subject name.
  */
  readonly subject?: string;
  /**
   * The certificate's expiration date and time.
  */
  readonly expiry?: Date;
  /**
   * The certificate's thumbprint.
  */
  readonly thumbprint?: string;
  /**
   * Determines whether certificate has been verified.
  */
  readonly isVerified?: boolean;
  /**
   * The certificate's create date and time.
  */
  readonly created?: Date;
  /**
   * The certificate's last update date and time.
  */
  readonly updated?: Date;
  /**
   * The certificate's verification code that will be used for proof of possession.
  */
  readonly verificationCode?: string;
  /**
   * The certificate content
  */
  readonly certificate?: string;
}

/**
 * The X509 Certificate.
*/
export interface CertificateWithNonceDescription extends BaseResource {
  properties?: CertificatePropertiesWithNonce;
  /**
   * The resource identifier.
  */
  readonly id?: string;
  /**
   * The name of the certificate.
  */
  readonly name?: string;
  /**
   * The entity tag.
  */
  readonly etag?: string;
  /**
   * The resource type.
  */
  readonly type?: string;
}

/**
 * The properties of an IoT hub shared access policy.
*/
export interface SharedAccessSignatureAuthorizationRule {
  /**
   * The name of the shared access policy.
  */
  keyName: string;
  /**
   * The primary key.
  */
  primaryKey?: string;
  /**
   * The secondary key.
  */
  secondaryKey?: string;
  /**
   * The permissions assigned to the shared access policy. Possible values include: 'RegistryRead',
   * 'RegistryWrite', 'ServiceConnect', 'DeviceConnect', 'RegistryRead, RegistryWrite',
   * 'RegistryRead, ServiceConnect', 'RegistryRead, DeviceConnect', 'RegistryWrite,
   * ServiceConnect', 'RegistryWrite, DeviceConnect', 'ServiceConnect, DeviceConnect',
   * 'RegistryRead, RegistryWrite, ServiceConnect', 'RegistryRead, RegistryWrite, DeviceConnect',
   * 'RegistryRead, ServiceConnect, DeviceConnect', 'RegistryWrite, ServiceConnect, DeviceConnect',
   * 'RegistryRead, RegistryWrite, ServiceConnect, DeviceConnect'
  */
  rights: string;
}

/**
 * The IP filter rules for the IoT hub.
*/
export interface IpFilterRule {
  /**
   * The name of the IP filter rule.
  */
  filterName: string;
  /**
   * The desired action for requests captured by this rule. Possible values include: 'Accept',
   * 'Reject'
  */
  action: string;
  /**
   * A string that contains the IP address range in CIDR notation for the rule.
  */
  ipMask: string;
}

/**
 * The properties of the provisioned Event Hub-compatible endpoint used by the IoT hub.
*/
export interface EventHubProperties {
  /**
   * The retention time for device-to-cloud messages in days. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages
  */
  retentionTimeInDays?: number;
  /**
   * The number of partitions for receiving device-to-cloud messages in the Event Hub-compatible
   * endpoint. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages.
  */
  partitionCount?: number;
  /**
   * The partition ids in the Event Hub-compatible endpoint.
  */
  readonly partitionIds?: string[];
  /**
   * The Event Hub-compatible name.
  */
  readonly path?: string;
  /**
   * The Event Hub-compatible endpoint.
  */
  readonly endpoint?: string;
}

/**
 * The properties related to service bus queue endpoint types.
*/
export interface RoutingServiceBusQueueEndpointProperties {
  /**
   * The connection string of the service bus queue endpoint.
  */
  connectionString: string;
  /**
   * The name that identifies this endpoint. The name can only include alphanumeric characters,
   * periods, underscores, hyphens and has a maximum length of 64 characters. The following names
   * are reserved:  events, fileNotifications, $default. Endpoint names must be unique across
   * endpoint types. The name need not be the same as the actual queue name.
  */
  name: string;
  /**
   * The subscription identifier of the service bus queue endpoint.
  */
  subscriptionId?: string;
  /**
   * The name of the resource group of the service bus queue endpoint.
  */
  resourceGroup?: string;
}

/**
 * The properties related to service bus topic endpoint types.
*/
export interface RoutingServiceBusTopicEndpointProperties {
  /**
   * The connection string of the service bus topic endpoint.
  */
  connectionString: string;
  /**
   * The name that identifies this endpoint. The name can only include alphanumeric characters,
   * periods, underscores, hyphens and has a maximum length of 64 characters. The following names
   * are reserved:  events, fileNotifications, $default. Endpoint names must be unique across
   * endpoint types.  The name need not be the same as the actual topic name.
  */
  name: string;
  /**
   * The subscription identifier of the service bus topic endpoint.
  */
  subscriptionId?: string;
  /**
   * The name of the resource group of the service bus topic endpoint.
  */
  resourceGroup?: string;
}

/**
 * The properties related to an event hub endpoint.
*/
export interface RoutingEventHubProperties {
  /**
   * The connection string of the event hub endpoint.
  */
  connectionString: string;
  /**
   * The name that identifies this endpoint. The name can only include alphanumeric characters,
   * periods, underscores, hyphens and has a maximum length of 64 characters. The following names
   * are reserved:  events, fileNotifications, $default. Endpoint names must be unique across
   * endpoint types.
  */
  name: string;
  /**
   * The subscription identifier of the event hub endpoint.
  */
  subscriptionId?: string;
  /**
   * The name of the resource group of the event hub endpoint.
  */
  resourceGroup?: string;
}

/**
 * The properties related to a storage container endpoint.
*/
export interface RoutingStorageContainerProperties {
  /**
   * The connection string of the storage account.
  */
  connectionString: string;
  /**
   * The name that identifies this endpoint. The name can only include alphanumeric characters,
   * periods, underscores, hyphens and has a maximum length of 64 characters. The following names
   * are reserved:  events, fileNotifications, $default. Endpoint names must be unique across
   * endpoint types.
  */
  name: string;
  /**
   * The subscription identifier of the storage account.
  */
  subscriptionId?: string;
  /**
   * The name of the resource group of the storage account.
  */
  resourceGroup?: string;
  /**
   * The name of storage container in the storage account.
  */
  containerName: string;
  /**
   * File name format for the blob. Default format is
   * {iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}. All parameters are mandatory but can be
   * reordered.
  */
  fileNameFormat?: string;
  /**
   * Time interval at which blobs are written to storage. Value should be between 60 and 720
   * seconds. Default value is 300 seconds.
  */
  batchFrequencyInSeconds?: number;
  /**
   * Maximum number of bytes for each blob written to storage. Value should be between
   * 10485760(10MB) and 524288000(500MB). Default value is 314572800(300MB).
  */
  maxChunkSizeInBytes?: number;
  /**
   * Encoding that is used to serialize messages to blobs. Supported values are 'avro',
   * 'avrodeflate', and 'JSON'. Default value is 'avro'. Possible values include: 'Avro',
   * 'AvroDeflate', 'JSON'
  */
  encoding?: string;
}

/**
 * The properties related to the custom endpoints to which your IoT hub routes messages based on
 * the routing rules. A maximum of 10 custom endpoints are allowed across all endpoint types for
 * paid hubs and only 1 custom endpoint is allowed across all endpoint types for free hubs.
*/
export interface RoutingEndpoints {
  /**
   * The list of Service Bus queue endpoints that IoT hub routes the messages to, based on the
   * routing rules.
  */
  serviceBusQueues?: RoutingServiceBusQueueEndpointProperties[];
  /**
   * The list of Service Bus topic endpoints that the IoT hub routes the messages to, based on the
   * routing rules.
  */
  serviceBusTopics?: RoutingServiceBusTopicEndpointProperties[];
  /**
   * The list of Event Hubs endpoints that IoT hub routes messages to, based on the routing rules.
   * This list does not include the built-in Event Hubs endpoint.
  */
  eventHubs?: RoutingEventHubProperties[];
  /**
   * The list of storage container endpoints that IoT hub routes messages to, based on the routing
   * rules.
  */
  storageContainers?: RoutingStorageContainerProperties[];
}

/**
 * The properties of a routing rule that your IoT hub uses to route messages to endpoints.
*/
export interface RouteProperties {
  /**
   * The name of the route. The name can only include alphanumeric characters, periods,
   * underscores, hyphens, has a maximum length of 64 characters, and must be unique.
  */
  name: string;
  /**
   * The source that the routing rule is to be applied to, such as DeviceMessages. Possible values
   * include: 'Invalid', 'DeviceMessages', 'TwinChangeEvents', 'DeviceLifecycleEvents',
   * 'DeviceJobLifecycleEvents'
  */
  source: string;
  /**
   * The condition that is evaluated to apply the routing rule. If no condition is provided, it
   * evaluates to true by default. For grammar, see:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
  */
  condition?: string;
  /**
   * The list of endpoints to which messages that satisfy the condition are routed. Currently only
   * one endpoint is allowed.
  */
  endpointNames: string[];
  /**
   * Used to specify whether a route is enabled.
  */
  isEnabled: boolean;
}

/**
 * The properties of the fallback route. IoT Hub uses these properties when it routes messages to
 * the fallback endpoint.
*/
export interface FallbackRouteProperties {
  /**
   * The name of the route. The name can only include alphanumeric characters, periods,
   * underscores, hyphens, has a maximum length of 64 characters, and must be unique.
  */
  name?: string;
  /**
   * The condition which is evaluated in order to apply the fallback route. If the condition is not
   * provided it will evaluate to true by default. For grammar, See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
  */
  condition?: string;
  /**
   * The list of endpoints to which the messages that satisfy the condition are routed to.
   * Currently only 1 endpoint is allowed.
  */
  endpointNames: string[];
  /**
   * Used to specify whether the fallback route is enabled.
  */
  isEnabled: boolean;
}

/**
 * The routing related properties of the IoT hub. See:
 * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
*/
export interface RoutingProperties {
  endpoints?: RoutingEndpoints;
  /**
   * The list of user-provided routing rules that the IoT hub uses to route messages to built-in
   * and custom endpoints. A maximum of 100 routing rules are allowed for paid hubs and a maximum
   * of 5 routing rules are allowed for free hubs.
  */
  routes?: RouteProperties[];
  /**
   * The properties of the route that is used as a fall-back route when none of the conditions
   * specified in the 'routes' section are met. This is an optional parameter. When this property
   * is not set, the messages which do not meet any of the conditions specified in the 'routes'
   * section get routed to the built-in eventhub endpoint.
  */
  fallbackRoute?: FallbackRouteProperties;
}

/**
 * The properties of the Azure Storage endpoint for file upload.
*/
export interface StorageEndpointProperties {
  /**
   * The period of time for which the SAS URI generated by IoT Hub for file upload is valid. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload#file-upload-notification-configuration-options.
  */
  sasTtlAsIso8601?: moment.Duration;
  /**
   * The connection string for the Azure Storage account to which files are uploaded.
  */
  connectionString: string;
  /**
   * The name of the root container where you upload files. The container need not exist but should
   * be creatable using the connectionString specified.
  */
  containerName: string;
}

/**
 * The properties of the messaging endpoints used by this IoT hub.
*/
export interface MessagingEndpointProperties {
  /**
   * The lock duration. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
  */
  lockDurationAsIso8601?: moment.Duration;
  /**
   * The period of time for which a message is available to consume before it is expired by the IoT
   * hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
  */
  ttlAsIso8601?: moment.Duration;
  /**
   * The number of times the IoT hub attempts to deliver a message. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
  */
  maxDeliveryCount?: number;
}

/**
 * The properties of the feedback queue for cloud-to-device messages.
*/
export interface FeedbackProperties {
  /**
   * The lock duration for the feedback queue. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
  */
  lockDurationAsIso8601?: moment.Duration;
  /**
   * The period of time for which a message is available to consume before it is expired by the IoT
   * hub. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
  */
  ttlAsIso8601?: moment.Duration;
  /**
   * The number of times the IoT hub attempts to deliver a message on the feedback queue. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
  */
  maxDeliveryCount?: number;
}

/**
 * The IoT hub cloud-to-device messaging properties.
*/
export interface CloudToDeviceProperties {
  /**
   * The max delivery count for cloud-to-device messages in the device queue. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
  */
  maxDeliveryCount?: number;
  /**
   * The default time to live for cloud-to-device messages in the device queue. See:
   * https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
  */
  defaultTtlAsIso8601?: moment.Duration;
  feedback?: FeedbackProperties;
}

/**
 * The device streams properties of iothub.
*/
export interface IotHubPropertiesDeviceStreams {
  /**
   * List of Device Streams Endpoints.
  */
  streamingEndpoints?: string[];
}

/**
 * The properties of an IoT hub.
*/
export interface IotHubProperties {
  /**
   * The shared access policies you can use to secure a connection to the IoT hub.
  */
  authorizationPolicies?: SharedAccessSignatureAuthorizationRule[];
  /**
   * The IP filter rules.
  */
  ipFilterRules?: IpFilterRule[];
  /**
   * The provisioning state.
  */
  readonly provisioningState?: string;
  /**
   * The hub state.
  */
  readonly state?: string;
  /**
   * The name of the host.
  */
  readonly hostName?: string;
  /**
   * The Event Hub-compatible endpoint properties. The only possible keys to this dictionary is
   * events. This key has to be present in the dictionary while making create or update calls for
   * the IoT hub.
  */
  eventHubEndpoints?: { [propertyName: string]: EventHubProperties };
  routing?: RoutingProperties;
  /**
   * The list of Azure Storage endpoints where you can upload files. Currently you can configure
   * only one Azure Storage account and that MUST have its key as $default. Specifying more than
   * one storage account causes an error to be thrown. Not specifying a value for this property
   * when the enableFileUploadNotifications property is set to True, causes an error to be thrown.
  */
  storageEndpoints?: { [propertyName: string]: StorageEndpointProperties };
  /**
   * The messaging endpoint properties for the file upload notification queue.
  */
  messagingEndpoints?: { [propertyName: string]: MessagingEndpointProperties };
  /**
   * If True, file upload notifications are enabled.
  */
  enableFileUploadNotifications?: boolean;
  cloudToDevice?: CloudToDeviceProperties;
  /**
   * IoT hub comments.
  */
  comments?: string;
  /**
   * The device streams properties of iothub.
  */
  deviceStreams?: IotHubPropertiesDeviceStreams;
  /**
   * The capabilities and features enabled for the IoT hub. Possible values include: 'None',
   * 'DeviceManagement'
  */
  features?: string;
}

/**
 * Information about the SKU of the IoT hub.
*/
export interface IotHubSkuInfo {
  /**
   * The name of the SKU. Possible values include: 'F1', 'S1', 'S2', 'S3', 'B1', 'B2', 'B3'
  */
  name: string;
  /**
   * The billing tier for the IoT hub. Possible values include: 'Free', 'Standard', 'Basic'
  */
  readonly tier?: string;
  /**
   * The number of provisioned IoT Hub units. See:
   * https://docs.microsoft.com/azure/azure-subscription-service-limits#iot-hub-limits.
  */
  capacity?: number;
}

/**
 * The common properties of an Azure resource.
*/
export interface Resource extends BaseResource {
  /**
   * The resource identifier.
  */
  readonly id?: string;
  /**
   * The resource name.
  */
  readonly name?: string;
  /**
   * The resource type.
  */
  readonly type?: string;
  /**
   * The resource location.
  */
  location: string;
  /**
   * The resource tags.
  */
  tags?: { [propertyName: string]: string };
}

/**
 * The description of the IoT hub.
*/
export interface IotHubDescription extends Resource {
  /**
   * The Etag field is *not* required. If it is provided in the response body, it must also be
   * provided as a header per the normal ETag convention.
  */
  etag?: string;
  /**
   * IotHub properties
  */
  properties?: IotHubProperties;
  /**
   * IotHub SKU info
  */
  sku: IotHubSkuInfo;
}

/**
 * The object that represents the operation.
*/
export interface OperationDisplay {
  /**
   * Service provider: Microsoft Devices
  */
  readonly provider?: string;
  /**
   * Resource Type: IotHubs
  */
  readonly resource?: string;
  /**
   * Name of the operation
  */
  readonly operation?: string;
  /**
   * Description of the operation
  */
  readonly description?: string;
}

/**
 * IoT Hub REST API operation
*/
export interface Operation {
  /**
   * Operation name: {provider}/{resource}/{read | write | action | delete}
  */
  readonly name?: string;
  /**
   * The object that represents the operation.
  */
  display?: OperationDisplay;
}

/**
 * Error details.
*/
export interface ErrorDetails {
  /**
   * The error code.
  */
  readonly code?: string;
  /**
   * The HTTP status code.
  */
  readonly httpStatusCode?: string;
  /**
   * The error message.
  */
  readonly message?: string;
  /**
   * The error details.
  */
  readonly details?: string;
}

/**
 * Quota metrics properties.
*/
export interface IotHubQuotaMetricInfo {
  /**
   * The name of the quota metric.
  */
  readonly name?: string;
  /**
   * The current value for the quota metric.
  */
  readonly currentValue?: number;
  /**
   * The maximum value of the quota metric.
  */
  readonly maxValue?: number;
}

/**
 * The health data for an endpoint
*/
export interface EndpointHealthData {
  /**
   * Id of the endpoint
  */
  endpointId?: string;
  /**
   * Health statuses have following meanings. The 'healthy' status shows that the endpoint is
   * accepting messages as expected. The 'unhealthy' status shows that the endpoint is not
   * accepting messages as expected and IoT Hub is retrying to send data to this endpoint. The
   * status of an unhealthy endpoint will be updated to healthy when IoT Hub has established an
   * eventually consistent state of health. The 'dead' status shows that the endpoint is not
   * accepting messages, after IoT Hub retried sending messages for the retrial period. See IoT Hub
   * metrics to identify errors and monitor issues with endpoints. The 'unknown' status shows that
   * the IoT Hub has not established a connection with the endpoint. No messages have been
   * delivered to or rejected from this endpoint. Possible values include: 'unknown', 'healthy',
   * 'unhealthy', 'dead'
  */
  healthStatus?: string;
}

/**
 * Identity registry statistics.
*/
export interface RegistryStatistics {
  /**
   * The total count of devices in the identity registry.
  */
  readonly totalDeviceCount?: number;
  /**
   * The count of enabled devices in the identity registry.
  */
  readonly enabledDeviceCount?: number;
  /**
   * The count of disabled devices in the identity registry.
  */
  readonly disabledDeviceCount?: number;
}

/**
 * The properties of the Job Response object.
*/
export interface JobResponse {
  /**
   * The job identifier.
  */
  readonly jobId?: string;
  /**
   * The start time of the job.
  */
  readonly startTimeUtc?: Date;
  /**
   * The time the job stopped processing.
  */
  readonly endTimeUtc?: Date;
  /**
   * The type of the job. Possible values include: 'unknown', 'export', 'import', 'backup',
   * 'readDeviceProperties', 'writeDeviceProperties', 'updateDeviceConfiguration', 'rebootDevice',
   * 'factoryResetDevice', 'firmwareUpdate'
  */
  readonly type?: string;
  /**
   * The status of the job. Possible values include: 'unknown', 'enqueued', 'running', 'completed',
   * 'failed', 'cancelled'
  */
  readonly status?: string;
  /**
   * If status == failed, this string containing the reason for the failure.
  */
  readonly failureReason?: string;
  /**
   * The status message for the job.
  */
  readonly statusMessage?: string;
  /**
   * The job identifier of the parent job, if any.
  */
  readonly parentJobId?: string;
}

/**
 * IoT Hub capacity information.
*/
export interface IotHubCapacity {
  /**
   * The minimum number of units.
  */
  readonly minimum?: number;
  /**
   * The maximum number of units.
  */
  readonly maximum?: number;
  /**
   * The default number of units.
  */
  readonly default?: number;
  /**
   * The type of the scaling enabled. Possible values include: 'Automatic', 'Manual', 'None'
  */
  readonly scaleType?: string;
}

/**
 * SKU properties.
*/
export interface IotHubSkuDescription {
  /**
   * The type of the resource.
  */
  readonly resourceType?: string;
  /**
   * The type of the resource.
  */
  sku: IotHubSkuInfo;
  /**
   * IotHub capacity
  */
  capacity: IotHubCapacity;
}

/**
 * A container holding only the Tags for a resource, allowing the user to update the tags on an IoT
 * Hub instance.
*/
export interface TagsResource {
  /**
   * Resource tags
  */
  tags?: { [propertyName: string]: string };
}

/**
 * The properties of the EventHubConsumerGroupInfo object.
*/
export interface EventHubConsumerGroupInfo extends BaseResource {
  /**
   * The tags.
  */
  properties?: { [propertyName: string]: string };
  /**
   * The Event Hub-compatible consumer group identifier.
  */
  readonly id?: string;
  /**
   * The Event Hub-compatible consumer group name.
  */
  readonly name?: string;
  /**
   * the resource type.
  */
  readonly type?: string;
  /**
   * The etag.
  */
  readonly etag?: string;
}

/**
 * Input values.
*/
export interface OperationInputs {
  /**
   * The name of the IoT hub to check.
  */
  name: string;
}

/**
 * The properties indicating whether a given IoT hub name is available.
*/
export interface IotHubNameAvailabilityInfo {
  /**
   * The value which indicates whether the provided name is available.
  */
  readonly nameAvailable?: boolean;
  /**
   * The reason for unavailability. Possible values include: 'Invalid', 'AlreadyExists'
  */
  readonly reason?: string;
  /**
   * The detailed reason message.
  */
  message?: string;
}

/**
 * Name of Iot Hub type
*/
export interface Name {
  /**
   * IotHub type
  */
  value?: string;
  /**
   * Localized value of name
  */
  localizedValue?: string;
}

/**
 * User subscription quota response
*/
export interface UserSubscriptionQuota {
  /**
   * IotHub type id
  */
  id?: string;
  /**
   * Response type
  */
  type?: string;
  /**
   * Unit of IotHub type
  */
  unit?: string;
  /**
   * Current number of IotHub type
  */
  currentValue?: number;
  /**
   * Numerical limit on IotHub type
  */
  limit?: number;
  /**
   * IotHub type
  */
  name?: Name;
}

/**
 * Json-serialized array of User subscription quota response
*/
export interface UserSubscriptionQuotaListResult {
  value?: UserSubscriptionQuota[];
  readonly nextLink?: string;
}

/**
 * Routing message
*/
export interface RoutingMessage {
  /**
   * Body of routing message
  */
  body?: string;
  /**
   * App properties
  */
  appProperties?: { [propertyName: string]: string };
  /**
   * System properties
  */
  systemProperties?: { [propertyName: string]: string };
}

export interface RoutingTwinProperties {
  /**
   * Twin desired properties
  */
  desired?: any;
  /**
   * Twin desired properties
  */
  reported?: any;
}

/**
 * Twin reference input parameter. This is an optional parameter
*/
export interface RoutingTwin {
  /**
   * Twin Tags
  */
  tags?: any;
  properties?: RoutingTwinProperties;
}

/**
 * Input for testing all routes
*/
export interface TestAllRoutesInput {
  /**
   * Routing source. Possible values include: 'Invalid', 'DeviceMessages', 'TwinChangeEvents',
   * 'DeviceLifecycleEvents', 'DeviceJobLifecycleEvents'
  */
  routingSource?: string;
  /**
   * Routing message
  */
  message?: RoutingMessage;
  /**
   * Routing Twin Reference
  */
  twin?: RoutingTwin;
}

/**
 * Routes that matched
*/
export interface MatchedRoute {
  /**
   * Properties of routes that matched
  */
  properties?: RouteProperties;
}

/**
 * Result of testing all routes
*/
export interface TestAllRoutesResult {
  /**
   * JSON-serialized array of matched routes
  */
  routes?: MatchedRoute[];
}

/**
 * Input for testing route
*/
export interface TestRouteInput {
  /**
   * Routing message
  */
  message?: RoutingMessage;
  /**
   * Route properties
  */
  route: RouteProperties;
  /**
   * Routing Twin Reference
  */
  twin?: RoutingTwin;
}

/**
 * Position where the route error happened
*/
export interface RouteErrorPosition {
  /**
   * Line where the route error happened
  */
  line?: number;
  /**
   * Column where the route error happened
  */
  column?: number;
}

/**
 * Range of route errors
*/
export interface RouteErrorRange {
  /**
   * Start where the route error happened
  */
  start?: RouteErrorPosition;
  /**
   * End where the route error happened
  */
  end?: RouteErrorPosition;
}

/**
 * Compilation error when evaluating route
*/
export interface RouteCompilationError {
  /**
   * Route error message
  */
  message?: string;
  /**
   * Severity of the route error. Possible values include: 'error', 'warning'
  */
  severity?: string;
  /**
   * Location where the route error happened
  */
  location?: RouteErrorRange;
}

/**
 * Detailed result of testing a route
*/
export interface TestRouteResultDetails {
  /**
   * JSON-serialized list of route compilation errors
  */
  compilationErrors?: RouteCompilationError[];
}

/**
 * Result of testing one route
*/
export interface TestRouteResult {
  /**
   * Result of testing route. Possible values include: 'undefined', 'false', 'true'
  */
  result?: string;
  /**
   * Detailed result of testing route
  */
  details?: TestRouteResultDetails;
}

/**
 * Use to provide parameters when requesting an export of all devices in the IoT hub.
*/
export interface ExportDevicesRequest {
  /**
   * The export blob container URI.
  */
  exportBlobContainerUri: string;
  /**
   * The value indicating whether keys should be excluded during export.
  */
  excludeKeys: boolean;
}

/**
 * Use to provide parameters when requesting an import of all devices in the hub.
*/
export interface ImportDevicesRequest {
  /**
   * The input blob container URI.
  */
  inputBlobContainerUri: string;
  /**
   * The output blob container URI.
  */
  outputBlobContainerUri: string;
}

/**
 * Result of the request to list IoT Hub operations. It contains a list of operations and a URL
 * link to get the next set of results.
*/
export interface OperationListResult extends Array<Operation> {
  /**
   * URL to get the next set of operation list results if there are any.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of IotHubDescription objects with a next link.
*/
export interface IotHubDescriptionListResult extends Array<IotHubDescription> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of IotHubSkuDescription objects with a next link.
*/
export interface IotHubSkuDescriptionListResult extends Array<IotHubSkuDescription> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of Event Hub-compatible consumer group names with a next link.
*/
export interface EventHubConsumerGroupsListResult extends Array<EventHubConsumerGroupInfo> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of JobResponse objects with a next link.
*/
export interface JobResponseListResult extends Array<JobResponse> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of IotHubQuotaMetricInfo objects with a next link.
*/
export interface IotHubQuotaMetricInfoListResult extends Array<IotHubQuotaMetricInfo> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}

/**
 * The JSON-serialized array of EndpointHealthData objects with a next link.
*/
export interface EndpointHealthDataListResult extends Array<EndpointHealthData> {
  /**
   * Link to more results
  */
  readonly nextLink?: string;
}

/**
 * The list of shared access policies with a next link.
*/
export interface SharedAccessSignatureAuthorizationRuleListResult extends
Array<SharedAccessSignatureAuthorizationRule> {
  /**
   * The next link.
  */
  readonly nextLink?: string;
}
