/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError } from "ms-rest-azure";
import * as moment from "moment";

export {

  BaseResource,
  CloudError
};

/**
 * Base class for models
 */
export interface BaseModel {
  /**
   * The identifier.
   */
  readonly id?: string;
  /**
   * The name.
   */
  readonly name?: string;
  /**
   * The type.
   */
  readonly type?: string;
}

/**
 * The access control record
 */
export interface AccessControlRecord extends BaseModel {
  /**
   * The Iscsi initiator name (IQN)
   */
  initiatorName: string;
}

/**
 * source at which the alert can be raised
 */
export interface AlertSource {
  /**
   * Name of the source.
   */
  name?: string;
  /**
   * The time zone.
   */
  timeZone?: string;
  /**
   * Source type of the alert. Possible values include: 'Resource', 'Device'
   */
  alertSourceType?: string;
}

/**
 * Error details for the alert
 */
export interface AlertErrorDetails {
  /**
   * Error code.
   */
  errorCode?: string;
  /**
   * Error Message
   */
  errorMessage?: string;
  /**
   * Number of occurrences.
   */
  occurences?: number;
}

/**
 * Alert class
 */
export interface Alert extends BaseModel {
  /**
   * Title of the alert
   */
  title: string;
  /**
   * Device or Resource alert. Possible values include: 'Resource', 'Device'
   */
  scope: string;
  /**
   * Type of the alert
   */
  alertType: string;
  /**
   * UTC time at which the alert appeared
   */
  appearedAtTime: Date;
  /**
   * UTC time at which the alert appeared on the source
   */
  appearedAtSourceTime: Date;
  /**
   * UTC time at which the alert got cleared
   */
  clearedAtTime?: Date;
  /**
   * UTC time at which the alert was cleared on the source
   */
  clearedAtSourceTime?: Date;
  /**
   * Source at which the alert was cleared
   */
  source: AlertSource;
  /**
   * Recommendation for acting on the alert
   */
  recommendation?: string;
  /**
   * Reason for resolving the alert
   */
  resolutionReason?: string;
  /**
   * Severity of the alert. Possible values include: 'Informational', 'Warning', 'Critical'
   */
  severity: string;
  /**
   * Current status of the alert. Possible values include: 'Active', 'Cleared'
   */
  status: string;
  /**
   * ErrorDetails of the alert
   */
  errorDetails?: AlertErrorDetails;
  /**
   * Other information about the alert
   */
  detailedInformation?: { [propertyName: string]: string };
}

/**
 * Filters that can be specified on the alert
 */
export interface AlertFilter {
  /**
   * Status of the alert. Possible values include: 'Active', 'Cleared'
   */
  status?: string;
  /**
   * Severity of the alert. Possible values include: 'Informational', 'Warning', 'Critical'
   */
  severity?: string;
  /**
   * Source of the alert. Possible values include: 'Resource', 'Device'
   */
  sourceType?: string;
  /**
   * Source name of the alert
   */
  sourceName?: string;
  /**
   * UTC time on which the alert appeared
   */
  appearedOnTime?: Date;
}

/**
 * AlertSettings on the device which represents how alerts will be processed
 */
export interface AlertSettings extends BaseModel {
  /**
   * Value indicating whether user/admins will receive emails when an alert condition occurs on the
   * system. Possible values include: 'Enabled', 'Disabled'
   */
  emailNotification: string;
  /**
   * Value indicating whether service owners will receive emails when an alert condition occurs on
   * the system. Applicable only if emailNotification flag is Enabled. Possible values include:
   * 'Enabled', 'Disabled'
   */
  notificationToServiceOwners: string;
  /**
   * Culture setting to be used while building alert emails. For eg: "en-US"
   */
  alertNotificationCulture: string;
  /**
   * List of email addresses (apart from admin/co-admin of subscription) to whom the alert emails
   * need to be sent
   */
  additionalRecipientEmailList?: string[];
}

/**
 * This class can be used as the Type for any secret entity represented as Password,
 * CertThumbprint, Algorithm. This class is intended to be used when the secret is encrypted with
 * an asymmetric key pair. The encryptionAlgorithm field is mainly for future usage to potentially
 * allow different entities encrypted using different algorithms.
 */
export interface AsymmetricEncryptedSecret {
  /**
   * The value of the secret itself. If the secret is in plaintext then EncryptionAlgorithm will be
   * none and EncryptionCertThumbprint will be null.
   */
  value: string;
  /**
   * Thumbprint certificate that was used to encrypt "Value"
   */
  encryptionCertificateThumbprint?: string;
  /**
   * Algorithm used to encrypt "Value". Possible values include: 'None', 'AES256',
   * 'RSAES_PKCS1_v_1_5'
   */
  encryptionAlgorithm: string;
}

/**
 * Contains the localized display information for this particular operation / action.
 * These value will be used by several clients for
 * (1) custom role definitions for RBAC;
 * (2) complex query filters for the event service; and (3) audit history / records for management
 * operations.
 */
export interface AvailableProviderOperationDisplay {
  /**
   * Gets or sets Provider
   * The localized friendly form of the resource provider name – it is expected to also include the
   * publisher/company responsible.
   * It should use Title Casing and begin with “Microsoft” for 1st party services.
   */
  provider?: string;
  /**
   * Gets or sets Resource
   * The localized friendly form of the resource type related to this action/operation – it should
   * match the public documentation for the resource provider.
   * It should use Title Casing – for examples, please refer to the “name” section.
   */
  resource?: string;
  /**
   * Gets or sets Operation
   * The localized friendly name for the operation, as it should be shown to the user.
   * It should be concise (to fit in drop downs) but clear (i.e. self-documenting). It should use
   * Title Casing and include the entity/resource to which it applies.
   */
  operation?: string;
  /**
   * Gets or sets Description
   * The localized friendly description for the operation, as it should be shown to the user.
   * It should be thorough, yet concise – it will be used in tool tips and detailed views.
   */
  description?: string;
}

/**
 * Class represents provider operation
 */
export interface AvailableProviderOperation {
  /**
   * Gets or sets the name of the operation being performed on this particular object
   * Return value format: "{resourceProviderNamespace}/{resourceType}/{read|write|deletion|action}"
   * Eg: Microsoft.StorSimple/managers/devices/fileServers/read
   * Microsoft.StorSimple/managers/devices/alerts/clearAlerts/action
   */
  name?: string;
  /**
   * Gets or sets Display information
   * Contains the localized display information for this particular operation/action
   */
  display?: AvailableProviderOperationDisplay;
  /**
   * Gets or sets Origin
   * The intended executor of the operation; governs the display of the operation in the RBAC UX
   * and the audit logs UX.
   * Default value is “user,system”
   */
  origin?: string;
  /**
   * Gets or sets Properties
   * Reserved for future use
   */
  properties?: any;
}

/**
 * Class represents BackupElement
 */
export interface BackupElement extends BaseModel {
  /**
   * The size in bytes.
   */
  sizeInBytes: number;
  /**
   * The name of the endpoint.
   */
  endpointName: string;
  /**
   * The data policy of backed up endpoint. Possible values include: 'Invalid', 'Local', 'Tiered',
   * 'Cloud'
   */
  dataPolicy: string;
}

/**
 * The backup.
 */
export interface Backup extends BaseModel {
  /**
   * The path id of the target FileServer or IscsiServer for which the backup was taken.
   */
  targetId?: string;
  /**
   * Type of target, FileServer or IscsiServer
   */
  targetType?: string;
  /**
   * The backup size in bytes.
   */
  sizeInBytes: number;
  /**
   * The time when the backup was created.
   */
  createdTime?: Date;
  /**
   * The time when the backup will expire.
   */
  expirationTime?: Date;
  /**
   * Indicates how the backup was initiated "Manual | Scheduled". Possible values include:
   * 'Manual', 'Scheduled'
   */
  initiatedBy: string;
  /**
   * The Device Identifier.
   */
  deviceId: string;
  /**
   * The backup elements.
   */
  elements: BackupElement[];
}

/**
 * Backup OData filter class
 */
export interface BackupFilter {
  /**
   * Gets or sets InitiatedBy. Possible values include: 'Manual', 'Scheduled'
   */
  initiatedBy?: string;
  /**
   * Gets or sets CreatedTime
   */
  createdTime?: Date;
}

/**
 * The Time.
 */
export interface Time {
  /**
   * The hour.
   */
  hour: number;
  /**
   * The minute.
   */
  minute: number;
}

/**
 * The Backup Schedule Group
 */
export interface BackupScheduleGroup extends BaseModel {
  /**
   * The start time. When this field is specified we will generate Default GrandFather Father Son
   * Backup Schedules.
   */
  startTime: Time;
}

/**
 * Challenge-Handshake Authentication Protocol (CHAP) setting
 */
export interface ChapSettings extends BaseModel {
  /**
   * The chap password.
   */
  password: AsymmetricEncryptedSecret;
}

/**
 * Request for clearing the alert
 */
export interface ClearAlertRequest {
  /**
   * Resolution message while clearing the request
   */
  resolutionMessage?: string;
  /**
   * List of alert Ids to be cleared
   */
  alerts: string[];
}

/**
 * The File Share.
 */
export interface FileShare extends BaseModel {
  /**
   * Description for file share
   */
  description?: string;
  /**
   * The Share Status. Possible values include: 'Online', 'Offline'
   */
  shareStatus: string;
  /**
   * The data policy. Possible values include: 'Invalid', 'Local', 'Tiered', 'Cloud'
   */
  dataPolicy: string;
  /**
   * The user/group who will have full permission in this share. Active directory email address.
   * Example: xyz@contoso.com or Contoso\xyz.
   */
  adminUser: string;
  /**
   * The total provisioned capacity in Bytes
   */
  provisionedCapacityInBytes: number;
  /**
   * The used capacity in Bytes.
   */
  readonly usedCapacityInBytes?: number;
  /**
   * The local used capacity in Bytes.
   */
  readonly localUsedCapacityInBytes?: number;
  /**
   * The monitoring status. Possible values include: 'Enabled', 'Disabled'
   */
  monitoringStatus: string;
}

/**
 * The iSCSI disk.
 */
export interface ISCSIDisk extends BaseModel {
  /**
   * The description.
   */
  description?: string;
  /**
   * The disk status. Possible values include: 'Online', 'Offline'
   */
  diskStatus: string;
  /**
   * The access control records.
   */
  accessControlRecords: string[];
  /**
   * The data policy. Possible values include: 'Invalid', 'Local', 'Tiered', 'Cloud'
   */
  dataPolicy: string;
  /**
   * The provisioned capacity in bytes.
   */
  provisionedCapacityInBytes: number;
  /**
   * The used capacity in bytes.
   */
  readonly usedCapacityInBytes?: number;
  /**
   * The local used capacity in bytes.
   */
  readonly localUsedCapacityInBytes?: number;
  /**
   * The monitoring. Possible values include: 'Enabled', 'Disabled'
   */
  monitoringStatus: string;
}

/**
 * Clone Job Request Model.
 */
export interface CloneRequest {
  /**
   * DeviceId of the device which will act as the Clone target
   */
  targetDeviceId: string;
  /**
   * Access point Id on which clone job will performed.
   */
  targetAccessPointId: string;
  /**
   * Name of new endpoint which will created as part of clone job.
   */
  newEndpointName: string;
  /**
   * Share Object.
   */
  share?: FileShare;
  /**
   * Disk Object
   */
  disk?: ISCSIDisk;
}

/**
 * Class containing more granular details about the device
 */
export interface DeviceDetails {
  /**
   * Total number of endpoints that are currently on the device ( i.e. number of shares on
   * FileServer or number of volumes on IscsiServer)
   */
  endpointCount?: number;
  /**
   * Total storage available on the device in bytes.
   */
  totalStorageInBytes?: number;
  /**
   * Total local storage capacity in device in bytes.
   */
  totalLocalStorageInBytes?: number;
  /**
   * Storage in bytes that has been provisioned on the device including both local and cloud
   */
  provisionedStorageInBytes?: number;
  /**
   * Storage in bytes that has been provisioned locally on the device
   */
  provisionedLocalStorageInBytes?: number;
  /**
   * Storage that is being currently used in bytes including both local and cloud
   */
  usingStorageInBytes?: number;
  /**
   * Local Storage that is being currently used in bytes
   */
  usingLocalStorageInBytes?: number;
  /**
   * Total size taken up by backups in bytes
   */
  totalBackupSizeInBytes?: number;
  /**
   * Total pending available storage on the device in bytes
   */
  availableStorageInBytes?: number;
  /**
   * Local pending storage available on the device in bytes
   */
  availableLocalStorageInBytes?: number;
}

/**
 * Represents a StorSimple device object along with its properties
 */
export interface Device extends BaseModel {
  /**
   * The UTC time at which the device was activated
   */
  activationTime?: Date;
  /**
   * Operations that are allowed on the device based on its current state
   */
  allowedDeviceOperations?: string[];
  /**
   * Language culture setting on the device. For eg: "en-US"
   */
  culture?: string;
  /**
   * Device can be configured either as FileServer or IscsiServer
   */
  deviceCapabilities?: string[];
  /**
   * Short description given for the device
   */
  deviceDescription?: string;
  /**
   * Fully qualified name of the domain to which the device is attached
   */
  domainName?: string;
  /**
   * Version number of the software running on the device
   */
  deviceSoftwareVersion?: string;
  /**
   * Friendly name for the software version
   */
  friendlySoftwareName?: string;
  /**
   * "Complete" if the device has been successfully registered as File/IscsiServer and the creation
   * of share/volume is complete, "Pending" if the device is only registered but the creation of
   * share/volume is complete is still pending. Possible values include: 'Complete', 'Pending'
   */
  deviceConfigurationStatus?: string;
  /**
   * Name of the device model
   */
  modelDescription?: string;
  /**
   * Current status of the device. Possible values include: 'Unknown', 'Online', 'Offline',
   * 'RequiresAttention', 'MaintenanceMode', 'Creating', 'Provisioning', 'Deleted', 'ReadyToSetup',
   * 'Deactivated', 'Deactivating'
   */
  status?: string;
  /**
   * Type of the device. Possible values include: 'Invalid', 'Appliance', 'VirtualAppliance',
   * 'Series9000OnPremVirtualAppliance', 'Series9000VirtualAppliance',
   * 'Series9000PhysicalAppliance'
   */
  deviceType?: string;
  /**
   * subclass containing more storage-related information about the device. This field will be
   * populated only if the get call is made with $expand = details.
   */
  details?: DeviceDetails;
}

/**
 * Class that represents the Input for the PATCH call on Device. Currently the only patchable
 * property on device is "DeviceDescription"
 */
export interface DevicePatch {
  /**
   * Short description given for the device
   */
  deviceDescription?: string;
}

/**
 * The EncryptionSettings
 */
export interface EncryptionSettings extends BaseModel {
  /**
   * The encryption status which indicates if encryption is enabled or not. Possible values
   * include: 'Enabled', 'Disabled'
   */
  encryptionStatus: string;
  /**
   * The key rollover status which indicates if key rollover is required or not. If secrets
   * encryption has been upgraded, then it requires key rollover. Possible values include:
   * 'Required', 'NotRequired'
   */
  keyRolloverStatus: string;
}

export interface Message {
  language?: string;
  value?: string;
}

export interface Item {
  key: string;
  value: string;
}

export interface ErrorModel {
  errorCode: string;
  message: Message;
  values?: Item[];
}

/**
 * The Failover request object.
*/
export interface FailoverRequest {
  accesspointIds?: string[];
  targetDeviceId?: string;
  skipValidation?: boolean;
  keepSourceDevice?: boolean;
}

/**
 * The file server.
*/
export interface FileServer extends BaseModel {
  /**
   * Domain of the file server
  */
  domainName: string;
  /**
   * The storage domain id.
  */
  storageDomainId: string;
  /**
   * The backup policy id.
  */
  backupScheduleGroupId: string;
  /**
   * The description of the file server
  */
  description?: string;
}

/**
 * Details related to the IP address configuration
*/
export interface IPConfig {
  /**
   * The IP address of the network adapter, either ipv4 or ipv6.
  */
  ipAddress: string;
  /**
   * The prefix length of the network adapter.
  */
  prefixLength?: number;
  /**
   * The gateway of the network adapter.
  */
  gateway: string;
}

/**
 * The iSCSI server.
*/
export interface ISCSIServer extends BaseModel {
  /**
   * The storage domain id.
  */
  storageDomainId: string;
  /**
   * The backup policy id.
  */
  backupScheduleGroupId: string;
  /**
   * The description.
  */
  description?: string;
  /**
   * The chap id.
  */
  chapId?: string;
  /**
   * The reverse chap id.
  */
  reverseChapId?: string;
}

/**
 * The job error items.
*/
export interface JobErrorItem {
  /**
   * The recommended actions.
  */
  recommendations?: string[];
  /**
   * The code intended for programmatic access
  */
  code: string;
  /**
   * The message intended to describe the error in detail
  */
  message: string;
}

/**
 * The job error information containing List of JobErrorItem.
*/
export interface JobErrorDetails {
  /**
   * The error details.
  */
  errorDetails?: JobErrorItem[];
  /**
   * The code intended for programmatic access
  */
  code: string;
  /**
   * The message intended to describe the error in detail
  */
  message: string;
}

/**
 * Contains details about the multiple job stages of a job
*/
export interface JobStage {
  /**
   * The message of the job stage.
  */
  message?: string;
  /**
   * The stage status. Possible values include: 'Invalid', 'Running', 'Succeeded', 'Failed',
   * 'Canceled', 'Paused', 'Scheduled'
  */
  stageStatus: string;
  /**
   * The details of the stage.
  */
  detail?: string;
  /**
   * The error code of the stage if any.
  */
  errorCode?: string;
}

/**
 * Stats that are available for all jobs in common
*/
export interface JobStats {
  /**
   * Completed work item count.
  */
  completedWorkItemCount?: number;
  /**
   * Total work item count.
  */
  totalWorkItemCount?: number;
  /**
   * The estimated time remaining.
  */
  estimatedTimeRemaining?: number;
}

/**
 * details available during the download
*/
export interface UpdateDownloadProgress {
  /**
   * The download phase. Possible values include: 'Unknown', 'Initializing', 'Downloading',
   * 'Verifying'
  */
  downloadPhase?: string;
  /**
   * Percentage of completion.
  */
  percentComplete?: number;
  /**
   * Total bytes to download.
  */
  totalBytesToDownload?: number;
  /**
   * Total bytes downloaded.
  */
  totalBytesDownloaded?: number;
  /**
   * Number of updates to download.
  */
  numberOfUpdatesToDownload?: number;
  /**
   * Number of updates downloaded.
  */
  numberOfUpdatesDownloaded?: number;
}

/**
 * Class representing the progress during installation of updates
*/
export interface UpdateInstallProgress {
  /**
   * Percentage of completion.
  */
  percentComplete?: number;
  /**
   * Number of updates to install.
  */
  numberOfUpdatesToInstall?: number;
  /**
   * Number of updates installed.
  */
  numberOfUpdatesInstalled?: number;
}

/**
 * The Job.
*/
export interface Job extends BaseModel {
  /**
   * Current status of the job. Possible values include: 'Invalid', 'Running', 'Succeeded',
   * 'Failed', 'Canceled', 'Paused', 'Scheduled'
  */
  status: string;
  /**
   * The UTC time at which the job was started
  */
  startTime?: Date;
  /**
   * The UTC time at which the job completed
  */
  endTime?: Date;
  /**
   * The percentage of the job that is already complete
  */
  percentComplete: number;
  /**
   * The Error details.
  */
  error?: JobErrorDetails;
  /**
   * Type of the job. Possible values include: 'Backup', 'Clone', 'Failover', 'DownloadUpdates',
   * 'InstallUpdates'
  */
  jobType: string;
  /**
   * Id of the object that is created by the job
  */
  targetId?: string;
  /**
   * The entity identifier for which the job ran.
  */
  entityId?: string;
  /**
   * The entity type for which the job ran.
  */
  entityType?: string;
  /**
   * The job stages.
  */
  jobStages?: JobStage[];
  /**
   * The device id in which the job is currently running
  */
  deviceId?: string;
  /**
   * Represents whether the job is cancellable or not
  */
  isCancellable?: boolean;
  /**
   * stats properties for the job
  */
  stats?: JobStats;
  /**
   * The target type of the backup. Possible values include: 'FileServer', 'DiskServer'
  */
  targetType?: string;
  /**
   * The source device identifier of the failover job.
  */
  sourceDeviceId?: string;
  /**
   * The time of the backup used for the failover.
  */
  backupPointInTime?: Date;
  /**
   * The download progress.
  */
  downloadProgress?: UpdateDownloadProgress;
  /**
   * The install progress.
  */
  installProgress?: UpdateInstallProgress;
}

/**
 * Filters that can be specified for the job
*/
export interface JobFilter {
  /**
   * The job type. Possible values include: 'Backup', 'Clone', 'Failover', 'DownloadUpdates',
   * 'InstallUpdates'
  */
  jobType: string;
  /**
   * The job status. Possible values include: 'Invalid', 'Running', 'Succeeded', 'Failed',
   * 'Canceled', 'Paused', 'Scheduled'
  */
  status: string;
  /**
   * The start time of the job.
  */
  startTime?: Date;
}

/**
 * Intrinsic settings which refers to the type of the StorSimple manager
*/
export interface ManagerIntrinsicSettings {
  /**
   * Refers to the type of the StorSimple Manager. Possible values include: 'GardaV1', 'HelsinkiV1'
  */
  type: string;
}

/**
 * The Sku.
*/
export interface ManagerSku {
}

/**
 * The Azure Resource.
*/
export interface Resource extends BaseResource {
  /**
   * The Resource Id
  */
  readonly id?: string;
  /**
   * The Resource Name
  */
  readonly name?: string;
  /**
   * The Resource type
  */
  readonly type?: string;
  /**
   * The Geo location of the Manager
  */
  location: string;
  /**
   * Tags attached to the Manager
  */
  tags?: { [propertyName: string]: string };
}

/**
 * The StorSimple Manager
*/
export interface Manager extends Resource {
  /**
   * Specifies if the Manager is Garda or Helsinki
  */
  cisIntrinsicSettings?: ManagerIntrinsicSettings;
  /**
   * Specifies the state of the resource as it is getting provisioned. Value of "Succeeded" means
   * the Manager was successfully created
  */
  readonly provisioningState?: string;
  /**
   * ETag of the Manager
  */
  etag?: string;
}

/**
 * The extended info of the manager.
*/
export interface ManagerExtendedInfo extends BaseModel {
  /**
   * Represents the version of the ExtendedInfo object being persisted
  */
  version?: string;
  /**
   * Represents the CIK of the resource
  */
  integrityKey: string;
  /**
   * Represents the CEK of the resource
  */
  encryptionKey?: string;
  /**
   * Represents the Cert thumbprint that was used to encrypt the CEK
  */
  encryptionKeyThumbprint?: string;
  /**
   * Represents the portal thumbprint which can be used optionally to encrypt the entire data
   * before storing it.
  */
  portalCertificateThumbprint?: string;
  /**
   * Represents the encryption algorithm used to encrypt the other keys. None - if EncryptionKey is
   * saved in plain text format. AlgorithmName - if encryption is used
  */
  algorithm: string;
  /**
   * ETag of the Resource
  */
  etag?: string;
}

/**
 * The StorSimple Manager patch.
*/
export interface ManagerPatch {
  /**
   * The tags attached to the StorSimple Manager.
  */
  tags?: { [propertyName: string]: string };
}

/**
 * Metric availability specifies the time grain (aggregation interval or frequency) and the
 * retention period for that time grain
*/
export interface MetricAvailablity {
  /**
   * The time grain, specifies the aggregation interval for the metric.
  */
  timeGrain: string;
  /**
   * The retention period for the metric at the specified timegrain
  */
  retention: string;
}

/**
 * The metric data.
*/
export interface MetricData {
  /**
   * The time when the metric data is fetched
  */
  timeStamp: Date;
  /**
   * The sum of all the samples available in the given instance of time for the specific metric
   * data
  */
  sum: number;
  /**
   * The count of samples of the metric data available for the given instance
  */
  count: number;
  /**
   * The average of all sample for the given instance
  */
  average: number;
  /**
   * The minimum of all samples available
  */
  minimum: number;
  /**
   * The maximum of all samples available
  */
  maximum: number;
}

/**
 * The name of the metric
*/
export interface MetricName {
  /**
   * Name of the metric
  */
  value: string;
  /**
   * Localized name of the metric
  */
  localizedValue: string;
}

/**
 * Metric dimension
*/
export interface MetricDimension {
  /**
   * Metric dimension name
  */
  name: string;
  /**
   * Metric dimension values
  */
  value: string;
}

/**
 * Monitoring metric definition represents the metadata of the metrics.
*/
export interface MetricDefinition {
  /**
   * The metric name
  */
  name: MetricName;
  /**
   * The metric unit. Possible values include: 'Bytes', 'BytesPerSecond', 'Count',
   * 'CountPerSecond', 'Percent', 'Seconds'
  */
  unit: string;
  /**
   * The metric aggregation type. Possible values include: 'Average', 'Last', 'Maximum', 'Minimum',
   * 'None', 'Total'
  */
  primaryAggregationType: string;
  /**
   * The metric source id
  */
  resourceId: string;
  /**
   * The available metric granularities
  */
  metricAvailabilities: MetricAvailablity[];
  /**
   * The supported dimensions
  */
  dimensions: MetricDimension[];
  /**
   * The metric definition type
  */
  type: string;
}

/**
 * Class representing the name filter to be passed while fetching metrics
*/
export interface MetricNameFilter {
  /**
   * The value.
  */
  value?: string;
}

/**
 * class representing the filters to be passed while fetching metrics
*/
export interface MetricFilter {
  /**
   * filter for name property
  */
  name?: MetricNameFilter;
  /**
   * starttime for fetching metrics
  */
  startTime?: Date;
  /**
   * endtime for fetching metrics
  */
  endTime?: Date;
  /**
   * timegrain of the metrics
  */
  timeGrain?: string;
}

/**
 * Monitoring metric
*/
export interface Metrics {
  /**
   * The id of metric source
  */
  resourceId: string;
  /**
   * The metric start time
  */
  startTime: Date;
  /**
   * The metric end time
  */
  endTime: Date;
  /**
   * The time grain, time grain indicates frequency of the metric data
  */
  timeGrain: string;
  /**
   * The metric aggregation type. Possible values include: 'Average', 'Last', 'Maximum', 'Minimum',
   * 'None', 'Total'
  */
  primaryAggregation: string;
  /**
   * The name of the metrics
  */
  name: MetricName;
  /**
   * The Metric dimension which indicates the source of the metric
  */
  dimensions: MetricDimension[];
  /**
   * The unit of the metric data. Possible values include: 'Bytes', 'BytesPerSecond', 'Count',
   * 'CountPerSecond', 'Percent', 'Seconds'
  */
  unit: string;
  /**
   * The Type of the metric data
  */
  type: string;
  /**
   * The metric data
  */
  values: MetricData[];
}

/**
 * Represents a networkAdapter in a particular node.
*/
export interface NetworkAdapter {
  /**
   * The name of the network adapter.
  */
  networkAdapterName: string;
  /**
   * The ipv4 configuration of the network adapter.
  */
  iPv4Info?: IPConfig;
  /**
   * The ipv6 configuration of the network adapter.
  */
  iPv6Info?: IPConfig;
  /**
   * Represents state of DHCP. Possible values include: 'Enabled', 'Disabled'
  */
  dhcpStatus: string;
  /**
   * The speed of the network adapter.
  */
  linkSpeed?: number;
}

/**
 * Represents a single node in a device.
*/
export interface NodeNetwork {
  /**
   * The array of network adapters in the node.
  */
  networkAdapters: NetworkAdapter[];
}

/**
 * The NetworkSettings of a device
*/
export interface NetworkSettings extends BaseModel {
  /**
   * The Primary DNS server for the device
  */
  primaryDnsServer: string;
  /**
   * The secondary DNS server for the device
  */
  secondaryDnsServer?: string;
  /**
   * The NetworkAdapters under each node of the device.
  */
  nodeNetworks: NodeNetwork[];
}

/**
 * The SecuritySettings of a device
*/
export interface SecuritySettings extends BaseModel {
  /**
   * Device administrator password as an encrypted string (encrypted using RSA PKCS #1) is used to
   * log into the  local web UI of the device. Actual password could have at least 8 characters
   * that are a combination of  uppercase, lowercase, numeric, and special characters
  */
  deviceAdminPassword: AsymmetricEncryptedSecret;
}

/**
 * Request for sending test alert email
*/
export interface SendTestAlertEmailRequest {
  /**
   * List of emails to send the test alerts
  */
  emailList: string[];
}

/**
 * The storage account credential
*/
export interface StorageAccountCredential extends BaseModel {
  /**
   * The cloud service provider. Possible values include: 'Azure', 'S3', 'S3_RRS', 'OpenStack',
   * 'HP'
  */
  cloudType: string;
  /**
   * The storage endpoint
  */
  endPoint: string;
  /**
   * The storage account login
  */
  login: string;
  /**
   * The storage account's geo location
  */
  location?: string;
  /**
   * SSL needs to be enabled or not. Possible values include: 'Enabled', 'Disabled'
  */
  enableSSL: string;
  /**
   * The details of the storage account password
  */
  accessKey?: AsymmetricEncryptedSecret;
}

/**
 * The storage domain.
*/
export interface StorageDomain extends BaseModel {
  /**
   * The storage account credentials.
  */
  storageAccountCredentialIds: string[];
  /**
   * The encryption key used to encrypt the data. This is a user secret.
  */
  encryptionKey?: AsymmetricEncryptedSecret;
  /**
   * The encryption status "Enabled | Disabled". Possible values include: 'Enabled', 'Disabled'
  */
  encryptionStatus: string;
}

/**
 * This class can be used as the Type for any secret entity represented as Value,
 * ValueCertificateThumbprint, EncryptionAlgorithm. In this case, "Value" is a secret and the
 * "valueThumbprint" represents the certificate thumbprint of the value. The algorithm field is
 * mainly for future usage to potentially allow different entities encrypted using different
 * algorithms.
*/
export interface SymmetricEncryptedSecret {
  /**
   * The value of the secret itself. If the secret is in plaintext or null then EncryptionAlgorithm
   * will be none
  */
  value: string;
  /**
   * Thumbprint cert that was used to encrypt "Value"
  */
  valueCertificateThumbprint?: string;
  /**
   * Algorithm used to encrypt "Value". Possible values include: 'None', 'AES256',
   * 'RSAES_PKCS1_v_1_5'
  */
  encryptionAlgorithm: string;
}

/**
 * The TimeSettings of a device
*/
export interface TimeSettings extends BaseModel {
  /**
   * The timezone of device, like '(UTC -06:00) Central America'
  */
  timeZone: string;
  /**
   * The primary Network Time Protocol (NTP) server name, like 'time.windows.com'.
  */
  primaryTimeServer: string;
  /**
   * The secondary Network Time Protocol (NTP) server name, like 'time.contoso.com'. It's optional.
  */
  secondaryTimeServer?: string;
}

/**
 * The updates profile
*/
export interface Updates extends BaseModel {
  /**
   * The current Device version.
  */
  deviceVersion?: string;
  /**
   * The last time when the device did an update scan.
  */
  deviceLastScannedTime?: Date;
  /**
   * Set to true if regular updates were detected for the current version of the device.
  */
  regularUpdatesAvailable?: boolean;
  /**
   * Set to true if RegularUpdatesAvailable is true and if at least one of the updateItems detected
   * has needs a reboot to install.
  */
  rebootRequiredForInstall?: boolean;
  /**
   * The total number of items pending for download.
  */
  totalItemsPendingForDownload?: number;
  /**
   * The total number of items pending for install.
  */
  totalItemsPendingForInstall?: number;
  /**
   * The current update operation. Possible values include: 'Idle', 'Scanning', 'Downloading',
   * 'Installing'
  */
  status?: string;
  /**
   * The time when the last scan job was completed (success|cancelled|failed) on the device.
  */
  lastCompletedScanTime?: Date;
  /**
   * The time when the last Download job was completed (success|cancelled|failed) on the device.
  */
  lastCompletedDownloadJobTime?: Date;
  /**
   * The time when the last Install job was completed (success|cancelled|failed) on the device.
  */
  lastCompletedInstallJobTime?: Date;
  /**
   * If a download is in progress, this field contains the JobId of that particular download job
  */
  inProgressDownloadJobId?: string;
  /**
   * If an install is in progress, this field contains the JobId of that particular install job
  */
  inProgressInstallJobId?: string;
  /**
   * The time when the currently running scan (if any) started
  */
  inProgressScanStartedTime?: Date;
  /**
   * The time when the currently running download (if any) started
  */
  inProgressDownloadJobStartedTime?: Date;
  /**
   * The time when the currently running install (if any) started
  */
  inProgressInstallJobStartedTime?: Date;
}

/**
 * Upload Certificate Request to IDM
*/
export interface UploadCertificateRequest {
  /**
   * Specify the Authentication type. Possible values include: 'Invalid', 'AccessControlService',
   * 'AzureActiveDirectory'
  */
  authType?: string;
  /**
   * Gets or sets the base64 encoded certificate raw data string
  */
  certificate: string;
  /**
   * Gets ContractVersion. Possible values include: 'InvalidVersion', 'V2011_09', 'V2012_02',
   * 'V2012_05', 'V2012_12', 'V2013_04', 'V2013_10', 'V2013_11', 'V2014_04', 'V2014_06',
   * 'V2014_07', 'V2014_09', 'V2014_10', 'V2014_12', 'V2015_01', 'V2015_02', 'V2015_04',
   * 'V2015_05', 'V2015_06', 'V2015_07', 'V2015_08', 'V2015_10', 'V2015_12', 'V2016_01',
   * 'V2016_02', 'V2016_04', 'V2016_05', 'V2016_07', 'V2016_08'
  */
  readonly contractVersion?: string;
}

/**
 * Upload Certificate Response from IDM
*/
export interface UploadCertificateResponse extends BaseModel {
  /**
   * Specify the Authentication type. Possible values include: 'Invalid', 'AccessControlService',
   * 'AzureActiveDirectory'
  */
  authType?: string;
  /**
   * Gets or sets the base64 encoded certificate raw data string
  */
  certificate: string;
  /**
   * Gets or Sets the ResourceId
  */
  resourceId: number;
  /**
   * AAD tenant authority
  */
  aadAuthority: string;
  /**
   * AAD tenant Id
  */
  aadTenantId: string;
  /**
   * AAD service principal clientId
  */
  servicePrincipalClientId: string;
  /**
   * AAD service principal ObjectId
  */
  servicePrincipalObjectId: string;
  /**
   * Azure Management Endpoint Audience
  */
  azureManagementEndpointAudience: string;
  /**
   * Certificate Subject Name
  */
  subject: string;
  /**
   * Certificate Validity start Date time
  */
  validFrom: Date;
  /**
   * Certificate Validity End Date time
  */
  validTo: Date;
  /**
   * Certificate thumbprint
  */
  thumbprint: string;
  /**
   * Certificate friendly name
  */
  friendlyName: string;
  /**
   * Certificate issuer
  */
  issuer: string;
}

/**
 * List of StorSimple Managers under a particular resourceGroup
*/
export interface ManagerList extends Array<Manager> {
}

/**
 * Collection of metrics
*/
export interface MetricList extends Array<Metrics> {
}

/**
 * List of metric definition
*/
export interface MetricDefinitionList extends Array<MetricDefinition> {
}

/**
 * Class for set of operations used for discovery of available provider operations.
*/
export interface AvailableProviderOperations extends Array<AvailableProviderOperation> {
  /**
   * The NextLink.
  */
  nextLink?: string;
}

/**
 * Collection of AccessControlRecords
*/
export interface AccessControlRecordList extends Array<AccessControlRecord> {
}

/**
 * Collection of Alerts
*/
export interface AlertList extends Array<Alert> {
  /**
   * Id of the next page of alerts
  */
  nextLink?: string;
}

/**
 * Collection of backups
*/
export interface BackupList extends Array<Backup> {
  /**
   * The NextLink.
  */
  nextLink?: string;
}

/**
 * Collection of Devices
*/
export interface DeviceList extends Array<Device> {
}

/**
 * The list response of backup schedule groups
*/
export interface BackupScheduleGroupList extends Array<BackupScheduleGroup> {
}

/**
 * Collection of Chap setting entities
*/
export interface ChapSettingsList extends Array<ChapSettings> {
}

/**
 * Collection of Iscsi disk
*/
export interface ISCSIDiskList extends Array<ISCSIDisk> {
}

/**
 * Collection of file servers
*/
export interface FileServerList extends Array<FileServer> {
}

/**
 * Collection of file shares
*/
export interface FileShareList extends Array<FileShare> {
}

/**
 * Collection of Iscsi servers
*/
export interface ISCSIServerList extends Array<ISCSIServer> {
}

/**
 * Collection of jobs
*/
export interface JobList extends Array<Job> {
  /**
   * The NextLink.
  */
  nextLink?: string;
}

/**
 * Collection of Storage account credential entities
*/
export interface StorageAccountCredentialList extends Array<StorageAccountCredential> {
}

/**
 * Collection of storage domains
*/
export interface StorageDomainList extends Array<StorageDomain> {
}
