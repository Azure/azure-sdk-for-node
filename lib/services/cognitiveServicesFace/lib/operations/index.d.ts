/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
*/

import { ServiceClientOptions, RequestOptions, ServiceCallback, HttpOperationResponse } from 'ms-rest';
import * as stream from 'stream';
import * as models from '../models';


/**
 * @class
 * Face
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface Face {


    /**
     * Given query face's faceId, to search the similar-looking faces from a faceId
     * array, a face list or a large face list. faceId array contains the faces
     * created by [Face -
     * Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236),
     * which will expire 24 hours after creation. A "faceListId" is created by
     * [FaceList -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b)
     * containing persistedFaceIds that will not expire. And a "largeFaceListId" is
     * created by [LargeFaceList -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc)
     * containing persistedFaceIds that will also not expire. Depending on the
     * input the returned similar faces list contains faceIds or persistedFaceIds
     * ranked by similarity.
     * <br/>Find similar has two working modes, "matchPerson" and "matchFace".
     * "matchPerson" is the default mode that it tries to find faces of the same
     * person as possible by using internal same-person thresholds. It is useful to
     * find a known person's other photos. Note that an empty list will be returned
     * if no faces pass the internal thresholds. "matchFace" mode ignores
     * same-person thresholds and returns ranked similar faces anyway, even the
     * similarity is low. It can be used in the cases like searching
     * celebrity-looking faces.
     * <br/>The 'recognitionModel' associated with the query face's faceId should
     * be the same as the 'recognitionModel' used by the target faceId array, face
     * list or large face list.
     *
     *
     * @param {uuid} faceId FaceId of the query face. User needs to call Face -
     * Detect first to get a valid faceId. Note that this faceId is not persisted
     * and will expire 24 hours after the detection call
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.faceListId] An existing user-specified unique
     * candidate face list, created in Face List - Create a Face List. Face list
     * contains a set of persistedFaceIds which are persisted and will never
     * expire. Parameter faceListId, largeFaceListId and faceIds should not be
     * provided at the same time.
     *
     * @param {string} [options.largeFaceListId] An existing user-specified unique
     * candidate large face list, created in LargeFaceList - Create. Large face
     * list contains a set of persistedFaceIds which are persisted and will never
     * expire. Parameter faceListId, largeFaceListId and faceIds should not be
     * provided at the same time.
     *
     * @param {array} [options.faceIds] An array of candidate faceIds. All of them
     * are created by Face - Detect and the faceIds will expire 24 hours after the
     * detection call. The number of faceIds is limited to 1000. Parameter
     * faceListId, largeFaceListId and faceIds should not be provided at the same
     * time.
     *
     * @param {number} [options.maxNumOfCandidatesReturned] The number of top
     * similar faces returned. The valid range is [1, 1000].
     *
     * @param {string} [options.mode] Similar face searching mode. It can be
     * "matchPerson" or "matchFace". Possible values include: 'matchPerson',
     * 'matchFace'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    findSimilarWithHttpOperationResponse(faceId: string, options?: { faceListId? : string, largeFaceListId? : string, faceIds? : string[], maxNumOfCandidatesReturned? : number, mode? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.SimilarFace[]>>;

    /**
     * Given query face's faceId, to search the similar-looking faces from a faceId
     * array, a face list or a large face list. faceId array contains the faces
     * created by [Face -
     * Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236),
     * which will expire 24 hours after creation. A "faceListId" is created by
     * [FaceList -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b)
     * containing persistedFaceIds that will not expire. And a "largeFaceListId" is
     * created by [LargeFaceList -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc)
     * containing persistedFaceIds that will also not expire. Depending on the
     * input the returned similar faces list contains faceIds or persistedFaceIds
     * ranked by similarity.
     * <br/>Find similar has two working modes, "matchPerson" and "matchFace".
     * "matchPerson" is the default mode that it tries to find faces of the same
     * person as possible by using internal same-person thresholds. It is useful to
     * find a known person's other photos. Note that an empty list will be returned
     * if no faces pass the internal thresholds. "matchFace" mode ignores
     * same-person thresholds and returns ranked similar faces anyway, even the
     * similarity is low. It can be used in the cases like searching
     * celebrity-looking faces.
     * <br/>The 'recognitionModel' associated with the query face's faceId should
     * be the same as the 'recognitionModel' used by the target faceId array, face
     * list or large face list.
     *
     *
     * @param {uuid} faceId FaceId of the query face. User needs to call Face -
     * Detect first to get a valid faceId. Note that this faceId is not persisted
     * and will expire 24 hours after the detection call
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.faceListId] An existing user-specified unique
     * candidate face list, created in Face List - Create a Face List. Face list
     * contains a set of persistedFaceIds which are persisted and will never
     * expire. Parameter faceListId, largeFaceListId and faceIds should not be
     * provided at the same time.
     *
     * @param {string} [options.largeFaceListId] An existing user-specified unique
     * candidate large face list, created in LargeFaceList - Create. Large face
     * list contains a set of persistedFaceIds which are persisted and will never
     * expire. Parameter faceListId, largeFaceListId and faceIds should not be
     * provided at the same time.
     *
     * @param {array} [options.faceIds] An array of candidate faceIds. All of them
     * are created by Face - Detect and the faceIds will expire 24 hours after the
     * detection call. The number of faceIds is limited to 1000. Parameter
     * faceListId, largeFaceListId and faceIds should not be provided at the same
     * time.
     *
     * @param {number} [options.maxNumOfCandidatesReturned] The number of top
     * similar faces returned. The valid range is [1, 1000].
     *
     * @param {string} [options.mode] Similar face searching mode. It can be
     * "matchPerson" or "matchFace". Possible values include: 'matchPerson',
     * 'matchFace'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    findSimilar(faceId: string, options?: { faceListId? : string, largeFaceListId? : string, faceIds? : string[], maxNumOfCandidatesReturned? : number, mode? : string, customHeaders? : { [headerName: string]: string; } }): Promise<models.SimilarFace[]>;
    findSimilar(faceId: string, callback: ServiceCallback<models.SimilarFace[]>): void;
    findSimilar(faceId: string, options: { faceListId? : string, largeFaceListId? : string, faceIds? : string[], maxNumOfCandidatesReturned? : number, mode? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.SimilarFace[]>): void;


    /**
     * Divide candidate faces into groups based on face similarity.<br />
     * * The output is one or more disjointed face groups and a messyGroup. A face
     * group contains faces that have similar looking, often of the same person.
     * Face groups are ranked by group size, i.e. number of faces. Notice that
     * faces belonging to a same person might be split into several groups in the
     * result.
     * * MessyGroup is a special face group containing faces that cannot find any
     * similar counterpart face from original faces. The messyGroup will not appear
     * in the result if all faces found their counterparts.
     * * Group API needs at least 2 candidate faces and 1000 at most. We suggest to
     * try [Face -
     * Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a)
     * when you only have 2 candidate faces.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same.
     *
     *
     * @param {array} faceIds Array of candidate faceId created by Face - Detect.
     * The maximum is 1000 faces
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<GroupResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    groupWithHttpOperationResponse(faceIds: string[], options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.GroupResult>>;

    /**
     * Divide candidate faces into groups based on face similarity.<br />
     * * The output is one or more disjointed face groups and a messyGroup. A face
     * group contains faces that have similar looking, often of the same person.
     * Face groups are ranked by group size, i.e. number of faces. Notice that
     * faces belonging to a same person might be split into several groups in the
     * result.
     * * MessyGroup is a special face group containing faces that cannot find any
     * similar counterpart face from original faces. The messyGroup will not appear
     * in the result if all faces found their counterparts.
     * * Group API needs at least 2 candidate faces and 1000 at most. We suggest to
     * try [Face -
     * Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a)
     * when you only have 2 candidate faces.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same.
     *
     *
     * @param {array} faceIds Array of candidate faceId created by Face - Detect.
     * The maximum is 1000 faces
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {GroupResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {GroupResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link GroupResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    group(faceIds: string[], options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.GroupResult>;
    group(faceIds: string[], callback: ServiceCallback<models.GroupResult>): void;
    group(faceIds: string[], options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.GroupResult>): void;


    /**
     * 1-to-many identification to find the closest matches of the specific query
     * person face from a person group or large person group.
     * <br/> For each face in the faceIds array, Face Identify will compute
     * similarities between the query face and all the faces in the person group
     * (given by personGroupId) or large person group (given by
     * largePersonGroupId), and return candidate person(s) for that face ranked by
     * similarity confidence. The person group/large person group should be trained
     * to make it ready for identification. See more in [PersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249)
     * and [LargePersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4).
     * <br/>
     *
     * Remarks:<br />
     * * The algorithm allows more than one face to be identified independently at
     * the same request, but no more than 10 faces.
     * * Each person in the person group/large person group could have more than
     * one face, but no more than 248 faces.
     * * Higher face image quality means better identification precision. Please
     * consider high-quality faces: frontal, clear, and face size is 200x200 pixels
     * (100 pixels between eyes) or bigger.
     * * Number of candidates returned is restricted by maxNumOfCandidatesReturned
     * and confidenceThreshold. If no person is identified, the returned candidates
     * will be an empty array.
     * * Try [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237)
     * when you need to find similar faces from a face list/large face list instead
     * of a person group/large person group.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same as the 'recognitionModel' used by the target person group or large
     * person group.
     *
     *
     * @param {array} faceIds Array of query faces faceIds, created by the Face -
     * Detect. Each of the faces are identified independently. The valid number of
     * faceIds is between [1, 10].
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.personGroupId] PersonGroupId of the target person
     * group, created by PersonGroup - Create. Parameter personGroupId and
     * largePersonGroupId should not be provided at the same time.
     *
     * @param {string} [options.largePersonGroupId] LargePersonGroupId of the
     * target large person group, created by LargePersonGroup - Create. Parameter
     * personGroupId and largePersonGroupId should not be provided at the same
     * time.
     *
     * @param {number} [options.maxNumOfCandidatesReturned] The range of
     * maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
     *
     * @param {number} [options.confidenceThreshold] Confidence threshold of
     * identification, used to judge whether one face belong to one person. The
     * range of confidenceThreshold is [0, 1] (default specified by algorithm).
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    identifyWithHttpOperationResponse(faceIds: string[], options?: { personGroupId? : string, largePersonGroupId? : string, maxNumOfCandidatesReturned? : number, confidenceThreshold? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.IdentifyResult[]>>;

    /**
     * 1-to-many identification to find the closest matches of the specific query
     * person face from a person group or large person group.
     * <br/> For each face in the faceIds array, Face Identify will compute
     * similarities between the query face and all the faces in the person group
     * (given by personGroupId) or large person group (given by
     * largePersonGroupId), and return candidate person(s) for that face ranked by
     * similarity confidence. The person group/large person group should be trained
     * to make it ready for identification. See more in [PersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249)
     * and [LargePersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4).
     * <br/>
     *
     * Remarks:<br />
     * * The algorithm allows more than one face to be identified independently at
     * the same request, but no more than 10 faces.
     * * Each person in the person group/large person group could have more than
     * one face, but no more than 248 faces.
     * * Higher face image quality means better identification precision. Please
     * consider high-quality faces: frontal, clear, and face size is 200x200 pixels
     * (100 pixels between eyes) or bigger.
     * * Number of candidates returned is restricted by maxNumOfCandidatesReturned
     * and confidenceThreshold. If no person is identified, the returned candidates
     * will be an empty array.
     * * Try [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237)
     * when you need to find similar faces from a face list/large face list instead
     * of a person group/large person group.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same as the 'recognitionModel' used by the target person group or large
     * person group.
     *
     *
     * @param {array} faceIds Array of query faces faceIds, created by the Face -
     * Detect. Each of the faces are identified independently. The valid number of
     * faceIds is between [1, 10].
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.personGroupId] PersonGroupId of the target person
     * group, created by PersonGroup - Create. Parameter personGroupId and
     * largePersonGroupId should not be provided at the same time.
     *
     * @param {string} [options.largePersonGroupId] LargePersonGroupId of the
     * target large person group, created by LargePersonGroup - Create. Parameter
     * personGroupId and largePersonGroupId should not be provided at the same
     * time.
     *
     * @param {number} [options.maxNumOfCandidatesReturned] The range of
     * maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
     *
     * @param {number} [options.confidenceThreshold] Confidence threshold of
     * identification, used to judge whether one face belong to one person. The
     * range of confidenceThreshold is [0, 1] (default specified by algorithm).
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    identify(faceIds: string[], options?: { personGroupId? : string, largePersonGroupId? : string, maxNumOfCandidatesReturned? : number, confidenceThreshold? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.IdentifyResult[]>;
    identify(faceIds: string[], callback: ServiceCallback<models.IdentifyResult[]>): void;
    identify(faceIds: string[], options: { personGroupId? : string, largePersonGroupId? : string, maxNumOfCandidatesReturned? : number, confidenceThreshold? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.IdentifyResult[]>): void;


    /**
     * Verify whether two faces belong to a same person or whether one face belongs
     * to a person.
     * <br/>
     * Remarks:<br />
     * * Higher face image quality means better identification precision. Please
     * consider high-quality faces: frontal, clear, and face size is 200x200 pixels
     * (100 pixels between eyes) or bigger.
     * * For the scenarios that are sensitive to accuracy please make your own
     * judgment.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same as the 'recognitionModel' used by the target face, person group or
     * large person group.
     *
     *
     * @param {uuid} faceId1 FaceId of the first face, comes from Face - Detect
     *
     * @param {uuid} faceId2 FaceId of the second face, comes from Face - Detect
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VerifyResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    verifyFaceToFaceWithHttpOperationResponse(faceId1: string, faceId2: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VerifyResult>>;

    /**
     * Verify whether two faces belong to a same person or whether one face belongs
     * to a person.
     * <br/>
     * Remarks:<br />
     * * Higher face image quality means better identification precision. Please
     * consider high-quality faces: frontal, clear, and face size is 200x200 pixels
     * (100 pixels between eyes) or bigger.
     * * For the scenarios that are sensitive to accuracy please make your own
     * judgment.
     * * The 'recognitionModel' associated with the query faces' faceIds should be
     * the same as the 'recognitionModel' used by the target face, person group or
     * large person group.
     *
     *
     * @param {uuid} faceId1 FaceId of the first face, comes from Face - Detect
     *
     * @param {uuid} faceId2 FaceId of the second face, comes from Face - Detect
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VerifyResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VerifyResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VerifyResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    verifyFaceToFace(faceId1: string, faceId2: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.VerifyResult>;
    verifyFaceToFace(faceId1: string, faceId2: string, callback: ServiceCallback<models.VerifyResult>): void;
    verifyFaceToFace(faceId1: string, faceId2: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VerifyResult>): void;


    /**
     * Detect human faces in an image, return face rectangles, and optionally with
     * faceIds, landmarks, and attributes.<br />
     * * Optional parameters including faceId, landmarks, and attributes.
     * Attributes include age, gender, headPose, smile, facialHair, glasses,
     * emotion, hair, makeup, occlusion, accessories, blur, exposure and noise.
     * * The extracted face feature, instead of the actual image, will be stored on
     * server. The faceId is an identifier of the face feature and will be used in
     * [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239),
     * [Face -
     * Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a),
     * and [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * It will expire 24 hours after the detection call.
     * * Higher face image quality means better detection and recognition
     * precision. Please consider high-quality faces: frontal, clear, and face size
     * is 200x200 pixels (100 pixels between eyes) or bigger.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The
     * allowed image file size is from 1KB to 6MB.
     * * Faces are detectable when its size is 36x36 to 4096x4096 pixels. If need
     * to detect very small but clear faces, please try to enlarge the input image.
     * * Up to 64 faces can be returned for an image. Faces are ranked by face
     * rectangle size from large to small.
     * * Face detector prefer frontal and near-frontal faces. There are cases that
     * faces may not be detected, e.g. exceptionally large face angles (head-pose)
     * or being occluded, or wrong image orientation.
     * * Attributes (age, gender, headPose, smile, facialHair, glasses, emotion,
     * hair, makeup, occlusion, accessories, blur, exposure and noise) may not be
     * perfectly accurate. HeadPose's pitch value is a reserved field and will
     * always return 0.
     * * Different 'recognitionModel' values are provided. If follow-up operations
     * like Verify, Identify, Find Similar are needed, please specify the
     * recognition model with 'recognitionModel' parameter. The default value for
     * 'recognitionModel' is 'recognition_01', if latest model needed, please
     * explicitly specify the model you need in this parameter. Once specified, the
     * detected faceIds will be associated with the specified recognition model.
     * More details, please refer to [How to specify a recognition
     * model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)
     *
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnFaceId] A value indicating whether the
     * operation should return faceIds of detected faces.
     *
     * @param {boolean} [options.returnFaceLandmarks] A value indicating whether
     * the operation should return landmarks of the detected faces.
     *
     * @param {array} [options.returnFaceAttributes] Analyze and return the one or
     * more specified face attributes in the comma-separated string like
     * "returnFaceAttributes=age,gender". Supported face attributes include age,
     * gender, headPose, smile, facialHair, glasses and emotion. Note that each
     * face attribute analysis has additional computational and time cost.
     *
     * @param {string} [options.recognitionModel] Name of recognition model.
     * Recognition model is used when the face features are extracted and
     * associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A
     * recognition model name can be provided when performing Face - Detect or
     * (Large)FaceList - Create or (Large)PersonGroup - Create. The default value
     * is 'recognition_01', if latest model needed, please explicitly specify the
     * model you need. Possible values include: 'recognition_01', 'recognition_02'
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    detectWithUrlWithHttpOperationResponse(url: string, options?: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DetectedFace[]>>;

    /**
     * Detect human faces in an image, return face rectangles, and optionally with
     * faceIds, landmarks, and attributes.<br />
     * * Optional parameters including faceId, landmarks, and attributes.
     * Attributes include age, gender, headPose, smile, facialHair, glasses,
     * emotion, hair, makeup, occlusion, accessories, blur, exposure and noise.
     * * The extracted face feature, instead of the actual image, will be stored on
     * server. The faceId is an identifier of the face feature and will be used in
     * [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239),
     * [Face -
     * Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a),
     * and [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * It will expire 24 hours after the detection call.
     * * Higher face image quality means better detection and recognition
     * precision. Please consider high-quality faces: frontal, clear, and face size
     * is 200x200 pixels (100 pixels between eyes) or bigger.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The
     * allowed image file size is from 1KB to 6MB.
     * * Faces are detectable when its size is 36x36 to 4096x4096 pixels. If need
     * to detect very small but clear faces, please try to enlarge the input image.
     * * Up to 64 faces can be returned for an image. Faces are ranked by face
     * rectangle size from large to small.
     * * Face detector prefer frontal and near-frontal faces. There are cases that
     * faces may not be detected, e.g. exceptionally large face angles (head-pose)
     * or being occluded, or wrong image orientation.
     * * Attributes (age, gender, headPose, smile, facialHair, glasses, emotion,
     * hair, makeup, occlusion, accessories, blur, exposure and noise) may not be
     * perfectly accurate. HeadPose's pitch value is a reserved field and will
     * always return 0.
     * * Different 'recognitionModel' values are provided. If follow-up operations
     * like Verify, Identify, Find Similar are needed, please specify the
     * recognition model with 'recognitionModel' parameter. The default value for
     * 'recognitionModel' is 'recognition_01', if latest model needed, please
     * explicitly specify the model you need in this parameter. Once specified, the
     * detected faceIds will be associated with the specified recognition model.
     * More details, please refer to [How to specify a recognition
     * model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)
     *
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnFaceId] A value indicating whether the
     * operation should return faceIds of detected faces.
     *
     * @param {boolean} [options.returnFaceLandmarks] A value indicating whether
     * the operation should return landmarks of the detected faces.
     *
     * @param {array} [options.returnFaceAttributes] Analyze and return the one or
     * more specified face attributes in the comma-separated string like
     * "returnFaceAttributes=age,gender". Supported face attributes include age,
     * gender, headPose, smile, facialHair, glasses and emotion. Note that each
     * face attribute analysis has additional computational and time cost.
     *
     * @param {string} [options.recognitionModel] Name of recognition model.
     * Recognition model is used when the face features are extracted and
     * associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A
     * recognition model name can be provided when performing Face - Detect or
     * (Large)FaceList - Create or (Large)PersonGroup - Create. The default value
     * is 'recognition_01', if latest model needed, please explicitly specify the
     * model you need. Possible values include: 'recognition_01', 'recognition_02'
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    detectWithUrl(url: string, options?: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.DetectedFace[]>;
    detectWithUrl(url: string, callback: ServiceCallback<models.DetectedFace[]>): void;
    detectWithUrl(url: string, options: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DetectedFace[]>): void;


    /**
     * Verify whether two faces belong to a same person. Compares a face Id with a
     * Person Id
     *
     * @param {uuid} faceId FaceId of the face, comes from Face - Detect
     *
     * @param {uuid} personId Specify a certain person in a person group or a large
     * person group. personId is created in PersonGroup Person - Create or
     * LargePersonGroup Person - Create.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.personGroupId] Using existing personGroupId and
     * personId for fast loading a specified person. personGroupId is created in
     * PersonGroup - Create. Parameter personGroupId and largePersonGroupId should
     * not be provided at the same time.
     *
     * @param {string} [options.largePersonGroupId] Using existing
     * largePersonGroupId and personId for fast loading a specified person.
     * largePersonGroupId is created in LargePersonGroup - Create. Parameter
     * personGroupId and largePersonGroupId should not be provided at the same
     * time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<VerifyResult>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    verifyFaceToPersonWithHttpOperationResponse(faceId: string, personId: string, options?: { personGroupId? : string, largePersonGroupId? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.VerifyResult>>;

    /**
     * Verify whether two faces belong to a same person. Compares a face Id with a
     * Person Id
     *
     * @param {uuid} faceId FaceId of the face, comes from Face - Detect
     *
     * @param {uuid} personId Specify a certain person in a person group or a large
     * person group. personId is created in PersonGroup Person - Create or
     * LargePersonGroup Person - Create.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.personGroupId] Using existing personGroupId and
     * personId for fast loading a specified person. personGroupId is created in
     * PersonGroup - Create. Parameter personGroupId and largePersonGroupId should
     * not be provided at the same time.
     *
     * @param {string} [options.largePersonGroupId] Using existing
     * largePersonGroupId and personId for fast loading a specified person.
     * largePersonGroupId is created in LargePersonGroup - Create. Parameter
     * personGroupId and largePersonGroupId should not be provided at the same
     * time.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {VerifyResult} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {VerifyResult} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link VerifyResult} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    verifyFaceToPerson(faceId: string, personId: string, options?: { personGroupId? : string, largePersonGroupId? : string, customHeaders? : { [headerName: string]: string; } }): Promise<models.VerifyResult>;
    verifyFaceToPerson(faceId: string, personId: string, callback: ServiceCallback<models.VerifyResult>): void;
    verifyFaceToPerson(faceId: string, personId: string, options: { personGroupId? : string, largePersonGroupId? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.VerifyResult>): void;


    /**
     * Detect human faces in an image and returns face locations, and optionally
     * with faceIds, landmarks, and attributes.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnFaceId] A value indicating whether the
     * operation should return faceIds of detected faces.
     *
     * @param {boolean} [options.returnFaceLandmarks] A value indicating whether
     * the operation should return landmarks of the detected faces.
     *
     * @param {array} [options.returnFaceAttributes] Analyze and return the one or
     * more specified face attributes in the comma-separated string like
     * "returnFaceAttributes=age,gender". Supported face attributes include age,
     * gender, headPose, smile, facialHair, glasses and emotion. Note that each
     * face attribute analysis has additional computational and time cost.
     *
     * @param {string} [options.recognitionModel] Name of recognition model.
     * Recognition model is used when the face features are extracted and
     * associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A
     * recognition model name can be provided when performing Face - Detect or
     * (Large)FaceList - Create or (Large)PersonGroup - Create. The default value
     * is 'recognition_01', if latest model needed, please explicitly specify the
     * model you need. Possible values include: 'recognition_01', 'recognition_02'
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    detectWithStreamWithHttpOperationResponse(image: stream.Readable, options?: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.DetectedFace[]>>;

    /**
     * Detect human faces in an image and returns face locations, and optionally
     * with faceIds, landmarks, and attributes.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnFaceId] A value indicating whether the
     * operation should return faceIds of detected faces.
     *
     * @param {boolean} [options.returnFaceLandmarks] A value indicating whether
     * the operation should return landmarks of the detected faces.
     *
     * @param {array} [options.returnFaceAttributes] Analyze and return the one or
     * more specified face attributes in the comma-separated string like
     * "returnFaceAttributes=age,gender". Supported face attributes include age,
     * gender, headPose, smile, facialHair, glasses and emotion. Note that each
     * face attribute analysis has additional computational and time cost.
     *
     * @param {string} [options.recognitionModel] Name of recognition model.
     * Recognition model is used when the face features are extracted and
     * associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A
     * recognition model name can be provided when performing Face - Detect or
     * (Large)FaceList - Create or (Large)PersonGroup - Create. The default value
     * is 'recognition_01', if latest model needed, please explicitly specify the
     * model you need. Possible values include: 'recognition_01', 'recognition_02'
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    detectWithStream(image: stream.Readable, options?: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.DetectedFace[]>;
    detectWithStream(image: stream.Readable, callback: ServiceCallback<models.DetectedFace[]>): void;
    detectWithStream(image: stream.Readable, options: { returnFaceId? : boolean, returnFaceLandmarks? : boolean, returnFaceAttributes? : string[], recognitionModel? : string, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.DetectedFace[]>): void;
}

/**
 * @class
 * PersonGroupPerson
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface PersonGroupPerson {


    /**
     * Create a new person in a specified person group.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Person>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(personGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person>>;

    /**
     * Create a new person in a specified person group.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Person} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Person} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Person} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(personGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<models.Person>;
    create(personGroupId: string, callback: ServiceCallback<models.Person>): void;
    create(personGroupId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person>): void;


    /**
     * List all persons in a person group, and retrieve person information
     * (including personId, name, userData and persistedFaceIds of registered faces
     * of the person).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting person id to return (used to list a
     * range of persons).
     *
     * @param {number} [options.top] Number of persons to return starting with the
     * person id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(personGroupId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person[]>>;

    /**
     * List all persons in a person group, and retrieve person information
     * (including personId, name, userData and persistedFaceIds of registered faces
     * of the person).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting person id to return (used to list a
     * range of persons).
     *
     * @param {number} [options.top] Number of persons to return starting with the
     * person id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(personGroupId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.Person[]>;
    list(personGroupId: string, callback: ServiceCallback<models.Person[]>): void;
    list(personGroupId: string, options: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person[]>): void;


    /**
     * Delete an existing person from a person group. All stored person data, and
     * face features in the person entry will be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(personGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing person from a person group. All stored person data, and
     * face features in the person entry will be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(personGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(personGroupId: string, personId: string, callback: ServiceCallback<void>): void;
    deleteMethod(personGroupId: string, personId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve a person's information, including registered persisted faces, name
     * and userData.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Person>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(personGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person>>;

    /**
     * Retrieve a person's information, including registered persisted faces, name
     * and userData.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Person} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Person} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Person} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(personGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Person>;
    get(personGroupId: string, personId: string, callback: ServiceCallback<models.Person>): void;
    get(personGroupId: string, personId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person>): void;


    /**
     * Update name or userData of a person.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(personGroupId: string, personId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update name or userData of a person.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(personGroupId: string, personId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(personGroupId: string, personId: string, callback: ServiceCallback<void>): void;
    update(personGroupId: string, personId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete a face from a person. Relative feature for the persisted face will
     * also be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFaceWithHttpOperationResponse(personGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete a face from a person. Relative feature for the persisted face will
     * also be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteFace(personGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteFace(personGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    deleteFace(personGroupId: string, personId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve information about a persisted face (specified by persistedFaceId,
     * personId and its belonging personGroupId).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFaceWithHttpOperationResponse(personGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Retrieve information about a persisted face (specified by persistedFaceId,
     * personId and its belonging personGroupId).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getFace(personGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    getFace(personGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<models.PersistedFace>): void;
    getFace(personGroupId: string, personId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Update a person persisted face's userData field.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateFaceWithHttpOperationResponse(personGroupId: string, personId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update a person persisted face's userData field.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    updateFace(personGroupId: string, personId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    updateFace(personGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    updateFace(personGroupId: string, personId: string, persistedFaceId: string, options: { userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromUrlWithHttpOperationResponse(personGroupId: string, personId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromUrl(personGroupId: string, personId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromUrl(personGroupId: string, personId: string, url: string, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromUrl(personGroupId: string, personId: string, url: string, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromStreamWithHttpOperationResponse(personGroupId: string, personId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromStream(personGroupId: string, personId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromStream(personGroupId: string, personId: string, image: stream.Readable, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromStream(personGroupId: string, personId: string, image: stream.Readable, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;
}

/**
 * @class
 * PersonGroupOperations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface PersonGroupOperations {


    /**
     * Create a new person group with specified personGroupId, name, user-provided
     * userData and recognitionModel.
     * <br /> A person group is the container of the uploaded person data,
     * including face images and face recognition features.
     * <br /> After creation, use [PersonGroup Person -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c)
     * to add persons into the group, and then call [PersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249)
     * to get this group ready for [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> The person's face, image, and userData will be stored on server until
     * [PersonGroup Person -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d)
     * or [PersonGroup -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245)
     * is called.
     * <br />
     * * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000
     * persons.
     * * S0-tier subscription quota: 1,000,000 person groups. Each holds up to
     * 10,000 persons.
     * * to handle larger scale face identification problem, please consider using
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     * <br />
     * 'recognitionModel' should be specified to associate with this person group.
     * The default value for 'recognitionModel' is 'recognition_01', if the latest
     * model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing person group will use the
     * recognition model that's already associated with the collection. Existing
     * face features in a person group can't be updated to features extracted by
     * another version of recognition model.
     *
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(personGroupId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Create a new person group with specified personGroupId, name, user-provided
     * userData and recognitionModel.
     * <br /> A person group is the container of the uploaded person data,
     * including face images and face recognition features.
     * <br /> After creation, use [PersonGroup Person -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c)
     * to add persons into the group, and then call [PersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249)
     * to get this group ready for [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> The person's face, image, and userData will be stored on server until
     * [PersonGroup Person -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d)
     * or [PersonGroup -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245)
     * is called.
     * <br />
     * * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000
     * persons.
     * * S0-tier subscription quota: 1,000,000 person groups. Each holds up to
     * 10,000 persons.
     * * to handle larger scale face identification problem, please consider using
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     * <br />
     * 'recognitionModel' should be specified to associate with this person group.
     * The default value for 'recognitionModel' is 'recognition_01', if the latest
     * model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing person group will use the
     * recognition model that's already associated with the collection. Existing
     * face features in a person group can't be updated to features extracted by
     * another version of recognition model.
     *
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(personGroupId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    create(personGroupId: string, callback: ServiceCallback<void>): void;
    create(personGroupId: string, options: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing person group. Persisted face features of all people in
     * the person group will also be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing person group. Persisted face features of all people in
     * the person group will also be deleted.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(personGroupId: string, callback: ServiceCallback<void>): void;
    deleteMethod(personGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve person group name, userData and recognitionModel. To get person
     * information under this personGroup, use [PersonGroup Person -
     * List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersonGroup>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(personGroupId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersonGroup>>;

    /**
     * Retrieve person group name, userData and recognitionModel. To get person
     * information under this personGroup, use [PersonGroup Person -
     * List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersonGroup} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersonGroup} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersonGroup} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(personGroupId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.PersonGroup>;
    get(personGroupId: string, callback: ServiceCallback<models.PersonGroup>): void;
    get(personGroupId: string, options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersonGroup>): void;


    /**
     * Update an existing person group's display name and userData. The properties
     * which does not appear in request body will not be updated.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(personGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update an existing person group's display name and userData. The properties
     * which does not appear in request body will not be updated.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(personGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(personGroupId: string, callback: ServiceCallback<void>): void;
    update(personGroupId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<TrainingStatus>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTrainingStatusWithHttpOperationResponse(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.TrainingStatus>>;

    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {TrainingStatus} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {TrainingStatus} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link TrainingStatus} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getTrainingStatus(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.TrainingStatus>;
    getTrainingStatus(personGroupId: string, callback: ServiceCallback<models.TrainingStatus>): void;
    getTrainingStatus(personGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.TrainingStatus>): void;


    /**
     * List person groups’ personGroupId, name, userData and recognitionModel.<br
     * />
     * * Person groups are stored in alphabetical order of personGroupId.
     * * "start" parameter (string, optional) is a user-provided personGroupId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 person groups: "group1", ..., "group5".
     * <br /> "start=&top=" will return all 5 groups.
     * <br /> "start=&top=2" will return "group1", "group2".
     * <br /> "start=group2&top=3" will return "group3", "group4", "group5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] List person groups from the least
     * personGroupId greater than the "start".
     *
     * @param {number} [options.top] The number of person groups to list.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersonGroup[]>>;

    /**
     * List person groups’ personGroupId, name, userData and recognitionModel.<br
     * />
     * * Person groups are stored in alphabetical order of personGroupId.
     * * "start" parameter (string, optional) is a user-provided personGroupId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 person groups: "group1", ..., "group5".
     * <br /> "start=&top=" will return all 5 groups.
     * <br /> "start=&top=2" will return "group1", "group2".
     * <br /> "start=group2&top=3" will return "group3", "group4", "group5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] List person groups from the least
     * personGroupId greater than the "start".
     *
     * @param {number} [options.top] The number of person groups to list.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.PersonGroup[]>;
    list(callback: ServiceCallback<models.PersonGroup[]>): void;
    list(options: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersonGroup[]>): void;


    /**
     * Queue a person group training task, the training task may not be started
     * immediately.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    trainWithHttpOperationResponse(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Queue a person group training task, the training task may not be started
     * immediately.
     *
     * @param {string} personGroupId Id referencing a particular person group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    train(personGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    train(personGroupId: string, callback: ServiceCallback<void>): void;
    train(personGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;
}

/**
 * @class
 * FaceListOperations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface FaceListOperations {


    /**
     * Create an empty face list with user-specified faceListId, name, an optional
     * userData and recognitionModel. Up to 64 face lists are allowed in one
     * subscription.
     * <br /> Face list is a list of faces, up to 1,000 faces, and used by [Face -
     * Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * <br /> After creation, user should use [FaceList - Add
     * Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250)
     * to import the faces. Faces are stored on server until [FaceList -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f)
     * is called.
     * <br /> Find Similar is used for scenario like finding celebrity-like faces,
     * similar face filtering, or as a light way face identification. But if the
     * actual use is to identify person, please use
     * [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244)
     * /
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d)
     * and [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> Please consider
     * [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc)
     * when the face number is large. It can support up to 1,000,000 faces.
     * 'recognitionModel' should be specified to associate with this face list. The
     * default value for 'recognitionModel' is 'recognition_01', if the latest
     * model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing face list will use the
     * recognition model that's already associated with the collection. Existing
     * face features in a face list can't be updated to features extracted by
     * another version of recognition model.
     *
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(faceListId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Create an empty face list with user-specified faceListId, name, an optional
     * userData and recognitionModel. Up to 64 face lists are allowed in one
     * subscription.
     * <br /> Face list is a list of faces, up to 1,000 faces, and used by [Face -
     * Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * <br /> After creation, user should use [FaceList - Add
     * Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250)
     * to import the faces. Faces are stored on server until [FaceList -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f)
     * is called.
     * <br /> Find Similar is used for scenario like finding celebrity-like faces,
     * similar face filtering, or as a light way face identification. But if the
     * actual use is to identify person, please use
     * [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244)
     * /
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d)
     * and [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> Please consider
     * [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc)
     * when the face number is large. It can support up to 1,000,000 faces.
     * 'recognitionModel' should be specified to associate with this face list. The
     * default value for 'recognitionModel' is 'recognition_01', if the latest
     * model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing face list will use the
     * recognition model that's already associated with the collection. Existing
     * face features in a face list can't be updated to features extracted by
     * another version of recognition model.
     *
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(faceListId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    create(faceListId: string, callback: ServiceCallback<void>): void;
    create(faceListId: string, options: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve a face list’s faceListId, name, userData, recognitionModel and
     * faces in the face list.
     *
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<FaceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(faceListId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.FaceList>>;

    /**
     * Retrieve a face list’s faceListId, name, userData, recognitionModel and
     * faces in the face list.
     *
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {FaceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {FaceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link FaceList} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(faceListId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.FaceList>;
    get(faceListId: string, callback: ServiceCallback<models.FaceList>): void;
    get(faceListId: string, options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.FaceList>): void;


    /**
     * Update information of a face list.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(faceListId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update information of a face list.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(faceListId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(faceListId: string, callback: ServiceCallback<void>): void;
    update(faceListId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing face list according to faceListId. Persisted face images
     * in the face list will also be deleted.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(faceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing face list according to faceListId. Persisted face images
     * in the face list will also be deleted.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(faceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(faceListId: string, callback: ServiceCallback<void>): void;
    deleteMethod(faceListId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * List face lists’ faceListId, name, userData and recognitionModel. <br />
     * To get face information inside faceList use [FaceList -
     * Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c)
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.FaceList[]>>;

    /**
     * List face lists’ faceListId, name, userData and recognitionModel. <br />
     * To get face information inside faceList use [FaceList -
     * Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c)
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.FaceList[]>;
    list(callback: ServiceCallback<models.FaceList[]>): void;
    list(options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.FaceList[]>): void;


    /**
     * Delete an existing face from a face list (given by a persistedFaceId and a
     * faceListId). Persisted image related to the face will also be deleted.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFaceWithHttpOperationResponse(faceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing face from a face list (given by a persistedFaceId and a
     * faceListId). Persisted image related to the face will also be deleted.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteFace(faceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteFace(faceListId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    deleteFace(faceListId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Add a face to a face list. The input face is specified as an image with a
     * targetFace rectangle. It returns a persistedFaceId representing the added
     * face, and persistedFaceId will not expire.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromUrlWithHttpOperationResponse(faceListId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a face to a face list. The input face is specified as an image with a
     * targetFace rectangle. It returns a persistedFaceId representing the added
     * face, and persistedFaceId will not expire.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromUrl(faceListId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromUrl(faceListId: string, url: string, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromUrl(faceListId: string, url: string, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Add a face to a face list. The input face is specified as an image with a
     * targetFace rectangle. It returns a persistedFaceId representing the added
     * face, and persistedFaceId will not expire.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromStreamWithHttpOperationResponse(faceListId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a face to a face list. The input face is specified as an image with a
     * targetFace rectangle. It returns a persistedFaceId representing the added
     * face, and persistedFaceId will not expire.
     *
     * @param {string} faceListId Id referencing a particular face list.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromStream(faceListId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromStream(faceListId: string, image: stream.Readable, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromStream(faceListId: string, image: stream.Readable, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;
}

/**
 * @class
 * LargePersonGroupPerson
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface LargePersonGroupPerson {


    /**
     * Create a new person in a specified large person group.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Person>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(largePersonGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person>>;

    /**
     * Create a new person in a specified large person group.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Person} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Person} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Person} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(largePersonGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<models.Person>;
    create(largePersonGroupId: string, callback: ServiceCallback<models.Person>): void;
    create(largePersonGroupId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person>): void;


    /**
     * List all persons in a large person group, and retrieve person information
     * (including personId, name, userData and persistedFaceIds of registered faces
     * of the person).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting person id to return (used to list a
     * range of persons).
     *
     * @param {number} [options.top] Number of persons to return starting with the
     * person id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(largePersonGroupId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person[]>>;

    /**
     * List all persons in a large person group, and retrieve person information
     * (including personId, name, userData and persistedFaceIds of registered faces
     * of the person).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting person id to return (used to list a
     * range of persons).
     *
     * @param {number} [options.top] Number of persons to return starting with the
     * person id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(largePersonGroupId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.Person[]>;
    list(largePersonGroupId: string, callback: ServiceCallback<models.Person[]>): void;
    list(largePersonGroupId: string, options: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person[]>): void;


    /**
     * Delete an existing person from a large person group. All stored person data,
     * and face features in the person entry will be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(largePersonGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing person from a large person group. All stored person data,
     * and face features in the person entry will be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(largePersonGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(largePersonGroupId: string, personId: string, callback: ServiceCallback<void>): void;
    deleteMethod(largePersonGroupId: string, personId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve a person's information, including registered persisted faces, name
     * and userData.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Person>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(largePersonGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Person>>;

    /**
     * Retrieve a person's information, including registered persisted faces, name
     * and userData.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Person} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Person} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Person} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(largePersonGroupId: string, personId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Person>;
    get(largePersonGroupId: string, personId: string, callback: ServiceCallback<models.Person>): void;
    get(largePersonGroupId: string, personId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Person>): void;


    /**
     * Update name or userData of a person.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(largePersonGroupId: string, personId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update name or userData of a person.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(largePersonGroupId: string, personId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(largePersonGroupId: string, personId: string, callback: ServiceCallback<void>): void;
    update(largePersonGroupId: string, personId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete a face from a person. Relative feature for the persisted face will
     * also be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFaceWithHttpOperationResponse(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete a face from a person. Relative feature for the persisted face will
     * also be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteFace(largePersonGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    deleteFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve information about a persisted face (specified by persistedFaceId,
     * personId and its belonging largePersonGroupId).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFaceWithHttpOperationResponse(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Retrieve information about a persisted face (specified by persistedFaceId,
     * personId and its belonging largePersonGroupId).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    getFace(largePersonGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<models.PersistedFace>): void;
    getFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Update a person persisted face's userData field.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateFaceWithHttpOperationResponse(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update a person persisted face's userData field.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    updateFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    updateFace(largePersonGroupId: string, personId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    updateFace(largePersonGroupId: string, personId: string, persistedFaceId: string, options: { userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromUrlWithHttpOperationResponse(largePersonGroupId: string, personId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromUrl(largePersonGroupId: string, personId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromUrl(largePersonGroupId: string, personId: string, url: string, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromUrl(largePersonGroupId: string, personId: string, url: string, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromStreamWithHttpOperationResponse(largePersonGroupId: string, personId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a representative face to a person for identification. The input face is
     * specified as an image with a targetFace rectangle.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {uuid} personId Id referencing a particular person.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromStream(largePersonGroupId: string, personId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromStream(largePersonGroupId: string, personId: string, image: stream.Readable, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromStream(largePersonGroupId: string, personId: string, image: stream.Readable, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;
}

/**
 * @class
 * LargePersonGroupOperations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface LargePersonGroupOperations {


    /**
     * Create a new large person group with user-specified largePersonGroupId,
     * name, an optional userData and recognitionModel.
     * <br /> A large person group is the container of the uploaded person data,
     * including face images and face recognition feature, and up to 1,000,000
     * people.
     * <br /> After creation, use [LargePersonGroup Person -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40)
     * to add person into the group, and call [LargePersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4)
     * to get this group ready for [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> The person face, image, and userData will be stored on server until
     * [LargePersonGroup Person -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2)
     * or [LargePersonGroup -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f)
     * is called.
     * <br />
     * * Free-tier subscription quota: 1,000 large person groups.
     * * S0-tier subscription quota: 1,000,000 large person groups.
     * <br />
     * 'recognitionModel' should be specified to associate with this large person
     * group. The default value for 'recognitionModel' is 'recognition_01', if the
     * latest model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing large person group will
     * use the recognition model that's already associated with the collection.
     * Existing face features in a large person group can't be updated to features
     * extracted by another version of recognition model.
     *
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(largePersonGroupId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Create a new large person group with user-specified largePersonGroupId,
     * name, an optional userData and recognitionModel.
     * <br /> A large person group is the container of the uploaded person data,
     * including face images and face recognition feature, and up to 1,000,000
     * people.
     * <br /> After creation, use [LargePersonGroup Person -
     * Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40)
     * to add person into the group, and call [LargePersonGroup -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4)
     * to get this group ready for [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br /> The person face, image, and userData will be stored on server until
     * [LargePersonGroup Person -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2)
     * or [LargePersonGroup -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f)
     * is called.
     * <br />
     * * Free-tier subscription quota: 1,000 large person groups.
     * * S0-tier subscription quota: 1,000,000 large person groups.
     * <br />
     * 'recognitionModel' should be specified to associate with this large person
     * group. The default value for 'recognitionModel' is 'recognition_01', if the
     * latest model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing large person group will
     * use the recognition model that's already associated with the collection.
     * Existing face features in a large person group can't be updated to features
     * extracted by another version of recognition model.
     *
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(largePersonGroupId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    create(largePersonGroupId: string, callback: ServiceCallback<void>): void;
    create(largePersonGroupId: string, options: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing large person group. Persisted face features of all people
     * in the large person group will also be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing large person group. Persisted face features of all people
     * in the large person group will also be deleted.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(largePersonGroupId: string, callback: ServiceCallback<void>): void;
    deleteMethod(largePersonGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve the information of a large person group, including its name,
     * userData and recognitionModel. This API returns large person group
     * information only, use [LargePersonGroup Person -
     * List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1)
     * instead to retrieve person information under the large person group.
     *
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<LargePersonGroup>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(largePersonGroupId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.LargePersonGroup>>;

    /**
     * Retrieve the information of a large person group, including its name,
     * userData and recognitionModel. This API returns large person group
     * information only, use [LargePersonGroup Person -
     * List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1)
     * instead to retrieve person information under the large person group.
     *
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {LargePersonGroup} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {LargePersonGroup} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link LargePersonGroup} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(largePersonGroupId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.LargePersonGroup>;
    get(largePersonGroupId: string, callback: ServiceCallback<models.LargePersonGroup>): void;
    get(largePersonGroupId: string, options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.LargePersonGroup>): void;


    /**
     * Update an existing large person group's display name and userData. The
     * properties which does not appear in request body will not be updated.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(largePersonGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update an existing large person group's display name and userData. The
     * properties which does not appear in request body will not be updated.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(largePersonGroupId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(largePersonGroupId: string, callback: ServiceCallback<void>): void;
    update(largePersonGroupId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<TrainingStatus>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTrainingStatusWithHttpOperationResponse(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.TrainingStatus>>;

    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {TrainingStatus} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {TrainingStatus} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link TrainingStatus} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getTrainingStatus(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.TrainingStatus>;
    getTrainingStatus(largePersonGroupId: string, callback: ServiceCallback<models.TrainingStatus>): void;
    getTrainingStatus(largePersonGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.TrainingStatus>): void;


    /**
     * List all existing large person groups’ largePersonGroupId, name, userData
     * and recognitionModel.<br />
     * * Large person groups are stored in alphabetical order of
     * largePersonGroupId.
     * * "start" parameter (string, optional) is a user-provided largePersonGroupId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 large person groups: "group1", ..., "group5".
     * <br /> "start=&top=" will return all 5 groups.
     * <br /> "start=&top=2" will return "group1", "group2".
     * <br /> "start=group2&top=3" will return "group3", "group4", "group5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] List large person groups from the least
     * largePersonGroupId greater than the "start".
     *
     * @param {number} [options.top] The number of large person groups to list.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.LargePersonGroup[]>>;

    /**
     * List all existing large person groups’ largePersonGroupId, name, userData
     * and recognitionModel.<br />
     * * Large person groups are stored in alphabetical order of
     * largePersonGroupId.
     * * "start" parameter (string, optional) is a user-provided largePersonGroupId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 large person groups: "group1", ..., "group5".
     * <br /> "start=&top=" will return all 5 groups.
     * <br /> "start=&top=2" will return "group1", "group2".
     * <br /> "start=group2&top=3" will return "group3", "group4", "group5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] List large person groups from the least
     * largePersonGroupId greater than the "start".
     *
     * @param {number} [options.top] The number of large person groups to list.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.LargePersonGroup[]>;
    list(callback: ServiceCallback<models.LargePersonGroup[]>): void;
    list(options: { start? : string, top? : number, returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.LargePersonGroup[]>): void;


    /**
     * Queue a large person group training task, the training task may not be
     * started immediately.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    trainWithHttpOperationResponse(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Queue a large person group training task, the training task may not be
     * started immediately.
     *
     * @param {string} largePersonGroupId Id referencing a particular large person
     * group.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    train(largePersonGroupId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    train(largePersonGroupId: string, callback: ServiceCallback<void>): void;
    train(largePersonGroupId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;
}

/**
 * @class
 * LargeFaceListOperations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface LargeFaceListOperations {


    /**
     * Create an empty large face list with user-specified largeFaceListId, name,
     * an optional userData and recognitionModel.
     * <br /> Large face list is a list of faces, up to 1,000,000 faces, and used
     * by [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * <br /> After creation, user should use [LargeFaceList Face -
     * Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3)
     * to import the faces and [LargeFaceList -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1)
     * to make it ready for [Face -
     * FindSimilar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * Faces are stored on server until [LargeFaceList -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd)
     * is called.
     * <br /> Find Similar is used for scenario like finding celebrity-like faces,
     * similar face filtering, or as a light way face identification. But if the
     * actual use is to identify person, please use
     * [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244)
     * /
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d)
     * and [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br />
     * * Free-tier subscription quota: 64 large face lists.
     * * S0-tier subscription quota: 1,000,000 large face lists.
     * <br />
     * 'recognitionModel' should be specified to associate with this large face
     * list. The default value for 'recognitionModel' is 'recognition_01', if the
     * latest model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing large face list will use
     * the recognition model that's already associated with the collection.
     * Existing face features in a large face list can't be updated to features
     * extracted by another version of recognition model.
     *
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(largeFaceListId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Create an empty large face list with user-specified largeFaceListId, name,
     * an optional userData and recognitionModel.
     * <br /> Large face list is a list of faces, up to 1,000,000 faces, and used
     * by [Face - Find
     * Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * <br /> After creation, user should use [LargeFaceList Face -
     * Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3)
     * to import the faces and [LargeFaceList -
     * Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1)
     * to make it ready for [Face -
     * FindSimilar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
     * Faces are stored on server until [LargeFaceList -
     * Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd)
     * is called.
     * <br /> Find Similar is used for scenario like finding celebrity-like faces,
     * similar face filtering, or as a light way face identification. But if the
     * actual use is to identify person, please use
     * [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244)
     * /
     * [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d)
     * and [Face -
     * Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     * <br />
     * * Free-tier subscription quota: 64 large face lists.
     * * S0-tier subscription quota: 1,000,000 large face lists.
     * <br />
     * 'recognitionModel' should be specified to associate with this large face
     * list. The default value for 'recognitionModel' is 'recognition_01', if the
     * latest model needed, please explicitly specify the model you need in this
     * parameter. New faces that are added to an existing large face list will use
     * the recognition model that's already associated with the collection.
     * Existing face features in a large face list can't be updated to features
     * extracted by another version of recognition model.
     *
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {string} [options.recognitionModel] Possible values include:
     * 'recognition_01', 'recognition_02'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    create(largeFaceListId: string, options?: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    create(largeFaceListId: string, callback: ServiceCallback<void>): void;
    create(largeFaceListId: string, options: { name? : string, userData? : string, recognitionModel? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve a large face list’s largeFaceListId, name, userData and
     * recognitionModel.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<LargeFaceList>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(largeFaceListId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.LargeFaceList>>;

    /**
     * Retrieve a large face list’s largeFaceListId, name, userData and
     * recognitionModel.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {LargeFaceList} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {LargeFaceList} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link LargeFaceList} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(largeFaceListId: string, options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.LargeFaceList>;
    get(largeFaceListId: string, callback: ServiceCallback<models.LargeFaceList>): void;
    get(largeFaceListId: string, options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.LargeFaceList>): void;


    /**
     * Update information of a large face list.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(largeFaceListId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update information of a large face list.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.name] User defined name, maximum length is 128.
     *
     * @param {string} [options.userData] User specified data. Length should not
     * exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(largeFaceListId: string, options?: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(largeFaceListId: string, callback: ServiceCallback<void>): void;
    update(largeFaceListId: string, options: { name? : string, userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing large face list according to faceListId. Persisted face
     * images in the large face list will also be deleted.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing large face list according to faceListId. Persisted face
     * images in the large face list will also be deleted.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(largeFaceListId: string, callback: ServiceCallback<void>): void;
    deleteMethod(largeFaceListId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve the training status of a large face list (completed or ongoing).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<TrainingStatus>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getTrainingStatusWithHttpOperationResponse(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.TrainingStatus>>;

    /**
     * Retrieve the training status of a large face list (completed or ongoing).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {TrainingStatus} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {TrainingStatus} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link TrainingStatus} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getTrainingStatus(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.TrainingStatus>;
    getTrainingStatus(largeFaceListId: string, callback: ServiceCallback<models.TrainingStatus>): void;
    getTrainingStatus(largeFaceListId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.TrainingStatus>): void;


    /**
     * List large face lists’ information of largeFaceListId, name, userData and
     * recognitionModel. <br />
     * To get face information inside largeFaceList use [LargeFaceList Face -
     * Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)<br
     * />
     * * Large face lists are stored in alphabetical order of largeFaceListId.
     * * "start" parameter (string, optional) is a user-provided largeFaceListId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 large person lists: "list1", ..., "list5".
     * <br /> "start=&top=" will return all 5 lists.
     * <br /> "start=&top=2" will return "list1", "list2".
     * <br /> "start=list2&top=3" will return "list3", "list4", "list5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.LargeFaceList[]>>;

    /**
     * List large face lists’ information of largeFaceListId, name, userData and
     * recognitionModel. <br />
     * To get face information inside largeFaceList use [LargeFaceList Face -
     * Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)<br
     * />
     * * Large face lists are stored in alphabetical order of largeFaceListId.
     * * "start" parameter (string, optional) is a user-provided largeFaceListId
     * value that returned entries have larger ids by string comparison. "start"
     * set to empty to indicate return from the first item.
     * * "top" parameter (int, optional) specifies the number of entries to return.
     * A maximal of 1000 entries can be returned in one call. To fetch more, you
     * can specify "start" with the last returned entry’s Id of the current call.
     * <br />
     * For example, total 5 large person lists: "list1", ..., "list5".
     * <br /> "start=&top=" will return all 5 lists.
     * <br /> "start=&top=2" will return "list1", "list2".
     * <br /> "start=list2&top=3" will return "list3", "list4", "list5".
     *
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {boolean} [options.returnRecognitionModel] A value indicating whether
     * the operation should return 'recognitionModel' in response.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<models.LargeFaceList[]>;
    list(callback: ServiceCallback<models.LargeFaceList[]>): void;
    list(options: { returnRecognitionModel? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.LargeFaceList[]>): void;


    /**
     * Queue a large face list training task, the training task may not be started
     * immediately.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    trainWithHttpOperationResponse(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Queue a large face list training task, the training task may not be started
     * immediately.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    train(largeFaceListId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    train(largeFaceListId: string, callback: ServiceCallback<void>): void;
    train(largeFaceListId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing face from a large face list (given by a persistedFaceId
     * and a largeFaceListId). Persisted image related to the face will also be
     * deleted.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteFaceWithHttpOperationResponse(largeFaceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing face from a large face list (given by a persistedFaceId
     * and a largeFaceListId). Persisted image related to the face will also be
     * deleted.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteFace(largeFaceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteFace(largeFaceListId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    deleteFace(largeFaceListId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve information about a persisted face (specified by persistedFaceId
     * and its belonging largeFaceListId).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getFaceWithHttpOperationResponse(largeFaceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Retrieve information about a persisted face (specified by persistedFaceId
     * and its belonging largeFaceListId).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getFace(largeFaceListId: string, persistedFaceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    getFace(largeFaceListId: string, persistedFaceId: string, callback: ServiceCallback<models.PersistedFace>): void;
    getFace(largeFaceListId: string, persistedFaceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * Update a persisted face's userData field.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateFaceWithHttpOperationResponse(largeFaceListId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update a persisted face's userData field.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {uuid} persistedFaceId Id referencing a particular persistedFaceId of
     * an existing face.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-provided data attached to the face.
     * The size limit is 1KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    updateFace(largeFaceListId: string, persistedFaceId: string, options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    updateFace(largeFaceListId: string, persistedFaceId: string, callback: ServiceCallback<void>): void;
    updateFace(largeFaceListId: string, persistedFaceId: string, options: { userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Add a face to a large face list. The input face is specified as an image
     * with a targetFace rectangle. It returns a persistedFaceId representing the
     * added face, and persistedFaceId will not expire.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromUrlWithHttpOperationResponse(largeFaceListId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a face to a large face list. The input face is specified as an image
     * with a targetFace rectangle. It returns a persistedFaceId representing the
     * added face, and persistedFaceId will not expire.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {string} url Publicly reachable URL of an image
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromUrl(largeFaceListId: string, url: string, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromUrl(largeFaceListId: string, url: string, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromUrl(largeFaceListId: string, url: string, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;


    /**
     * List all faces in a large face list, and retrieve face information
     * (including userData and persistedFaceIds of registered faces of the face).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting face id to return (used to list a
     * range of faces).
     *
     * @param {number} [options.top] Number of faces to return starting with the
     * face id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listFacesWithHttpOperationResponse(largeFaceListId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace[]>>;

    /**
     * List all faces in a large face list, and retrieve face information
     * (including userData and persistedFaceIds of registered faces of the face).
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.start] Starting face id to return (used to list a
     * range of faces).
     *
     * @param {number} [options.top] Number of faces to return starting with the
     * face id indicated by the 'start' parameter.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    listFaces(largeFaceListId: string, options?: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace[]>;
    listFaces(largeFaceListId: string, callback: ServiceCallback<models.PersistedFace[]>): void;
    listFaces(largeFaceListId: string, options: { start? : string, top? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace[]>): void;


    /**
     * Add a face to a large face list. The input face is specified as an image
     * with a targetFace rectangle. It returns a persistedFaceId representing the
     * added face, and persistedFaceId will not expire.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<PersistedFace>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    addFaceFromStreamWithHttpOperationResponse(largeFaceListId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.PersistedFace>>;

    /**
     * Add a face to a large face list. The input face is specified as an image
     * with a targetFace rectangle. It returns a persistedFaceId representing the
     * added face, and persistedFaceId will not expire.
     *
     * @param {string} largeFaceListId Id referencing a particular large face list.
     *
     * @param {object} image An image stream.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User-specified data about the face for
     * any purpose. The maximum length is 1KB.
     *
     * @param {array} [options.targetFace] A face rectangle to specify the target
     * face to be added to a person in the format of
     * "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If
     * there is more than one face in the image, targetFace is required to specify
     * which face to add. No targetFace means there is only one face detected in
     * the entire image.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {PersistedFace} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {PersistedFace} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link PersistedFace} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    addFaceFromStream(largeFaceListId: string, image: stream.Readable, options?: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }): Promise<models.PersistedFace>;
    addFaceFromStream(largeFaceListId: string, image: stream.Readable, callback: ServiceCallback<models.PersistedFace>): void;
    addFaceFromStream(largeFaceListId: string, image: stream.Readable, options: { userData? : string, targetFace? : number[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.PersistedFace>): void;
}

/**
 * @class
 * SnapshotOperations
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the FaceClient.
 */
export interface SnapshotOperations {


    /**
     * Submit an operation to take a snapshot of face list, large face list, person
     * group or large person group, with user-specified snapshot type, source
     * object id, apply scope and an optional user data.<br />
     * The snapshot interfaces are for users to backup and restore their face data
     * from one face subscription to another, inside same region or across regions.
     * The workflow contains two phases, user first calls Snapshot - Take to create
     * a copy of the source object and store it as a snapshot, then calls Snapshot
     * - Apply to paste the snapshot to target subscription. The snapshots are
     * stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.<br />
     * Taking snapshot is an asynchronous operation. An operation id can be
     * obtained from the "Operation-Location" field in response header, to be used
     * in OperationStatus - Get for tracking the progress of creating the snapshot.
     * The snapshot id will be included in the "resourceLocation" field in
     * OperationStatus - Get response when the operation status is "succeeded".<br
     * />
     * Snapshot taking time depends on the number of person and face entries in the
     * source object. It could be in seconds, or up to several hours for 1,000,000
     * persons with multiple faces.<br />
     * Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. User can delete the snapshot using Snapshot -
     * Delete by themselves any time before expiration.<br />
     * Taking snapshot for a certain object will not block any other operations
     * against the object. All read-only operations (Get/List and
     * Identify/FindSimilar/Verify) can be conducted as usual. For all writable
     * operations, including Add/Update/Delete the source object or its
     * persons/faces and Train, they are not blocked but not recommended because
     * writable updates may not be reflected on the snapshot during its taking.
     * After snapshot taking is completed, all readable and writable operations can
     * work as normal. Snapshot will also include the training results of the
     * source object, which means target subscription the snapshot applied to does
     * not need re-train the target object before calling Identify/FindSimilar.<br
     * />
     * * Free-tier subscription quota: 100 take operations per month.
     * * S0-tier subscription quota: 100 take operations per day.
     *
     * @param {string} type User specified type for the source object to take
     * snapshot from. Currently FaceList, PersonGroup, LargeFaceList and
     * LargePersonGroup are supported. Possible values include: 'FaceList',
     * 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     *
     * @param {string} objectId User specified source object id to take snapshot
     * from.
     *
     * @param {array} applyScope User specified array of target Face subscription
     * ids for the snapshot. For each snapshot, only subscriptions included in the
     * applyScope of Snapshot - Take can apply it.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User specified data about the snapshot
     * for any purpose. Length should not exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    takeWithHttpOperationResponse(type: string, objectId: string, applyScope: string[], options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Submit an operation to take a snapshot of face list, large face list, person
     * group or large person group, with user-specified snapshot type, source
     * object id, apply scope and an optional user data.<br />
     * The snapshot interfaces are for users to backup and restore their face data
     * from one face subscription to another, inside same region or across regions.
     * The workflow contains two phases, user first calls Snapshot - Take to create
     * a copy of the source object and store it as a snapshot, then calls Snapshot
     * - Apply to paste the snapshot to target subscription. The snapshots are
     * stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.<br />
     * Taking snapshot is an asynchronous operation. An operation id can be
     * obtained from the "Operation-Location" field in response header, to be used
     * in OperationStatus - Get for tracking the progress of creating the snapshot.
     * The snapshot id will be included in the "resourceLocation" field in
     * OperationStatus - Get response when the operation status is "succeeded".<br
     * />
     * Snapshot taking time depends on the number of person and face entries in the
     * source object. It could be in seconds, or up to several hours for 1,000,000
     * persons with multiple faces.<br />
     * Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. User can delete the snapshot using Snapshot -
     * Delete by themselves any time before expiration.<br />
     * Taking snapshot for a certain object will not block any other operations
     * against the object. All read-only operations (Get/List and
     * Identify/FindSimilar/Verify) can be conducted as usual. For all writable
     * operations, including Add/Update/Delete the source object or its
     * persons/faces and Train, they are not blocked but not recommended because
     * writable updates may not be reflected on the snapshot during its taking.
     * After snapshot taking is completed, all readable and writable operations can
     * work as normal. Snapshot will also include the training results of the
     * source object, which means target subscription the snapshot applied to does
     * not need re-train the target object before calling Identify/FindSimilar.<br
     * />
     * * Free-tier subscription quota: 100 take operations per month.
     * * S0-tier subscription quota: 100 take operations per day.
     *
     * @param {string} type User specified type for the source object to take
     * snapshot from. Currently FaceList, PersonGroup, LargeFaceList and
     * LargePersonGroup are supported. Possible values include: 'FaceList',
     * 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     *
     * @param {string} objectId User specified source object id to take snapshot
     * from.
     *
     * @param {array} applyScope User specified array of target Face subscription
     * ids for the snapshot. For each snapshot, only subscriptions included in the
     * applyScope of Snapshot - Take can apply it.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.userData] User specified data about the snapshot
     * for any purpose. Length should not exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    take(type: string, objectId: string, applyScope: string[], options?: { userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    take(type: string, objectId: string, applyScope: string[], callback: ServiceCallback<void>): void;
    take(type: string, objectId: string, applyScope: string[], options: { userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * List all accessible snapshots with related information, including snapshots
     * that were taken by the user, or snapshots to be applied to the user
     * (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.type] User specified object type as a search
     * filter. Possible values include: 'FaceList', 'LargeFaceList',
     * 'LargePersonGroup', 'PersonGroup'
     *
     * @param {array} [options.applyScope] User specified snapshot apply scopes as
     * a search filter. ApplyScope is an array of the target Azure subscription ids
     * for the snapshot, specified by the user who created the snapshot by Snapshot
     * - Take.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options?: { type? : string, applyScope? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Snapshot[]>>;

    /**
     * List all accessible snapshots with related information, including snapshots
     * that were taken by the user, or snapshots to be applied to the user
     * (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.type] User specified object type as a search
     * filter. Possible values include: 'FaceList', 'LargeFaceList',
     * 'LargePersonGroup', 'PersonGroup'
     *
     * @param {array} [options.applyScope] User specified snapshot apply scopes as
     * a search filter. ApplyScope is an array of the target Azure subscription ids
     * for the snapshot, specified by the user who created the snapshot by Snapshot
     * - Take.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Array} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Array} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    list(options?: { type? : string, applyScope? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<models.Snapshot[]>;
    list(callback: ServiceCallback<models.Snapshot[]>): void;
    list(options: { type? : string, applyScope? : string[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Snapshot[]>): void;


    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the
     * source subscription who took it, and target subscriptions included in the
     * applyScope in Snapshot - Take.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<Snapshot>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(snapshotId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.Snapshot>>;

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the
     * source subscription who took it, and target subscriptions included in the
     * applyScope in Snapshot - Take.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {Snapshot} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {Snapshot} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link Snapshot} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    get(snapshotId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.Snapshot>;
    get(snapshotId: string, callback: ServiceCallback<models.Snapshot>): void;
    get(snapshotId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.Snapshot>): void;


    /**
     * Update the information of a snapshot. Only the source subscription who took
     * the snapshot can update the snapshot.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {array} [options.applyScope] Array of the target Face subscription
     * ids for the snapshot, specified by the user who created the snapshot when
     * calling Snapshot - Take. For each snapshot, only subscriptions included in
     * the applyScope of Snapshot - Take can apply it.
     *
     * @param {string} [options.userData] User specified data about the snapshot
     * for any purpose. Length should not exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(snapshotId: string, options?: { applyScope? : string[], userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Update the information of a snapshot. Only the source subscription who took
     * the snapshot can update the snapshot.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {array} [options.applyScope] Array of the target Face subscription
     * ids for the snapshot, specified by the user who created the snapshot when
     * calling Snapshot - Take. For each snapshot, only subscriptions included in
     * the applyScope of Snapshot - Take can apply it.
     *
     * @param {string} [options.userData] User specified data about the snapshot
     * for any purpose. Length should not exceed 16KB.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    update(snapshotId: string, options?: { applyScope? : string[], userData? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    update(snapshotId: string, callback: ServiceCallback<void>): void;
    update(snapshotId: string, options: { applyScope? : string[], userData? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Delete an existing snapshot according to the snapshotId. All object data and
     * information in the snapshot will also be deleted. Only the source
     * subscription who took the snapshot can delete the snapshot. If the user does
     * not delete a snapshot with this API, the snapshot will still be
     * automatically deleted in 48 hours after creation.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(snapshotId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and
     * information in the snapshot will also be deleted. Only the source
     * subscription who took the snapshot can delete the snapshot. If the user does
     * not delete a snapshot with this API, the snapshot will still be
     * automatically deleted in 48 hours after creation.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    deleteMethod(snapshotId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    deleteMethod(snapshotId: string, callback: ServiceCallback<void>): void;
    deleteMethod(snapshotId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Submit an operation to apply a snapshot to current subscription. For each
     * snapshot, only subscriptions included in the applyScope of Snapshot - Take
     * can apply it.<br />
     * The snapshot interfaces are for users to backup and restore their face data
     * from one face subscription to another, inside same region or across regions.
     * The workflow contains two phases, user first calls Snapshot - Take to create
     * a copy of the source object and store it as a snapshot, then calls Snapshot
     * - Apply to paste the snapshot to target subscription. The snapshots are
     * stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.<br />
     * Applying snapshot is an asynchronous operation. An operation id can be
     * obtained from the "Operation-Location" field in response header, to be used
     * in OperationStatus - Get for tracking the progress of applying the snapshot.
     * The target object id will be included in the "resourceLocation" field in
     * OperationStatus - Get response when the operation status is "succeeded".<br
     * />
     * Snapshot applying time depends on the number of person and face entries in
     * the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000
     * persons with multiple faces.<br />
     * Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. So the target subscription is required to apply
     * the snapshot in 48 hours since its creation.<br />
     * Applying a snapshot will not block any other operations against the target
     * object, however it is not recommended because the correctness cannot be
     * guaranteed during snapshot applying. After snapshot applying is completed,
     * all operations towards the target object can work as normal. Snapshot also
     * includes the training results of the source object, which means target
     * subscription the snapshot applied to does not need re-train the target
     * object before calling Identify/FindSimilar.<br />
     * One snapshot can be applied multiple times in parallel, while currently only
     * CreateNew apply mode is supported, which means the apply operation will fail
     * if target subscription already contains an object of same type and using the
     * same objectId. Users can specify the "objectId" in request body to avoid
     * such conflicts.<br />
     * * Free-tier subscription quota: 100 apply operations per month.
     * * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {string} objectId User specified target object id to be created from
     * the snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.mode] Snapshot applying mode. Currently only
     * CreateNew is supported, which means the apply operation will fail if target
     * subscription already contains an object of same type and using the same
     * objectId. Users can specify the "objectId" in request body to avoid such
     * conflicts. Possible values include: 'CreateNew'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<null>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    applyWithHttpOperationResponse(snapshotId: string, objectId: string, options?: { mode? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

    /**
     * Submit an operation to apply a snapshot to current subscription. For each
     * snapshot, only subscriptions included in the applyScope of Snapshot - Take
     * can apply it.<br />
     * The snapshot interfaces are for users to backup and restore their face data
     * from one face subscription to another, inside same region or across regions.
     * The workflow contains two phases, user first calls Snapshot - Take to create
     * a copy of the source object and store it as a snapshot, then calls Snapshot
     * - Apply to paste the snapshot to target subscription. The snapshots are
     * stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.<br />
     * Applying snapshot is an asynchronous operation. An operation id can be
     * obtained from the "Operation-Location" field in response header, to be used
     * in OperationStatus - Get for tracking the progress of applying the snapshot.
     * The target object id will be included in the "resourceLocation" field in
     * OperationStatus - Get response when the operation status is "succeeded".<br
     * />
     * Snapshot applying time depends on the number of person and face entries in
     * the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000
     * persons with multiple faces.<br />
     * Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. So the target subscription is required to apply
     * the snapshot in 48 hours since its creation.<br />
     * Applying a snapshot will not block any other operations against the target
     * object, however it is not recommended because the correctness cannot be
     * guaranteed during snapshot applying. After snapshot applying is completed,
     * all operations towards the target object can work as normal. Snapshot also
     * includes the training results of the source object, which means target
     * subscription the snapshot applied to does not need re-train the target
     * object before calling Identify/FindSimilar.<br />
     * One snapshot can be applied multiple times in parallel, while currently only
     * CreateNew apply mode is supported, which means the apply operation will fail
     * if target subscription already contains an object of same type and using the
     * same objectId. Users can specify the "objectId" in request body to avoid
     * such conflicts.<br />
     * * Free-tier subscription quota: 100 apply operations per month.
     * * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param {uuid} snapshotId Id referencing a particular snapshot.
     *
     * @param {string} objectId User specified target object id to be created from
     * the snapshot.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {string} [options.mode] Snapshot applying mode. Currently only
     * CreateNew is supported, which means the apply operation will fail if target
     * subscription already contains an object of same type and using the same
     * objectId. Users can specify the "objectId" in request body to avoid such
     * conflicts. Possible values include: 'CreateNew'
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {null} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {null} [result]   - The deserialized result object if an error did not occur.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    apply(snapshotId: string, objectId: string, options?: { mode? : string, customHeaders? : { [headerName: string]: string; } }): Promise<void>;
    apply(snapshotId: string, objectId: string, callback: ServiceCallback<void>): void;
    apply(snapshotId: string, objectId: string, options: { mode? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param {uuid} operationId Id referencing a particular take/apply snapshot
     * operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse<OperationStatus>} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getOperationStatusWithHttpOperationResponse(operationId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.OperationStatus>>;

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param {uuid} operationId Id referencing a particular take/apply snapshot
     * operation.
     *
     * @param {object} [options] Optional Parameters.
     *
     * @param {object} [options.customHeaders] Headers that will be added to the
     * request
     *
     * @param {ServiceCallback} [optionalCallback] - The optional callback.
     *
     * @returns {ServiceCallback|Promise} If a callback was passed as the last
     * parameter then it returns the callback else returns a Promise.
     *
     * {Promise} A promise is returned.
     *
     *                      @resolve {OperationStatus} - The deserialized result object.
     *
     *                      @reject {Error|ServiceError} - The error object.
     *
     * {ServiceCallback} optionalCallback(err, result, request, response)
     *
     *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
     *
     *                      {OperationStatus} [result]   - The deserialized result object if an error did not occur.
     *                      See {@link OperationStatus} for more information.
     *
     *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
     *
     *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
     */
    getOperationStatus(operationId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.OperationStatus>;
    getOperationStatus(operationId: string, callback: ServiceCallback<models.OperationStatus>): void;
    getOperationStatus(operationId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.OperationStatus>): void;
}
