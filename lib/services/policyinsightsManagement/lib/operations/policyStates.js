/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * Queries policy states for the resources under the management group.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} managementGroupName Management group name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForManagementGroup(policyStatesResource, managementGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let managementGroupsNamespace = 'Microsoft.Management';
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (managementGroupName === null || managementGroupName === undefined || typeof managementGroupName.valueOf() !== 'string') {
      throw new Error('managementGroupName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{managementGroupsNamespace}', encodeURIComponent(managementGroupsNamespace));
  requestUrl = requestUrl.replace('{managementGroupName}', encodeURIComponent(managementGroupName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the resources under the management group.
 *
 * @param {string} managementGroupName Management group name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForManagementGroup(managementGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  let managementGroupsNamespace = 'Microsoft.Management';
  // Validate
  try {
    if (managementGroupName === null || managementGroupName === undefined || typeof managementGroupName.valueOf() !== 'string') {
      throw new Error('managementGroupName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{managementGroupsNamespace}', encodeURIComponent(managementGroupsNamespace));
  requestUrl = requestUrl.replace('{managementGroupName}', encodeURIComponent(managementGroupName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the resources under the subscription.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForSubscription(policyStatesResource, subscriptionId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the resources under the subscription.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForSubscription(subscriptionId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the resources under the resource group.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} resourceGroupName Resource group name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForResourceGroup(policyStatesResource, subscriptionId, resourceGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the resources under the resource group.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} resourceGroupName Resource group name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForResourceGroup(subscriptionId, resourceGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the resource.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} resourceId Resource ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForResource(policyStatesResource, resourceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (resourceId === null || resourceId === undefined || typeof resourceId.valueOf() !== 'string') {
      throw new Error('resourceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{resourceId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{resourceId}', resourceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the resource.
 *
 * @param {string} resourceId Resource ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForResource(resourceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  // Validate
  try {
    if (resourceId === null || resourceId === undefined || typeof resourceId.valueOf() !== 'string') {
      throw new Error('resourceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{resourceId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{resourceId}', resourceId);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the subscription level policy set definition.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policySetDefinitionName Policy set definition name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForPolicySetDefinition(policyStatesResource, subscriptionId, policySetDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policySetDefinitionName === null || policySetDefinitionName === undefined || typeof policySetDefinitionName.valueOf() !== 'string') {
      throw new Error('policySetDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policySetDefinitionName}', encodeURIComponent(policySetDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the subscription level policy set definition.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policySetDefinitionName Policy set definition name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForPolicySetDefinition(subscriptionId, policySetDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policySetDefinitionName === null || policySetDefinitionName === undefined || typeof policySetDefinitionName.valueOf() !== 'string') {
      throw new Error('policySetDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policySetDefinitionName}', encodeURIComponent(policySetDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the subscription level policy definition.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policyDefinitionName Policy definition name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForPolicyDefinition(policyStatesResource, subscriptionId, policyDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policyDefinitionName === null || policyDefinitionName === undefined || typeof policyDefinitionName.valueOf() !== 'string') {
      throw new Error('policyDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyDefinitionName}', encodeURIComponent(policyDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the subscription level policy definition.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policyDefinitionName Policy definition name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForPolicyDefinition(subscriptionId, policyDefinitionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policyDefinitionName === null || policyDefinitionName === undefined || typeof policyDefinitionName.valueOf() !== 'string') {
      throw new Error('policyDefinitionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyDefinitionName}', encodeURIComponent(policyDefinitionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the subscription level policy assignment.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policyAssignmentName Policy assignment name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource, subscriptionId, policyAssignmentName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policyAssignmentName === null || policyAssignmentName === undefined || typeof policyAssignmentName.valueOf() !== 'string') {
      throw new Error('policyAssignmentName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyAssignmentName}', encodeURIComponent(policyAssignmentName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the subscription level policy assignment.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} policyAssignmentName Policy assignment name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForSubscriptionLevelPolicyAssignment(subscriptionId, policyAssignmentName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (policyAssignmentName === null || policyAssignmentName === undefined || typeof policyAssignmentName.valueOf() !== 'string') {
      throw new Error('policyAssignmentName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyAssignmentName}', encodeURIComponent(policyAssignmentName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Queries policy states for the resource group level policy assignment.
 *
 * @param {string} policyStatesResource The virtual resource under PolicyStates
 * resource type. In a given time range, 'latest' represents the latest policy
 * state(s), whereas 'default' represents all policy state(s). Possible values
 * include: 'default', 'latest'
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} resourceGroupName Resource group name.
 *
 * @param {string} policyAssignmentName Policy assignment name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PolicyStatesQueryResults} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (policyStatesResource === null || policyStatesResource === undefined || typeof policyStatesResource.valueOf() !== 'string') {
      throw new Error('policyStatesResource cannot be null or undefined and it must be of type string.');
    }
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (policyAssignmentName === null || policyAssignmentName === undefined || typeof policyAssignmentName.valueOf() !== 'string') {
      throw new Error('policyAssignmentName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let orderBy;
  let select;
  let from;
  let to;
  let filter;
  let apply;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      orderBy = queryOptions.orderBy;
      if (orderBy !== null && orderBy !== undefined && typeof orderBy.valueOf() !== 'string') {
        throw new Error('orderBy must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      select = queryOptions.select;
      if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
        throw new Error('select must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      apply = queryOptions.apply;
      if (apply !== null && apply !== undefined && typeof apply.valueOf() !== 'string') {
        throw new Error('apply must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults';
  requestUrl = requestUrl.replace('{policyStatesResource}', encodeURIComponent(policyStatesResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyAssignmentName}', encodeURIComponent(policyAssignmentName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (orderBy !== null && orderBy !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderBy));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (apply !== null && apply !== undefined) {
    queryParameters.push('$apply=' + encodeURIComponent(apply));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PolicyStatesQueryResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Summarizes policy states for the resource group level policy assignment.
 *
 * @param {string} subscriptionId Microsoft Azure subscription ID.
 *
 * @param {string} resourceGroupName Resource group name.
 *
 * @param {string} policyAssignmentName Policy assignment name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.queryOptions] Additional parameters for the
 * operation
 *
 * @param {number} [options.queryOptions.top] Maximum number of records to
 * return.
 *
 * @param {string} [options.queryOptions.orderBy] Ordering expression using
 * OData notation. One or more comma-separated column names with an optional
 * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
 * asc".
 *
 * @param {string} [options.queryOptions.select] Select expression using OData
 * notation. Limits the columns on each record to just those requested, e.g.
 * "$select=PolicyAssignmentId, ResourceId".
 *
 * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
 * specifying the start time of the interval to query. When not specified, the
 * service uses ($to - 1-day).
 *
 * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
 * specifying the end time of the interval to query. When not specified, the
 * service uses request time.
 *
 * @param {string} [options.queryOptions.filter] OData filter expression.
 *
 * @param {string} [options.queryOptions.apply] OData apply expression for
 * aggregations.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SummarizeResults} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _summarizeForResourceGroupLevelPolicyAssignment(subscriptionId, resourceGroupName, policyAssignmentName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let queryOptions = (options && options.queryOptions !== undefined) ? options.queryOptions : undefined;
  let policyStatesSummaryResource = 'latest';
  let authorizationNamespace = 'Microsoft.Authorization';
  // Validate
  try {
    if (subscriptionId === null || subscriptionId === undefined || typeof subscriptionId.valueOf() !== 'string') {
      throw new Error('subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (policyAssignmentName === null || policyAssignmentName === undefined || typeof policyAssignmentName.valueOf() !== 'string') {
      throw new Error('policyAssignmentName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let top;
  let from;
  let to;
  let filter;
  try {
    if (queryOptions !== null && queryOptions !== undefined)
    {
      top = queryOptions.top;
      if (top !== null && top !== undefined && typeof top !== 'number') {
        throw new Error('top must be of type number.');
      }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      from = queryOptions.from;
      if (from && !(from instanceof Date ||
          (typeof from.valueOf() === 'string' && !isNaN(Date.parse(from))))) {
            throw new Error('from must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      to = queryOptions.to;
      if (to && !(to instanceof Date ||
          (typeof to.valueOf() === 'string' && !isNaN(Date.parse(to))))) {
            throw new Error('to must be of type date.');
          }
    }
    if (queryOptions !== null && queryOptions !== undefined)
    {
      filter = queryOptions.filter;
      if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
        throw new Error('filter must be of type string.');
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize';
  requestUrl = requestUrl.replace('{policyStatesSummaryResource}', encodeURIComponent(policyStatesSummaryResource));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{authorizationNamespace}', encodeURIComponent(authorizationNamespace));
  requestUrl = requestUrl.replace('{policyAssignmentName}', encodeURIComponent(policyAssignmentName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top.toString()));
  }
  if (from !== null && from !== undefined) {
    queryParameters.push('$from=' + encodeURIComponent(client.serializeObject(from)));
  }
  if (to !== null && to !== undefined) {
    queryParameters.push('$to=' + encodeURIComponent(client.serializeObject(to)));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SummarizeResults']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets OData metadata XML document.
 *
 * @param {string} scope A valid scope, i.e. management group, subscription,
 * resource group, or resource ID. Scope used has no effect on metadata
 * returned.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMetadata(scope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (scope === null || scope === undefined || typeof scope.valueOf() !== 'string') {
      throw new Error('scope cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + '{scope}/providers/Microsoft.PolicyInsights/policyStates/$metadata';
  requestUrl = requestUrl.replace('{scope}', scope);
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['QueryFailure']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a PolicyStates. */
class PolicyStates {
  /**
   * Create a PolicyStates.
   * @param {PolicyInsightsClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._listQueryResultsForManagementGroup = _listQueryResultsForManagementGroup;
    this._summarizeForManagementGroup = _summarizeForManagementGroup;
    this._listQueryResultsForSubscription = _listQueryResultsForSubscription;
    this._summarizeForSubscription = _summarizeForSubscription;
    this._listQueryResultsForResourceGroup = _listQueryResultsForResourceGroup;
    this._summarizeForResourceGroup = _summarizeForResourceGroup;
    this._listQueryResultsForResource = _listQueryResultsForResource;
    this._summarizeForResource = _summarizeForResource;
    this._listQueryResultsForPolicySetDefinition = _listQueryResultsForPolicySetDefinition;
    this._summarizeForPolicySetDefinition = _summarizeForPolicySetDefinition;
    this._listQueryResultsForPolicyDefinition = _listQueryResultsForPolicyDefinition;
    this._summarizeForPolicyDefinition = _summarizeForPolicyDefinition;
    this._listQueryResultsForSubscriptionLevelPolicyAssignment = _listQueryResultsForSubscriptionLevelPolicyAssignment;
    this._summarizeForSubscriptionLevelPolicyAssignment = _summarizeForSubscriptionLevelPolicyAssignment;
    this._listQueryResultsForResourceGroupLevelPolicyAssignment = _listQueryResultsForResourceGroupLevelPolicyAssignment;
    this._summarizeForResourceGroupLevelPolicyAssignment = _summarizeForResourceGroupLevelPolicyAssignment;
    this._getMetadata = _getMetadata;
  }

  /**
   * Queries policy states for the resources under the management group.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} managementGroupName Management group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForManagementGroupWithHttpOperationResponse(policyStatesResource, managementGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForManagementGroup(policyStatesResource, managementGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the resources under the management group.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} managementGroupName Management group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForManagementGroup(policyStatesResource, managementGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForManagementGroup(policyStatesResource, managementGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForManagementGroup(policyStatesResource, managementGroupName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the resources under the management group.
   *
   * @param {string} managementGroupName Management group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForManagementGroupWithHttpOperationResponse(managementGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForManagementGroup(managementGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the resources under the management group.
   *
   * @param {string} managementGroupName Management group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForManagementGroup(managementGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForManagementGroup(managementGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForManagementGroup(managementGroupName, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the resources under the subscription.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForSubscriptionWithHttpOperationResponse(policyStatesResource, subscriptionId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForSubscription(policyStatesResource, subscriptionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the resources under the subscription.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForSubscription(policyStatesResource, subscriptionId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForSubscription(policyStatesResource, subscriptionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForSubscription(policyStatesResource, subscriptionId, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the resources under the subscription.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForSubscriptionWithHttpOperationResponse(subscriptionId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForSubscription(subscriptionId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the resources under the subscription.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForSubscription(subscriptionId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForSubscription(subscriptionId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForSubscription(subscriptionId, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the resources under the resource group.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForResourceGroupWithHttpOperationResponse(policyStatesResource, subscriptionId, resourceGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForResourceGroup(policyStatesResource, subscriptionId, resourceGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the resources under the resource group.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForResourceGroup(policyStatesResource, subscriptionId, resourceGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForResourceGroup(policyStatesResource, subscriptionId, resourceGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForResourceGroup(policyStatesResource, subscriptionId, resourceGroupName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the resources under the resource group.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForResourceGroupWithHttpOperationResponse(subscriptionId, resourceGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForResourceGroup(subscriptionId, resourceGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the resources under the resource group.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForResourceGroup(subscriptionId, resourceGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForResourceGroup(subscriptionId, resourceGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForResourceGroup(subscriptionId, resourceGroupName, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the resource.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} resourceId Resource ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForResourceWithHttpOperationResponse(policyStatesResource, resourceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForResource(policyStatesResource, resourceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the resource.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} resourceId Resource ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForResource(policyStatesResource, resourceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForResource(policyStatesResource, resourceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForResource(policyStatesResource, resourceId, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the resource.
   *
   * @param {string} resourceId Resource ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForResourceWithHttpOperationResponse(resourceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForResource(resourceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the resource.
   *
   * @param {string} resourceId Resource ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForResource(resourceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForResource(resourceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForResource(resourceId, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the subscription level policy set definition.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policySetDefinitionName Policy set definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForPolicySetDefinitionWithHttpOperationResponse(policyStatesResource, subscriptionId, policySetDefinitionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForPolicySetDefinition(policyStatesResource, subscriptionId, policySetDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the subscription level policy set definition.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policySetDefinitionName Policy set definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForPolicySetDefinition(policyStatesResource, subscriptionId, policySetDefinitionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForPolicySetDefinition(policyStatesResource, subscriptionId, policySetDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForPolicySetDefinition(policyStatesResource, subscriptionId, policySetDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the subscription level policy set definition.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policySetDefinitionName Policy set definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForPolicySetDefinitionWithHttpOperationResponse(subscriptionId, policySetDefinitionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForPolicySetDefinition(subscriptionId, policySetDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the subscription level policy set definition.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policySetDefinitionName Policy set definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForPolicySetDefinition(subscriptionId, policySetDefinitionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForPolicySetDefinition(subscriptionId, policySetDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForPolicySetDefinition(subscriptionId, policySetDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the subscription level policy definition.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyDefinitionName Policy definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForPolicyDefinitionWithHttpOperationResponse(policyStatesResource, subscriptionId, policyDefinitionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForPolicyDefinition(policyStatesResource, subscriptionId, policyDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the subscription level policy definition.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyDefinitionName Policy definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForPolicyDefinition(policyStatesResource, subscriptionId, policyDefinitionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForPolicyDefinition(policyStatesResource, subscriptionId, policyDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForPolicyDefinition(policyStatesResource, subscriptionId, policyDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the subscription level policy definition.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyDefinitionName Policy definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForPolicyDefinitionWithHttpOperationResponse(subscriptionId, policyDefinitionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForPolicyDefinition(subscriptionId, policyDefinitionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the subscription level policy definition.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyDefinitionName Policy definition name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForPolicyDefinition(subscriptionId, policyDefinitionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForPolicyDefinition(subscriptionId, policyDefinitionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForPolicyDefinition(subscriptionId, policyDefinitionName, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the subscription level policy assignment.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForSubscriptionLevelPolicyAssignmentWithHttpOperationResponse(policyStatesResource, subscriptionId, policyAssignmentName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource, subscriptionId, policyAssignmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the subscription level policy assignment.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource, subscriptionId, policyAssignmentName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource, subscriptionId, policyAssignmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource, subscriptionId, policyAssignmentName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the subscription level policy assignment.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForSubscriptionLevelPolicyAssignmentWithHttpOperationResponse(subscriptionId, policyAssignmentName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForSubscriptionLevelPolicyAssignment(subscriptionId, policyAssignmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the subscription level policy assignment.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForSubscriptionLevelPolicyAssignment(subscriptionId, policyAssignmentName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForSubscriptionLevelPolicyAssignment(subscriptionId, policyAssignmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForSubscriptionLevelPolicyAssignment(subscriptionId, policyAssignmentName, options, optionalCallback);
    }
  }

  /**
   * Queries policy states for the resource group level policy assignment.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PolicyStatesQueryResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listQueryResultsForResourceGroupLevelPolicyAssignmentWithHttpOperationResponse(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Queries policy states for the resource group level policy assignment.
   *
   * @param {string} policyStatesResource The virtual resource under PolicyStates
   * resource type. In a given time range, 'latest' represents the latest policy
   * state(s), whereas 'default' represents all policy state(s). Possible values
   * include: 'default', 'latest'
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PolicyStatesQueryResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PolicyStatesQueryResults} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource, subscriptionId, resourceGroupName, policyAssignmentName, options, optionalCallback);
    }
  }

  /**
   * Summarizes policy states for the resource group level policy assignment.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SummarizeResults>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  summarizeForResourceGroupLevelPolicyAssignmentWithHttpOperationResponse(subscriptionId, resourceGroupName, policyAssignmentName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._summarizeForResourceGroupLevelPolicyAssignment(subscriptionId, resourceGroupName, policyAssignmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Summarizes policy states for the resource group level policy assignment.
   *
   * @param {string} subscriptionId Microsoft Azure subscription ID.
   *
   * @param {string} resourceGroupName Resource group name.
   *
   * @param {string} policyAssignmentName Policy assignment name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.queryOptions] Additional parameters for the
   * operation
   *
   * @param {number} [options.queryOptions.top] Maximum number of records to
   * return.
   *
   * @param {string} [options.queryOptions.orderBy] Ordering expression using
   * OData notation. One or more comma-separated column names with an optional
   * "desc" (the default) or "asc", e.g. "$orderby=PolicyAssignmentId, ResourceId
   * asc".
   *
   * @param {string} [options.queryOptions.select] Select expression using OData
   * notation. Limits the columns on each record to just those requested, e.g.
   * "$select=PolicyAssignmentId, ResourceId".
   *
   * @param {date} [options.queryOptions.from] ISO 8601 formatted timestamp
   * specifying the start time of the interval to query. When not specified, the
   * service uses ($to - 1-day).
   *
   * @param {date} [options.queryOptions.to] ISO 8601 formatted timestamp
   * specifying the end time of the interval to query. When not specified, the
   * service uses request time.
   *
   * @param {string} [options.queryOptions.filter] OData filter expression.
   *
   * @param {string} [options.queryOptions.apply] OData apply expression for
   * aggregations.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SummarizeResults} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SummarizeResults} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  summarizeForResourceGroupLevelPolicyAssignment(subscriptionId, resourceGroupName, policyAssignmentName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._summarizeForResourceGroupLevelPolicyAssignment(subscriptionId, resourceGroupName, policyAssignmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._summarizeForResourceGroupLevelPolicyAssignment(subscriptionId, resourceGroupName, policyAssignmentName, options, optionalCallback);
    }
  }

  /**
   * Gets OData metadata XML document.
   *
   * @param {string} scope A valid scope, i.e. management group, subscription,
   * resource group, or resource ID. Scope used has no effect on metadata
   * returned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMetadataWithHttpOperationResponse(scope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMetadata(scope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets OData metadata XML document.
   *
   * @param {string} scope A valid scope, i.e. management group, subscription,
   * resource group, or resource ID. Scope used has no effect on metadata
   * returned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMetadata(scope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMetadata(scope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMetadata(scope, options, optionalCallback);
    }
  }

}

module.exports = PolicyStates;
